// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_vision_ds_Point2D
#include <vision/ds/Point2D.h>
#endif
#ifndef INCLUDED_vision_ds_Ray2D
#include <vision/ds/Ray2D.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_b310a30a17e7e9da_48_new,"vision.ds.Ray2D","new",0x7672d1b5,"vision.ds.Ray2D.new","vision/ds/Ray2D.hx",48,0x18aa71fb)
HX_LOCAL_STACK_FRAME(_hx_pos_b310a30a17e7e9da_80_getPointAtX,"vision.ds.Ray2D","getPointAtX",0xfaef36a0,"vision.ds.Ray2D.getPointAtX","vision/ds/Ray2D.hx",80,0x18aa71fb)
HX_LOCAL_STACK_FRAME(_hx_pos_b310a30a17e7e9da_87_getPointAtY,"vision.ds.Ray2D","getPointAtY",0xfaef36a1,"vision.ds.Ray2D.getPointAtY","vision/ds/Ray2D.hx",87,0x18aa71fb)
HX_LOCAL_STACK_FRAME(_hx_pos_b310a30a17e7e9da_99_intersect,"vision.ds.Ray2D","intersect",0xfdeb2ff4,"vision.ds.Ray2D.intersect","vision/ds/Ray2D.hx",99,0x18aa71fb)
HX_LOCAL_STACK_FRAME(_hx_pos_b310a30a17e7e9da_111_distanceTo,"vision.ds.Ray2D","distanceTo",0xd7dfd75b,"vision.ds.Ray2D.distanceTo","vision/ds/Ray2D.hx",111,0x18aa71fb)
HX_LOCAL_STACK_FRAME(_hx_pos_b310a30a17e7e9da_115_set_slope,"vision.ds.Ray2D","set_slope",0x613cd4a3,"vision.ds.Ray2D.set_slope","vision/ds/Ray2D.hx",115,0x18aa71fb)
HX_LOCAL_STACK_FRAME(_hx_pos_b310a30a17e7e9da_121_set_degrees,"vision.ds.Ray2D","set_degrees",0xf372291f,"vision.ds.Ray2D.set_degrees","vision/ds/Ray2D.hx",121,0x18aa71fb)
HX_LOCAL_STACK_FRAME(_hx_pos_b310a30a17e7e9da_127_set_radians,"vision.ds.Ray2D","set_radians",0xe0078bea,"vision.ds.Ray2D.set_radians","vision/ds/Ray2D.hx",127,0x18aa71fb)
HX_LOCAL_STACK_FRAME(_hx_pos_b310a30a17e7e9da_133_get_yIntercept,"vision.ds.Ray2D","get_yIntercept",0x571ab79d,"vision.ds.Ray2D.get_yIntercept","vision/ds/Ray2D.hx",133,0x18aa71fb)
HX_LOCAL_STACK_FRAME(_hx_pos_b310a30a17e7e9da_141_get_xIntercept,"vision.ds.Ray2D","get_xIntercept",0x96d03fbe,"vision.ds.Ray2D.get_xIntercept","vision/ds/Ray2D.hx",141,0x18aa71fb)
HX_LOCAL_STACK_FRAME(_hx_pos_b310a30a17e7e9da_71_from2Points,"vision.ds.Ray2D","from2Points",0x3e92d220,"vision.ds.Ray2D.from2Points","vision/ds/Ray2D.hx",71,0x18aa71fb)
namespace vision{
namespace ds{

void Ray2D_obj::__construct( ::vision::ds::Point2D point, ::Dynamic m, ::Dynamic degrees, ::Dynamic radians){
            	HX_STACKFRAME(&_hx_pos_b310a30a17e7e9da_48_new)
HXLINE(  49)		this->point = point;
HXLINE(  50)		if (::hx::IsNotNull( m )) {
HXLINE(  51)			{
HXLINE(  51)				Float value = ( (Float)(m) );
HXDLIN(  51)				this->degrees = ((::Math_obj::atan(value) * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN(  51)				this->radians = ::Math_obj::atan(value);
HXDLIN(  51)				this->slope = value;
            			}
HXLINE(  52)			{
HXLINE(  52)				Float value1 = ((::Math_obj::atan(( (Float)(m) )) * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN(  52)				this->slope = ::Math_obj::tan(((value1 * ::Math_obj::PI) / ( (Float)(180) )));
HXDLIN(  52)				this->radians = ((value1 * ::Math_obj::PI) / ( (Float)(180) ));
HXDLIN(  52)				this->degrees = value1;
            			}
HXLINE(  53)			{
HXLINE(  53)				Float value2 = ::Math_obj::atan(( (Float)(m) ));
HXDLIN(  53)				this->slope = ::Math_obj::tan(value2);
HXDLIN(  53)				this->degrees = ((value2 * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN(  53)				this->radians = value2;
            			}
            		}
            		else {
HXLINE(  54)			if (::hx::IsNotNull( degrees )) {
HXLINE(  55)				{
HXLINE(  55)					Float value3 = ( (Float)(degrees) );
HXDLIN(  55)					this->slope = ::Math_obj::tan(((value3 * ::Math_obj::PI) / ( (Float)(180) )));
HXDLIN(  55)					this->radians = ((value3 * ::Math_obj::PI) / ( (Float)(180) ));
HXDLIN(  55)					this->degrees = value3;
            				}
HXLINE(  56)				{
HXLINE(  56)					Float value4 = ::Math_obj::tan(((( (Float)(degrees) ) * ::Math_obj::PI) / ( (Float)(180) )));
HXDLIN(  56)					this->degrees = ((::Math_obj::atan(value4) * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN(  56)					this->radians = ::Math_obj::atan(value4);
HXDLIN(  56)					this->slope = value4;
            				}
HXLINE(  57)				{
HXLINE(  57)					Float value5 = ((( (Float)(degrees) ) * ::Math_obj::PI) / ( (Float)(180) ));
HXDLIN(  57)					this->slope = ::Math_obj::tan(value5);
HXDLIN(  57)					this->degrees = ((value5 * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN(  57)					this->radians = value5;
            				}
            			}
            			else {
HXLINE(  58)				if (::hx::IsNotNull( radians )) {
HXLINE(  59)					{
HXLINE(  59)						Float value6 = ( (Float)(radians) );
HXDLIN(  59)						this->slope = ::Math_obj::tan(value6);
HXDLIN(  59)						this->degrees = ((value6 * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN(  59)						this->radians = value6;
            					}
HXLINE(  60)					{
HXLINE(  60)						Float value7 = ::Math_obj::tan(( (Float)(radians) ));
HXDLIN(  60)						this->degrees = ((::Math_obj::atan(value7) * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN(  60)						this->radians = ::Math_obj::atan(value7);
HXDLIN(  60)						this->slope = value7;
            					}
HXLINE(  61)					{
HXLINE(  61)						Float value8 = ((( (Float)(radians) ) * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN(  61)						this->slope = ::Math_obj::tan(((value8 * ::Math_obj::PI) / ( (Float)(180) )));
HXDLIN(  61)						this->radians = ((value8 * ::Math_obj::PI) / ( (Float)(180) ));
HXDLIN(  61)						this->degrees = value8;
            					}
            				}
            			}
            		}
            	}

Dynamic Ray2D_obj::__CreateEmpty() { return new Ray2D_obj; }

void *Ray2D_obj::_hx_vtable = 0;

Dynamic Ray2D_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Ray2D_obj > _hx_result = new Ray2D_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool Ray2D_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7f7d3855;
}

 ::vision::ds::Point2D Ray2D_obj::getPointAtX(Float x){
            	HX_GC_STACKFRAME(&_hx_pos_b310a30a17e7e9da_80_getPointAtX)
HXDLIN(  80)		Float px = this->point->x;
HXDLIN(  80)		Float py = this->point->y;
HXDLIN(  80)		Float _hx_tmp;
HXDLIN(  80)		if ((px > 0)) {
HXDLIN(  80)			_hx_tmp = (py - (this->slope * px));
            		}
            		else {
HXDLIN(  80)			_hx_tmp = (py + (this->slope * px));
            		}
HXDLIN(  80)		return  ::vision::ds::Point2D_obj::__alloc( HX_CTX ,x,((this->slope * x) + _hx_tmp));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Ray2D_obj,getPointAtX,return )

 ::vision::ds::Point2D Ray2D_obj::getPointAtY(Float y){
            	HX_GC_STACKFRAME(&_hx_pos_b310a30a17e7e9da_87_getPointAtY)
HXDLIN(  87)		Float px = this->point->x;
HXDLIN(  87)		Float py = this->point->y;
HXDLIN(  87)		Float _hx_tmp;
HXDLIN(  87)		if ((px > 0)) {
HXDLIN(  87)			_hx_tmp = (py - (this->slope * px));
            		}
            		else {
HXDLIN(  87)			_hx_tmp = (py + (this->slope * px));
            		}
HXDLIN(  87)		return  ::vision::ds::Point2D_obj::__alloc( HX_CTX ,((y - _hx_tmp) / this->slope),y);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Ray2D_obj,getPointAtY,return )

 ::vision::ds::Point2D Ray2D_obj::intersect( ::vision::ds::Ray2D ray){
            	HX_GC_STACKFRAME(&_hx_pos_b310a30a17e7e9da_99_intersect)
HXDLIN(  99)		Float line1StartX = this->point->x;
HXDLIN(  99)		Float line1StartY = this->point->y;
HXDLIN(  99)		Float line1EndX = (this->point->x + (::Math_obj::cos(this->radians) * ( (Float)(1000) )));
HXDLIN(  99)		Float line1EndY = (this->point->y + (::Math_obj::sin(this->radians) * ( (Float)(1000) )));
HXDLIN(  99)		Float line2StartX = ray->point->x;
HXDLIN(  99)		Float line2StartY = ray->point->y;
HXDLIN(  99)		Float line2EndX = (ray->point->x + (::Math_obj::cos(ray->radians) * ( (Float)(1000) )));
HXDLIN(  99)		Float line2EndY = (ray->point->y + (::Math_obj::sin(ray->radians) * ( (Float)(1000) )));
HXDLIN(  99)		Float a;
HXDLIN(  99)		Float b;
HXDLIN(  99)		Float numerator1;
HXDLIN(  99)		Float numerator2;
HXDLIN(  99)		 ::vision::ds::Point2D result = null();
HXDLIN(  99)		Float denominator = (((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY)));
HXDLIN(  99)		if ((denominator == 0)) {
HXDLIN(  99)			return result;
            		}
            		else {
HXDLIN(  99)			a = (line1StartY - line2StartY);
HXDLIN(  99)			b = (line1StartX - line2StartX);
HXDLIN(  99)			numerator1 = (((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b));
HXDLIN(  99)			numerator2 = (((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b));
HXDLIN(  99)			a = (numerator1 / denominator);
HXDLIN(  99)			b = (numerator2 / denominator);
HXDLIN(  99)			result =  ::vision::ds::Point2D_obj::__alloc( HX_CTX ,null(),null());
HXDLIN(  99)			result->x = (line1StartX + (a * (line1EndX - line1StartX)));
HXDLIN(  99)			result->y = (line1StartY + (a * (line1EndY - line1StartY)));
HXDLIN(  99)			return result;
            		}
HXDLIN(  99)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Ray2D_obj,intersect,return )

Float Ray2D_obj::distanceTo( ::vision::ds::Ray2D ray){
            	HX_GC_STACKFRAME(&_hx_pos_b310a30a17e7e9da_111_distanceTo)
HXDLIN( 111)		if ((this->radians != ray->radians)) {
HXDLIN( 111)			return ( (Float)(0) );
            		}
            		else {
HXDLIN( 111)			 ::vision::ds::Point2D point = this->point;
HXDLIN( 111)			Float ray2_slope;
HXDLIN( 111)			Float ray2_radians;
HXDLIN( 111)			Float ray2_degrees;
HXDLIN( 111)			 ::Dynamic m = null();
HXDLIN( 111)			 ::Dynamic degrees = (this->degrees + 90);
HXDLIN( 111)			 ::Dynamic radians = null();
HXDLIN( 111)			 ::vision::ds::Point2D ray2_point = point;
HXDLIN( 111)			if (::hx::IsNotNull( m )) {
HXDLIN( 111)				{
HXDLIN( 111)					Float value = ( (Float)(m) );
HXDLIN( 111)					ray2_degrees = ((::Math_obj::atan(value) * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN( 111)					ray2_radians = ::Math_obj::atan(value);
HXDLIN( 111)					ray2_slope = value;
            				}
HXDLIN( 111)				{
HXDLIN( 111)					Float value1 = ((::Math_obj::atan(( (Float)(m) )) * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN( 111)					ray2_slope = ::Math_obj::tan(((value1 * ::Math_obj::PI) / ( (Float)(180) )));
HXDLIN( 111)					ray2_radians = ((value1 * ::Math_obj::PI) / ( (Float)(180) ));
HXDLIN( 111)					ray2_degrees = value1;
            				}
HXDLIN( 111)				{
HXDLIN( 111)					Float value2 = ::Math_obj::atan(( (Float)(m) ));
HXDLIN( 111)					ray2_slope = ::Math_obj::tan(value2);
HXDLIN( 111)					ray2_degrees = ((value2 * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN( 111)					ray2_radians = value2;
            				}
            			}
            			else {
HXDLIN( 111)				if (::hx::IsNotNull( degrees )) {
HXDLIN( 111)					{
HXDLIN( 111)						Float value3 = ( (Float)(degrees) );
HXDLIN( 111)						ray2_slope = ::Math_obj::tan(((value3 * ::Math_obj::PI) / ( (Float)(180) )));
HXDLIN( 111)						ray2_radians = ((value3 * ::Math_obj::PI) / ( (Float)(180) ));
HXDLIN( 111)						ray2_degrees = value3;
            					}
HXDLIN( 111)					{
HXDLIN( 111)						Float value4 = ::Math_obj::tan(((( (Float)(degrees) ) * ::Math_obj::PI) / ( (Float)(180) )));
HXDLIN( 111)						ray2_degrees = ((::Math_obj::atan(value4) * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN( 111)						ray2_radians = ::Math_obj::atan(value4);
HXDLIN( 111)						ray2_slope = value4;
            					}
HXDLIN( 111)					{
HXDLIN( 111)						Float value5 = ((( (Float)(degrees) ) * ::Math_obj::PI) / ( (Float)(180) ));
HXDLIN( 111)						ray2_slope = ::Math_obj::tan(value5);
HXDLIN( 111)						ray2_degrees = ((value5 * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN( 111)						ray2_radians = value5;
            					}
            				}
            				else {
HXDLIN( 111)					if (::hx::IsNotNull( radians )) {
HXDLIN( 111)						{
HXDLIN( 111)							Float value6 = ( (Float)(radians) );
HXDLIN( 111)							ray2_slope = ::Math_obj::tan(value6);
HXDLIN( 111)							ray2_degrees = ((value6 * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN( 111)							ray2_radians = value6;
            						}
HXDLIN( 111)						{
HXDLIN( 111)							Float value7 = ::Math_obj::tan(( (Float)(radians) ));
HXDLIN( 111)							ray2_degrees = ((::Math_obj::atan(value7) * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN( 111)							ray2_radians = ::Math_obj::atan(value7);
HXDLIN( 111)							ray2_slope = value7;
            						}
HXDLIN( 111)						{
HXDLIN( 111)							Float value8 = ((( (Float)(radians) ) * ( (Float)(180) )) / ::Math_obj::PI);
HXDLIN( 111)							ray2_slope = ::Math_obj::tan(((value8 * ::Math_obj::PI) / ( (Float)(180) )));
HXDLIN( 111)							ray2_radians = ((value8 * ::Math_obj::PI) / ( (Float)(180) ));
HXDLIN( 111)							ray2_degrees = value8;
            						}
            					}
            				}
            			}
HXDLIN( 111)			Float line1StartX = ray->point->x;
HXDLIN( 111)			Float line1StartY = ray->point->y;
HXDLIN( 111)			Float line1EndX = (ray->point->x + (::Math_obj::cos(ray->radians) * ( (Float)(1000) )));
HXDLIN( 111)			Float line1EndY = (ray->point->y + (::Math_obj::sin(ray->radians) * ( (Float)(1000) )));
HXDLIN( 111)			Float line2StartX = ray2_point->x;
HXDLIN( 111)			Float line2StartY = ray2_point->y;
HXDLIN( 111)			Float line2EndX = (ray2_point->x + (::Math_obj::cos(ray2_radians) * ( (Float)(1000) )));
HXDLIN( 111)			Float line2EndY = (ray2_point->y + (::Math_obj::sin(ray2_radians) * ( (Float)(1000) )));
HXDLIN( 111)			Float a;
HXDLIN( 111)			Float b;
HXDLIN( 111)			Float numerator1;
HXDLIN( 111)			Float numerator2;
HXDLIN( 111)			 ::vision::ds::Point2D result = null();
HXDLIN( 111)			Float denominator = (((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY)));
HXDLIN( 111)			 ::vision::ds::Point2D intersectionOfPerpendicularWithRay2;
HXDLIN( 111)			if ((denominator == 0)) {
HXDLIN( 111)				intersectionOfPerpendicularWithRay2 = result;
            			}
            			else {
HXLINE(  57)				a = (line1StartY - line2StartY);
HXLINE(  58)				b = (line1StartX - line2StartX);
HXLINE(  59)				numerator1 = (((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b));
HXLINE(  60)				numerator2 = (((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b));
HXLINE(  61)				a = (numerator1 / denominator);
HXLINE(  62)				b = (numerator2 / denominator);
HXLINE(  65)				result =  ::vision::ds::Point2D_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 111)				result->x = (line1StartX + (a * (line1EndX - line1StartX)));
HXDLIN( 111)				result->y = (line1StartY + (a * (line1EndY - line1StartY)));
HXDLIN( 111)				intersectionOfPerpendicularWithRay2 = result;
            			}
HXDLIN( 111)			Float x = (intersectionOfPerpendicularWithRay2->x - point->x);
HXDLIN( 111)			Float y = (intersectionOfPerpendicularWithRay2->y - point->y);
HXDLIN( 111)			return ::Math_obj::sqrt(((x * x) + (y * y)));
            		}
HXDLIN( 111)		return ((Float)0.);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Ray2D_obj,distanceTo,return )

Float Ray2D_obj::set_slope(Float value){
            	HX_STACKFRAME(&_hx_pos_b310a30a17e7e9da_115_set_slope)
HXLINE( 116)		this->degrees = ((::Math_obj::atan(value) * ( (Float)(180) )) / ::Math_obj::PI);
HXLINE( 117)		this->radians = ::Math_obj::atan(value);
HXLINE( 118)		return (this->slope = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Ray2D_obj,set_slope,return )

Float Ray2D_obj::set_degrees(Float value){
            	HX_STACKFRAME(&_hx_pos_b310a30a17e7e9da_121_set_degrees)
HXLINE( 122)		this->slope = ::Math_obj::tan(((value * ::Math_obj::PI) / ( (Float)(180) )));
HXLINE( 123)		this->radians = ((value * ::Math_obj::PI) / ( (Float)(180) ));
HXLINE( 124)		return (this->degrees = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Ray2D_obj,set_degrees,return )

Float Ray2D_obj::set_radians(Float value){
            	HX_STACKFRAME(&_hx_pos_b310a30a17e7e9da_127_set_radians)
HXLINE( 128)		this->slope = ::Math_obj::tan(value);
HXLINE( 129)		this->degrees = ((value * ( (Float)(180) )) / ::Math_obj::PI);
HXLINE( 130)		return (this->radians = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Ray2D_obj,set_radians,return )

Float Ray2D_obj::get_yIntercept(){
            	HX_STACKFRAME(&_hx_pos_b310a30a17e7e9da_133_get_yIntercept)
HXLINE( 134)		Float px = this->point->x;
HXDLIN( 134)		Float py = this->point->y;
HXLINE( 135)		if ((px > 0)) {
HXLINE( 136)			return (py - (this->slope * px));
            		}
HXLINE( 138)		return (py + (this->slope * px));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Ray2D_obj,get_yIntercept,return )

Float Ray2D_obj::get_xIntercept(){
            	HX_STACKFRAME(&_hx_pos_b310a30a17e7e9da_141_get_xIntercept)
HXLINE( 142)		Float px = this->point->x;
HXDLIN( 142)		Float py = this->point->y;
HXLINE( 143)		if ((py > 0)) {
HXLINE( 144)			return ((py - (this->slope * px)) / this->slope);
            		}
HXLINE( 146)		return ((py + (this->slope * px)) / this->slope);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Ray2D_obj,get_xIntercept,return )

 ::vision::ds::Ray2D Ray2D_obj::from2Points( ::vision::ds::Point2D point1, ::vision::ds::Point2D point2){
            	HX_GC_STACKFRAME(&_hx_pos_b310a30a17e7e9da_71_from2Points)
HXLINE(  72)		Float s = ((point2->y - point1->y) / (point2->x - point1->x));
HXLINE(  73)		return  ::vision::ds::Ray2D_obj::__alloc( HX_CTX ,point1,s,null(),null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Ray2D_obj,from2Points,return )


::hx::ObjectPtr< Ray2D_obj > Ray2D_obj::__new( ::vision::ds::Point2D point, ::Dynamic m, ::Dynamic degrees, ::Dynamic radians) {
	::hx::ObjectPtr< Ray2D_obj > __this = new Ray2D_obj();
	__this->__construct(point,m,degrees,radians);
	return __this;
}

::hx::ObjectPtr< Ray2D_obj > Ray2D_obj::__alloc(::hx::Ctx *_hx_ctx, ::vision::ds::Point2D point, ::Dynamic m, ::Dynamic degrees, ::Dynamic radians) {
	Ray2D_obj *__this = (Ray2D_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Ray2D_obj), true, "vision.ds.Ray2D"));
	*(void **)__this = Ray2D_obj::_hx_vtable;
	__this->__construct(point,m,degrees,radians);
	return __this;
}

Ray2D_obj::Ray2D_obj()
{
}

void Ray2D_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Ray2D);
	HX_MARK_MEMBER_NAME(point,"point");
	HX_MARK_MEMBER_NAME(slope,"slope");
	HX_MARK_MEMBER_NAME(degrees,"degrees");
	HX_MARK_MEMBER_NAME(radians,"radians");
	HX_MARK_END_CLASS();
}

void Ray2D_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(point,"point");
	HX_VISIT_MEMBER_NAME(slope,"slope");
	HX_VISIT_MEMBER_NAME(degrees,"degrees");
	HX_VISIT_MEMBER_NAME(radians,"radians");
}

::hx::Val Ray2D_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"point") ) { return ::hx::Val( point ); }
		if (HX_FIELD_EQ(inName,"slope") ) { return ::hx::Val( slope ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"degrees") ) { return ::hx::Val( degrees ); }
		if (HX_FIELD_EQ(inName,"radians") ) { return ::hx::Val( radians ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"intersect") ) { return ::hx::Val( intersect_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_slope") ) { return ::hx::Val( set_slope_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"yIntercept") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_yIntercept() ); }
		if (HX_FIELD_EQ(inName,"xIntercept") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_xIntercept() ); }
		if (HX_FIELD_EQ(inName,"distanceTo") ) { return ::hx::Val( distanceTo_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"getPointAtX") ) { return ::hx::Val( getPointAtX_dyn() ); }
		if (HX_FIELD_EQ(inName,"getPointAtY") ) { return ::hx::Val( getPointAtY_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_degrees") ) { return ::hx::Val( set_degrees_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_radians") ) { return ::hx::Val( set_radians_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"get_yIntercept") ) { return ::hx::Val( get_yIntercept_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_xIntercept") ) { return ::hx::Val( get_xIntercept_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Ray2D_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"from2Points") ) { outValue = from2Points_dyn(); return true; }
	}
	return false;
}

::hx::Val Ray2D_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"point") ) { point=inValue.Cast<  ::vision::ds::Point2D >(); return inValue; }
		if (HX_FIELD_EQ(inName,"slope") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_slope(inValue.Cast< Float >()) );slope=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"degrees") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_degrees(inValue.Cast< Float >()) );degrees=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"radians") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_radians(inValue.Cast< Float >()) );radians=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Ray2D_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("point",50,b4,8f,c6));
	outFields->push(HX_("slope",2b,5d,cc,7e));
	outFields->push(HX_("degrees",a7,e3,5a,3a));
	outFields->push(HX_("radians",72,46,f0,26));
	outFields->push(HX_("yIntercept",89,2a,e7,bc));
	outFields->push(HX_("xIntercept",aa,b2,9c,fc));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Ray2D_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::vision::ds::Point2D */ ,(int)offsetof(Ray2D_obj,point),HX_("point",50,b4,8f,c6)},
	{::hx::fsFloat,(int)offsetof(Ray2D_obj,slope),HX_("slope",2b,5d,cc,7e)},
	{::hx::fsFloat,(int)offsetof(Ray2D_obj,degrees),HX_("degrees",a7,e3,5a,3a)},
	{::hx::fsFloat,(int)offsetof(Ray2D_obj,radians),HX_("radians",72,46,f0,26)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Ray2D_obj_sStaticStorageInfo = 0;
#endif

static ::String Ray2D_obj_sMemberFields[] = {
	HX_("point",50,b4,8f,c6),
	HX_("slope",2b,5d,cc,7e),
	HX_("degrees",a7,e3,5a,3a),
	HX_("radians",72,46,f0,26),
	HX_("getPointAtX",4b,58,3f,d2),
	HX_("getPointAtY",4c,58,3f,d2),
	HX_("intersect",df,00,75,42),
	HX_("distanceTo",10,d4,ec,8b),
	HX_("set_slope",8e,a5,c6,a5),
	HX_("set_degrees",ca,4a,c2,ca),
	HX_("set_radians",95,ad,57,b7),
	HX_("get_yIntercept",d2,b2,dc,32),
	HX_("get_xIntercept",f3,3a,92,72),
	::String(null()) };

::hx::Class Ray2D_obj::__mClass;

static ::String Ray2D_obj_sStaticFields[] = {
	HX_("from2Points",cb,f3,e2,15),
	::String(null())
};

void Ray2D_obj::__register()
{
	Ray2D_obj _hx_dummy;
	Ray2D_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("vision.ds.Ray2D",43,d3,78,1b);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Ray2D_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Ray2D_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Ray2D_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Ray2D_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Ray2D_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Ray2D_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace vision
} // end namespace ds
