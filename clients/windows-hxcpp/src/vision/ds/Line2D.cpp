// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_vision_ds_Line2D
#include <vision/ds/Line2D.h>
#endif
#ifndef INCLUDED_vision_ds_Point2D
#include <vision/ds/Point2D.h>
#endif
#ifndef INCLUDED_vision_ds_Ray2D
#include <vision/ds/Ray2D.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_ca7ce2accd6837d2_8_new,"vision.ds.Line2D","new",0x658a4851,"vision.ds.Line2D.new","vision/ds/Line2D.hx",8,0xa053e19f)
HX_LOCAL_STACK_FRAME(_hx_pos_ca7ce2accd6837d2_59_get_length,"vision.ds.Line2D","get_length",0x28a2dcde,"vision.ds.Line2D.get_length","vision/ds/Line2D.hx",59,0xa053e19f)
HX_LOCAL_STACK_FRAME(_hx_pos_ca7ce2accd6837d2_71_intersect,"vision.ds.Line2D","intersect",0x14138390,"vision.ds.Line2D.intersect","vision/ds/Line2D.hx",71,0xa053e19f)
HX_LOCAL_STACK_FRAME(_hx_pos_ca7ce2accd6837d2_83_distanceTo,"vision.ds.Line2D","distanceTo",0x2500ac3f,"vision.ds.Line2D.distanceTo","vision/ds/Line2D.hx",83,0xa053e19f)
HX_LOCAL_STACK_FRAME(_hx_pos_ca7ce2accd6837d2_91_toString,"vision.ds.Line2D","toString",0x036aef1b,"vision.ds.Line2D.toString","vision/ds/Line2D.hx",91,0xa053e19f)
HX_LOCAL_STACK_FRAME(_hx_pos_ca7ce2accd6837d2_111_toRay2D,"vision.ds.Line2D","toRay2D",0x5b7be132,"vision.ds.Line2D.toRay2D","vision/ds/Line2D.hx",111,0xa053e19f)
HX_LOCAL_STACK_FRAME(_hx_pos_ca7ce2accd6837d2_114_set_start,"vision.ds.Line2D","set_start",0x7ca43f76,"vision.ds.Line2D.set_start","vision/ds/Line2D.hx",114,0xa053e19f)
HX_LOCAL_STACK_FRAME(_hx_pos_ca7ce2accd6837d2_121_set_end,"vision.ds.Line2D","set_end",0xc49321ef,"vision.ds.Line2D.set_end","vision/ds/Line2D.hx",121,0xa053e19f)
HX_LOCAL_STACK_FRAME(_hx_pos_ca7ce2accd6837d2_129_get_middle,"vision.ds.Line2D","get_middle",0xd5fa1b4d,"vision.ds.Line2D.get_middle","vision/ds/Line2D.hx",129,0xa053e19f)
HX_LOCAL_STACK_FRAME(_hx_pos_ca7ce2accd6837d2_132_set_middle,"vision.ds.Line2D","set_middle",0xd977b9c1,"vision.ds.Line2D.set_middle","vision/ds/Line2D.hx",132,0xa053e19f)
HX_LOCAL_STACK_FRAME(_hx_pos_ca7ce2accd6837d2_99_fromRay2D,"vision.ds.Line2D","fromRay2D",0x6a4f3d23,"vision.ds.Line2D.fromRay2D","vision/ds/Line2D.hx",99,0xa053e19f)
namespace vision{
namespace ds{

void Line2D_obj::__construct( ::vision::ds::Point2D start, ::vision::ds::Point2D end){
            	HX_GC_STACKFRAME(&_hx_pos_ca7ce2accd6837d2_8_new)
HXLINE(  38)		this->end =  ::vision::ds::Point2D_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ));
HXLINE(  33)		this->start =  ::vision::ds::Point2D_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ));
HXLINE(  49)		this->start->x = start->x;
HXLINE(  50)		this->start->y = start->y;
HXLINE(  51)		this->end->x = end->x;
HXLINE(  52)		this->end->y = end->y;
HXLINE(  53)		Float x = (end->x - start->x);
HXDLIN(  53)		Float y = (end->y - start->y);
HXDLIN(  53)		this->radians = ::Math_obj::atan2(x,y);
HXLINE(  54)		this->slope = ::Math_obj::tan(this->radians);
HXLINE(  55)		this->degrees = ((this->radians * ( (Float)(180) )) / ::Math_obj::PI);
            	}

Dynamic Line2D_obj::__CreateEmpty() { return new Line2D_obj; }

void *Line2D_obj::_hx_vtable = 0;

Dynamic Line2D_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Line2D_obj > _hx_result = new Line2D_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Line2D_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x6048be01;
}

Float Line2D_obj::get_length(){
            	HX_STACKFRAME(&_hx_pos_ca7ce2accd6837d2_59_get_length)
HXDLIN(  59)		return ::Math_obj::sqrt((::Math_obj::pow((this->end->x - this->start->x),( (Float)(2) )) + ::Math_obj::pow((this->end->y - this->start->y),( (Float)(2) ))));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Line2D_obj,get_length,return )

 ::vision::ds::Point2D Line2D_obj::intersect( ::vision::ds::Line2D line){
            	HX_GC_STACKFRAME(&_hx_pos_ca7ce2accd6837d2_71_intersect)
HXDLIN(  71)		Float x1 = this->start->x;
HXDLIN(  71)		Float y1 = this->start->y;
HXDLIN(  71)		Float x2 = this->end->x;
HXDLIN(  71)		Float y2 = this->end->y;
HXDLIN(  71)		Float x3 = line->start->x;
HXDLIN(  71)		Float y3 = line->start->y;
HXDLIN(  71)		Float x4 = line->end->x;
HXDLIN(  71)		Float y4 = line->end->y;
HXDLIN(  71)		Float denominator = (((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1)));
HXDLIN(  71)		 ::vision::ds::Point2D _hx_tmp;
HXDLIN(  71)		bool _hx_tmp1;
HXDLIN(  71)		bool _hx_tmp2;
HXDLIN(  71)		if ((x1 == x2)) {
HXDLIN(  71)			_hx_tmp2 = (y1 == y2);
            		}
            		else {
HXDLIN(  71)			_hx_tmp2 = false;
            		}
HXDLIN(  71)		if (!(_hx_tmp2)) {
HXDLIN(  71)			if ((x3 == x4)) {
HXDLIN(  71)				_hx_tmp1 = (y3 == y4);
            			}
            			else {
HXDLIN(  71)				_hx_tmp1 = false;
            			}
            		}
            		else {
HXDLIN(  71)			_hx_tmp1 = true;
            		}
HXDLIN(  71)		if (_hx_tmp1) {
HXDLIN(  71)			_hx_tmp = null();
            		}
            		else {
HXDLIN(  71)			if ((denominator == 0)) {
HXDLIN(  71)				_hx_tmp = null();
            			}
            			else {
HXDLIN(  71)				Float ua = ((((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3))) / denominator);
HXDLIN(  71)				Float ub = ((((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3))) / denominator);
HXDLIN(  71)				bool _hx_tmp3;
HXDLIN(  71)				bool _hx_tmp4;
HXDLIN(  71)				bool _hx_tmp5;
HXDLIN(  71)				if (!((ua < 0))) {
HXDLIN(  71)					_hx_tmp5 = (ua > 1);
            				}
            				else {
HXDLIN(  71)					_hx_tmp5 = true;
            				}
HXDLIN(  71)				if (!(_hx_tmp5)) {
HXDLIN(  71)					_hx_tmp4 = (ub < 0);
            				}
            				else {
HXDLIN(  71)					_hx_tmp4 = true;
            				}
HXDLIN(  71)				if (!(_hx_tmp4)) {
HXDLIN(  71)					_hx_tmp3 = (ub > 1);
            				}
            				else {
HXDLIN(  71)					_hx_tmp3 = true;
            				}
HXDLIN(  71)				if (_hx_tmp3) {
HXDLIN(  71)					_hx_tmp = null();
            				}
            				else {
HXDLIN(  71)					Float x = (x1 + (ua * (x2 - x1)));
HXDLIN(  71)					Float y = (y1 + (ua * (y2 - y1)));
HXDLIN(  71)					Float _g = ( (Float)(::Std_obj::_hx_int(x)) );
HXDLIN(  71)					_hx_tmp =  ::vision::ds::Point2D_obj::__alloc( HX_CTX ,_g,( (Float)(::Std_obj::_hx_int(y)) ));
            				}
            			}
            		}
HXDLIN(  71)		return _hx_tmp;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Line2D_obj,intersect,return )

Float Line2D_obj::distanceTo( ::vision::ds::Line2D line){
            	HX_GC_STACKFRAME(&_hx_pos_ca7ce2accd6837d2_83_distanceTo)
HXDLIN(  83)		Float x1 = this->start->x;
HXDLIN(  83)		Float y1 = this->start->y;
HXDLIN(  83)		Float x2 = this->end->x;
HXDLIN(  83)		Float y2 = this->end->y;
HXDLIN(  83)		Float x3 = line->start->x;
HXDLIN(  83)		Float y3 = line->start->y;
HXDLIN(  83)		Float x4 = line->end->x;
HXDLIN(  83)		Float y4 = line->end->y;
HXDLIN(  83)		Float denominator = (((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1)));
HXDLIN(  83)		 ::vision::ds::Point2D _hx_tmp;
HXDLIN(  83)		bool _hx_tmp1;
HXDLIN(  83)		bool _hx_tmp2;
HXDLIN(  83)		if ((x1 == x2)) {
HXDLIN(  83)			_hx_tmp2 = (y1 == y2);
            		}
            		else {
HXDLIN(  83)			_hx_tmp2 = false;
            		}
HXDLIN(  83)		if (!(_hx_tmp2)) {
HXDLIN(  83)			if ((x3 == x4)) {
HXDLIN(  83)				_hx_tmp1 = (y3 == y4);
            			}
            			else {
HXDLIN(  83)				_hx_tmp1 = false;
            			}
            		}
            		else {
HXDLIN(  83)			_hx_tmp1 = true;
            		}
HXDLIN(  83)		if (_hx_tmp1) {
HXDLIN(  83)			_hx_tmp = null();
            		}
            		else {
HXDLIN(  83)			if ((denominator == 0)) {
HXDLIN(  83)				_hx_tmp = null();
            			}
            			else {
HXDLIN(  83)				Float ua = ((((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3))) / denominator);
HXDLIN(  83)				Float ub = ((((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3))) / denominator);
HXDLIN(  83)				bool _hx_tmp3;
HXDLIN(  83)				bool _hx_tmp4;
HXDLIN(  83)				bool _hx_tmp5;
HXDLIN(  83)				if (!((ua < 0))) {
HXDLIN(  83)					_hx_tmp5 = (ua > 1);
            				}
            				else {
HXDLIN(  83)					_hx_tmp5 = true;
            				}
HXDLIN(  83)				if (!(_hx_tmp5)) {
HXDLIN(  83)					_hx_tmp4 = (ub < 0);
            				}
            				else {
HXDLIN(  83)					_hx_tmp4 = true;
            				}
HXDLIN(  83)				if (!(_hx_tmp4)) {
HXDLIN(  83)					_hx_tmp3 = (ub > 1);
            				}
            				else {
HXDLIN(  83)					_hx_tmp3 = true;
            				}
HXDLIN(  83)				if (_hx_tmp3) {
HXDLIN(  83)					_hx_tmp = null();
            				}
            				else {
HXDLIN(  83)					Float x = (x1 + (ua * (x2 - x1)));
HXDLIN(  83)					Float y = (y1 + (ua * (y2 - y1)));
HXDLIN(  83)					Float _g = ( (Float)(::Std_obj::_hx_int(x)) );
HXDLIN(  83)					_hx_tmp =  ::vision::ds::Point2D_obj::__alloc( HX_CTX ,_g,( (Float)(::Std_obj::_hx_int(y)) ));
            				}
            			}
            		}
HXDLIN(  83)		if (::hx::IsNotNull( _hx_tmp )) {
HXDLIN(  83)			return ( (Float)(0) );
            		}
            		else {
HXDLIN(  83)			 ::vision::ds::Point2D point = line->start;
HXDLIN(  83)			Float ch = ((((this->start->y - this->end->y) * point->x) + ((this->end->x - this->start->x) * point->y)) + ((this->start->x * this->end->y) - (this->end->x * this->start->y)));
HXDLIN(  83)			Float del = ::Math_obj::sqrt((::Math_obj::pow((this->end->x - this->start->x),( (Float)(2) )) + ::Math_obj::pow((this->end->y - this->start->y),( (Float)(2) ))));
HXDLIN(  83)			Float d = (ch / del);
HXDLIN(  83)			Float distance1 = d;
HXDLIN(  83)			 ::vision::ds::Point2D point1 = line->end;
HXDLIN(  83)			Float ch1 = ((((this->start->y - this->end->y) * point1->x) + ((this->end->x - this->start->x) * point1->y)) + ((this->start->x * this->end->y) - (this->end->x * this->start->y)));
HXDLIN(  83)			Float del1 = ::Math_obj::sqrt((::Math_obj::pow((this->end->x - this->start->x),( (Float)(2) )) + ::Math_obj::pow((this->end->y - this->start->y),( (Float)(2) ))));
HXDLIN(  83)			Float d1 = (ch1 / del1);
HXDLIN(  83)			Float distance2 = d1;
HXDLIN(  83)			 ::vision::ds::Point2D point2 = this->start;
HXDLIN(  83)			Float ch2 = ((((line->start->y - line->end->y) * point2->x) + ((line->end->x - line->start->x) * point2->y)) + ((line->start->x * line->end->y) - (line->end->x * line->start->y)));
HXDLIN(  83)			Float del2 = ::Math_obj::sqrt((::Math_obj::pow((line->end->x - line->start->x),( (Float)(2) )) + ::Math_obj::pow((line->end->y - line->start->y),( (Float)(2) ))));
HXDLIN(  83)			Float d2 = (ch2 / del2);
HXDLIN(  83)			Float distance3 = d2;
HXDLIN(  83)			 ::vision::ds::Point2D point3 = this->end;
HXDLIN(  83)			Float ch3 = ((((line->start->y - line->end->y) * point3->x) + ((line->end->x - line->start->x) * point3->y)) + ((line->start->x * line->end->y) - (line->end->x * line->start->y)));
HXDLIN(  83)			Float del3 = ::Math_obj::sqrt((::Math_obj::pow((line->end->x - line->start->x),( (Float)(2) )) + ::Math_obj::pow((line->end->y - line->start->y),( (Float)(2) ))));
HXDLIN(  83)			Float d3 = (ch3 / del3);
HXDLIN(  83)			Float distance4 = d3;
HXDLIN(  83)			::Array< Float > values = ::Array_obj< Float >::__new(4)->init(0,distance1)->init(1,distance2)->init(2,distance3)->init(3,distance4);
HXDLIN(  83)			Float min = values->__get(0);
HXDLIN(  83)			{
HXDLIN(  83)				int _g1 = 0;
HXDLIN(  83)				int _g2 = values->length;
HXDLIN(  83)				while((_g1 < _g2)){
HXDLIN(  83)					_g1 = (_g1 + 1);
HXDLIN(  83)					int i = (_g1 - 1);
HXDLIN(  83)					if ((values->__get(i) < min)) {
HXDLIN(  83)						min = values->__get(i);
            					}
            				}
            			}
HXDLIN(  83)			Float distance = min;
HXDLIN(  83)			return distance;
            		}
HXDLIN(  83)		return ((Float)0.);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Line2D_obj,distanceTo,return )

::String Line2D_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_ca7ce2accd6837d2_91_toString)
HXDLIN(  91)		return ((((((((HX_("\n (",92,b2,07,00) + this->start->x) + HX_(", ",74,26,00,00)) + this->start->y) + HX_(") --> (",2f,6d,51,7b)) + this->end->x) + HX_(", ",74,26,00,00)) + this->end->y) + HX_(")",29,00,00,00));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Line2D_obj,toString,return )

 ::vision::ds::Ray2D Line2D_obj::toRay2D(){
            	HX_GC_STACKFRAME(&_hx_pos_ca7ce2accd6837d2_111_toRay2D)
HXDLIN( 111)		return  ::vision::ds::Ray2D_obj::__alloc( HX_CTX ,this->start,this->slope,null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(Line2D_obj,toRay2D,return )

 ::vision::ds::Point2D Line2D_obj::set_start( ::vision::ds::Point2D value){
            	HX_STACKFRAME(&_hx_pos_ca7ce2accd6837d2_114_set_start)
HXLINE( 115)		 ::vision::ds::Point2D point2 = this->end;
HXDLIN( 115)		Float x = (point2->x - value->x);
HXDLIN( 115)		Float y = (point2->y - value->y);
HXDLIN( 115)		this->radians = ::Math_obj::atan2(x,y);
HXLINE( 116)		this->slope = ::Math_obj::tan(this->radians);
HXLINE( 117)		this->degrees = ((this->radians * ( (Float)(180) )) / ::Math_obj::PI);
HXLINE( 118)		return (this->start = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Line2D_obj,set_start,return )

 ::vision::ds::Point2D Line2D_obj::set_end( ::vision::ds::Point2D value){
            	HX_STACKFRAME(&_hx_pos_ca7ce2accd6837d2_121_set_end)
HXLINE( 122)		 ::vision::ds::Point2D point2 = this->end;
HXDLIN( 122)		Float x = (point2->x - value->x);
HXDLIN( 122)		Float y = (point2->y - value->y);
HXDLIN( 122)		this->radians = ::Math_obj::atan2(x,y);
HXLINE( 123)		this->slope = ::Math_obj::tan(this->radians);
HXLINE( 124)		this->degrees = ((this->radians * ( (Float)(180) )) / ::Math_obj::PI);
HXLINE( 125)		return (this->end = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Line2D_obj,set_end,return )

 ::vision::ds::Point2D Line2D_obj::get_middle(){
            	HX_GC_STACKFRAME(&_hx_pos_ca7ce2accd6837d2_129_get_middle)
HXDLIN( 129)		return  ::vision::ds::Point2D_obj::__alloc( HX_CTX ,((this->start->x + this->end->x) / ( (Float)(2) )),((this->start->y + this->end->y) / ( (Float)(2) )));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Line2D_obj,get_middle,return )

 ::vision::ds::Point2D Line2D_obj::set_middle( ::vision::ds::Point2D value){
            	HX_GC_STACKFRAME(&_hx_pos_ca7ce2accd6837d2_132_set_middle)
HXLINE( 133)		Float previousMiddle_x = ((this->start->x + this->end->x) / ( (Float)(2) ));
HXDLIN( 133)		Float previousMiddle_y = ((this->start->y + this->end->y) / ( (Float)(2) ));
HXLINE( 134)		Float diffX = (value->x - previousMiddle_x);
HXLINE( 135)		Float diffY = (value->y - previousMiddle_y);
HXLINE( 137)		 ::vision::ds::Point2D fh = this->start;
HXDLIN( 137)		fh->y = (fh->y + diffY);
HXLINE( 138)		 ::vision::ds::Point2D fh1 = this->end;
HXDLIN( 138)		fh1->y = (fh1->y + diffY);
HXLINE( 139)		 ::vision::ds::Point2D fh2 = this->start;
HXDLIN( 139)		fh2->x = (fh2->x + diffX);
HXLINE( 140)		 ::vision::ds::Point2D fh3 = this->end;
HXDLIN( 140)		fh3->x = (fh3->x + diffX);
HXLINE( 142)		return  ::vision::ds::Point2D_obj::__alloc( HX_CTX ,((this->start->x + this->end->x) / ( (Float)(2) )),((this->start->y + this->end->y) / ( (Float)(2) )));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Line2D_obj,set_middle,return )

 ::vision::ds::Line2D Line2D_obj::fromRay2D( ::vision::ds::Ray2D ray){
            	HX_GC_STACKFRAME(&_hx_pos_ca7ce2accd6837d2_99_fromRay2D)
HXLINE( 100)		Float x = ray->point->x;
HXLINE( 101)		Float y = ray->point->y;
HXLINE( 102)		Float length = ( (Float)(1) );
HXLINE( 103)		int end = ::Std_obj::_hx_int((x + (length * ::Math_obj::cos(ray->radians))));
HXDLIN( 103)		 ::vision::ds::Point2D end1 =  ::vision::ds::Point2D_obj::__alloc( HX_CTX ,end,::Std_obj::_hx_int((y + (length * ::Math_obj::sin(ray->radians)))));
HXLINE( 104)		return  ::vision::ds::Line2D_obj::__alloc( HX_CTX ,ray->point,end1);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Line2D_obj,fromRay2D,return )


::hx::ObjectPtr< Line2D_obj > Line2D_obj::__new( ::vision::ds::Point2D start, ::vision::ds::Point2D end) {
	::hx::ObjectPtr< Line2D_obj > __this = new Line2D_obj();
	__this->__construct(start,end);
	return __this;
}

::hx::ObjectPtr< Line2D_obj > Line2D_obj::__alloc(::hx::Ctx *_hx_ctx, ::vision::ds::Point2D start, ::vision::ds::Point2D end) {
	Line2D_obj *__this = (Line2D_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Line2D_obj), true, "vision.ds.Line2D"));
	*(void **)__this = Line2D_obj::_hx_vtable;
	__this->__construct(start,end);
	return __this;
}

Line2D_obj::Line2D_obj()
{
}

void Line2D_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Line2D);
	HX_MARK_MEMBER_NAME(length,"length");
	HX_MARK_MEMBER_NAME(slope,"slope");
	HX_MARK_MEMBER_NAME(degrees,"degrees");
	HX_MARK_MEMBER_NAME(radians,"radians");
	HX_MARK_MEMBER_NAME(start,"start");
	HX_MARK_MEMBER_NAME(end,"end");
	HX_MARK_END_CLASS();
}

void Line2D_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(length,"length");
	HX_VISIT_MEMBER_NAME(slope,"slope");
	HX_VISIT_MEMBER_NAME(degrees,"degrees");
	HX_VISIT_MEMBER_NAME(radians,"radians");
	HX_VISIT_MEMBER_NAME(start,"start");
	HX_VISIT_MEMBER_NAME(end,"end");
}

::hx::Val Line2D_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"end") ) { return ::hx::Val( end ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"slope") ) { return ::hx::Val( slope ); }
		if (HX_FIELD_EQ(inName,"start") ) { return ::hx::Val( start ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"length") ) { return ::hx::Val( inCallProp == ::hx::paccAlways ? get_length() : length ); }
		if (HX_FIELD_EQ(inName,"middle") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_middle() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"degrees") ) { return ::hx::Val( degrees ); }
		if (HX_FIELD_EQ(inName,"radians") ) { return ::hx::Val( radians ); }
		if (HX_FIELD_EQ(inName,"toRay2D") ) { return ::hx::Val( toRay2D_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_end") ) { return ::hx::Val( set_end_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"toString") ) { return ::hx::Val( toString_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"intersect") ) { return ::hx::Val( intersect_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_start") ) { return ::hx::Val( set_start_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"get_length") ) { return ::hx::Val( get_length_dyn() ); }
		if (HX_FIELD_EQ(inName,"distanceTo") ) { return ::hx::Val( distanceTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_middle") ) { return ::hx::Val( get_middle_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_middle") ) { return ::hx::Val( set_middle_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Line2D_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"fromRay2D") ) { outValue = fromRay2D_dyn(); return true; }
	}
	return false;
}

::hx::Val Line2D_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"end") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_end(inValue.Cast<  ::vision::ds::Point2D >()) );end=inValue.Cast<  ::vision::ds::Point2D >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"slope") ) { slope=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"start") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_start(inValue.Cast<  ::vision::ds::Point2D >()) );start=inValue.Cast<  ::vision::ds::Point2D >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"length") ) { length=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"middle") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_middle(inValue.Cast<  ::vision::ds::Point2D >()) ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"degrees") ) { degrees=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"radians") ) { radians=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Line2D_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("length",e6,94,07,9f));
	outFields->push(HX_("slope",2b,5d,cc,7e));
	outFields->push(HX_("degrees",a7,e3,5a,3a));
	outFields->push(HX_("radians",72,46,f0,26));
	outFields->push(HX_("start",62,74,0b,84));
	outFields->push(HX_("end",db,03,4d,00));
	outFields->push(HX_("middle",55,d3,5e,4c));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Line2D_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(Line2D_obj,length),HX_("length",e6,94,07,9f)},
	{::hx::fsFloat,(int)offsetof(Line2D_obj,slope),HX_("slope",2b,5d,cc,7e)},
	{::hx::fsFloat,(int)offsetof(Line2D_obj,degrees),HX_("degrees",a7,e3,5a,3a)},
	{::hx::fsFloat,(int)offsetof(Line2D_obj,radians),HX_("radians",72,46,f0,26)},
	{::hx::fsObject /*  ::vision::ds::Point2D */ ,(int)offsetof(Line2D_obj,start),HX_("start",62,74,0b,84)},
	{::hx::fsObject /*  ::vision::ds::Point2D */ ,(int)offsetof(Line2D_obj,end),HX_("end",db,03,4d,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Line2D_obj_sStaticStorageInfo = 0;
#endif

static ::String Line2D_obj_sMemberFields[] = {
	HX_("length",e6,94,07,9f),
	HX_("slope",2b,5d,cc,7e),
	HX_("degrees",a7,e3,5a,3a),
	HX_("radians",72,46,f0,26),
	HX_("start",62,74,0b,84),
	HX_("end",db,03,4d,00),
	HX_("get_length",af,04,8f,8f),
	HX_("intersect",df,00,75,42),
	HX_("distanceTo",10,d4,ec,8b),
	HX_("toString",ac,d0,6e,38),
	HX_("toRay2D",c1,1c,ac,b0),
	HX_("set_start",c5,bc,05,ab),
	HX_("set_end",7e,5d,c3,19),
	HX_("get_middle",1e,43,e6,3c),
	HX_("set_middle",92,e1,63,40),
	::String(null()) };

::hx::Class Line2D_obj::__mClass;

static ::String Line2D_obj_sStaticFields[] = {
	HX_("fromRay2D",72,ba,b0,98),
	::String(null())
};

void Line2D_obj::__register()
{
	Line2D_obj _hx_dummy;
	Line2D_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("vision.ds.Line2D",df,cb,31,1c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Line2D_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Line2D_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Line2D_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Line2D_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Line2D_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Line2D_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace vision
} // end namespace ds
