// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_vision_ds_Array2D
#include <vision/ds/Array2D.h>
#endif
#ifndef INCLUDED_vision_exceptions_MatrixOperationError
#include <vision/exceptions/MatrixOperationError.h>
#endif
#ifndef INCLUDED_vision_exceptions_VisionException
#include <vision/exceptions/VisionException.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_3b4015f92377854f_15_new,"vision.exceptions.MatrixOperationError","new",0xf358ff38,"vision.exceptions.MatrixOperationError.new","vision/exceptions/MatrixOperationError.hx",15,0xe8fb1598)
HX_LOCAL_STACK_FRAME(_hx_pos_3b4015f92377854f_18_errorByType,"vision.exceptions.MatrixOperationError","errorByType",0x5d58b8f1,"vision.exceptions.MatrixOperationError.errorByType","vision/exceptions/MatrixOperationError.hx",18,0xe8fb1598)
static const ::String _hx_array_data_18334346_45[] = {
	HX_("",00,00,00,00),
};
static const ::String _hx_array_data_18334346_46[] = {
	HX_("",00,00,00,00),
};
static const ::String _hx_array_data_18334346_47[] = {
	HX_("",00,00,00,00),
};
static const ::String _hx_array_data_18334346_48[] = {
	HX_("",00,00,00,00),
};
namespace vision{
namespace exceptions{

void MatrixOperationError_obj::__construct(::String op,::Array< ::Dynamic> matrices,int offense){
            	HX_STACKFRAME(&_hx_pos_3b4015f92377854f_15_new)
HXDLIN(  15)		{
HXDLIN(  15)			::String _hx_tmp = ::vision::exceptions::MatrixOperationError_obj::errorByType(op,matrices,offense);
HXDLIN(  15)			::String _hx_tmp1 = op.charAt(0).toUpperCase();
HXDLIN(  15)			super::__construct(_hx_tmp,((HX_("Matrix ",9f,6a,b8,60) + (_hx_tmp1 + op.substr(1,null()))) + HX_(" Error",88,c7,c2,d1)));
            		}
HXDLIN(  15)		{
HXDLIN(  15)			this->_hx___skipStack++;
            		}
            	}

Dynamic MatrixOperationError_obj::__CreateEmpty() { return new MatrixOperationError_obj; }

void *MatrixOperationError_obj::_hx_vtable = 0;

Dynamic MatrixOperationError_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< MatrixOperationError_obj > _hx_result = new MatrixOperationError_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool MatrixOperationError_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x677ddc49) {
		if (inClassId<=(int)0x122b8ece) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x122b8ece;
		} else {
			return inClassId==(int)0x677ddc49;
		}
	} else {
		return inClassId==(int)0x7cf1c557;
	}
}

::String MatrixOperationError_obj::errorByType(::String type,::Array< ::Dynamic> mats,int off){
            	HX_STACKFRAME(&_hx_pos_3b4015f92377854f_18_errorByType)
HXLINE(  19)		::String sign = HX_("",00,00,00,00);
HXLINE(  20)		::String _hx_switch_0 = type;
            		if (  (_hx_switch_0==HX_("Add",01,aa,31,00)) ||  (_hx_switch_0==HX_("Addition",1c,29,f1,81)) ||  (_hx_switch_0==HX_("add",21,f2,49,00)) ||  (_hx_switch_0==HX_("addition",fc,6c,3f,a8)) ){
HXLINE(  23)			sign = HX_("+",2b,00,00,00);
HXDLIN(  23)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("Div",31,f5,33,00)) ||  (_hx_switch_0==HX_("Division",4d,19,37,2f)) ||  (_hx_switch_0==HX_("div",51,3d,4c,00)) ||  (_hx_switch_0==HX_("division",2d,5d,85,55)) ){
HXLINE(  22)			sign = HX_W(u"\u00f7",aa94,0000);
HXDLIN(  22)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("Mult",10,94,3e,33)) ||  (_hx_switch_0==HX_("Multiplication",a6,08,95,a4)) ||  (_hx_switch_0==HX_("mult",f0,67,65,48)) ||  (_hx_switch_0==HX_("multiplication",86,74,3f,fa)) ){
HXLINE(  21)			sign = HX_W(u"\u00d7",aa74,0000);
HXDLIN(  21)			goto _hx_goto_1;
            		}
            		if (  (_hx_switch_0==HX_("Sub",60,61,3f,00)) ||  (_hx_switch_0==HX_("Subtraction",14,95,40,f0)) ||  (_hx_switch_0==HX_("sub",80,a9,57,00)) ||  (_hx_switch_0==HX_("subtraction",34,fd,0d,0c)) ){
HXLINE(  24)			sign = HX_("-",2d,00,00,00);
HXDLIN(  24)			goto _hx_goto_1;
            		}
            		_hx_goto_1:;
HXLINE(  27)		::String msg = HX_("Cannot calculate:\n\n",f1,cc,ab,26);
HXLINE(  28)		::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN(  28)		{
HXLINE(  28)			int _g1 = 0;
HXDLIN(  28)			 ::vision::ds::Array2D this1 = mats->__get(0).StaticCast<  ::vision::ds::Array2D >();
HXDLIN(  28)			::String array;
HXDLIN(  28)			{
HXLINE(  28)				int maxLen = 1;
HXDLIN(  28)				{
HXLINE(  28)					int _g2 = 0;
HXDLIN(  28)					::Array< Float > _g3 = this1->inner;
HXDLIN(  28)					while((_g2 < _g3->length)){
HXLINE(  28)						Float item = _g3->__get(_g2);
HXDLIN(  28)						_g2 = (_g2 + 1);
HXDLIN(  28)						Float multiplier = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)						int len = ::Std_obj::string((( (Float)(::Math_obj::round((item * multiplier))) ) / multiplier)).length;
HXDLIN(  28)						if ((len > maxLen)) {
HXLINE(  28)							maxLen = len;
            						}
            					}
            				}
HXDLIN(  28)				maxLen = (maxLen + 1);
HXDLIN(  28)				::String st = HX_("",00,00,00,00);
HXDLIN(  28)				{
HXLINE(  28)					int _g4 = 0;
HXDLIN(  28)					int _g5 = (((maxLen * this1->width) + (2 * (this1->width - 1))) - 1);
HXDLIN(  28)					while((_g4 < _g5)){
HXLINE(  28)						_g4 = (_g4 + 1);
HXDLIN(  28)						int i = (_g4 - 1);
HXDLIN(  28)						st = (st + HX_(" ",20,00,00,00));
            					}
            				}
HXDLIN(  28)				::String top = ((HX_W(u"\n\u250c ",cd10,57d4) + st) + HX_W(u" \u2510",d2be,15d2));
HXDLIN(  28)				::String st1 = HX_("",00,00,00,00);
HXDLIN(  28)				{
HXLINE(  28)					int _g6 = 0;
HXDLIN(  28)					int _g7 = (((maxLen * this1->width) + (2 * (this1->width - 1))) - 1);
HXDLIN(  28)					while((_g6 < _g7)){
HXLINE(  28)						_g6 = (_g6 + 1);
HXDLIN(  28)						int i1 = (_g6 - 1);
HXDLIN(  28)						st1 = (st1 + HX_(" ",20,00,00,00));
            					}
            				}
HXDLIN(  28)				::String bottom = ((HX_W(u"\u2514 ",06fe,95d3) + st1) + HX_W(u" \u2518",d2c6,15d2));
HXDLIN(  28)				::Array< ::String > rows = ::Array_obj< ::String >::fromData( _hx_array_data_18334346_45,1);
HXDLIN(  28)				int counter = 0;
HXDLIN(  28)				int floor = 0;
HXDLIN(  28)				{
HXLINE(  28)					int _g8 = 0;
HXDLIN(  28)					::Array< Float > _g9 = this1->inner;
HXDLIN(  28)					while((_g8 < _g9->length)){
HXLINE(  28)						Float item1 = _g9->__get(_g8);
HXDLIN(  28)						_g8 = (_g8 + 1);
HXDLIN(  28)						if ((counter < this1->width)) {
HXLINE(  28)							Float multiplier1 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)							::String itemString = ::Std_obj::string((( (Float)(::Math_obj::round((item1 * multiplier1))) ) / multiplier1));
HXDLIN(  28)							Float multiplier2 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)							if ((item1 != (( (Float)(::Math_obj::round((item1 * multiplier2))) ) / multiplier2))) {
HXLINE(  28)								itemString = (itemString + HX_W(u"\u2026",ed88,00ab));
            							}
HXDLIN(  28)							if ((itemString.length < maxLen)) {
HXLINE(  28)								::String st2 = HX_("",00,00,00,00);
HXDLIN(  28)								{
HXLINE(  28)									int _g10 = 0;
HXDLIN(  28)									int _g11 = ::Math_obj::floor((( (Float)((maxLen - itemString.length)) ) / ( (Float)(2) )));
HXDLIN(  28)									while((_g10 < _g11)){
HXLINE(  28)										_g10 = (_g10 + 1);
HXDLIN(  28)										int i2 = (_g10 - 1);
HXDLIN(  28)										st2 = (st2 + HX_(" ",20,00,00,00));
            									}
            								}
HXDLIN(  28)								::String itemString1 = (st2 + itemString);
HXDLIN(  28)								::String st3 = HX_("",00,00,00,00);
HXDLIN(  28)								{
HXLINE(  28)									int _g12 = 0;
HXDLIN(  28)									int _g13 = ::Math_obj::ceil((( (Float)((maxLen - itemString.length)) ) / ( (Float)(2) )));
HXDLIN(  28)									while((_g12 < _g13)){
HXLINE(  28)										_g12 = (_g12 + 1);
HXDLIN(  28)										int i3 = (_g12 - 1);
HXDLIN(  28)										st3 = (st3 + HX_(" ",20,00,00,00));
            									}
            								}
HXDLIN(  28)								itemString = (itemString1 + st3);
            							}
HXDLIN(  28)							::String add = (HX_(", ",74,26,00,00) + itemString);
HXDLIN(  28)							if ((counter == 0)) {
HXLINE(  28)								add = add.substr(2,null());
            							}
HXDLIN(  28)							::Array< ::String > rows1 = rows;
HXDLIN(  28)							int floor1 = floor;
HXDLIN(  28)							rows1[floor1] = (rows1->__get(floor1) + add);
HXDLIN(  28)							counter = (counter + 1);
            						}
            						else {
HXLINE(  28)							counter = 0;
HXDLIN(  28)							floor = (floor + 1);
HXDLIN(  28)							rows[floor] = HX_("",00,00,00,00);
HXDLIN(  28)							Float multiplier3 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)							::String itemString2 = ::Std_obj::string((( (Float)(::Math_obj::round((item1 * multiplier3))) ) / multiplier3));
HXDLIN(  28)							Float multiplier4 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)							if ((item1 != (( (Float)(::Math_obj::round((item1 * multiplier4))) ) / multiplier4))) {
HXLINE(  28)								itemString2 = (itemString2 + HX_W(u"\u2026",ed88,00ab));
            							}
HXDLIN(  28)							if ((itemString2.length < maxLen)) {
HXLINE(  28)								::String st4 = HX_("",00,00,00,00);
HXDLIN(  28)								{
HXLINE(  28)									int _g14 = 0;
HXDLIN(  28)									int _g15 = ::Math_obj::floor((( (Float)((maxLen - itemString2.length)) ) / ( (Float)(2) )));
HXDLIN(  28)									while((_g14 < _g15)){
HXLINE(  28)										_g14 = (_g14 + 1);
HXDLIN(  28)										int i4 = (_g14 - 1);
HXDLIN(  28)										st4 = (st4 + HX_(" ",20,00,00,00));
            									}
            								}
HXDLIN(  28)								::String itemString3 = (st4 + itemString2);
HXDLIN(  28)								::String st5 = HX_("",00,00,00,00);
HXDLIN(  28)								{
HXLINE(  28)									int _g16 = 0;
HXDLIN(  28)									int _g17 = ::Math_obj::ceil((( (Float)((maxLen - itemString2.length)) ) / ( (Float)(2) )));
HXDLIN(  28)									while((_g16 < _g17)){
HXLINE(  28)										_g16 = (_g16 + 1);
HXDLIN(  28)										int i5 = (_g16 - 1);
HXDLIN(  28)										st5 = (st5 + HX_(" ",20,00,00,00));
            									}
            								}
HXDLIN(  28)								itemString2 = (itemString3 + st5);
            							}
HXDLIN(  28)							::String add1 = (HX_("",00,00,00,00) + itemString2);
HXDLIN(  28)							::Array< ::String > rows2 = rows;
HXDLIN(  28)							int floor2 = floor;
HXDLIN(  28)							rows2[floor2] = (rows2->__get(floor2) + add1);
HXDLIN(  28)							counter = (counter + 1);
            						}
            					}
            				}
HXDLIN(  28)				::String string = (top + HX_("\n",0a,00,00,00));
HXDLIN(  28)				{
HXLINE(  28)					int _g18 = 0;
HXDLIN(  28)					while((_g18 < rows->length)){
HXLINE(  28)						::String r = rows->__get(_g18);
HXDLIN(  28)						_g18 = (_g18 + 1);
HXDLIN(  28)						string = (string + ((HX_W(u"\u2502 ",f750,95d2) + r) + HX_W(u"\u2502\n",f73a,95d2)));
            					}
            				}
HXDLIN(  28)				string = (string + bottom);
HXDLIN(  28)				array = string;
            			}
HXDLIN(  28)			int array1 = array.split(HX_("\n",0a,00,00,00))->length;
HXDLIN(  28)			 ::vision::ds::Array2D this2 = mats->__get(1).StaticCast<  ::vision::ds::Array2D >();
HXDLIN(  28)			::String array2;
HXDLIN(  28)			{
HXLINE(  28)				int maxLen1 = 1;
HXDLIN(  28)				{
HXLINE(  28)					int _g19 = 0;
HXDLIN(  28)					::Array< Float > _g20 = this2->inner;
HXDLIN(  28)					while((_g19 < _g20->length)){
HXLINE(  28)						Float item2 = _g20->__get(_g19);
HXDLIN(  28)						_g19 = (_g19 + 1);
HXDLIN(  28)						Float multiplier5 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)						int len1 = ::Std_obj::string((( (Float)(::Math_obj::round((item2 * multiplier5))) ) / multiplier5)).length;
HXDLIN(  28)						if ((len1 > maxLen1)) {
HXLINE(  28)							maxLen1 = len1;
            						}
            					}
            				}
HXDLIN(  28)				maxLen1 = (maxLen1 + 1);
HXDLIN(  28)				::String st6 = HX_("",00,00,00,00);
HXDLIN(  28)				{
HXLINE(  28)					int _g21 = 0;
HXDLIN(  28)					int _g22 = (((maxLen1 * this2->width) + (2 * (this2->width - 1))) - 1);
HXDLIN(  28)					while((_g21 < _g22)){
HXLINE(  28)						_g21 = (_g21 + 1);
HXDLIN(  28)						int i6 = (_g21 - 1);
HXDLIN(  28)						st6 = (st6 + HX_(" ",20,00,00,00));
            					}
            				}
HXDLIN(  28)				::String top1 = ((HX_W(u"\n\u250c ",cd10,57d4) + st6) + HX_W(u" \u2510",d2be,15d2));
HXDLIN(  28)				::String st7 = HX_("",00,00,00,00);
HXDLIN(  28)				{
HXLINE(  28)					int _g23 = 0;
HXDLIN(  28)					int _g24 = (((maxLen1 * this2->width) + (2 * (this2->width - 1))) - 1);
HXDLIN(  28)					while((_g23 < _g24)){
HXLINE(  28)						_g23 = (_g23 + 1);
HXDLIN(  28)						int i7 = (_g23 - 1);
HXDLIN(  28)						st7 = (st7 + HX_(" ",20,00,00,00));
            					}
            				}
HXDLIN(  28)				::String bottom1 = ((HX_W(u"\u2514 ",06fe,95d3) + st7) + HX_W(u" \u2518",d2c6,15d2));
HXDLIN(  28)				::Array< ::String > rows3 = ::Array_obj< ::String >::fromData( _hx_array_data_18334346_46,1);
HXDLIN(  28)				int counter1 = 0;
HXDLIN(  28)				int floor3 = 0;
HXDLIN(  28)				{
HXLINE(  28)					int _g25 = 0;
HXDLIN(  28)					::Array< Float > _g26 = this2->inner;
HXDLIN(  28)					while((_g25 < _g26->length)){
HXLINE(  28)						Float item3 = _g26->__get(_g25);
HXDLIN(  28)						_g25 = (_g25 + 1);
HXDLIN(  28)						if ((counter1 < this2->width)) {
HXLINE(  28)							Float multiplier6 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)							::String itemString4 = ::Std_obj::string((( (Float)(::Math_obj::round((item3 * multiplier6))) ) / multiplier6));
HXDLIN(  28)							Float multiplier7 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)							if ((item3 != (( (Float)(::Math_obj::round((item3 * multiplier7))) ) / multiplier7))) {
HXLINE(  28)								itemString4 = (itemString4 + HX_W(u"\u2026",ed88,00ab));
            							}
HXDLIN(  28)							if ((itemString4.length < maxLen1)) {
HXLINE(  28)								::String st8 = HX_("",00,00,00,00);
HXDLIN(  28)								{
HXLINE(  28)									int _g27 = 0;
HXDLIN(  28)									int _g28 = ::Math_obj::floor((( (Float)((maxLen1 - itemString4.length)) ) / ( (Float)(2) )));
HXDLIN(  28)									while((_g27 < _g28)){
HXLINE(  28)										_g27 = (_g27 + 1);
HXDLIN(  28)										int i8 = (_g27 - 1);
HXDLIN(  28)										st8 = (st8 + HX_(" ",20,00,00,00));
            									}
            								}
HXDLIN(  28)								::String itemString5 = (st8 + itemString4);
HXDLIN(  28)								::String st9 = HX_("",00,00,00,00);
HXDLIN(  28)								{
HXLINE(  28)									int _g29 = 0;
HXDLIN(  28)									int _g30 = ::Math_obj::ceil((( (Float)((maxLen1 - itemString4.length)) ) / ( (Float)(2) )));
HXDLIN(  28)									while((_g29 < _g30)){
HXLINE(  28)										_g29 = (_g29 + 1);
HXDLIN(  28)										int i9 = (_g29 - 1);
HXDLIN(  28)										st9 = (st9 + HX_(" ",20,00,00,00));
            									}
            								}
HXDLIN(  28)								itemString4 = (itemString5 + st9);
            							}
HXDLIN(  28)							::String add2 = (HX_(", ",74,26,00,00) + itemString4);
HXDLIN(  28)							if ((counter1 == 0)) {
HXLINE(  28)								add2 = add2.substr(2,null());
            							}
HXDLIN(  28)							::Array< ::String > rows4 = rows3;
HXDLIN(  28)							int floor4 = floor3;
HXDLIN(  28)							rows4[floor4] = (rows4->__get(floor4) + add2);
HXDLIN(  28)							counter1 = (counter1 + 1);
            						}
            						else {
HXLINE(  28)							counter1 = 0;
HXDLIN(  28)							floor3 = (floor3 + 1);
HXDLIN(  28)							rows3[floor3] = HX_("",00,00,00,00);
HXDLIN(  28)							Float multiplier8 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)							::String itemString6 = ::Std_obj::string((( (Float)(::Math_obj::round((item3 * multiplier8))) ) / multiplier8));
HXDLIN(  28)							Float multiplier9 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)							if ((item3 != (( (Float)(::Math_obj::round((item3 * multiplier9))) ) / multiplier9))) {
HXLINE(  28)								itemString6 = (itemString6 + HX_W(u"\u2026",ed88,00ab));
            							}
HXDLIN(  28)							if ((itemString6.length < maxLen1)) {
HXLINE(  28)								::String st10 = HX_("",00,00,00,00);
HXDLIN(  28)								{
HXLINE(  28)									int _g31 = 0;
HXDLIN(  28)									int _g32 = ::Math_obj::floor((( (Float)((maxLen1 - itemString6.length)) ) / ( (Float)(2) )));
HXDLIN(  28)									while((_g31 < _g32)){
HXLINE(  28)										_g31 = (_g31 + 1);
HXDLIN(  28)										int i10 = (_g31 - 1);
HXDLIN(  28)										st10 = (st10 + HX_(" ",20,00,00,00));
            									}
            								}
HXDLIN(  28)								::String itemString7 = (st10 + itemString6);
HXDLIN(  28)								::String st11 = HX_("",00,00,00,00);
HXDLIN(  28)								{
HXLINE(  28)									int _g33 = 0;
HXDLIN(  28)									int _g34 = ::Math_obj::ceil((( (Float)((maxLen1 - itemString6.length)) ) / ( (Float)(2) )));
HXDLIN(  28)									while((_g33 < _g34)){
HXLINE(  28)										_g33 = (_g33 + 1);
HXDLIN(  28)										int i11 = (_g33 - 1);
HXDLIN(  28)										st11 = (st11 + HX_(" ",20,00,00,00));
            									}
            								}
HXDLIN(  28)								itemString6 = (itemString7 + st11);
            							}
HXDLIN(  28)							::String add3 = (HX_("",00,00,00,00) + itemString6);
HXDLIN(  28)							::Array< ::String > rows5 = rows3;
HXDLIN(  28)							int floor5 = floor3;
HXDLIN(  28)							rows5[floor5] = (rows5->__get(floor5) + add3);
HXDLIN(  28)							counter1 = (counter1 + 1);
            						}
            					}
            				}
HXDLIN(  28)				::String string1 = (top1 + HX_("\n",0a,00,00,00));
HXDLIN(  28)				{
HXLINE(  28)					int _g35 = 0;
HXDLIN(  28)					while((_g35 < rows3->length)){
HXLINE(  28)						::String r1 = rows3->__get(_g35);
HXDLIN(  28)						_g35 = (_g35 + 1);
HXDLIN(  28)						string1 = (string1 + ((HX_W(u"\u2502 ",f750,95d2) + r1) + HX_W(u"\u2502\n",f73a,95d2)));
            					}
            				}
HXDLIN(  28)				string1 = (string1 + bottom1);
HXDLIN(  28)				array2 = string1;
            			}
HXDLIN(  28)			::Array< int > values = ::Array_obj< int >::__new(2)->init(0,array1)->init(1,array2.split(HX_("\n",0a,00,00,00))->length);
HXDLIN(  28)			int max = values->__get(0);
HXDLIN(  28)			{
HXLINE(  28)				int _g36 = 0;
HXDLIN(  28)				int _g37 = values->length;
HXDLIN(  28)				while((_g36 < _g37)){
HXLINE(  28)					_g36 = (_g36 + 1);
HXDLIN(  28)					int i12 = (_g36 - 1);
HXDLIN(  28)					if ((values->__get(i12) > max)) {
HXLINE(  28)						max = values->__get(i12);
            					}
            				}
            			}
HXDLIN(  28)			int _g38 = max;
HXDLIN(  28)			while((_g1 < _g38)){
HXLINE(  28)				_g1 = (_g1 + 1);
HXDLIN(  28)				int i13 = (_g1 - 1);
HXDLIN(  28)				::String _hx_tmp;
HXDLIN(  28)				if (((mats->__get(0).StaticCast<  ::vision::ds::Array2D >()->height + 3) > i13)) {
HXLINE(  28)					 ::vision::ds::Array2D this3 = mats->__get(0).StaticCast<  ::vision::ds::Array2D >();
HXDLIN(  28)					::String _hx_tmp1;
HXDLIN(  28)					{
HXLINE(  28)						int maxLen2 = 1;
HXDLIN(  28)						{
HXLINE(  28)							int _g39 = 0;
HXDLIN(  28)							::Array< Float > _g40 = this3->inner;
HXDLIN(  28)							while((_g39 < _g40->length)){
HXLINE(  28)								Float item4 = _g40->__get(_g39);
HXDLIN(  28)								_g39 = (_g39 + 1);
HXDLIN(  28)								Float multiplier10 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)								int len2 = ::Std_obj::string((( (Float)(::Math_obj::round((item4 * multiplier10))) ) / multiplier10)).length;
HXDLIN(  28)								if ((len2 > maxLen2)) {
HXLINE(  28)									maxLen2 = len2;
            								}
            							}
            						}
HXDLIN(  28)						maxLen2 = (maxLen2 + 1);
HXDLIN(  28)						::String st12 = HX_("",00,00,00,00);
HXDLIN(  28)						{
HXLINE(  28)							int _g41 = 0;
HXDLIN(  28)							int _g42 = (((maxLen2 * this3->width) + (2 * (this3->width - 1))) - 1);
HXDLIN(  28)							while((_g41 < _g42)){
HXLINE(  28)								_g41 = (_g41 + 1);
HXDLIN(  28)								int i14 = (_g41 - 1);
HXDLIN(  28)								st12 = (st12 + HX_(" ",20,00,00,00));
            							}
            						}
HXDLIN(  28)						::String top2 = ((HX_W(u"\n\u250c ",cd10,57d4) + st12) + HX_W(u" \u2510",d2be,15d2));
HXDLIN(  28)						::String st13 = HX_("",00,00,00,00);
HXDLIN(  28)						{
HXLINE(  28)							int _g43 = 0;
HXDLIN(  28)							int _g44 = (((maxLen2 * this3->width) + (2 * (this3->width - 1))) - 1);
HXDLIN(  28)							while((_g43 < _g44)){
HXLINE(  28)								_g43 = (_g43 + 1);
HXDLIN(  28)								int i15 = (_g43 - 1);
HXDLIN(  28)								st13 = (st13 + HX_(" ",20,00,00,00));
            							}
            						}
HXDLIN(  28)						::String bottom2 = ((HX_W(u"\u2514 ",06fe,95d3) + st13) + HX_W(u" \u2518",d2c6,15d2));
HXDLIN(  28)						::Array< ::String > rows6 = ::Array_obj< ::String >::fromData( _hx_array_data_18334346_47,1);
HXDLIN(  28)						int counter2 = 0;
HXDLIN(  28)						int floor6 = 0;
HXDLIN(  28)						{
HXLINE(  28)							int _g45 = 0;
HXDLIN(  28)							::Array< Float > _g46 = this3->inner;
HXDLIN(  28)							while((_g45 < _g46->length)){
HXLINE(  28)								Float item5 = _g46->__get(_g45);
HXDLIN(  28)								_g45 = (_g45 + 1);
HXDLIN(  28)								if ((counter2 < this3->width)) {
HXLINE(  28)									Float multiplier11 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)									::String itemString8 = ::Std_obj::string((( (Float)(::Math_obj::round((item5 * multiplier11))) ) / multiplier11));
HXDLIN(  28)									Float multiplier12 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)									if ((item5 != (( (Float)(::Math_obj::round((item5 * multiplier12))) ) / multiplier12))) {
HXLINE(  28)										itemString8 = (itemString8 + HX_W(u"\u2026",ed88,00ab));
            									}
HXDLIN(  28)									if ((itemString8.length < maxLen2)) {
HXLINE(  28)										::String st14 = HX_("",00,00,00,00);
HXDLIN(  28)										{
HXLINE(  28)											int _g47 = 0;
HXDLIN(  28)											int _g48 = ::Math_obj::floor((( (Float)((maxLen2 - itemString8.length)) ) / ( (Float)(2) )));
HXDLIN(  28)											while((_g47 < _g48)){
HXLINE(  28)												_g47 = (_g47 + 1);
HXDLIN(  28)												int i16 = (_g47 - 1);
HXDLIN(  28)												st14 = (st14 + HX_(" ",20,00,00,00));
            											}
            										}
HXDLIN(  28)										::String itemString9 = (st14 + itemString8);
HXDLIN(  28)										::String st15 = HX_("",00,00,00,00);
HXDLIN(  28)										{
HXLINE(  28)											int _g49 = 0;
HXDLIN(  28)											int _g50 = ::Math_obj::ceil((( (Float)((maxLen2 - itemString8.length)) ) / ( (Float)(2) )));
HXDLIN(  28)											while((_g49 < _g50)){
HXLINE(  28)												_g49 = (_g49 + 1);
HXDLIN(  28)												int i17 = (_g49 - 1);
HXDLIN(  28)												st15 = (st15 + HX_(" ",20,00,00,00));
            											}
            										}
HXDLIN(  28)										itemString8 = (itemString9 + st15);
            									}
HXDLIN(  28)									::String add4 = (HX_(", ",74,26,00,00) + itemString8);
HXDLIN(  28)									if ((counter2 == 0)) {
HXLINE(  28)										add4 = add4.substr(2,null());
            									}
HXDLIN(  28)									::Array< ::String > rows7 = rows6;
HXDLIN(  28)									int floor7 = floor6;
HXDLIN(  28)									rows7[floor7] = (rows7->__get(floor7) + add4);
HXDLIN(  28)									counter2 = (counter2 + 1);
            								}
            								else {
HXLINE(  28)									counter2 = 0;
HXDLIN(  28)									floor6 = (floor6 + 1);
HXDLIN(  28)									rows6[floor6] = HX_("",00,00,00,00);
HXDLIN(  28)									Float multiplier13 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)									::String itemString10 = ::Std_obj::string((( (Float)(::Math_obj::round((item5 * multiplier13))) ) / multiplier13));
HXDLIN(  28)									Float multiplier14 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)									if ((item5 != (( (Float)(::Math_obj::round((item5 * multiplier14))) ) / multiplier14))) {
HXLINE(  28)										itemString10 = (itemString10 + HX_W(u"\u2026",ed88,00ab));
            									}
HXDLIN(  28)									if ((itemString10.length < maxLen2)) {
HXLINE(  28)										::String st16 = HX_("",00,00,00,00);
HXDLIN(  28)										{
HXLINE(  28)											int _g51 = 0;
HXDLIN(  28)											int _g52 = ::Math_obj::floor((( (Float)((maxLen2 - itemString10.length)) ) / ( (Float)(2) )));
HXDLIN(  28)											while((_g51 < _g52)){
HXLINE(  28)												_g51 = (_g51 + 1);
HXDLIN(  28)												int i18 = (_g51 - 1);
HXDLIN(  28)												st16 = (st16 + HX_(" ",20,00,00,00));
            											}
            										}
HXDLIN(  28)										::String itemString11 = (st16 + itemString10);
HXDLIN(  28)										::String st17 = HX_("",00,00,00,00);
HXDLIN(  28)										{
HXLINE(  28)											int _g53 = 0;
HXDLIN(  28)											int _g54 = ::Math_obj::ceil((( (Float)((maxLen2 - itemString10.length)) ) / ( (Float)(2) )));
HXDLIN(  28)											while((_g53 < _g54)){
HXLINE(  28)												_g53 = (_g53 + 1);
HXDLIN(  28)												int i19 = (_g53 - 1);
HXDLIN(  28)												st17 = (st17 + HX_(" ",20,00,00,00));
            											}
            										}
HXDLIN(  28)										itemString10 = (itemString11 + st17);
            									}
HXDLIN(  28)									::String add5 = (HX_("",00,00,00,00) + itemString10);
HXDLIN(  28)									::Array< ::String > rows8 = rows6;
HXDLIN(  28)									int floor8 = floor6;
HXDLIN(  28)									rows8[floor8] = (rows8->__get(floor8) + add5);
HXDLIN(  28)									counter2 = (counter2 + 1);
            								}
            							}
            						}
HXDLIN(  28)						::String string2 = (top2 + HX_("\n",0a,00,00,00));
HXDLIN(  28)						{
HXLINE(  28)							int _g55 = 0;
HXDLIN(  28)							while((_g55 < rows6->length)){
HXLINE(  28)								::String r2 = rows6->__get(_g55);
HXDLIN(  28)								_g55 = (_g55 + 1);
HXDLIN(  28)								string2 = (string2 + ((HX_W(u"\u2502 ",f750,95d2) + r2) + HX_W(u"\u2502\n",f73a,95d2)));
            							}
            						}
HXDLIN(  28)						string2 = (string2 + bottom2);
HXDLIN(  28)						_hx_tmp1 = string2;
            					}
HXDLIN(  28)					_hx_tmp = _hx_tmp1.split(HX_("\n",0a,00,00,00))->__get(i13);
            				}
            				else {
HXLINE(  28)					_hx_tmp = HX_("",00,00,00,00);
            				}
HXDLIN(  28)				::String _hx_tmp2;
HXDLIN(  28)				if (((mats->__get(1).StaticCast<  ::vision::ds::Array2D >()->height + 3) > i13)) {
HXLINE(  28)					 ::vision::ds::Array2D this4 = mats->__get(1).StaticCast<  ::vision::ds::Array2D >();
HXDLIN(  28)					::String _hx_tmp3;
HXDLIN(  28)					{
HXLINE(  28)						int maxLen3 = 1;
HXDLIN(  28)						{
HXLINE(  28)							int _g56 = 0;
HXDLIN(  28)							::Array< Float > _g57 = this4->inner;
HXDLIN(  28)							while((_g56 < _g57->length)){
HXLINE(  28)								Float item6 = _g57->__get(_g56);
HXDLIN(  28)								_g56 = (_g56 + 1);
HXDLIN(  28)								Float multiplier15 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)								int len3 = ::Std_obj::string((( (Float)(::Math_obj::round((item6 * multiplier15))) ) / multiplier15)).length;
HXDLIN(  28)								if ((len3 > maxLen3)) {
HXLINE(  28)									maxLen3 = len3;
            								}
            							}
            						}
HXDLIN(  28)						maxLen3 = (maxLen3 + 1);
HXDLIN(  28)						::String st18 = HX_("",00,00,00,00);
HXDLIN(  28)						{
HXLINE(  28)							int _g58 = 0;
HXDLIN(  28)							int _g59 = (((maxLen3 * this4->width) + (2 * (this4->width - 1))) - 1);
HXDLIN(  28)							while((_g58 < _g59)){
HXLINE(  28)								_g58 = (_g58 + 1);
HXDLIN(  28)								int i20 = (_g58 - 1);
HXDLIN(  28)								st18 = (st18 + HX_(" ",20,00,00,00));
            							}
            						}
HXDLIN(  28)						::String top3 = ((HX_W(u"\n\u250c ",cd10,57d4) + st18) + HX_W(u" \u2510",d2be,15d2));
HXDLIN(  28)						::String st19 = HX_("",00,00,00,00);
HXDLIN(  28)						{
HXLINE(  28)							int _g60 = 0;
HXDLIN(  28)							int _g61 = (((maxLen3 * this4->width) + (2 * (this4->width - 1))) - 1);
HXDLIN(  28)							while((_g60 < _g61)){
HXLINE(  28)								_g60 = (_g60 + 1);
HXDLIN(  28)								int i21 = (_g60 - 1);
HXDLIN(  28)								st19 = (st19 + HX_(" ",20,00,00,00));
            							}
            						}
HXDLIN(  28)						::String bottom3 = ((HX_W(u"\u2514 ",06fe,95d3) + st19) + HX_W(u" \u2518",d2c6,15d2));
HXDLIN(  28)						::Array< ::String > rows9 = ::Array_obj< ::String >::fromData( _hx_array_data_18334346_48,1);
HXDLIN(  28)						int counter3 = 0;
HXDLIN(  28)						int floor9 = 0;
HXDLIN(  28)						{
HXLINE(  28)							int _g62 = 0;
HXDLIN(  28)							::Array< Float > _g63 = this4->inner;
HXDLIN(  28)							while((_g62 < _g63->length)){
HXLINE(  28)								Float item7 = _g63->__get(_g62);
HXDLIN(  28)								_g62 = (_g62 + 1);
HXDLIN(  28)								if ((counter3 < this4->width)) {
HXLINE(  28)									Float multiplier16 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)									::String itemString12 = ::Std_obj::string((( (Float)(::Math_obj::round((item7 * multiplier16))) ) / multiplier16));
HXDLIN(  28)									Float multiplier17 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)									if ((item7 != (( (Float)(::Math_obj::round((item7 * multiplier17))) ) / multiplier17))) {
HXLINE(  28)										itemString12 = (itemString12 + HX_W(u"\u2026",ed88,00ab));
            									}
HXDLIN(  28)									if ((itemString12.length < maxLen3)) {
HXLINE(  28)										::String st20 = HX_("",00,00,00,00);
HXDLIN(  28)										{
HXLINE(  28)											int _g64 = 0;
HXDLIN(  28)											int _g65 = ::Math_obj::floor((( (Float)((maxLen3 - itemString12.length)) ) / ( (Float)(2) )));
HXDLIN(  28)											while((_g64 < _g65)){
HXLINE(  28)												_g64 = (_g64 + 1);
HXDLIN(  28)												int i22 = (_g64 - 1);
HXDLIN(  28)												st20 = (st20 + HX_(" ",20,00,00,00));
            											}
            										}
HXDLIN(  28)										::String itemString13 = (st20 + itemString12);
HXDLIN(  28)										::String st21 = HX_("",00,00,00,00);
HXDLIN(  28)										{
HXLINE(  28)											int _g66 = 0;
HXDLIN(  28)											int _g67 = ::Math_obj::ceil((( (Float)((maxLen3 - itemString12.length)) ) / ( (Float)(2) )));
HXDLIN(  28)											while((_g66 < _g67)){
HXLINE(  28)												_g66 = (_g66 + 1);
HXDLIN(  28)												int i23 = (_g66 - 1);
HXDLIN(  28)												st21 = (st21 + HX_(" ",20,00,00,00));
            											}
            										}
HXDLIN(  28)										itemString12 = (itemString13 + st21);
            									}
HXDLIN(  28)									::String add6 = (HX_(", ",74,26,00,00) + itemString12);
HXDLIN(  28)									if ((counter3 == 0)) {
HXLINE(  28)										add6 = add6.substr(2,null());
            									}
HXDLIN(  28)									::Array< ::String > rows10 = rows9;
HXDLIN(  28)									int floor10 = floor9;
HXDLIN(  28)									rows10[floor10] = (rows10->__get(floor10) + add6);
HXDLIN(  28)									counter3 = (counter3 + 1);
            								}
            								else {
HXLINE(  28)									counter3 = 0;
HXDLIN(  28)									floor9 = (floor9 + 1);
HXDLIN(  28)									rows9[floor9] = HX_("",00,00,00,00);
HXDLIN(  28)									Float multiplier18 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)									::String itemString14 = ::Std_obj::string((( (Float)(::Math_obj::round((item7 * multiplier18))) ) / multiplier18));
HXDLIN(  28)									Float multiplier19 = ::Math_obj::pow(( (Float)(10) ),( (Float)(3) ));
HXDLIN(  28)									if ((item7 != (( (Float)(::Math_obj::round((item7 * multiplier19))) ) / multiplier19))) {
HXLINE(  28)										itemString14 = (itemString14 + HX_W(u"\u2026",ed88,00ab));
            									}
HXDLIN(  28)									if ((itemString14.length < maxLen3)) {
HXLINE(  28)										::String st22 = HX_("",00,00,00,00);
HXDLIN(  28)										{
HXLINE(  28)											int _g68 = 0;
HXDLIN(  28)											int _g69 = ::Math_obj::floor((( (Float)((maxLen3 - itemString14.length)) ) / ( (Float)(2) )));
HXDLIN(  28)											while((_g68 < _g69)){
HXLINE(  28)												_g68 = (_g68 + 1);
HXDLIN(  28)												int i24 = (_g68 - 1);
HXDLIN(  28)												st22 = (st22 + HX_(" ",20,00,00,00));
            											}
            										}
HXDLIN(  28)										::String itemString15 = (st22 + itemString14);
HXDLIN(  28)										::String st23 = HX_("",00,00,00,00);
HXDLIN(  28)										{
HXLINE(  28)											int _g70 = 0;
HXDLIN(  28)											int _g71 = ::Math_obj::ceil((( (Float)((maxLen3 - itemString14.length)) ) / ( (Float)(2) )));
HXDLIN(  28)											while((_g70 < _g71)){
HXLINE(  28)												_g70 = (_g70 + 1);
HXDLIN(  28)												int i25 = (_g70 - 1);
HXDLIN(  28)												st23 = (st23 + HX_(" ",20,00,00,00));
            											}
            										}
HXDLIN(  28)										itemString14 = (itemString15 + st23);
            									}
HXDLIN(  28)									::String add7 = (HX_("",00,00,00,00) + itemString14);
HXDLIN(  28)									::Array< ::String > rows11 = rows9;
HXDLIN(  28)									int floor11 = floor9;
HXDLIN(  28)									rows11[floor11] = (rows11->__get(floor11) + add7);
HXDLIN(  28)									counter3 = (counter3 + 1);
            								}
            							}
            						}
HXDLIN(  28)						::String string3 = (top3 + HX_("\n",0a,00,00,00));
HXDLIN(  28)						{
HXLINE(  28)							int _g72 = 0;
HXDLIN(  28)							while((_g72 < rows9->length)){
HXLINE(  28)								::String r3 = rows9->__get(_g72);
HXDLIN(  28)								_g72 = (_g72 + 1);
HXDLIN(  28)								string3 = (string3 + ((HX_W(u"\u2502 ",f750,95d2) + r3) + HX_W(u"\u2502\n",f73a,95d2)));
            							}
            						}
HXDLIN(  28)						string3 = (string3 + bottom3);
HXDLIN(  28)						_hx_tmp3 = string3;
            					}
HXDLIN(  28)					_hx_tmp2 = _hx_tmp3.split(HX_("\n",0a,00,00,00))->__get(i13);
            				}
            				else {
HXLINE(  28)					_hx_tmp2 = HX_("",00,00,00,00);
            				}
HXDLIN(  28)				_g->push(::Array_obj< ::String >::__new(2)->init(0,_hx_tmp)->init(1,_hx_tmp2));
            			}
            		}
HXDLIN(  28)		::Array< ::Dynamic> rows12 = _g;
HXLINE(  29)		::Array< int > values1 = ::Array_obj< int >::__new(2)->init(0,(mats->__get(0).StaticCast<  ::vision::ds::Array2D >()->height + 2))->init(1,(mats->__get(1).StaticCast<  ::vision::ds::Array2D >()->height + 2));
HXDLIN(  29)		int max1 = values1->__get(0);
HXDLIN(  29)		{
HXLINE(  29)			int _g73 = 0;
HXDLIN(  29)			int _g74 = values1->length;
HXDLIN(  29)			while((_g73 < _g74)){
HXLINE(  29)				_g73 = (_g73 + 1);
HXDLIN(  29)				int i26 = (_g73 - 1);
HXDLIN(  29)				if ((values1->__get(i26) > max1)) {
HXLINE(  29)					max1 = values1->__get(i26);
            				}
            			}
            		}
HXDLIN(  29)		int signRow = ::Math_obj::ceil((( (Float)(max1) ) / ( (Float)(2) )));
HXLINE(  30)		int currentRow = 0;
HXLINE(  31)		{
HXLINE(  31)			int _g75 = 0;
HXDLIN(  31)			while((_g75 < rows12->length)){
HXLINE(  31)				::Array< ::String > r4 = rows12->__get(_g75).StaticCast< ::Array< ::String > >();
HXDLIN(  31)				_g75 = (_g75 + 1);
HXLINE(  32)				if ((r4->__get(0).length == 0)) {
HXLINE(  32)					::Array< ::String > _g76 = ::Array_obj< ::String >::__new(0);
HXDLIN(  32)					{
HXLINE(  32)						int _g77 = 0;
HXDLIN(  32)						int _g78 = r4->__get(1).length;
HXDLIN(  32)						while((_g77 < _g78)){
HXLINE(  32)							_g77 = (_g77 + 1);
HXDLIN(  32)							int i27 = (_g77 - 1);
HXDLIN(  32)							_g76->push(HX_(" ",20,00,00,00));
            						}
            					}
HXDLIN(  32)					r4[0] = _g76->join(HX_("",00,00,00,00));
            				}
HXLINE(  33)				if ((r4->__get(1).length == 0)) {
HXLINE(  33)					::Array< ::String > _g79 = ::Array_obj< ::String >::__new(0);
HXDLIN(  33)					{
HXLINE(  33)						int _g80 = 0;
HXDLIN(  33)						int _g81 = r4->__get(0).length;
HXDLIN(  33)						while((_g80 < _g81)){
HXLINE(  33)							_g80 = (_g80 + 1);
HXDLIN(  33)							int i28 = (_g80 - 1);
HXDLIN(  33)							_g79->push(HX_(" ",20,00,00,00));
            						}
            					}
HXDLIN(  33)					r4[1] = _g79->join(HX_("",00,00,00,00));
            				}
HXLINE(  35)				msg = (msg + ((HX_("\t",09,00,00,00) + r4->__get(0)) + HX_("  ",00,1c,00,00)));
HXLINE(  37)				if ((currentRow == signRow)) {
HXLINE(  38)					msg = (msg + sign);
            				}
            				else {
HXLINE(  40)					msg = (msg + HX_(" ",20,00,00,00));
            				}
HXLINE(  42)				msg = (msg + (HX_("  ",00,1c,00,00) + r4->__get(1)));
HXLINE(  43)				currentRow = (currentRow + 1);
HXLINE(  44)				msg = (msg + HX_("\n",0a,00,00,00));
            			}
            		}
HXLINE(  47)		msg = (msg + HX_("\n\t",bf,08,00,00));
HXLINE(  49)		switch((int)(off)){
            			case (int)0: {
HXLINE(  50)				msg = (msg + ((((HX_("Width of first matrix (",a8,22,22,bf) + mats->__get(0).StaticCast<  ::vision::ds::Array2D >()->width) + HX_(") is different from the height of the second (",3a,7f,c8,20)) + mats->__get(1).StaticCast<  ::vision::ds::Array2D >()->height) + HX_(")",29,00,00,00)));
            			}
            			break;
            			case (int)1: {
HXLINE(  51)				msg = (msg + ((((((((HX_("Width & height of first matrix (",1d,0c,e5,36) + mats->__get(0).StaticCast<  ::vision::ds::Array2D >()->width) + HX_W(u"\u00d7",aa74,0000)) + mats->__get(0).StaticCast<  ::vision::ds::Array2D >()->height) + HX_(") are different from those of the second matrix (",bc,e5,6c,39)) + mats->__get(1).StaticCast<  ::vision::ds::Array2D >()->width) + HX_W(u"\u00d7",aa74,0000)) + mats->__get(1).StaticCast<  ::vision::ds::Array2D >()->height) + HX_(")",29,00,00,00)));
            			}
            			break;
            			case (int)2: {
HXLINE(  52)				msg = (msg + ((((((((HX_("Width & height of first matrix (",1d,0c,e5,36) + mats->__get(0).StaticCast<  ::vision::ds::Array2D >()->width) + HX_W(u"\u00d7",aa74,0000)) + mats->__get(0).StaticCast<  ::vision::ds::Array2D >()->height) + HX_(") are different from those of the second matrix (",bc,e5,6c,39)) + mats->__get(1).StaticCast<  ::vision::ds::Array2D >()->width) + HX_W(u"\u00d7",aa74,0000)) + mats->__get(1).StaticCast<  ::vision::ds::Array2D >()->height) + HX_(")",29,00,00,00)));
            			}
            			break;
            			case (int)3: {
HXLINE(  53)				msg = (msg + ((((HX_("Width of first matrix (",a8,22,22,bf) + mats->__get(0).StaticCast<  ::vision::ds::Array2D >()->width) + HX_(") is different from the height of the second (",3a,7f,c8,20)) + mats->__get(1).StaticCast<  ::vision::ds::Array2D >()->height) + HX_(")",29,00,00,00)));
            			}
            			break;
            		}
HXLINE(  56)		return msg;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(MatrixOperationError_obj,errorByType,return )


::hx::ObjectPtr< MatrixOperationError_obj > MatrixOperationError_obj::__new(::String op,::Array< ::Dynamic> matrices,int offense) {
	::hx::ObjectPtr< MatrixOperationError_obj > __this = new MatrixOperationError_obj();
	__this->__construct(op,matrices,offense);
	return __this;
}

::hx::ObjectPtr< MatrixOperationError_obj > MatrixOperationError_obj::__alloc(::hx::Ctx *_hx_ctx,::String op,::Array< ::Dynamic> matrices,int offense) {
	MatrixOperationError_obj *__this = (MatrixOperationError_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(MatrixOperationError_obj), true, "vision.exceptions.MatrixOperationError"));
	*(void **)__this = MatrixOperationError_obj::_hx_vtable;
	__this->__construct(op,matrices,offense);
	return __this;
}

MatrixOperationError_obj::MatrixOperationError_obj()
{
}

bool MatrixOperationError_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"errorByType") ) { outValue = errorByType_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *MatrixOperationError_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *MatrixOperationError_obj_sStaticStorageInfo = 0;
#endif

::hx::Class MatrixOperationError_obj::__mClass;

static ::String MatrixOperationError_obj_sStaticFields[] = {
	HX_("errorByType",19,f2,c4,00),
	::String(null())
};

void MatrixOperationError_obj::__register()
{
	MatrixOperationError_obj _hx_dummy;
	MatrixOperationError_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("vision.exceptions.MatrixOperationError",46,43,33,18);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &MatrixOperationError_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(MatrixOperationError_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< MatrixOperationError_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = MatrixOperationError_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = MatrixOperationError_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace vision
} // end namespace exceptions
