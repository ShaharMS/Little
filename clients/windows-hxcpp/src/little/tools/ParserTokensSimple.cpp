// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_little_tools_ParserTokensSimple
#include <little/tools/ParserTokensSimple.h>
#endif
namespace little{
namespace tools{

::little::tools::ParserTokensSimple ParserTokensSimple_obj::BLOCK;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::CHARACTERS;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::CONDITION_CALL;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::DECIMAL;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::DOCUMENTATION;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::ERROR_MESSAGE;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::EXPRESSION;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::EXTERNAL;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::EXTERNAL_CONDITION;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::FALSE_VALUE;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::FUNCTION;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::FUNCTION_CALL;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::IDENTIFIER;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::MODULE;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::NOBODY;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::NULL_VALUE;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::NUMBER;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::PART_ARRAY;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::PROPERTY_ACCESS;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::READ;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::RETURN;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::SET_LINE;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::SET_MODULE;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::SIGN;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::SPLIT_LINE;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::TRUE_VALUE;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::TYPE_DECLARATION;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::VARIABLE;

::little::tools::ParserTokensSimple ParserTokensSimple_obj::WRITE;

bool ParserTokensSimple_obj::__GetStatic(const ::String &inName, ::Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	if (inName==HX_("BLOCK",2d,ad,ea,32)) { outValue = ParserTokensSimple_obj::BLOCK; return true; }
	if (inName==HX_("CHARACTERS",aa,cc,d7,47)) { outValue = ParserTokensSimple_obj::CHARACTERS; return true; }
	if (inName==HX_("CONDITION_CALL",22,65,82,fd)) { outValue = ParserTokensSimple_obj::CONDITION_CALL; return true; }
	if (inName==HX_("DECIMAL",71,88,a7,66)) { outValue = ParserTokensSimple_obj::DECIMAL; return true; }
	if (inName==HX_("DOCUMENTATION",9a,29,a7,27)) { outValue = ParserTokensSimple_obj::DOCUMENTATION; return true; }
	if (inName==HX_("ERROR_MESSAGE",d0,4e,5d,5f)) { outValue = ParserTokensSimple_obj::ERROR_MESSAGE; return true; }
	if (inName==HX_("EXPRESSION",98,85,a8,20)) { outValue = ParserTokensSimple_obj::EXPRESSION; return true; }
	if (inName==HX_("EXTERNAL",4b,d2,08,3d)) { outValue = ParserTokensSimple_obj::EXTERNAL; return true; }
	if (inName==HX_("EXTERNAL_CONDITION",47,93,5b,5f)) { outValue = ParserTokensSimple_obj::EXTERNAL_CONDITION; return true; }
	if (inName==HX_("FALSE_VALUE",55,f0,96,1b)) { outValue = ParserTokensSimple_obj::FALSE_VALUE; return true; }
	if (inName==HX_("FUNCTION",18,3b,d8,6d)) { outValue = ParserTokensSimple_obj::FUNCTION; return true; }
	if (inName==HX_("FUNCTION_CALL",65,8a,8e,e9)) { outValue = ParserTokensSimple_obj::FUNCTION_CALL; return true; }
	if (inName==HX_("IDENTIFIER",69,3c,36,c0)) { outValue = ParserTokensSimple_obj::IDENTIFIER; return true; }
	if (inName==HX_("MODULE",ac,e0,55,73)) { outValue = ParserTokensSimple_obj::MODULE; return true; }
	if (inName==HX_("NOBODY",63,3b,5a,d8)) { outValue = ParserTokensSimple_obj::NOBODY; return true; }
	if (inName==HX_("NULL_VALUE",59,84,bf,9f)) { outValue = ParserTokensSimple_obj::NULL_VALUE; return true; }
	if (inName==HX_("NUMBER",c9,32,fd,53)) { outValue = ParserTokensSimple_obj::NUMBER; return true; }
	if (inName==HX_("PART_ARRAY",ed,90,29,3d)) { outValue = ParserTokensSimple_obj::PART_ARRAY; return true; }
	if (inName==HX_("PROPERTY_ACCESS",8e,5f,ed,95)) { outValue = ParserTokensSimple_obj::PROPERTY_ACCESS; return true; }
	if (inName==HX_("READ",56,13,68,36)) { outValue = ParserTokensSimple_obj::READ; return true; }
	if (inName==HX_("RETURN",b0,50,b0,bb)) { outValue = ParserTokensSimple_obj::RETURN; return true; }
	if (inName==HX_("SET_LINE",11,4d,23,3c)) { outValue = ParserTokensSimple_obj::SET_LINE; return true; }
	if (inName==HX_("SET_MODULE",09,8f,90,d9)) { outValue = ParserTokensSimple_obj::SET_MODULE; return true; }
	if (inName==HX_("SIGN",3d,58,14,37)) { outValue = ParserTokensSimple_obj::SIGN; return true; }
	if (inName==HX_("SPLIT_LINE",d9,b6,ad,95)) { outValue = ParserTokensSimple_obj::SPLIT_LINE; return true; }
	if (inName==HX_("TRUE_VALUE",60,dc,59,88)) { outValue = ParserTokensSimple_obj::TRUE_VALUE; return true; }
	if (inName==HX_("TYPE_DECLARATION",95,c8,ac,6c)) { outValue = ParserTokensSimple_obj::TYPE_DECLARATION; return true; }
	if (inName==HX_("VARIABLE",3c,a2,92,c2)) { outValue = ParserTokensSimple_obj::VARIABLE; return true; }
	if (inName==HX_("WRITE",bf,a4,47,4e)) { outValue = ParserTokensSimple_obj::WRITE; return true; }
	return super::__GetStatic(inName, outValue, inCallProp);
}

HX_DEFINE_CREATE_ENUM(ParserTokensSimple_obj)

int ParserTokensSimple_obj::__FindIndex(::String inName)
{
	if (inName==HX_("BLOCK",2d,ad,ea,32)) return 13;
	if (inName==HX_("CHARACTERS",aa,cc,d7,47)) return 19;
	if (inName==HX_("CONDITION_CALL",22,65,82,fd)) return 5;
	if (inName==HX_("DECIMAL",71,88,a7,66)) return 18;
	if (inName==HX_("DOCUMENTATION",9a,29,a7,27)) return 20;
	if (inName==HX_("ERROR_MESSAGE",d0,4e,5d,5f)) return 24;
	if (inName==HX_("EXPRESSION",98,85,a8,20)) return 12;
	if (inName==HX_("EXTERNAL",4b,d2,08,3d)) return 22;
	if (inName==HX_("EXTERNAL_CONDITION",47,93,5b,5f)) return 23;
	if (inName==HX_("FALSE_VALUE",55,f0,96,1b)) return 27;
	if (inName==HX_("FUNCTION",18,3b,d8,6d)) return 4;
	if (inName==HX_("FUNCTION_CALL",65,8a,8e,e9)) return 10;
	if (inName==HX_("IDENTIFIER",69,3c,36,c0)) return 8;
	if (inName==HX_("MODULE",ac,e0,55,73)) return 21;
	if (inName==HX_("NOBODY",63,3b,5a,d8)) return 28;
	if (inName==HX_("NULL_VALUE",59,84,bf,9f)) return 25;
	if (inName==HX_("NUMBER",c9,32,fd,53)) return 17;
	if (inName==HX_("PART_ARRAY",ed,90,29,3d)) return 14;
	if (inName==HX_("PROPERTY_ACCESS",8e,5f,ed,95)) return 15;
	if (inName==HX_("READ",56,13,68,36)) return 6;
	if (inName==HX_("RETURN",b0,50,b0,bb)) return 11;
	if (inName==HX_("SET_LINE",11,4d,23,3c)) return 0;
	if (inName==HX_("SET_MODULE",09,8f,90,d9)) return 1;
	if (inName==HX_("SIGN",3d,58,14,37)) return 16;
	if (inName==HX_("SPLIT_LINE",d9,b6,ad,95)) return 2;
	if (inName==HX_("TRUE_VALUE",60,dc,59,88)) return 26;
	if (inName==HX_("TYPE_DECLARATION",95,c8,ac,6c)) return 9;
	if (inName==HX_("VARIABLE",3c,a2,92,c2)) return 3;
	if (inName==HX_("WRITE",bf,a4,47,4e)) return 7;
	return super::__FindIndex(inName);
}

int ParserTokensSimple_obj::__FindArgCount(::String inName)
{
	if (inName==HX_("BLOCK",2d,ad,ea,32)) return 0;
	if (inName==HX_("CHARACTERS",aa,cc,d7,47)) return 0;
	if (inName==HX_("CONDITION_CALL",22,65,82,fd)) return 0;
	if (inName==HX_("DECIMAL",71,88,a7,66)) return 0;
	if (inName==HX_("DOCUMENTATION",9a,29,a7,27)) return 0;
	if (inName==HX_("ERROR_MESSAGE",d0,4e,5d,5f)) return 0;
	if (inName==HX_("EXPRESSION",98,85,a8,20)) return 0;
	if (inName==HX_("EXTERNAL",4b,d2,08,3d)) return 0;
	if (inName==HX_("EXTERNAL_CONDITION",47,93,5b,5f)) return 0;
	if (inName==HX_("FALSE_VALUE",55,f0,96,1b)) return 0;
	if (inName==HX_("FUNCTION",18,3b,d8,6d)) return 0;
	if (inName==HX_("FUNCTION_CALL",65,8a,8e,e9)) return 0;
	if (inName==HX_("IDENTIFIER",69,3c,36,c0)) return 0;
	if (inName==HX_("MODULE",ac,e0,55,73)) return 0;
	if (inName==HX_("NOBODY",63,3b,5a,d8)) return 0;
	if (inName==HX_("NULL_VALUE",59,84,bf,9f)) return 0;
	if (inName==HX_("NUMBER",c9,32,fd,53)) return 0;
	if (inName==HX_("PART_ARRAY",ed,90,29,3d)) return 0;
	if (inName==HX_("PROPERTY_ACCESS",8e,5f,ed,95)) return 0;
	if (inName==HX_("READ",56,13,68,36)) return 0;
	if (inName==HX_("RETURN",b0,50,b0,bb)) return 0;
	if (inName==HX_("SET_LINE",11,4d,23,3c)) return 0;
	if (inName==HX_("SET_MODULE",09,8f,90,d9)) return 0;
	if (inName==HX_("SIGN",3d,58,14,37)) return 0;
	if (inName==HX_("SPLIT_LINE",d9,b6,ad,95)) return 0;
	if (inName==HX_("TRUE_VALUE",60,dc,59,88)) return 0;
	if (inName==HX_("TYPE_DECLARATION",95,c8,ac,6c)) return 0;
	if (inName==HX_("VARIABLE",3c,a2,92,c2)) return 0;
	if (inName==HX_("WRITE",bf,a4,47,4e)) return 0;
	return super::__FindArgCount(inName);
}

::hx::Val ParserTokensSimple_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	if (inName==HX_("BLOCK",2d,ad,ea,32)) return BLOCK;
	if (inName==HX_("CHARACTERS",aa,cc,d7,47)) return CHARACTERS;
	if (inName==HX_("CONDITION_CALL",22,65,82,fd)) return CONDITION_CALL;
	if (inName==HX_("DECIMAL",71,88,a7,66)) return DECIMAL;
	if (inName==HX_("DOCUMENTATION",9a,29,a7,27)) return DOCUMENTATION;
	if (inName==HX_("ERROR_MESSAGE",d0,4e,5d,5f)) return ERROR_MESSAGE;
	if (inName==HX_("EXPRESSION",98,85,a8,20)) return EXPRESSION;
	if (inName==HX_("EXTERNAL",4b,d2,08,3d)) return EXTERNAL;
	if (inName==HX_("EXTERNAL_CONDITION",47,93,5b,5f)) return EXTERNAL_CONDITION;
	if (inName==HX_("FALSE_VALUE",55,f0,96,1b)) return FALSE_VALUE;
	if (inName==HX_("FUNCTION",18,3b,d8,6d)) return FUNCTION;
	if (inName==HX_("FUNCTION_CALL",65,8a,8e,e9)) return FUNCTION_CALL;
	if (inName==HX_("IDENTIFIER",69,3c,36,c0)) return IDENTIFIER;
	if (inName==HX_("MODULE",ac,e0,55,73)) return MODULE;
	if (inName==HX_("NOBODY",63,3b,5a,d8)) return NOBODY;
	if (inName==HX_("NULL_VALUE",59,84,bf,9f)) return NULL_VALUE;
	if (inName==HX_("NUMBER",c9,32,fd,53)) return NUMBER;
	if (inName==HX_("PART_ARRAY",ed,90,29,3d)) return PART_ARRAY;
	if (inName==HX_("PROPERTY_ACCESS",8e,5f,ed,95)) return PROPERTY_ACCESS;
	if (inName==HX_("READ",56,13,68,36)) return READ;
	if (inName==HX_("RETURN",b0,50,b0,bb)) return RETURN;
	if (inName==HX_("SET_LINE",11,4d,23,3c)) return SET_LINE;
	if (inName==HX_("SET_MODULE",09,8f,90,d9)) return SET_MODULE;
	if (inName==HX_("SIGN",3d,58,14,37)) return SIGN;
	if (inName==HX_("SPLIT_LINE",d9,b6,ad,95)) return SPLIT_LINE;
	if (inName==HX_("TRUE_VALUE",60,dc,59,88)) return TRUE_VALUE;
	if (inName==HX_("TYPE_DECLARATION",95,c8,ac,6c)) return TYPE_DECLARATION;
	if (inName==HX_("VARIABLE",3c,a2,92,c2)) return VARIABLE;
	if (inName==HX_("WRITE",bf,a4,47,4e)) return WRITE;
	return super::__Field(inName,inCallProp);
}

static ::String ParserTokensSimple_obj_sStaticFields[] = {
	HX_("SET_LINE",11,4d,23,3c),
	HX_("SET_MODULE",09,8f,90,d9),
	HX_("SPLIT_LINE",d9,b6,ad,95),
	HX_("VARIABLE",3c,a2,92,c2),
	HX_("FUNCTION",18,3b,d8,6d),
	HX_("CONDITION_CALL",22,65,82,fd),
	HX_("READ",56,13,68,36),
	HX_("WRITE",bf,a4,47,4e),
	HX_("IDENTIFIER",69,3c,36,c0),
	HX_("TYPE_DECLARATION",95,c8,ac,6c),
	HX_("FUNCTION_CALL",65,8a,8e,e9),
	HX_("RETURN",b0,50,b0,bb),
	HX_("EXPRESSION",98,85,a8,20),
	HX_("BLOCK",2d,ad,ea,32),
	HX_("PART_ARRAY",ed,90,29,3d),
	HX_("PROPERTY_ACCESS",8e,5f,ed,95),
	HX_("SIGN",3d,58,14,37),
	HX_("NUMBER",c9,32,fd,53),
	HX_("DECIMAL",71,88,a7,66),
	HX_("CHARACTERS",aa,cc,d7,47),
	HX_("DOCUMENTATION",9a,29,a7,27),
	HX_("MODULE",ac,e0,55,73),
	HX_("EXTERNAL",4b,d2,08,3d),
	HX_("EXTERNAL_CONDITION",47,93,5b,5f),
	HX_("ERROR_MESSAGE",d0,4e,5d,5f),
	HX_("NULL_VALUE",59,84,bf,9f),
	HX_("TRUE_VALUE",60,dc,59,88),
	HX_("FALSE_VALUE",55,f0,96,1b),
	HX_("NOBODY",63,3b,5a,d8),
	::String(null())
};

::hx::Class ParserTokensSimple_obj::__mClass;

Dynamic __Create_ParserTokensSimple_obj() { return new ParserTokensSimple_obj; }

void ParserTokensSimple_obj::__register()
{

::hx::Static(__mClass) = ::hx::_hx_RegisterClass(HX_("little.tools.ParserTokensSimple",b6,97,6c,97), ::hx::TCanCast< ParserTokensSimple_obj >,ParserTokensSimple_obj_sStaticFields,0,
	&__Create_ParserTokensSimple_obj, &__Create,
	&super::__SGetClass(), &CreateParserTokensSimple_obj, 0
#ifdef HXCPP_VISIT_ALLOCS
    , 0
#endif
#ifdef HXCPP_SCRIPTABLE
    , 0
#endif
);
	__mClass->mGetStaticField = &ParserTokensSimple_obj::__GetStatic;
}

void ParserTokensSimple_obj::__boot()
{
BLOCK = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("BLOCK",2d,ad,ea,32),13);
CHARACTERS = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("CHARACTERS",aa,cc,d7,47),19);
CONDITION_CALL = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("CONDITION_CALL",22,65,82,fd),5);
DECIMAL = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("DECIMAL",71,88,a7,66),18);
DOCUMENTATION = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("DOCUMENTATION",9a,29,a7,27),20);
ERROR_MESSAGE = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("ERROR_MESSAGE",d0,4e,5d,5f),24);
EXPRESSION = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("EXPRESSION",98,85,a8,20),12);
EXTERNAL = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("EXTERNAL",4b,d2,08,3d),22);
EXTERNAL_CONDITION = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("EXTERNAL_CONDITION",47,93,5b,5f),23);
FALSE_VALUE = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("FALSE_VALUE",55,f0,96,1b),27);
FUNCTION = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("FUNCTION",18,3b,d8,6d),4);
FUNCTION_CALL = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("FUNCTION_CALL",65,8a,8e,e9),10);
IDENTIFIER = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("IDENTIFIER",69,3c,36,c0),8);
MODULE = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("MODULE",ac,e0,55,73),21);
NOBODY = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("NOBODY",63,3b,5a,d8),28);
NULL_VALUE = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("NULL_VALUE",59,84,bf,9f),25);
NUMBER = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("NUMBER",c9,32,fd,53),17);
PART_ARRAY = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("PART_ARRAY",ed,90,29,3d),14);
PROPERTY_ACCESS = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("PROPERTY_ACCESS",8e,5f,ed,95),15);
READ = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("READ",56,13,68,36),6);
RETURN = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("RETURN",b0,50,b0,bb),11);
SET_LINE = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("SET_LINE",11,4d,23,3c),0);
SET_MODULE = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("SET_MODULE",09,8f,90,d9),1);
SIGN = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("SIGN",3d,58,14,37),16);
SPLIT_LINE = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("SPLIT_LINE",d9,b6,ad,95),2);
TRUE_VALUE = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("TRUE_VALUE",60,dc,59,88),26);
TYPE_DECLARATION = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("TYPE_DECLARATION",95,c8,ac,6c),9);
VARIABLE = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("VARIABLE",3c,a2,92,c2),3);
WRITE = ::hx::CreateConstEnum< ParserTokensSimple_obj >(HX_("WRITE",bf,a4,47,4e),7);
}


} // end namespace little
} // end namespace tools
