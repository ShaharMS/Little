// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_little_KeywordConfig
#include <little/KeywordConfig.h>
#endif
#ifndef INCLUDED_little_Little
#include <little/Little.h>
#endif
#ifndef INCLUDED_little_lexer_Lexer
#include <little/lexer/Lexer.h>
#endif
#ifndef INCLUDED_little_lexer_LexerTokens
#include <little/lexer/LexerTokens.h>
#endif
#ifndef INCLUDED_little_tools_TextTools
#include <little/tools/TextTools.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_d178103d13821afc_16_lex,"little.lexer.Lexer","lex",0x25ab6c03,"little.lexer.Lexer.lex","little/lexer/Lexer.hx",16,0x3d9e942e)
HX_LOCAL_STACK_FRAME(_hx_pos_d178103d13821afc_94_separateBooleanIdentifiers,"little.lexer.Lexer","separateBooleanIdentifiers",0x7945aec1,"little.lexer.Lexer.separateBooleanIdentifiers","little/lexer/Lexer.hx",94,0x3d9e942e)
HX_LOCAL_STACK_FRAME(_hx_pos_d178103d13821afc_107_mergeOrSplitKnownSigns,"little.lexer.Lexer","mergeOrSplitKnownSigns",0x47336c2e,"little.lexer.Lexer.mergeOrSplitKnownSigns","little/lexer/Lexer.hx",107,0x3d9e942e)
namespace little{
namespace lexer{

void Lexer_obj::__construct() { }

Dynamic Lexer_obj::__CreateEmpty() { return new Lexer_obj; }

void *Lexer_obj::_hx_vtable = 0;

Dynamic Lexer_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Lexer_obj > _hx_result = new Lexer_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Lexer_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x6ee2cb96;
}

::Array< ::Dynamic> Lexer_obj::lex(::String code){
            	HX_GC_STACKFRAME(&_hx_pos_d178103d13821afc_16_lex)
HXLINE(  17)		::Array< ::Dynamic> tokens = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  19)		int i = 0;
HXLINE(  20)		while((i < code.length)){
HXLINE(  21)			::String _hx_char = code.charAt(i);
HXLINE(  22)			bool _hx_tmp;
HXDLIN(  22)			if ((i < (code.length - 2))) {
HXLINE(  22)				_hx_tmp = (::little::tools::TextTools_obj::replace(code.substr(i,3),HX_("\"",22,00,00,00),HX_("",00,00,00,00)).length == 0);
            			}
            			else {
HXLINE(  22)				_hx_tmp = false;
            			}
HXDLIN(  22)			if (_hx_tmp) {
HXLINE(  23)				::String string = HX_("",00,00,00,00);
HXLINE(  24)				int queuedNewlines = 0;
HXLINE(  25)				i = (i + 3);
HXLINE(  26)				while(true){
HXLINE(  26)					bool _hx_tmp1;
HXDLIN(  26)					if ((i < (code.length - 2))) {
HXLINE(  26)						_hx_tmp1 = (::little::tools::TextTools_obj::replace(code.substr(i,3),HX_("\"",22,00,00,00),HX_("",00,00,00,00)).length != 0);
            					}
            					else {
HXLINE(  26)						_hx_tmp1 = false;
            					}
HXDLIN(  26)					if (!(_hx_tmp1)) {
HXLINE(  26)						goto _hx_goto_1;
            					}
HXLINE(  27)					string = (string + code.charAt(i));
HXLINE(  28)					if ((code.charAt(i) == HX_("\n",0a,00,00,00))) {
HXLINE(  28)						queuedNewlines = (queuedNewlines + 1);
            					}
HXLINE(  29)					i = (i + 1);
            				}
            				_hx_goto_1:;
HXLINE(  31)				i = (i + 2);
HXLINE(  32)				{
HXLINE(  32)					int _g = 0;
HXDLIN(  32)					int _g1 = queuedNewlines;
HXDLIN(  32)					while((_g < _g1)){
HXLINE(  32)						_g = (_g + 1);
HXDLIN(  32)						int j = (_g - 1);
HXDLIN(  32)						tokens->push(::little::lexer::LexerTokens_obj::Newline_dyn());
            					}
            				}
HXLINE(  33)				tokens->push(::little::lexer::LexerTokens_obj::Documentation(::StringTools_obj::trim(::little::tools::TextTools_obj::replace(::little::tools::TextTools_obj::replace(string,HX_("<br>",b2,8d,f3,27),HX_("\n",0a,00,00,00)),HX_("</br>",db,95,66,ab),HX_("\n",0a,00,00,00)))));
            			}
            			else {
HXLINE(  35)				if ((_hx_char == HX_("\"",22,00,00,00))) {
HXLINE(  36)					::String string1 = HX_("",00,00,00,00);
HXLINE(  37)					i = (i + 1);
HXLINE(  38)					while(true){
HXLINE(  38)						bool _hx_tmp2;
HXDLIN(  38)						if ((i < code.length)) {
HXLINE(  38)							_hx_tmp2 = (code.charAt(i) != HX_("\"",22,00,00,00));
            						}
            						else {
HXLINE(  38)							_hx_tmp2 = false;
            						}
HXDLIN(  38)						if (!(_hx_tmp2)) {
HXLINE(  38)							goto _hx_goto_3;
            						}
HXLINE(  39)						string1 = (string1 + code.charAt(i));
HXLINE(  40)						i = (i + 1);
            					}
            					_hx_goto_3:;
HXLINE(  42)					tokens->push(::little::lexer::LexerTokens_obj::Characters(string1));
            				}
            				else {
HXLINE(  43)					if (::little::tools::TextTools_obj::contains(HX_("1234567890.",73,61,e5,e0),_hx_char)) {
HXLINE(  44)						::String num = _hx_char;
HXLINE(  45)						i = (i + 1);
HXLINE(  46)						while(true){
HXLINE(  46)							bool _hx_tmp3;
HXDLIN(  46)							if ((i < code.length)) {
HXLINE(  46)								_hx_tmp3 = ::little::tools::TextTools_obj::contains(HX_("1234567890.",73,61,e5,e0),code.charAt(i));
            							}
            							else {
HXLINE(  46)								_hx_tmp3 = false;
            							}
HXDLIN(  46)							if (!(_hx_tmp3)) {
HXLINE(  46)								goto _hx_goto_4;
            							}
HXLINE(  47)							num = (num + code.charAt(i));
HXLINE(  48)							i = (i + 1);
            						}
            						_hx_goto_4:;
HXLINE(  50)						i = (i - 1);
HXLINE(  51)						if ((num == HX_(".",2e,00,00,00))) {
HXLINE(  51)							tokens->push(::little::lexer::LexerTokens_obj::Sign(HX_(".",2e,00,00,00)));
            						}
            						else {
HXLINE(  52)							if (::StringTools_obj::endsWith(num,HX_(".",2e,00,00,00))) {
HXLINE(  53)								tokens->push(::little::lexer::LexerTokens_obj::Number(::little::tools::TextTools_obj::replaceLast(num,HX_(".",2e,00,00,00),HX_("",00,00,00,00))));
HXLINE(  54)								tokens->push(::little::lexer::LexerTokens_obj::Sign(HX_(".",2e,00,00,00)));
            							}
            							else {
HXLINE(  56)								tokens->push(::little::lexer::LexerTokens_obj::Number(num));
            							}
            						}
            					}
            					else {
HXLINE(  58)						if ((_hx_char == HX_("\n",0a,00,00,00))) {
HXLINE(  59)							tokens->push(::little::lexer::LexerTokens_obj::Newline_dyn());
            						}
            						else {
HXLINE(  60)							bool _hx_tmp4;
HXDLIN(  60)							if ((_hx_char != HX_(";",3b,00,00,00))) {
HXLINE(  60)								_hx_tmp4 = (_hx_char == HX_(",",2c,00,00,00));
            							}
            							else {
HXLINE(  60)								_hx_tmp4 = true;
            							}
HXDLIN(  60)							if (_hx_tmp4) {
HXLINE(  61)								tokens->push(::little::lexer::LexerTokens_obj::SplitLine_dyn());
            							}
            							else {
HXLINE(  62)								if (::little::KeywordConfig_obj::recognizedOperators->contains(_hx_char)) {
HXLINE(  63)									::String sign = _hx_char;
HXLINE(  64)									i = (i + 1);
HXLINE(  65)									while(true){
HXLINE(  65)										bool _hx_tmp5;
HXDLIN(  65)										if ((i < code.length)) {
HXLINE(  65)											::Array< ::String > _hx_tmp6 = ::little::KeywordConfig_obj::recognizedOperators;
HXDLIN(  65)											_hx_tmp5 = _hx_tmp6->contains(code.charAt(i));
            										}
            										else {
HXLINE(  65)											_hx_tmp5 = false;
            										}
HXDLIN(  65)										if (!(_hx_tmp5)) {
HXLINE(  65)											goto _hx_goto_5;
            										}
HXLINE(  66)										sign = (sign + code.charAt(i));
HXLINE(  67)										i = (i + 1);
            									}
            									_hx_goto_5:;
HXLINE(  69)									i = (i - 1);
HXLINE(  70)									tokens->push(::little::lexer::LexerTokens_obj::Sign(sign));
            								}
            								else {
HXLINE(  71)									if ( ::EReg_obj::__alloc( HX_CTX ,((HX_("[^",a3,4f,00,00) + ::little::KeywordConfig_obj::recognizedOperators->join(HX_("",00,00,00,00))) + HX_(" \\t\\n\\r;,\\(\\)\\[\\]\\{\\}]",53,ef,74,11)),HX_("g",67,00,00,00))->match(_hx_char)) {
HXLINE(  72)										::String name = _hx_char;
HXLINE(  73)										i = (i + 1);
HXLINE(  74)										while(true){
HXLINE(  74)											bool _hx_tmp7;
HXDLIN(  74)											if ((i < code.length)) {
HXLINE(  74)												 ::EReg _hx_tmp8 =  ::EReg_obj::__alloc( HX_CTX ,((HX_("[^",a3,4f,00,00) + ::little::KeywordConfig_obj::recognizedOperators->join(HX_("",00,00,00,00))) + HX_(" \\t\\n\\r;,\\(\\)\\[\\]\\{\\}]",53,ef,74,11)),HX_("g",67,00,00,00));
HXDLIN(  74)												_hx_tmp7 = _hx_tmp8->match(code.charAt(i));
            											}
            											else {
HXLINE(  74)												_hx_tmp7 = false;
            											}
HXDLIN(  74)											if (!(_hx_tmp7)) {
HXLINE(  74)												goto _hx_goto_6;
            											}
HXLINE(  75)											name = (name + code.charAt(i));
HXLINE(  76)											i = (i + 1);
            										}
            										_hx_goto_6:;
HXLINE(  78)										i = (i - 1);
HXLINE(  79)										tokens->push(::little::lexer::LexerTokens_obj::Identifier(name));
            									}
            								}
            							}
            						}
            					}
            				}
            			}
HXLINE(  81)			i = (i + 1);
            		}
HXLINE(  84)		tokens = ::little::lexer::Lexer_obj::separateBooleanIdentifiers(tokens);
HXLINE(  85)		tokens = ::little::lexer::Lexer_obj::mergeOrSplitKnownSigns(tokens);
HXLINE(  87)		return tokens;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Lexer_obj,lex,return )

::Array< ::Dynamic> Lexer_obj::separateBooleanIdentifiers(::Array< ::Dynamic> tokens){
            	HX_STACKFRAME(&_hx_pos_d178103d13821afc_94_separateBooleanIdentifiers)
HXDLIN(  94)		::Array< ::Dynamic> result = ::Array_obj< ::Dynamic>::__new(tokens->length);
HXDLIN(  94)		{
HXDLIN(  94)			int _g = 0;
HXDLIN(  94)			int _g1 = tokens->length;
HXDLIN(  94)			while((_g < _g1)){
HXDLIN(  94)				_g = (_g + 1);
HXDLIN(  94)				int i = (_g - 1);
HXDLIN(  94)				{
HXDLIN(  94)					 ::little::lexer::LexerTokens token = _hx_array_unsafe_get(tokens,i);
HXDLIN(  94)					 ::little::lexer::LexerTokens inValue;
HXLINE(  95)					bool inValue1;
HXDLIN(  95)					if (!(__hxcpp_enum_eq(token,::little::lexer::LexerTokens_obj::Identifier(::little::Little_obj::keywords->TRUE_VALUE)))) {
HXLINE(  95)						inValue1 = __hxcpp_enum_eq(token,::little::lexer::LexerTokens_obj::Identifier(::little::Little_obj::keywords->FALSE_VALUE));
            					}
            					else {
HXLINE(  95)						inValue1 = true;
            					}
HXDLIN(  95)					if (inValue1) {
HXDLIN(  94)						inValue = ::little::lexer::LexerTokens_obj::Boolean(::Type_obj::enumParameters(token)->__get(0));
            					}
            					else {
HXLINE(  97)						if (__hxcpp_enum_eq(token,::little::lexer::LexerTokens_obj::Identifier(::little::Little_obj::keywords->NULL_VALUE))) {
HXDLIN(  94)							inValue = ::little::lexer::LexerTokens_obj::NullValue_dyn();
            						}
            						else {
HXDLIN(  94)							inValue = token;
            						}
            					}
HXDLIN(  94)					result->__unsafe_set(i,inValue);
            				}
            			}
            		}
HXDLIN(  94)		return result;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Lexer_obj,separateBooleanIdentifiers,return )

::Array< ::Dynamic> Lexer_obj::mergeOrSplitKnownSigns(::Array< ::Dynamic> tokens){
            	HX_STACKFRAME(&_hx_pos_d178103d13821afc_107_mergeOrSplitKnownSigns)
HXLINE( 108)		::Array< ::Dynamic> post = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 110)		int i = 0;
HXLINE( 111)		while((i < tokens->length)){
HXLINE( 112)			 ::little::lexer::LexerTokens token = tokens->__get(i).StaticCast<  ::little::lexer::LexerTokens >();
HXLINE( 114)			if ((token->_hx_getIndex() == 1)) {
HXLINE( 115)				::String _hx_char = token->_hx_getString(0);
HXDLIN( 115)				{
HXLINE( 117)					::Array< ::String > recognizedSigns = ::little::tools::TextTools_obj::sortByLength(::little::Little_obj::keywords->RECOGNIZED_SIGNS->concat(::Array_obj< ::String >::__new(1)->init(0,::little::Little_obj::keywords->PROPERTY_ACCESS_SIGN)));
HXLINE( 118)					recognizedSigns->reverse();
HXLINE( 120)					bool shouldContinue = false;
HXLINE( 121)					while((_hx_char.length > 0)){
HXLINE( 122)						shouldContinue = false;
HXLINE( 123)						{
HXLINE( 123)							int _g = 0;
HXDLIN( 123)							while((_g < recognizedSigns->length)){
HXLINE( 123)								::String sign = recognizedSigns->__get(_g);
HXDLIN( 123)								_g = (_g + 1);
HXLINE( 124)								if (::StringTools_obj::startsWith(_hx_char,sign)) {
HXLINE( 125)									_hx_char = _hx_char.substring(sign.length,null());
HXLINE( 126)									post->push(::little::lexer::LexerTokens_obj::Sign(sign));
HXLINE( 127)									shouldContinue = true;
HXLINE( 128)									goto _hx_goto_12;
            								}
            							}
            							_hx_goto_12:;
            						}
HXLINE( 131)						if (shouldContinue) {
HXLINE( 131)							continue;
            						}
HXLINE( 132)						post->push(::little::lexer::LexerTokens_obj::Sign(_hx_char.charAt(0)));
HXLINE( 133)						_hx_char = _hx_char.substring(1,null());
            					}
            				}
            			}
            			else {
HXLINE( 136)				post->push(token);
            			}
HXLINE( 138)			i = (i + 1);
            		}
HXLINE( 141)		return post;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Lexer_obj,mergeOrSplitKnownSigns,return )


Lexer_obj::Lexer_obj()
{
}

bool Lexer_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"lex") ) { outValue = lex_dyn(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"mergeOrSplitKnownSigns") ) { outValue = mergeOrSplitKnownSigns_dyn(); return true; }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"separateBooleanIdentifiers") ) { outValue = separateBooleanIdentifiers_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Lexer_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Lexer_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Lexer_obj::__mClass;

static ::String Lexer_obj_sStaticFields[] = {
	HX_("lex",df,4b,52,00),
	HX_("separateBooleanIdentifiers",65,4a,eb,3e),
	HX_("mergeOrSplitKnownSigns",d2,65,31,16),
	::String(null())
};

void Lexer_obj::__register()
{
	Lexer_obj _hx_dummy;
	Lexer_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("little.lexer.Lexer",92,9e,49,4e);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Lexer_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Lexer_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Lexer_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Lexer_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Lexer_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace little
} // end namespace lexer
