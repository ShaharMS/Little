// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_vision_algorithms_Cramer
#include <vision/algorithms/Cramer.h>
#endif
#ifndef INCLUDED_vision_algorithms_PerspectiveWarp
#include <vision/algorithms/PerspectiveWarp.h>
#endif
#ifndef INCLUDED_vision_ds_Array2D
#include <vision/ds/Array2D.h>
#endif
#ifndef INCLUDED_vision_ds_Point2D
#include <vision/ds/Point2D.h>
#endif
#ifndef INCLUDED_vision_ds__Matrix2D_Matrix2D_Impl_
#include <vision/ds/_Matrix2D/Matrix2D_Impl_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_5344606cc25a2355_18_generateMatrix,"vision.algorithms.PerspectiveWarp","generateMatrix",0xa76a1ac4,"vision.algorithms.PerspectiveWarp.generateMatrix","vision/algorithms/PerspectiveWarp.hx",18,0x41c0ff1e)
namespace vision{
namespace algorithms{

void PerspectiveWarp_obj::__construct() { }

Dynamic PerspectiveWarp_obj::__CreateEmpty() { return new PerspectiveWarp_obj; }

void *PerspectiveWarp_obj::_hx_vtable = 0;

Dynamic PerspectiveWarp_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PerspectiveWarp_obj > _hx_result = new PerspectiveWarp_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool PerspectiveWarp_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x5c2da6f8;
}

 ::vision::ds::Array2D PerspectiveWarp_obj::generateMatrix(::Array< ::Dynamic> destinationPoints,::Array< ::Dynamic> sourcePoints){
            	HX_GC_STACKFRAME(&_hx_pos_5344606cc25a2355_18_generateMatrix)
HXLINE(  19)		bool _hx_tmp;
HXDLIN(  19)		if ((sourcePoints->length == 4)) {
HXLINE(  19)			_hx_tmp = (sourcePoints->length != 4);
            		}
            		else {
HXLINE(  19)			_hx_tmp = true;
            		}
HXDLIN(  19)		if (_hx_tmp) {
HXLINE(  19)			HX_STACK_DO_THROW(HX_("",00,00,00,00));
            		}
HXLINE(  21)		 ::vision::ds::Array2D M =  ::vision::ds::Array2D_obj::__alloc( HX_CTX ,3,3,null());
HXLINE(  22)		::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN(  22)		{
HXLINE(  22)			::Array< Float > _g1 = ::Array_obj< Float >::__new(0);
HXDLIN(  22)			{
HXLINE(  22)				_g1->push(((Float)0.));
HXDLIN(  22)				_g1->push(((Float)0.));
HXDLIN(  22)				_g1->push(((Float)0.));
HXDLIN(  22)				_g1->push(((Float)0.));
HXDLIN(  22)				_g1->push(((Float)0.));
HXDLIN(  22)				_g1->push(((Float)0.));
HXDLIN(  22)				_g1->push(((Float)0.));
HXDLIN(  22)				_g1->push(((Float)0.));
            			}
HXDLIN(  22)			_g->push(_g1);
HXDLIN(  22)			::Array< Float > _g2 = ::Array_obj< Float >::__new(0);
HXDLIN(  22)			{
HXLINE(  22)				_g2->push(((Float)0.));
HXDLIN(  22)				_g2->push(((Float)0.));
HXDLIN(  22)				_g2->push(((Float)0.));
HXDLIN(  22)				_g2->push(((Float)0.));
HXDLIN(  22)				_g2->push(((Float)0.));
HXDLIN(  22)				_g2->push(((Float)0.));
HXDLIN(  22)				_g2->push(((Float)0.));
HXDLIN(  22)				_g2->push(((Float)0.));
            			}
HXDLIN(  22)			_g->push(_g2);
HXDLIN(  22)			::Array< Float > _g3 = ::Array_obj< Float >::__new(0);
HXDLIN(  22)			{
HXLINE(  22)				_g3->push(((Float)0.));
HXDLIN(  22)				_g3->push(((Float)0.));
HXDLIN(  22)				_g3->push(((Float)0.));
HXDLIN(  22)				_g3->push(((Float)0.));
HXDLIN(  22)				_g3->push(((Float)0.));
HXDLIN(  22)				_g3->push(((Float)0.));
HXDLIN(  22)				_g3->push(((Float)0.));
HXDLIN(  22)				_g3->push(((Float)0.));
            			}
HXDLIN(  22)			_g->push(_g3);
HXDLIN(  22)			::Array< Float > _g4 = ::Array_obj< Float >::__new(0);
HXDLIN(  22)			{
HXLINE(  22)				_g4->push(((Float)0.));
HXDLIN(  22)				_g4->push(((Float)0.));
HXDLIN(  22)				_g4->push(((Float)0.));
HXDLIN(  22)				_g4->push(((Float)0.));
HXDLIN(  22)				_g4->push(((Float)0.));
HXDLIN(  22)				_g4->push(((Float)0.));
HXDLIN(  22)				_g4->push(((Float)0.));
HXDLIN(  22)				_g4->push(((Float)0.));
            			}
HXDLIN(  22)			_g->push(_g4);
HXDLIN(  22)			::Array< Float > _g5 = ::Array_obj< Float >::__new(0);
HXDLIN(  22)			{
HXLINE(  22)				_g5->push(((Float)0.));
HXDLIN(  22)				_g5->push(((Float)0.));
HXDLIN(  22)				_g5->push(((Float)0.));
HXDLIN(  22)				_g5->push(((Float)0.));
HXDLIN(  22)				_g5->push(((Float)0.));
HXDLIN(  22)				_g5->push(((Float)0.));
HXDLIN(  22)				_g5->push(((Float)0.));
HXDLIN(  22)				_g5->push(((Float)0.));
            			}
HXDLIN(  22)			_g->push(_g5);
HXDLIN(  22)			::Array< Float > _g6 = ::Array_obj< Float >::__new(0);
HXDLIN(  22)			{
HXLINE(  22)				_g6->push(((Float)0.));
HXDLIN(  22)				_g6->push(((Float)0.));
HXDLIN(  22)				_g6->push(((Float)0.));
HXDLIN(  22)				_g6->push(((Float)0.));
HXDLIN(  22)				_g6->push(((Float)0.));
HXDLIN(  22)				_g6->push(((Float)0.));
HXDLIN(  22)				_g6->push(((Float)0.));
HXDLIN(  22)				_g6->push(((Float)0.));
            			}
HXDLIN(  22)			_g->push(_g6);
HXDLIN(  22)			::Array< Float > _g7 = ::Array_obj< Float >::__new(0);
HXDLIN(  22)			{
HXLINE(  22)				_g7->push(((Float)0.));
HXDLIN(  22)				_g7->push(((Float)0.));
HXDLIN(  22)				_g7->push(((Float)0.));
HXDLIN(  22)				_g7->push(((Float)0.));
HXDLIN(  22)				_g7->push(((Float)0.));
HXDLIN(  22)				_g7->push(((Float)0.));
HXDLIN(  22)				_g7->push(((Float)0.));
HXDLIN(  22)				_g7->push(((Float)0.));
            			}
HXDLIN(  22)			_g->push(_g7);
HXDLIN(  22)			::Array< Float > _g8 = ::Array_obj< Float >::__new(0);
HXDLIN(  22)			{
HXLINE(  22)				_g8->push(((Float)0.));
HXDLIN(  22)				_g8->push(((Float)0.));
HXDLIN(  22)				_g8->push(((Float)0.));
HXDLIN(  22)				_g8->push(((Float)0.));
HXDLIN(  22)				_g8->push(((Float)0.));
HXDLIN(  22)				_g8->push(((Float)0.));
HXDLIN(  22)				_g8->push(((Float)0.));
HXDLIN(  22)				_g8->push(((Float)0.));
            			}
HXDLIN(  22)			_g->push(_g8);
            		}
HXDLIN(  22)		::Array< ::Dynamic> a = _g;
HXLINE(  23)		::Array< Float > _g9 = ::Array_obj< Float >::__new(0);
HXDLIN(  23)		{
HXLINE(  23)			_g9->push(((Float)0.));
HXDLIN(  23)			_g9->push(((Float)0.));
HXDLIN(  23)			_g9->push(((Float)0.));
HXDLIN(  23)			_g9->push(((Float)0.));
HXDLIN(  23)			_g9->push(((Float)0.));
HXDLIN(  23)			_g9->push(((Float)0.));
HXDLIN(  23)			_g9->push(((Float)0.));
HXDLIN(  23)			_g9->push(((Float)0.));
            		}
HXDLIN(  23)		::Array< Float > b = _g9;
HXLINE(  26)		{
HXLINE(  26)			int _g10 = 0;
HXDLIN(  26)			while((_g10 < 4)){
HXLINE(  26)				_g10 = (_g10 + 1);
HXDLIN(  26)				int i = (_g10 - 1);
HXLINE(  27)				a->__get(i).StaticCast< ::Array< Float > >()[0] = (a->__get((i + 4)).StaticCast< ::Array< Float > >()[3] = destinationPoints->__get(i).StaticCast<  ::vision::ds::Point2D >()->x);
HXLINE(  28)				a->__get(i).StaticCast< ::Array< Float > >()[1] = (a->__get((i + 4)).StaticCast< ::Array< Float > >()[4] = destinationPoints->__get(i).StaticCast<  ::vision::ds::Point2D >()->y);
HXLINE(  29)				a->__get(i).StaticCast< ::Array< Float > >()[2] = (a->__get((i + 4)).StaticCast< ::Array< Float > >()[5] = ( (Float)(1) ));
HXLINE(  30)				a->__get(i).StaticCast< ::Array< Float > >()[3] = (a->__get(i).StaticCast< ::Array< Float > >()[4] = (a->__get(i).StaticCast< ::Array< Float > >()[5] = (a->__get((i + 4)).StaticCast< ::Array< Float > >()[0] = (a->__get((i + 4)).StaticCast< ::Array< Float > >()[1] = (a->__get((i + 4)).StaticCast< ::Array< Float > >()[2] = ( (Float)(0) ))))));
HXLINE(  31)				a->__get(i).StaticCast< ::Array< Float > >()[6] = (-(destinationPoints->__get(i).StaticCast<  ::vision::ds::Point2D >()->x) * sourcePoints->__get(i).StaticCast<  ::vision::ds::Point2D >()->x);
HXLINE(  32)				a->__get(i).StaticCast< ::Array< Float > >()[7] = (-(destinationPoints->__get(i).StaticCast<  ::vision::ds::Point2D >()->y) * sourcePoints->__get(i).StaticCast<  ::vision::ds::Point2D >()->x);
HXLINE(  33)				a->__get((i + 4)).StaticCast< ::Array< Float > >()[6] = (-(destinationPoints->__get(i).StaticCast<  ::vision::ds::Point2D >()->x) * sourcePoints->__get(i).StaticCast<  ::vision::ds::Point2D >()->y);
HXLINE(  34)				a->__get((i + 4)).StaticCast< ::Array< Float > >()[7] = (-(destinationPoints->__get(i).StaticCast<  ::vision::ds::Point2D >()->y) * sourcePoints->__get(i).StaticCast<  ::vision::ds::Point2D >()->y);
HXLINE(  35)				b[i] = sourcePoints->__get(i).StaticCast<  ::vision::ds::Point2D >()->x;
HXLINE(  36)				b[(i + 4)] = sourcePoints->__get(i).StaticCast<  ::vision::ds::Point2D >()->y;
            			}
            		}
HXLINE(  40)		::Array< Float > x = ::vision::algorithms::Cramer_obj::solveVariablesFor(::vision::ds::_Matrix2D::Matrix2D_Impl__obj::from_array_array_float(a),b);
HXLINE(  41)		x[8] = ((Float)1.);
HXLINE(  43)		{
HXLINE(  43)			{
HXLINE(  44)				M->inner->set((0 * M->width),x->__get(0));
HXLINE(  45)				M->inner->set((1 + (0 * M->width)),x->__get(1));
HXLINE(  46)				M->inner->set((2 + (0 * M->width)),x->__get(2));
            			}
HXLINE(  43)			{
HXLINE(  44)				M->inner->set(M->width,x->__get(3));
HXLINE(  45)				M->inner->set((1 + M->width),x->__get(4));
HXLINE(  46)				M->inner->set((2 + M->width),x->__get(5));
            			}
HXLINE(  43)			{
HXLINE(  44)				M->inner->set((2 * M->width),x->__get(6));
HXLINE(  45)				M->inner->set((1 + (2 * M->width)),x->__get(7));
HXLINE(  46)				M->inner->set((2 + (2 * M->width)),x->__get(8));
            			}
            		}
HXLINE(  49)		return M;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(PerspectiveWarp_obj,generateMatrix,return )


PerspectiveWarp_obj::PerspectiveWarp_obj()
{
}

bool PerspectiveWarp_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 14:
		if (HX_FIELD_EQ(inName,"generateMatrix") ) { outValue = generateMatrix_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *PerspectiveWarp_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *PerspectiveWarp_obj_sStaticStorageInfo = 0;
#endif

::hx::Class PerspectiveWarp_obj::__mClass;

static ::String PerspectiveWarp_obj_sStaticFields[] = {
	HX_("generateMatrix",56,df,81,c2),
	::String(null())
};

void PerspectiveWarp_obj::__register()
{
	PerspectiveWarp_obj _hx_dummy;
	PerspectiveWarp_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("vision.algorithms.PerspectiveWarp",40,e1,1d,c9);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &PerspectiveWarp_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(PerspectiveWarp_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< PerspectiveWarp_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PerspectiveWarp_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PerspectiveWarp_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace vision
} // end namespace algorithms
