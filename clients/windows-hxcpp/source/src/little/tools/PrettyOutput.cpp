// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_little_lexer_Lexer
#include <little/lexer/Lexer.h>
#endif
#ifndef INCLUDED_little_lexer_LexerTokens
#include <little/lexer/LexerTokens.h>
#endif
#ifndef INCLUDED_little_parser_Parser
#include <little/parser/Parser.h>
#endif
#ifndef INCLUDED_little_parser_ParserTokens
#include <little/parser/ParserTokens.h>
#endif
#ifndef INCLUDED_little_tools_BaseOrderedMap
#include <little/tools/BaseOrderedMap.h>
#endif
#ifndef INCLUDED_little_tools_OrderedMapKeyValueIterator
#include <little/tools/OrderedMapKeyValueIterator.h>
#endif
#ifndef INCLUDED_little_tools_PrettyOutput
#include <little/tools/PrettyOutput.h>
#endif
#ifndef INCLUDED_little_tools_PrettyPrinter
#include <little/tools/PrettyPrinter.h>
#endif
#ifndef INCLUDED_little_tools__OrderedMap_OrderedMap_Impl_
#include <little/tools/_OrderedMap/OrderedMap_Impl_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_aee9c927d6d24379_13_generateAstHtml,"little.tools.PrettyOutput","generateAstHtml",0x43aa2fcc,"little.tools.PrettyOutput.generateAstHtml","little/tools/PrettyOutput.hx",13,0xe721025a)
namespace little{
namespace tools{

void PrettyOutput_obj::__construct() { }

Dynamic PrettyOutput_obj::__CreateEmpty() { return new PrettyOutput_obj; }

void *PrettyOutput_obj::_hx_vtable = 0;

Dynamic PrettyOutput_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PrettyOutput_obj > _hx_result = new PrettyOutput_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool PrettyOutput_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x06ce4378;
}

::String PrettyOutput_obj::generateAstHtml(::String code){
            	HX_GC_STACKFRAME(&_hx_pos_aee9c927d6d24379_13_generateAstHtml)
HXLINE(  14)		::String htmlFile = HX_("<table><tr><th>Stage</th><th>AST</th></tr>",73,17,98,a9);
HXLINE(  16)		::Array< ::Dynamic> lexical = ::little::parser::Parser_obj::convert(::little::lexer::Lexer_obj::lex(code));
HXLINE(  18)		 ::little::tools::BaseOrderedMap map = ::little::tools::_OrderedMap::OrderedMap_Impl__obj::_new();
HXLINE(  19)		{
HXLINE(  19)			 ::haxe::ds::StringMap _g =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXDLIN(  19)			_g->set(HX_("Merge Blocks",2e,6b,b3,be),::little::parser::Parser_obj::mergeBlocks_dyn());
HXDLIN(  19)			_g->set(HX_("Merge Expressions",33,36,c2,e2),::little::parser::Parser_obj::mergeExpressions_dyn());
HXDLIN(  19)			_g->set(HX_("Merge Property Operations",cf,a2,bd,25),::little::parser::Parser_obj::mergePropertyOperations_dyn());
HXDLIN(  19)			_g->set(HX_("Merge Type Declarations",d7,c7,ad,a2),::little::parser::Parser_obj::mergeTypeDecls_dyn());
HXDLIN(  19)			_g->set(HX_("Merge Complex Structures",98,45,5f,0e),::little::parser::Parser_obj::mergeComplexStructures_dyn());
HXDLIN(  19)			_g->set(HX_("Merge Calls",6d,82,c0,9a),::little::parser::Parser_obj::mergeCalls_dyn());
HXDLIN(  19)			_g->set(HX_("Merge Writes",5c,13,af,94),::little::parser::Parser_obj::mergeWrites_dyn());
HXDLIN(  19)			_g->set(HX_("Marge Values With Type Decl",70,2c,d3,de),::little::parser::Parser_obj::mergeValuesWithTypeDeclarations_dyn());
HXDLIN(  19)			_g->set(HX_("Merge Non-Block Bodies",5b,a3,49,87),::little::parser::Parser_obj::mergeNonBlockBodies_dyn());
HXDLIN(  19)			_g->set(HX_("Merge Elses",f2,4d,d8,c8),::little::parser::Parser_obj::mergeElses_dyn());
HXDLIN(  19)			::Dynamic map1 = _g;
HXDLIN(  19)			::Dynamic _g_map = map1;
HXDLIN(  19)			 ::Dynamic _g_keys = ::haxe::IMap_obj::keys(map1);
HXDLIN(  19)			while(( (bool)(_g_keys->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE(  19)				::String key = ( (::String)(_g_keys->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN(  19)				 ::Dynamic _g_value = ::haxe::IMap_obj::get(_g_map,key);
HXDLIN(  19)				::String _g_key = key;
HXDLIN(  19)				::String k = _g_key;
HXDLIN(  19)				 ::Dynamic v = _g_value;
HXLINE(  30)				::little::tools::_OrderedMap::OrderedMap_Impl__obj::set(map,k,v);
            			}
            		}
HXLINE(  32)		{
HXLINE(  32)			 ::little::tools::OrderedMapKeyValueIterator _g1 = map->keyValueIterator();
HXDLIN(  32)			while(true){
HXLINE(  32)				bool _hx_tmp;
HXDLIN(  32)				if ((_g1->karray->get_length() == _g1->varray->get_length())) {
HXLINE(  32)					_hx_tmp = (_g1->current < _g1->karray->get_length());
            				}
            				else {
HXLINE(  32)					_hx_tmp = false;
            				}
HXDLIN(  32)				if (!(_hx_tmp)) {
HXLINE(  32)					goto _hx_goto_1;
            				}
HXDLIN(  32)				 ::Dynamic _g_value1 = _g1->varray->__get(_g1->current);
HXDLIN(  32)				::String _g_key1 = ( (::String)(_g1->karray->__get(_g1->current++)) );
HXDLIN(  32)				::String key1 = _g_key1;
HXDLIN(  32)				 ::Dynamic func = _g_value1;
HXDLIN(  32)				{
HXLINE(  33)					htmlFile = (htmlFile + ((HX_("<tr><th>",d2,d5,14,af) + key1) + HX_("</th>",b7,35,74,ab)));
HXLINE(  34)					::String pretty = ::little::tools::PrettyPrinter_obj::printParserAst(( (::Array< ::Dynamic>)(func(lexical)) ),null());
HXLINE(  35)					pretty = ::StringTools_obj::replace(::StringTools_obj::replace(pretty,HX_("\n",0a,00,00,00),HX_("<br>",b2,8d,f3,27)),HX_("\t",09,00,00,00),HX_("&nbsp;&nbsp;&nbsp;&nbsp;",90,1f,59,64));
HXLINE(  36)					htmlFile = (htmlFile + ((HX_("<td>",12,2a,01,28) + pretty) + HX_("</td></tr>",52,16,99,6a)));
            				}
            			}
            			_hx_goto_1:;
            		}
HXLINE(  38)		htmlFile = (htmlFile + HX_("</table>",23,e1,a0,86));
HXLINE(  40)		return htmlFile;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(PrettyOutput_obj,generateAstHtml,return )


PrettyOutput_obj::PrettyOutput_obj()
{
}

bool PrettyOutput_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 15:
		if (HX_FIELD_EQ(inName,"generateAstHtml") ) { outValue = generateAstHtml_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *PrettyOutput_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *PrettyOutput_obj_sStaticStorageInfo = 0;
#endif

::hx::Class PrettyOutput_obj::__mClass;

static ::String PrettyOutput_obj_sStaticFields[] = {
	HX_("generateAstHtml",18,d3,d1,92),
	::String(null())
};

void PrettyOutput_obj::__register()
{
	PrettyOutput_obj _hx_dummy;
	PrettyOutput_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("little.tools.PrettyOutput",22,15,95,47);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &PrettyOutput_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(PrettyOutput_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< PrettyOutput_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PrettyOutput_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PrettyOutput_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace little
} // end namespace tools
