// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_38344beec7696400
#define INCLUDED_38344beec7696400
#include "cpp/Int64.h"
#endif
#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_vision_ds_Array2D
#include <vision/ds/Array2D.h>
#endif
#ifndef INCLUDED_vision_ds_Point2D
#include <vision/ds/Point2D.h>
#endif
#ifndef INCLUDED_vision_ds__Image_Image_Impl_
#include <vision/ds/_Image/Image_Impl_.h>
#endif
#ifndef INCLUDED_vision_exceptions_LibraryRequired
#include <vision/exceptions/LibraryRequired.h>
#endif
#ifndef INCLUDED_vision_exceptions_OutOfBounds
#include <vision/exceptions/OutOfBounds.h>
#endif
#ifndef INCLUDED_vision_exceptions_VisionException
#include <vision/exceptions/VisionException.h>
#endif
#ifndef INCLUDED_vision_tools_ImageTools
#include <vision/tools/ImageTools.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_4ef2e47ef5f607a3_122_loadFromFile,"vision.tools.ImageTools","loadFromFile",0x9c306741,"vision.tools.ImageTools.loadFromFile","vision/tools/ImageTools.hx",122,0x20db1cc3)
HX_LOCAL_STACK_FRAME(_hx_pos_4ef2e47ef5f607a3_191_saveToFile,"vision.tools.ImageTools","saveToFile",0x7217cb69,"vision.tools.ImageTools.saveToFile","vision/tools/ImageTools.hx",191,0x20db1cc3)
HX_LOCAL_STACK_FRAME(_hx_pos_4ef2e47ef5f607a3_270_addToScreen,"vision.tools.ImageTools","addToScreen",0xdbf4f233,"vision.tools.ImageTools.addToScreen","vision/tools/ImageTools.hx",270,0x20db1cc3)
HX_LOCAL_STACK_FRAME(_hx_pos_4ef2e47ef5f607a3_284_getNeighborsOfPixel,"vision.tools.ImageTools","getNeighborsOfPixel",0x3fca080f,"vision.tools.ImageTools.getNeighborsOfPixel","vision/tools/ImageTools.hx",284,0x20db1cc3)
HX_LOCAL_STACK_FRAME(_hx_pos_4ef2e47ef5f607a3_309_grayscalePixel,"vision.tools.ImageTools","grayscalePixel",0x11602274,"vision.tools.ImageTools.grayscalePixel","vision/tools/ImageTools.hx",309,0x20db1cc3)
HX_LOCAL_STACK_FRAME(_hx_pos_4ef2e47ef5f607a3_43_boot,"vision.tools.ImageTools","boot",0x53f1e527,"vision.tools.ImageTools.boot","vision/tools/ImageTools.hx",43,0x20db1cc3)
namespace vision{
namespace tools{

void ImageTools_obj::__construct() { }

Dynamic ImageTools_obj::__CreateEmpty() { return new ImageTools_obj; }

void *ImageTools_obj::_hx_vtable = 0;

Dynamic ImageTools_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ImageTools_obj > _hx_result = new ImageTools_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ImageTools_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1915f5d3;
}

int ImageTools_obj::defaultResizeAlgorithm;

void ImageTools_obj::loadFromFile( ::haxe::io::Bytes image,::String path, ::Dynamic onComplete){
            	HX_GC_STACKFRAME(&_hx_pos_4ef2e47ef5f607a3_122_loadFromFile)
HXDLIN( 122)		HX_STACK_DO_THROW( ::vision::exceptions::LibraryRequired_obj::__alloc( HX_CTX ,HX_("format",37,8f,8e,fd),::Array_obj< ::String >::__new(0),HX_("ImageTools.loadFromFile",9a,2d,59,06),HX_("function",18,ab,52,14)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(ImageTools_obj,loadFromFile,(void))

void ImageTools_obj::saveToFile( ::haxe::io::Bytes image,::String pathWithFileName,::hx::Null< int >  __o_saveFormat){
            		int saveFormat = __o_saveFormat.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_4ef2e47ef5f607a3_191_saveToFile)
HXDLIN( 191)		HX_STACK_DO_THROW( ::vision::exceptions::LibraryRequired_obj::__alloc( HX_CTX ,HX_("format",37,8f,8e,fd),::Array_obj< ::String >::__new(0),HX_("ImageTools.loadFromFile",9a,2d,59,06),HX_("function",18,ab,52,14)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(ImageTools_obj,saveToFile,(void))

 ::haxe::io::Bytes ImageTools_obj::addToScreen( ::haxe::io::Bytes image,int x,int y, ::Dynamic units){
            	HX_STACKFRAME(&_hx_pos_4ef2e47ef5f607a3_270_addToScreen)
HXDLIN( 270)		return image;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(ImageTools_obj,addToScreen,return )

 ::vision::ds::Array2D ImageTools_obj::getNeighborsOfPixel( ::haxe::io::Bytes image,int x,int y,int kernelSize){
            	HX_GC_STACKFRAME(&_hx_pos_4ef2e47ef5f607a3_284_getNeighborsOfPixel)
HXLINE( 285)		 ::vision::ds::Array2D neighbors =  ::vision::ds::Array2D_obj::__alloc( HX_CTX ,kernelSize,kernelSize,null());
HXLINE( 286)		int i = 0;
HXLINE( 287)		{
HXLINE( 287)			 ::haxe::io::Bytes neighbor_image = image;
HXDLIN( 287)			int neighbor_roundedDown = ((kernelSize - 1) >> 1);
HXDLIN( 287)			int neighbor_x = x;
HXDLIN( 287)			int neighbor_y = y;
HXDLIN( 287)			bool neighbor_circular = false;
HXDLIN( 287)			int neighbor_X = -(neighbor_roundedDown);
HXDLIN( 287)			int neighbor_Y = -(neighbor_roundedDown);
HXDLIN( 287)			while(true){
HXLINE( 287)				bool _hx_tmp;
HXDLIN( 287)				if ((neighbor_X <= neighbor_roundedDown)) {
HXLINE( 287)					_hx_tmp = (neighbor_Y <= neighbor_roundedDown);
            				}
            				else {
HXLINE( 287)					_hx_tmp = false;
            				}
HXDLIN( 287)				if (!(_hx_tmp)) {
HXLINE( 287)					goto _hx_goto_3;
            				}
HXDLIN( 287)				while(true){
HXLINE( 287)					neighbor_Y = (neighbor_Y + 1);
HXDLIN( 287)					if ((neighbor_Y > neighbor_roundedDown)) {
HXLINE( 287)						neighbor_Y = -(neighbor_roundedDown);
HXDLIN( 287)						neighbor_X = (neighbor_X + 1);
            					}
HXDLIN( 287)					bool _hx_tmp1;
HXDLIN( 287)					if (neighbor_circular) {
HXLINE( 287)						Float point1_x = ( (Float)(neighbor_X) );
HXDLIN( 287)						Float point1_y = ( (Float)(neighbor_Y) );
HXDLIN( 287)						Float point2_x = ( (Float)(neighbor_roundedDown) );
HXDLIN( 287)						Float point2_y = ( (Float)(neighbor_roundedDown) );
HXDLIN( 287)						Float x1 = (point2_x - point1_x);
HXDLIN( 287)						Float y1 = (point2_y - point1_y);
HXDLIN( 287)						_hx_tmp1 = (::Math_obj::sqrt(((x1 * x1) + (y1 * y1))) > neighbor_roundedDown);
            					}
            					else {
HXLINE( 287)						_hx_tmp1 = false;
            					}
HXDLIN( 287)					if (!(_hx_tmp1)) {
HXLINE( 287)						goto _hx_goto_4;
            					}
            				}
            				_hx_goto_4:;
HXDLIN( 287)				 ::haxe::io::Bytes this1 = neighbor_image;
HXDLIN( 287)				int y2 = (neighbor_y + neighbor_Y);
HXDLIN( 287)				 ::haxe::io::Bytes _this = this1;
HXDLIN( 287)				int ma = ((( (int)(_this->b->__get(0)) ) | (( (int)(_this->b->__get(1)) ) << 8)) - 1);
HXDLIN( 287)				::Array< int > values = ::Array_obj< int >::__new(2)->init(0,(neighbor_x + neighbor_X))->init(1,0);
HXDLIN( 287)				int max = values->__get(0);
HXDLIN( 287)				{
HXLINE( 287)					int _g = 0;
HXDLIN( 287)					int _g1 = values->length;
HXDLIN( 287)					while((_g < _g1)){
HXLINE( 287)						_g = (_g + 1);
HXDLIN( 287)						int i1 = (_g - 1);
HXDLIN( 287)						if ((values->__get(i1) > max)) {
HXLINE( 688)							max = values->__get(i1);
            						}
            					}
            				}
HXLINE( 287)				::Array< int > values1 = ::Array_obj< int >::__new(2)->init(0,max)->init(1,ma);
HXDLIN( 287)				int min = values1->__get(0);
HXDLIN( 287)				{
HXLINE( 287)					int _g2 = 0;
HXDLIN( 287)					int _g3 = values1->length;
HXDLIN( 287)					while((_g2 < _g3)){
HXLINE( 287)						_g2 = (_g2 + 1);
HXDLIN( 287)						int i2 = (_g2 - 1);
HXDLIN( 287)						if ((values1->__get(i2) < min)) {
HXLINE( 652)							min = values1->__get(i2);
            						}
            					}
            				}
HXLINE( 287)				int x2 = min;
HXDLIN( 287)				 ::haxe::io::Bytes _this1 = this1;
HXDLIN( 287)				int ma1 = (::Math_obj::ceil((( (Float)((this1->length - ::vision::ds::_Image::Image_Impl__obj::OFFSET)) ) / ( (Float)(((( (int)(_this1->b->__get(0)) ) | (( (int)(_this1->b->__get(1)) ) << 8)) * 4)) ))) - 1);
HXDLIN( 287)				::Array< int > values2 = ::Array_obj< int >::__new(2)->init(0,y2)->init(1,0);
HXDLIN( 287)				int max1 = values2->__get(0);
HXDLIN( 287)				{
HXLINE( 287)					int _g4 = 0;
HXDLIN( 287)					int _g5 = values2->length;
HXDLIN( 287)					while((_g4 < _g5)){
HXLINE( 287)						_g4 = (_g4 + 1);
HXDLIN( 287)						int i3 = (_g4 - 1);
HXDLIN( 287)						if ((values2->__get(i3) > max1)) {
HXLINE( 688)							max1 = values2->__get(i3);
            						}
            					}
            				}
HXLINE( 287)				::Array< int > values3 = ::Array_obj< int >::__new(2)->init(0,max1)->init(1,ma1);
HXDLIN( 287)				int min1 = values3->__get(0);
HXDLIN( 287)				{
HXLINE( 287)					int _g6 = 0;
HXDLIN( 287)					int _g7 = values3->length;
HXDLIN( 287)					while((_g6 < _g7)){
HXLINE( 287)						_g6 = (_g6 + 1);
HXDLIN( 287)						int i4 = (_g6 - 1);
HXDLIN( 287)						if ((values3->__get(i4) < min1)) {
HXLINE( 652)							min1 = values3->__get(i4);
            						}
            					}
            				}
HXLINE( 287)				int y3 = min1;
HXDLIN( 287)				bool _hx_tmp2;
HXDLIN( 287)				bool _hx_tmp3;
HXDLIN( 287)				bool _hx_tmp4;
HXDLIN( 287)				if ((x2 >= 0)) {
HXLINE( 287)					_hx_tmp4 = (y3 >= 0);
            				}
            				else {
HXLINE( 287)					_hx_tmp4 = false;
            				}
HXDLIN( 287)				if (_hx_tmp4) {
HXLINE( 287)					 ::haxe::io::Bytes _this2 = this1;
HXDLIN( 287)					_hx_tmp3 = (x2 < (( (int)(_this2->b->__get(0)) ) | (( (int)(_this2->b->__get(1)) ) << 8)));
            				}
            				else {
HXLINE( 287)					_hx_tmp3 = false;
            				}
HXDLIN( 287)				if (_hx_tmp3) {
HXLINE( 287)					 ::haxe::io::Bytes _this3 = this1;
HXDLIN( 287)					_hx_tmp2 = (y3 < ::Math_obj::ceil((( (Float)((this1->length - ::vision::ds::_Image::Image_Impl__obj::OFFSET)) ) / ( (Float)(((( (int)(_this3->b->__get(0)) ) | (( (int)(_this3->b->__get(1)) ) << 8)) * 4)) ))));
            				}
            				else {
HXLINE( 287)					_hx_tmp2 = false;
            				}
HXDLIN( 287)				if (!(_hx_tmp2)) {
HXLINE( 287)					::cpp::Int64 this2 = _hx_int64_make(x2,y3);
HXDLIN( 287)					int _hx_tmp5 = _hx_int64_high(this2);
HXDLIN( 287)					HX_STACK_DO_THROW( ::vision::exceptions::OutOfBounds_obj::__alloc( HX_CTX ,this1, ::vision::ds::Point2D_obj::__alloc( HX_CTX ,_hx_tmp5,_hx_int64_low(this2))));
            				}
HXDLIN( 287)				 ::haxe::io::Bytes _this4 = this1;
HXDLIN( 287)				int position = (((y3 * (( (int)(_this4->b->__get(0)) ) | (( (int)(_this4->b->__get(1)) ) << 8))) + x2) * 4);
HXDLIN( 287)				position = (position + ::vision::ds::_Image::Image_Impl__obj::OFFSET);
HXDLIN( 287)				int neighbor = ((((( (int)(this1->b->__get(position)) ) << 24) | (( (int)(this1->b->__get((position + 1))) ) << 16)) | (( (int)(this1->b->__get((position + 2))) ) << 8)) | ( (int)(this1->b->__get((position + 3))) ));
HXLINE( 288)				i = (i + 1);
HXDLIN( 288)				neighbors->inner->set((i - 1),neighbor);
            			}
            			_hx_goto_3:;
            		}
HXLINE( 290)		return neighbors;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(ImageTools_obj,getNeighborsOfPixel,return )

int ImageTools_obj::grayscalePixel(int pixel){
            	HX_STACKFRAME(&_hx_pos_4ef2e47ef5f607a3_309_grayscalePixel)
HXLINE( 310)		int gray = ::Std_obj::_hx_int((( (Float)(((((pixel >> 16) & 255) + ((pixel >> 8) & 255)) + (pixel & 255))) ) / ( (Float)(3) )));
HXLINE( 312)		int Alpha = ((pixel >> 24) & 255);
HXDLIN( 312)		int color = 0;
HXDLIN( 312)		{
HXLINE( 312)			color = (color & -16711681);
HXDLIN( 312)			int color1;
HXDLIN( 312)			if ((gray > 255)) {
HXLINE( 312)				color1 = 255;
            			}
            			else {
HXLINE( 312)				if ((gray < 0)) {
HXLINE( 312)					color1 = 0;
            				}
            				else {
HXLINE( 312)					color1 = gray;
            				}
            			}
HXDLIN( 312)			color = (color | (color1 << 16));
            		}
HXDLIN( 312)		{
HXLINE( 312)			color = (color & -65281);
HXDLIN( 312)			int color2;
HXDLIN( 312)			if ((gray > 255)) {
HXLINE( 312)				color2 = 255;
            			}
            			else {
HXLINE( 312)				if ((gray < 0)) {
HXLINE( 312)					color2 = 0;
            				}
            				else {
HXLINE( 312)					color2 = gray;
            				}
            			}
HXDLIN( 312)			color = (color | (color2 << 8));
            		}
HXDLIN( 312)		{
HXLINE( 312)			color = (color & -256);
HXDLIN( 312)			int color3;
HXDLIN( 312)			if ((gray > 255)) {
HXLINE( 312)				color3 = 255;
            			}
            			else {
HXLINE( 312)				if ((gray < 0)) {
HXLINE( 312)					color3 = 0;
            				}
            				else {
HXLINE( 312)					color3 = gray;
            				}
            			}
HXDLIN( 312)			color = (color | color3);
            		}
HXDLIN( 312)		{
HXLINE( 312)			color = (color & 16777215);
HXDLIN( 312)			int color4;
HXDLIN( 312)			if ((Alpha > 255)) {
HXLINE( 312)				color4 = 255;
            			}
            			else {
HXLINE( 312)				if ((Alpha < 0)) {
HXLINE( 312)					color4 = 0;
            				}
            				else {
HXLINE( 312)					color4 = Alpha;
            				}
            			}
HXDLIN( 312)			color = (color | (color4 << 24));
            		}
HXDLIN( 312)		return color;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ImageTools_obj,grayscalePixel,return )


ImageTools_obj::ImageTools_obj()
{
}

bool ImageTools_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"saveToFile") ) { outValue = saveToFile_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"addToScreen") ) { outValue = addToScreen_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"loadFromFile") ) { outValue = loadFromFile_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"grayscalePixel") ) { outValue = grayscalePixel_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"getNeighborsOfPixel") ) { outValue = getNeighborsOfPixel_dyn(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"defaultResizeAlgorithm") ) { outValue = ( defaultResizeAlgorithm ); return true; }
	}
	return false;
}

bool ImageTools_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 22:
		if (HX_FIELD_EQ(inName,"defaultResizeAlgorithm") ) { defaultResizeAlgorithm=ioValue.Cast< int >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *ImageTools_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo ImageTools_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &ImageTools_obj::defaultResizeAlgorithm,HX_("defaultResizeAlgorithm",1a,84,b7,b7)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void ImageTools_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ImageTools_obj::defaultResizeAlgorithm,"defaultResizeAlgorithm");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ImageTools_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ImageTools_obj::defaultResizeAlgorithm,"defaultResizeAlgorithm");
};

#endif

::hx::Class ImageTools_obj::__mClass;

static ::String ImageTools_obj_sStaticFields[] = {
	HX_("defaultResizeAlgorithm",1a,84,b7,b7),
	HX_("loadFromFile",4c,89,f0,5a),
	HX_("saveToFile",b4,c4,2e,c2),
	HX_("addToScreen",88,1a,f8,9f),
	HX_("getNeighborsOfPixel",64,0d,5d,01),
	HX_("grayscalePixel",3f,1d,f5,19),
	::String(null())
};

void ImageTools_obj::__register()
{
	ImageTools_obj _hx_dummy;
	ImageTools_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("vision.tools.ImageTools",99,a3,23,83);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ImageTools_obj::__GetStatic;
	__mClass->mSetStaticField = &ImageTools_obj::__SetStatic;
	__mClass->mMarkFunc = ImageTools_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(ImageTools_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< ImageTools_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ImageTools_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ImageTools_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ImageTools_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void ImageTools_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_4ef2e47ef5f607a3_43_boot)
HXDLIN(  43)		defaultResizeAlgorithm = 1;
            	}
}

} // end namespace vision
} // end namespace tools
