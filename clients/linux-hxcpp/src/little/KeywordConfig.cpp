// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_exceptions_ArgumentException
#include <haxe/exceptions/ArgumentException.h>
#endif
#ifndef INCLUDED_haxe_exceptions_PosException
#include <haxe/exceptions/PosException.h>
#endif
#ifndef INCLUDED_little_KeywordConfig
#include <little/KeywordConfig.h>
#endif
#ifndef INCLUDED_little_tools_TextTools
#include <little/tools/TextTools.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_affab903f7db177c_13_new,"little.KeywordConfig","new",0x439f0f65,"little.KeywordConfig.new","little/KeywordConfig.hx",13,0x656875ac)
HX_LOCAL_STACK_FRAME(_hx_pos_affab903f7db177c_78_change,"little.KeywordConfig","change",0xfcc6c38b,"little.KeywordConfig.change","little/KeywordConfig.hx",78,0x656875ac)
HX_LOCAL_STACK_FRAME(_hx_pos_affab903f7db177c_17_boot,"little.KeywordConfig","boot",0xdfa7698d,"little.KeywordConfig.boot","little/KeywordConfig.hx",17,0x656875ac)
HX_LOCAL_STACK_FRAME(_hx_pos_affab903f7db177c_26_boot,"little.KeywordConfig","boot",0xdfa7698d,"little.KeywordConfig.boot","little/KeywordConfig.hx",26,0x656875ac)
static const ::String _hx_array_data_90e878f3_6[] = {
	HX_("!",21,00,00,00),HX_("#",23,00,00,00),HX_("$",24,00,00,00),HX_("%",25,00,00,00),HX_("&",26,00,00,00),HX_("'",27,00,00,00),HX_("(",28,00,00,00),HX_(")",29,00,00,00),HX_("*",2a,00,00,00),HX_("+",2b,00,00,00),HX_("-",2d,00,00,00),HX_(".",2e,00,00,00),HX_("/",2f,00,00,00),HX_(":",3a,00,00,00),HX_("<",3c,00,00,00),HX_("=",3d,00,00,00),HX_(">",3e,00,00,00),HX_("?",3f,00,00,00),HX_("@",40,00,00,00),HX_("[",5b,00,00,00),HX_("\\",5c,00,00,00),HX_("]",5d,00,00,00),HX_("^",5e,00,00,00),HX_("_",5f,00,00,00),HX_("`",60,00,00,00),HX_("{",7b,00,00,00),HX_("|",7c,00,00,00),HX_("}",7d,00,00,00),HX_("~",7e,00,00,00),HX_("^",5e,00,00,00),HX_W(u"\u221a",f474,00ab),
};
HX_LOCAL_STACK_FRAME(_hx_pos_affab903f7db177c_32_boot,"little.KeywordConfig","boot",0xdfa7698d,"little.KeywordConfig.boot","little/KeywordConfig.hx",32,0x656875ac)
static const ::String _hx_array_data_90e878f3_8[] = {
	HX_("%",25,00,00,00),HX_("&",26,00,00,00),HX_("&&",40,21,00,00),HX_("*",2a,00,00,00),HX_("+",2b,00,00,00),HX_("-",2d,00,00,00),HX_("/",2f,00,00,00),HX_("<",3c,00,00,00),HX_("<=",81,34,00,00),HX_("==",60,35,00,00),HX_(">",3e,00,00,00),HX_(">=",3f,36,00,00),HX_("||",80,6c,00,00),HX_("|",7c,00,00,00),
};
HX_LOCAL_STACK_FRAME(_hx_pos_affab903f7db177c_38_boot,"little.KeywordConfig","boot",0xdfa7698d,"little.KeywordConfig.boot","little/KeywordConfig.hx",38,0x656875ac)
static const ::String _hx_array_data_90e878f3_10[] = {
	HX_("!",21,00,00,00),HX_("&",26,00,00,00),HX_("&&",40,21,00,00),HX_("||",80,6c,00,00),HX_("|",7c,00,00,00),HX_("*",2a,00,00,00),HX_("+",2b,00,00,00),HX_("-",2d,00,00,00),HX_("/",2f,00,00,00),HX_("<",3c,00,00,00),HX_("<=",81,34,00,00),HX_("==",60,35,00,00),HX_(">",3e,00,00,00),HX_(">=",3f,36,00,00),
};
namespace little{

void KeywordConfig_obj::__construct( ::little::KeywordConfig config,::hx::Null< bool >  __o_nullifyDefaults){
            		bool nullifyDefaults = __o_nullifyDefaults.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_affab903f7db177c_13_new)
HXLINE( 224)		this->INSTANTIATE_FUNCTION_NAME = HX_("create",fc,66,0f,7c);
HXLINE( 223)		this->TYPE_CAST_FUNCTION_PREFIX = HX_("to",7b,65,00,00);
HXLINE( 221)		this->FOR_LOOP_JUMP = HX_("jump",ee,c4,69,46);
HXLINE( 220)		this->FOR_LOOP_TO = HX_("to",7b,65,00,00);
HXLINE( 219)		this->FOR_LOOP_FROM = HX_("from",6a,a5,c2,43);
HXLINE( 217)		this->STDLIB__MEMORY_maxSize = HX_("maxSize",85,f9,83,cc);
HXLINE( 216)		this->STDLIB__MEMORY_size = HX_("size",c1,a0,53,4c);
HXLINE( 215)		this->STDLIB__MEMORY_write = HX_("write",df,6c,59,d0);
HXLINE( 214)		this->STDLIB__MEMORY_read = HX_("read",56,4b,a7,4b);
HXLINE( 213)		this->STDLIB__MEMORY_free = HX_("free",ac,9c,c2,43);
HXLINE( 212)		this->STDLIB__MEMORY_allocate = HX_("allocate",bd,d2,ea,90);
HXLINE( 209)		this->STDLIB__ARRAY_set = HX_("set",a2,9b,57,00);
HXLINE( 208)		this->STDLIB__ARRAY_get = HX_("get",96,80,4e,00);
HXLINE( 207)		this->STDLIB__ARRAY_elementType = HX_("elementType",96,db,7a,f0);
HXLINE( 206)		this->STDLIB__ARRAY_length = HX_("length",e6,94,07,9f);
HXLINE( 203)		this->STDLIB__STRING_fromCharCode = HX_("fromCharCode",ad,3a,3b,3c);
HXLINE( 202)		this->STDLIB__STRING_endsWith = HX_("endsWith",5e,7a,b6,db);
HXLINE( 201)		this->STDLIB__STRING_startsWith = HX_("startsWith",77,c0,cf,f9);
HXLINE( 200)		this->STDLIB__STRING_lastIndexOf = HX_("lastIndexOf",13,fd,6a,95);
HXLINE( 199)		this->STDLIB__STRING_indexOf = HX_("indexOf",c9,48,bf,e0);
HXLINE( 198)		this->STDLIB__STRING_contains = HX_("contains",1f,5a,7b,2c);
HXLINE( 197)		this->STDLIB__STRING_remove = HX_("remove",44,9c,88,04);
HXLINE( 196)		this->STDLIB__STRING_replace = HX_("replace",34,48,28,ab);
HXLINE( 195)		this->STDLIB__STRING_split = HX_("split",da,ea,6e,81);
HXLINE( 194)		this->STDLIB__STRING_charAt = HX_("charAt",69,79,75,b7);
HXLINE( 193)		this->STDLIB__STRING_substring = HX_("substring",51,f2,e7,e2);
HXLINE( 192)		this->STDLIB__STRING_trim = HX_("trim",e2,9c,03,4d);
HXLINE( 191)		this->STDLIB__STRING_toUpperCase = HX_("toUpperCase",37,30,fd,38);
HXLINE( 190)		this->STDLIB__STRING_toLowerCase = HX_("toLowerCase",56,4c,64,b8);
HXLINE( 189)		this->STDLIB__STRING_length = HX_("length",e6,94,07,9f);
HXLINE( 186)		this->STDLIB__FLOAT_isWhole = HX_("isWhole",ed,74,47,66);
HXLINE( 181)		this->POSITIVE_SIGN = HX_("+",2b,00,00,00);
HXLINE( 180)		this->NEGATE_SIGN = HX_("-",2d,00,00,00);
HXLINE( 179)		this->SQRT_SIGN = HX_W(u"\u221a",f474,00ab);
HXLINE( 178)		this->FACTORIAL_SIGN = HX_("!",21,00,00,00);
HXLINE( 177)		this->POW_SIGN = HX_("^",5e,00,00,00);
HXLINE( 176)		this->MOD_SIGN = HX_("%",25,00,00,00);
HXLINE( 175)		this->DIVIDE_SIGN = HX_("/",2f,00,00,00);
HXLINE( 174)		this->MULTIPLY_SIGN = HX_("*",2a,00,00,00);
HXLINE( 173)		this->SUBTRACT_SIGN = HX_("-",2d,00,00,00);
HXLINE( 172)		this->ADD_SIGN = HX_("+",2b,00,00,00);
HXLINE( 171)		this->NOT_SIGN = HX_("!",21,00,00,00);
HXLINE( 170)		this->AND_SIGN = HX_("&&",40,21,00,00);
HXLINE( 169)		this->OR_SIGN = HX_("||",80,6c,00,00);
HXLINE( 168)		this->XOR_SIGN = HX_("^^",40,52,00,00);
HXLINE( 167)		this->SMALLER_EQUALS_SIGN = HX_("<=",81,34,00,00);
HXLINE( 166)		this->LARGER_EQUALS_SIGN = HX_(">=",3f,36,00,00);
HXLINE( 165)		this->SMALLER_SIGN = HX_("<",3c,00,00,00);
HXLINE( 164)		this->LARGER_SIGN = HX_(">",3e,00,00,00);
HXLINE( 163)		this->NOT_EQUALS_SIGN = HX_("!=",fc,1c,00,00);
HXLINE( 162)		this->EQUALS_SIGN = HX_("==",60,35,00,00);
HXLINE( 160)		this->PROPERTY_ACCESS_SIGN = HX_(".",2e,00,00,00);
HXLINE( 155)		this->RECOGNIZED_SIGNS = ::Array_obj< ::String >::__new(0);
HXLINE( 153)		this->TYPE_UNKNOWN = HX_("Unknown",6a,4b,cc,ae);
HXLINE( 149)		this->CONDITION__AFTER = HX_("after",1c,66,a2,1d);
HXLINE( 148)		this->CONDITION__WHENEVER = HX_("whenever",d8,fa,66,76);
HXLINE( 147)		this->CONDITION__ELSE = HX_("else",b9,e4,14,43);
HXLINE( 146)		this->CONDITION__IF = HX_("if",dd,5b,00,00);
HXLINE( 145)		this->CONDITION__WHILE_LOOP = HX_("while",b1,43,bd,c9);
HXLINE( 144)		this->CONDITION__FOR_LOOP = HX_("for",09,c7,4d,00);
HXLINE( 142)		this->CONDITION_BODY_PARAMETER_NAME = HX_("code",2d,b1,c4,41);
HXLINE( 141)		this->CONDITION_PATTERN_PARAMETER_NAME = HX_("pattern",50,06,77,11);
HXLINE( 139)		this->RUN_CODE_FUNCTION_NAME = HX_("run",4b,e7,56,00);
HXLINE( 138)		this->READ_FUNCTION_NAME = HX_("read",56,4b,a7,4b);
HXLINE( 137)		this->RAISE_ERROR_FUNCTION_NAME = HX_("error",c8,cb,29,73);
HXLINE( 136)		this->PRINT_FUNCTION_NAME = HX_("print",2d,58,8b,c8);
HXLINE( 134)		this->OBJECT_ADDRESS_PROPERTY_NAME = HX_("address",b4,71,0b,9d);
HXLINE( 133)		this->OBJECT_TYPE_PROPERTY_NAME = HX_("type",ba,f2,08,4d);
HXLINE( 131)		this->MAIN_MODULE_NAME = HX_("Main",59,64,2f,33);
HXLINE( 129)		this->TYPE_SIGN = HX_("Sign",5d,bc,2c,37);
HXLINE( 123)		this->TYPE_MODULE = HX_("Type",da,1e,e2,37);
HXLINE( 117)		this->TYPE_CONDITION = HX_("Condition",7b,c9,06,9e);
HXLINE( 111)		this->TYPE_FUNCTION = HX_("Action",d6,af,da,4a);
HXLINE( 103)		this->TYPE_ARRAY = HX_("Array",79,dd,bc,b8);
HXLINE( 102)		this->TYPE_MEMORY = HX_("Memory",21,3f,54,39);
HXLINE( 101)		this->TYPE_OBJECT = HX_("Object",df,f2,d3,49);
HXLINE( 100)		this->TYPE_STRING = HX_("Characters",ca,5c,7f,4c);
HXLINE(  99)		this->TYPE_BOOLEAN = HX_("Boolean",88,12,50,4b);
HXLINE(  98)		this->TYPE_FLOAT = HX_("Decimal",71,dc,24,b4);
HXLINE(  97)		this->TYPE_INT = HX_("Number",e9,fa,0e,d6);
HXLINE(  96)		this->TYPE_DYNAMIC = HX_("Anything",a2,31,c0,d4);
HXLINE(  95)		this->FALSE_VALUE = HX_("false",a3,35,4f,fb);
HXLINE(  94)		this->TRUE_VALUE = HX_("true",4e,a7,03,4d);
HXLINE(  93)		this->NULL_VALUE = HX_("nothing",0d,9c,5f,4f);
HXLINE(  92)		this->FUNCTION_RETURN = HX_("return",b0,a4,2d,09);
HXLINE(  91)		this->TYPE_DECL_OR_CAST = HX_("as",f2,54,00,00);
HXLINE(  90)		this->FUNCTION_DECLARATION = HX_("action",b6,3b,46,16);
HXLINE(  89)		this->VARIABLE_DECLARATION = HX_("define",3b,7c,e4,66);
HXLINE(  48)		if (::hx::IsNull( config )) {
HXLINE(  49)			return;
            		}
HXLINE(  50)		if (nullifyDefaults) {
HXLINE(  51)			::Array< ::String > fields = ::Type_obj::getInstanceFields(::hx::ClassOf< ::little::KeywordConfig >());
HXLINE(  52)			fields->remove(HX_("defaultConfig",63,2a,4b,c2));
HXLINE(  53)			{
HXLINE(  53)				int _g = 0;
HXDLIN(  53)				while((_g < fields->length)){
HXLINE(  53)					::String field = fields->__get(_g);
HXDLIN(  53)					_g = (_g + 1);
HXLINE(  54)					::String configValue = ( (::String)(::Reflect_obj::field(config,field)) );
HXLINE(  56)					if ((configValue.length == 0)) {
HXLINE(  57)						HX_STACK_DO_THROW( ::haxe::exceptions::ArgumentException_obj::__alloc( HX_CTX ,(HX_("config.",2c,93,39,10) + field),HX_("Keywords of length 0 are not allowed.",f6,3a,0b,e6),null(),::hx::SourceInfo(HX_("src/little/KeywordConfig.hx",41,ce,9f,cc),57,HX_("little.KeywordConfig",f3,78,e8,90),HX_("new",60,d0,53,00))));
            					}
HXLINE(  58)					if (::little::tools::TextTools_obj::contains(configValue,HX_(" ",20,00,00,00))) {
HXLINE(  59)						HX_STACK_DO_THROW( ::haxe::exceptions::ArgumentException_obj::__alloc( HX_CTX ,(HX_("config.",2c,93,39,10) + field),HX_("Keywords cannot contain whitespaces.",8b,a7,23,64),null(),::hx::SourceInfo(HX_("src/little/KeywordConfig.hx",41,ce,9f,cc),59,HX_("little.KeywordConfig",f3,78,e8,90),HX_("new",60,d0,53,00))));
            					}
HXLINE(  60)					if (::little::tools::TextTools_obj::containsAny(configValue,::little::KeywordConfig_obj::recognizedOperators)) {
HXLINE(  61)						HX_STACK_DO_THROW( ::haxe::exceptions::ArgumentException_obj::__alloc( HX_CTX ,(HX_("config.",2c,93,39,10) + field),HX_("Keywords cannot contain operators/signs.",cb,90,a6,43),null(),::hx::SourceInfo(HX_("src/little/KeywordConfig.hx",41,ce,9f,cc),61,HX_("little.KeywordConfig",f3,78,e8,90),HX_("new",60,d0,53,00))));
            					}
HXLINE(  62)					 ::EReg _hx_tmp =  ::EReg_obj::__alloc( HX_CTX ,HX_("[0-9]",1c,5f,53,85),HX_("",00,00,00,00));
HXDLIN(  62)					if (_hx_tmp->match(configValue.charAt(0))) {
HXLINE(  63)						HX_STACK_DO_THROW( ::haxe::exceptions::ArgumentException_obj::__alloc( HX_CTX ,(HX_("config.",2c,93,39,10) + field),HX_("Keywords cannot start with numbers.",b9,71,2d,e4),null(),::hx::SourceInfo(HX_("src/little/KeywordConfig.hx",41,ce,9f,cc),63,HX_("little.KeywordConfig",f3,78,e8,90),HX_("new",60,d0,53,00))));
            					}
HXLINE(  65)					if (::hx::IsEq( configValue,::Reflect_obj::field(::little::KeywordConfig_obj::defaultConfig,field) )) {
HXLINE(  66)						::Reflect_obj::setField(::hx::ObjectPtr<OBJ_>(this),field,null());
            					}
            					else {
HXLINE(  68)						::Reflect_obj::setField(::hx::ObjectPtr<OBJ_>(this),field,configValue);
            					}
            				}
            			}
            		}
            	}

Dynamic KeywordConfig_obj::__CreateEmpty() { return new KeywordConfig_obj; }

void *KeywordConfig_obj::_hx_vtable = 0;

Dynamic KeywordConfig_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< KeywordConfig_obj > _hx_result = new KeywordConfig_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool KeywordConfig_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x2e5378ed;
}

void KeywordConfig_obj::change( ::little::KeywordConfig config){
            	HX_STACKFRAME(&_hx_pos_affab903f7db177c_78_change)
HXLINE(  79)		::Array< ::String > fields = ::Type_obj::getInstanceFields(::hx::ClassOf< ::little::KeywordConfig >());
HXLINE(  80)		fields->remove(HX_("defaultConfig",63,2a,4b,c2));
HXLINE(  81)		{
HXLINE(  81)			int _g = 0;
HXDLIN(  81)			while((_g < fields->length)){
HXLINE(  81)				::String field = fields->__get(_g);
HXDLIN(  81)				_g = (_g + 1);
HXLINE(  82)				::String configValue = ( (::String)(::Reflect_obj::field(config,field)) );
HXLINE(  83)				if (::hx::IsNull( configValue )) {
HXLINE(  84)					continue;
            				}
HXLINE(  85)				::Reflect_obj::setField(::hx::ObjectPtr<OBJ_>(this),field,configValue);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(KeywordConfig_obj,change,(void))

 ::little::KeywordConfig KeywordConfig_obj::defaultConfig;

::Array< ::String > KeywordConfig_obj::recognizedOperators;

::Array< ::String > KeywordConfig_obj::whiteSpacePrefixedOperators;

::Array< ::String > KeywordConfig_obj::whiteSpaceSuffixedOperators;


::hx::ObjectPtr< KeywordConfig_obj > KeywordConfig_obj::__new( ::little::KeywordConfig config,::hx::Null< bool >  __o_nullifyDefaults) {
	::hx::ObjectPtr< KeywordConfig_obj > __this = new KeywordConfig_obj();
	__this->__construct(config,__o_nullifyDefaults);
	return __this;
}

::hx::ObjectPtr< KeywordConfig_obj > KeywordConfig_obj::__alloc(::hx::Ctx *_hx_ctx, ::little::KeywordConfig config,::hx::Null< bool >  __o_nullifyDefaults) {
	KeywordConfig_obj *__this = (KeywordConfig_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(KeywordConfig_obj), true, "little.KeywordConfig"));
	*(void **)__this = KeywordConfig_obj::_hx_vtable;
	__this->__construct(config,__o_nullifyDefaults);
	return __this;
}

KeywordConfig_obj::KeywordConfig_obj()
{
}

void KeywordConfig_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(KeywordConfig);
	HX_MARK_MEMBER_NAME(VARIABLE_DECLARATION,"VARIABLE_DECLARATION");
	HX_MARK_MEMBER_NAME(FUNCTION_DECLARATION,"FUNCTION_DECLARATION");
	HX_MARK_MEMBER_NAME(TYPE_DECL_OR_CAST,"TYPE_DECL_OR_CAST");
	HX_MARK_MEMBER_NAME(FUNCTION_RETURN,"FUNCTION_RETURN");
	HX_MARK_MEMBER_NAME(NULL_VALUE,"NULL_VALUE");
	HX_MARK_MEMBER_NAME(TRUE_VALUE,"TRUE_VALUE");
	HX_MARK_MEMBER_NAME(FALSE_VALUE,"FALSE_VALUE");
	HX_MARK_MEMBER_NAME(TYPE_DYNAMIC,"TYPE_DYNAMIC");
	HX_MARK_MEMBER_NAME(TYPE_INT,"TYPE_INT");
	HX_MARK_MEMBER_NAME(TYPE_FLOAT,"TYPE_FLOAT");
	HX_MARK_MEMBER_NAME(TYPE_BOOLEAN,"TYPE_BOOLEAN");
	HX_MARK_MEMBER_NAME(TYPE_STRING,"TYPE_STRING");
	HX_MARK_MEMBER_NAME(TYPE_OBJECT,"TYPE_OBJECT");
	HX_MARK_MEMBER_NAME(TYPE_MEMORY,"TYPE_MEMORY");
	HX_MARK_MEMBER_NAME(TYPE_ARRAY,"TYPE_ARRAY");
	HX_MARK_MEMBER_NAME(TYPE_FUNCTION,"TYPE_FUNCTION");
	HX_MARK_MEMBER_NAME(TYPE_CONDITION,"TYPE_CONDITION");
	HX_MARK_MEMBER_NAME(TYPE_MODULE,"TYPE_MODULE");
	HX_MARK_MEMBER_NAME(TYPE_SIGN,"TYPE_SIGN");
	HX_MARK_MEMBER_NAME(MAIN_MODULE_NAME,"MAIN_MODULE_NAME");
	HX_MARK_MEMBER_NAME(OBJECT_TYPE_PROPERTY_NAME,"OBJECT_TYPE_PROPERTY_NAME");
	HX_MARK_MEMBER_NAME(OBJECT_ADDRESS_PROPERTY_NAME,"OBJECT_ADDRESS_PROPERTY_NAME");
	HX_MARK_MEMBER_NAME(PRINT_FUNCTION_NAME,"PRINT_FUNCTION_NAME");
	HX_MARK_MEMBER_NAME(RAISE_ERROR_FUNCTION_NAME,"RAISE_ERROR_FUNCTION_NAME");
	HX_MARK_MEMBER_NAME(READ_FUNCTION_NAME,"READ_FUNCTION_NAME");
	HX_MARK_MEMBER_NAME(RUN_CODE_FUNCTION_NAME,"RUN_CODE_FUNCTION_NAME");
	HX_MARK_MEMBER_NAME(CONDITION_PATTERN_PARAMETER_NAME,"CONDITION_PATTERN_PARAMETER_NAME");
	HX_MARK_MEMBER_NAME(CONDITION_BODY_PARAMETER_NAME,"CONDITION_BODY_PARAMETER_NAME");
	HX_MARK_MEMBER_NAME(CONDITION__FOR_LOOP,"CONDITION__FOR_LOOP");
	HX_MARK_MEMBER_NAME(CONDITION__WHILE_LOOP,"CONDITION__WHILE_LOOP");
	HX_MARK_MEMBER_NAME(CONDITION__IF,"CONDITION__IF");
	HX_MARK_MEMBER_NAME(CONDITION__ELSE,"CONDITION__ELSE");
	HX_MARK_MEMBER_NAME(CONDITION__WHENEVER,"CONDITION__WHENEVER");
	HX_MARK_MEMBER_NAME(CONDITION__AFTER,"CONDITION__AFTER");
	HX_MARK_MEMBER_NAME(TYPE_UNKNOWN,"TYPE_UNKNOWN");
	HX_MARK_MEMBER_NAME(RECOGNIZED_SIGNS,"RECOGNIZED_SIGNS");
	HX_MARK_MEMBER_NAME(PROPERTY_ACCESS_SIGN,"PROPERTY_ACCESS_SIGN");
	HX_MARK_MEMBER_NAME(EQUALS_SIGN,"EQUALS_SIGN");
	HX_MARK_MEMBER_NAME(NOT_EQUALS_SIGN,"NOT_EQUALS_SIGN");
	HX_MARK_MEMBER_NAME(LARGER_SIGN,"LARGER_SIGN");
	HX_MARK_MEMBER_NAME(SMALLER_SIGN,"SMALLER_SIGN");
	HX_MARK_MEMBER_NAME(LARGER_EQUALS_SIGN,"LARGER_EQUALS_SIGN");
	HX_MARK_MEMBER_NAME(SMALLER_EQUALS_SIGN,"SMALLER_EQUALS_SIGN");
	HX_MARK_MEMBER_NAME(XOR_SIGN,"XOR_SIGN");
	HX_MARK_MEMBER_NAME(OR_SIGN,"OR_SIGN");
	HX_MARK_MEMBER_NAME(AND_SIGN,"AND_SIGN");
	HX_MARK_MEMBER_NAME(NOT_SIGN,"NOT_SIGN");
	HX_MARK_MEMBER_NAME(ADD_SIGN,"ADD_SIGN");
	HX_MARK_MEMBER_NAME(SUBTRACT_SIGN,"SUBTRACT_SIGN");
	HX_MARK_MEMBER_NAME(MULTIPLY_SIGN,"MULTIPLY_SIGN");
	HX_MARK_MEMBER_NAME(DIVIDE_SIGN,"DIVIDE_SIGN");
	HX_MARK_MEMBER_NAME(MOD_SIGN,"MOD_SIGN");
	HX_MARK_MEMBER_NAME(POW_SIGN,"POW_SIGN");
	HX_MARK_MEMBER_NAME(FACTORIAL_SIGN,"FACTORIAL_SIGN");
	HX_MARK_MEMBER_NAME(SQRT_SIGN,"SQRT_SIGN");
	HX_MARK_MEMBER_NAME(NEGATE_SIGN,"NEGATE_SIGN");
	HX_MARK_MEMBER_NAME(POSITIVE_SIGN,"POSITIVE_SIGN");
	HX_MARK_MEMBER_NAME(STDLIB__FLOAT_isWhole,"STDLIB__FLOAT_isWhole");
	HX_MARK_MEMBER_NAME(STDLIB__STRING_length,"STDLIB__STRING_length");
	HX_MARK_MEMBER_NAME(STDLIB__STRING_toLowerCase,"STDLIB__STRING_toLowerCase");
	HX_MARK_MEMBER_NAME(STDLIB__STRING_toUpperCase,"STDLIB__STRING_toUpperCase");
	HX_MARK_MEMBER_NAME(STDLIB__STRING_trim,"STDLIB__STRING_trim");
	HX_MARK_MEMBER_NAME(STDLIB__STRING_substring,"STDLIB__STRING_substring");
	HX_MARK_MEMBER_NAME(STDLIB__STRING_charAt,"STDLIB__STRING_charAt");
	HX_MARK_MEMBER_NAME(STDLIB__STRING_split,"STDLIB__STRING_split");
	HX_MARK_MEMBER_NAME(STDLIB__STRING_replace,"STDLIB__STRING_replace");
	HX_MARK_MEMBER_NAME(STDLIB__STRING_remove,"STDLIB__STRING_remove");
	HX_MARK_MEMBER_NAME(STDLIB__STRING_contains,"STDLIB__STRING_contains");
	HX_MARK_MEMBER_NAME(STDLIB__STRING_indexOf,"STDLIB__STRING_indexOf");
	HX_MARK_MEMBER_NAME(STDLIB__STRING_lastIndexOf,"STDLIB__STRING_lastIndexOf");
	HX_MARK_MEMBER_NAME(STDLIB__STRING_startsWith,"STDLIB__STRING_startsWith");
	HX_MARK_MEMBER_NAME(STDLIB__STRING_endsWith,"STDLIB__STRING_endsWith");
	HX_MARK_MEMBER_NAME(STDLIB__STRING_fromCharCode,"STDLIB__STRING_fromCharCode");
	HX_MARK_MEMBER_NAME(STDLIB__ARRAY_length,"STDLIB__ARRAY_length");
	HX_MARK_MEMBER_NAME(STDLIB__ARRAY_elementType,"STDLIB__ARRAY_elementType");
	HX_MARK_MEMBER_NAME(STDLIB__ARRAY_get,"STDLIB__ARRAY_get");
	HX_MARK_MEMBER_NAME(STDLIB__ARRAY_set,"STDLIB__ARRAY_set");
	HX_MARK_MEMBER_NAME(STDLIB__MEMORY_allocate,"STDLIB__MEMORY_allocate");
	HX_MARK_MEMBER_NAME(STDLIB__MEMORY_free,"STDLIB__MEMORY_free");
	HX_MARK_MEMBER_NAME(STDLIB__MEMORY_read,"STDLIB__MEMORY_read");
	HX_MARK_MEMBER_NAME(STDLIB__MEMORY_write,"STDLIB__MEMORY_write");
	HX_MARK_MEMBER_NAME(STDLIB__MEMORY_size,"STDLIB__MEMORY_size");
	HX_MARK_MEMBER_NAME(STDLIB__MEMORY_maxSize,"STDLIB__MEMORY_maxSize");
	HX_MARK_MEMBER_NAME(FOR_LOOP_FROM,"FOR_LOOP_FROM");
	HX_MARK_MEMBER_NAME(FOR_LOOP_TO,"FOR_LOOP_TO");
	HX_MARK_MEMBER_NAME(FOR_LOOP_JUMP,"FOR_LOOP_JUMP");
	HX_MARK_MEMBER_NAME(TYPE_CAST_FUNCTION_PREFIX,"TYPE_CAST_FUNCTION_PREFIX");
	HX_MARK_MEMBER_NAME(INSTANTIATE_FUNCTION_NAME,"INSTANTIATE_FUNCTION_NAME");
	HX_MARK_END_CLASS();
}

void KeywordConfig_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(VARIABLE_DECLARATION,"VARIABLE_DECLARATION");
	HX_VISIT_MEMBER_NAME(FUNCTION_DECLARATION,"FUNCTION_DECLARATION");
	HX_VISIT_MEMBER_NAME(TYPE_DECL_OR_CAST,"TYPE_DECL_OR_CAST");
	HX_VISIT_MEMBER_NAME(FUNCTION_RETURN,"FUNCTION_RETURN");
	HX_VISIT_MEMBER_NAME(NULL_VALUE,"NULL_VALUE");
	HX_VISIT_MEMBER_NAME(TRUE_VALUE,"TRUE_VALUE");
	HX_VISIT_MEMBER_NAME(FALSE_VALUE,"FALSE_VALUE");
	HX_VISIT_MEMBER_NAME(TYPE_DYNAMIC,"TYPE_DYNAMIC");
	HX_VISIT_MEMBER_NAME(TYPE_INT,"TYPE_INT");
	HX_VISIT_MEMBER_NAME(TYPE_FLOAT,"TYPE_FLOAT");
	HX_VISIT_MEMBER_NAME(TYPE_BOOLEAN,"TYPE_BOOLEAN");
	HX_VISIT_MEMBER_NAME(TYPE_STRING,"TYPE_STRING");
	HX_VISIT_MEMBER_NAME(TYPE_OBJECT,"TYPE_OBJECT");
	HX_VISIT_MEMBER_NAME(TYPE_MEMORY,"TYPE_MEMORY");
	HX_VISIT_MEMBER_NAME(TYPE_ARRAY,"TYPE_ARRAY");
	HX_VISIT_MEMBER_NAME(TYPE_FUNCTION,"TYPE_FUNCTION");
	HX_VISIT_MEMBER_NAME(TYPE_CONDITION,"TYPE_CONDITION");
	HX_VISIT_MEMBER_NAME(TYPE_MODULE,"TYPE_MODULE");
	HX_VISIT_MEMBER_NAME(TYPE_SIGN,"TYPE_SIGN");
	HX_VISIT_MEMBER_NAME(MAIN_MODULE_NAME,"MAIN_MODULE_NAME");
	HX_VISIT_MEMBER_NAME(OBJECT_TYPE_PROPERTY_NAME,"OBJECT_TYPE_PROPERTY_NAME");
	HX_VISIT_MEMBER_NAME(OBJECT_ADDRESS_PROPERTY_NAME,"OBJECT_ADDRESS_PROPERTY_NAME");
	HX_VISIT_MEMBER_NAME(PRINT_FUNCTION_NAME,"PRINT_FUNCTION_NAME");
	HX_VISIT_MEMBER_NAME(RAISE_ERROR_FUNCTION_NAME,"RAISE_ERROR_FUNCTION_NAME");
	HX_VISIT_MEMBER_NAME(READ_FUNCTION_NAME,"READ_FUNCTION_NAME");
	HX_VISIT_MEMBER_NAME(RUN_CODE_FUNCTION_NAME,"RUN_CODE_FUNCTION_NAME");
	HX_VISIT_MEMBER_NAME(CONDITION_PATTERN_PARAMETER_NAME,"CONDITION_PATTERN_PARAMETER_NAME");
	HX_VISIT_MEMBER_NAME(CONDITION_BODY_PARAMETER_NAME,"CONDITION_BODY_PARAMETER_NAME");
	HX_VISIT_MEMBER_NAME(CONDITION__FOR_LOOP,"CONDITION__FOR_LOOP");
	HX_VISIT_MEMBER_NAME(CONDITION__WHILE_LOOP,"CONDITION__WHILE_LOOP");
	HX_VISIT_MEMBER_NAME(CONDITION__IF,"CONDITION__IF");
	HX_VISIT_MEMBER_NAME(CONDITION__ELSE,"CONDITION__ELSE");
	HX_VISIT_MEMBER_NAME(CONDITION__WHENEVER,"CONDITION__WHENEVER");
	HX_VISIT_MEMBER_NAME(CONDITION__AFTER,"CONDITION__AFTER");
	HX_VISIT_MEMBER_NAME(TYPE_UNKNOWN,"TYPE_UNKNOWN");
	HX_VISIT_MEMBER_NAME(RECOGNIZED_SIGNS,"RECOGNIZED_SIGNS");
	HX_VISIT_MEMBER_NAME(PROPERTY_ACCESS_SIGN,"PROPERTY_ACCESS_SIGN");
	HX_VISIT_MEMBER_NAME(EQUALS_SIGN,"EQUALS_SIGN");
	HX_VISIT_MEMBER_NAME(NOT_EQUALS_SIGN,"NOT_EQUALS_SIGN");
	HX_VISIT_MEMBER_NAME(LARGER_SIGN,"LARGER_SIGN");
	HX_VISIT_MEMBER_NAME(SMALLER_SIGN,"SMALLER_SIGN");
	HX_VISIT_MEMBER_NAME(LARGER_EQUALS_SIGN,"LARGER_EQUALS_SIGN");
	HX_VISIT_MEMBER_NAME(SMALLER_EQUALS_SIGN,"SMALLER_EQUALS_SIGN");
	HX_VISIT_MEMBER_NAME(XOR_SIGN,"XOR_SIGN");
	HX_VISIT_MEMBER_NAME(OR_SIGN,"OR_SIGN");
	HX_VISIT_MEMBER_NAME(AND_SIGN,"AND_SIGN");
	HX_VISIT_MEMBER_NAME(NOT_SIGN,"NOT_SIGN");
	HX_VISIT_MEMBER_NAME(ADD_SIGN,"ADD_SIGN");
	HX_VISIT_MEMBER_NAME(SUBTRACT_SIGN,"SUBTRACT_SIGN");
	HX_VISIT_MEMBER_NAME(MULTIPLY_SIGN,"MULTIPLY_SIGN");
	HX_VISIT_MEMBER_NAME(DIVIDE_SIGN,"DIVIDE_SIGN");
	HX_VISIT_MEMBER_NAME(MOD_SIGN,"MOD_SIGN");
	HX_VISIT_MEMBER_NAME(POW_SIGN,"POW_SIGN");
	HX_VISIT_MEMBER_NAME(FACTORIAL_SIGN,"FACTORIAL_SIGN");
	HX_VISIT_MEMBER_NAME(SQRT_SIGN,"SQRT_SIGN");
	HX_VISIT_MEMBER_NAME(NEGATE_SIGN,"NEGATE_SIGN");
	HX_VISIT_MEMBER_NAME(POSITIVE_SIGN,"POSITIVE_SIGN");
	HX_VISIT_MEMBER_NAME(STDLIB__FLOAT_isWhole,"STDLIB__FLOAT_isWhole");
	HX_VISIT_MEMBER_NAME(STDLIB__STRING_length,"STDLIB__STRING_length");
	HX_VISIT_MEMBER_NAME(STDLIB__STRING_toLowerCase,"STDLIB__STRING_toLowerCase");
	HX_VISIT_MEMBER_NAME(STDLIB__STRING_toUpperCase,"STDLIB__STRING_toUpperCase");
	HX_VISIT_MEMBER_NAME(STDLIB__STRING_trim,"STDLIB__STRING_trim");
	HX_VISIT_MEMBER_NAME(STDLIB__STRING_substring,"STDLIB__STRING_substring");
	HX_VISIT_MEMBER_NAME(STDLIB__STRING_charAt,"STDLIB__STRING_charAt");
	HX_VISIT_MEMBER_NAME(STDLIB__STRING_split,"STDLIB__STRING_split");
	HX_VISIT_MEMBER_NAME(STDLIB__STRING_replace,"STDLIB__STRING_replace");
	HX_VISIT_MEMBER_NAME(STDLIB__STRING_remove,"STDLIB__STRING_remove");
	HX_VISIT_MEMBER_NAME(STDLIB__STRING_contains,"STDLIB__STRING_contains");
	HX_VISIT_MEMBER_NAME(STDLIB__STRING_indexOf,"STDLIB__STRING_indexOf");
	HX_VISIT_MEMBER_NAME(STDLIB__STRING_lastIndexOf,"STDLIB__STRING_lastIndexOf");
	HX_VISIT_MEMBER_NAME(STDLIB__STRING_startsWith,"STDLIB__STRING_startsWith");
	HX_VISIT_MEMBER_NAME(STDLIB__STRING_endsWith,"STDLIB__STRING_endsWith");
	HX_VISIT_MEMBER_NAME(STDLIB__STRING_fromCharCode,"STDLIB__STRING_fromCharCode");
	HX_VISIT_MEMBER_NAME(STDLIB__ARRAY_length,"STDLIB__ARRAY_length");
	HX_VISIT_MEMBER_NAME(STDLIB__ARRAY_elementType,"STDLIB__ARRAY_elementType");
	HX_VISIT_MEMBER_NAME(STDLIB__ARRAY_get,"STDLIB__ARRAY_get");
	HX_VISIT_MEMBER_NAME(STDLIB__ARRAY_set,"STDLIB__ARRAY_set");
	HX_VISIT_MEMBER_NAME(STDLIB__MEMORY_allocate,"STDLIB__MEMORY_allocate");
	HX_VISIT_MEMBER_NAME(STDLIB__MEMORY_free,"STDLIB__MEMORY_free");
	HX_VISIT_MEMBER_NAME(STDLIB__MEMORY_read,"STDLIB__MEMORY_read");
	HX_VISIT_MEMBER_NAME(STDLIB__MEMORY_write,"STDLIB__MEMORY_write");
	HX_VISIT_MEMBER_NAME(STDLIB__MEMORY_size,"STDLIB__MEMORY_size");
	HX_VISIT_MEMBER_NAME(STDLIB__MEMORY_maxSize,"STDLIB__MEMORY_maxSize");
	HX_VISIT_MEMBER_NAME(FOR_LOOP_FROM,"FOR_LOOP_FROM");
	HX_VISIT_MEMBER_NAME(FOR_LOOP_TO,"FOR_LOOP_TO");
	HX_VISIT_MEMBER_NAME(FOR_LOOP_JUMP,"FOR_LOOP_JUMP");
	HX_VISIT_MEMBER_NAME(TYPE_CAST_FUNCTION_PREFIX,"TYPE_CAST_FUNCTION_PREFIX");
	HX_VISIT_MEMBER_NAME(INSTANTIATE_FUNCTION_NAME,"INSTANTIATE_FUNCTION_NAME");
}

::hx::Val KeywordConfig_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"change") ) { return ::hx::Val( change_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"OR_SIGN") ) { return ::hx::Val( OR_SIGN ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"TYPE_INT") ) { return ::hx::Val( TYPE_INT ); }
		if (HX_FIELD_EQ(inName,"XOR_SIGN") ) { return ::hx::Val( XOR_SIGN ); }
		if (HX_FIELD_EQ(inName,"AND_SIGN") ) { return ::hx::Val( AND_SIGN ); }
		if (HX_FIELD_EQ(inName,"NOT_SIGN") ) { return ::hx::Val( NOT_SIGN ); }
		if (HX_FIELD_EQ(inName,"ADD_SIGN") ) { return ::hx::Val( ADD_SIGN ); }
		if (HX_FIELD_EQ(inName,"MOD_SIGN") ) { return ::hx::Val( MOD_SIGN ); }
		if (HX_FIELD_EQ(inName,"POW_SIGN") ) { return ::hx::Val( POW_SIGN ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"TYPE_SIGN") ) { return ::hx::Val( TYPE_SIGN ); }
		if (HX_FIELD_EQ(inName,"SQRT_SIGN") ) { return ::hx::Val( SQRT_SIGN ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"NULL_VALUE") ) { return ::hx::Val( NULL_VALUE ); }
		if (HX_FIELD_EQ(inName,"TRUE_VALUE") ) { return ::hx::Val( TRUE_VALUE ); }
		if (HX_FIELD_EQ(inName,"TYPE_FLOAT") ) { return ::hx::Val( TYPE_FLOAT ); }
		if (HX_FIELD_EQ(inName,"TYPE_ARRAY") ) { return ::hx::Val( TYPE_ARRAY ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"FALSE_VALUE") ) { return ::hx::Val( FALSE_VALUE ); }
		if (HX_FIELD_EQ(inName,"TYPE_STRING") ) { return ::hx::Val( TYPE_STRING ); }
		if (HX_FIELD_EQ(inName,"TYPE_OBJECT") ) { return ::hx::Val( TYPE_OBJECT ); }
		if (HX_FIELD_EQ(inName,"TYPE_MEMORY") ) { return ::hx::Val( TYPE_MEMORY ); }
		if (HX_FIELD_EQ(inName,"TYPE_MODULE") ) { return ::hx::Val( TYPE_MODULE ); }
		if (HX_FIELD_EQ(inName,"EQUALS_SIGN") ) { return ::hx::Val( EQUALS_SIGN ); }
		if (HX_FIELD_EQ(inName,"LARGER_SIGN") ) { return ::hx::Val( LARGER_SIGN ); }
		if (HX_FIELD_EQ(inName,"DIVIDE_SIGN") ) { return ::hx::Val( DIVIDE_SIGN ); }
		if (HX_FIELD_EQ(inName,"NEGATE_SIGN") ) { return ::hx::Val( NEGATE_SIGN ); }
		if (HX_FIELD_EQ(inName,"FOR_LOOP_TO") ) { return ::hx::Val( FOR_LOOP_TO ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"TYPE_DYNAMIC") ) { return ::hx::Val( TYPE_DYNAMIC ); }
		if (HX_FIELD_EQ(inName,"TYPE_BOOLEAN") ) { return ::hx::Val( TYPE_BOOLEAN ); }
		if (HX_FIELD_EQ(inName,"TYPE_UNKNOWN") ) { return ::hx::Val( TYPE_UNKNOWN ); }
		if (HX_FIELD_EQ(inName,"SMALLER_SIGN") ) { return ::hx::Val( SMALLER_SIGN ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"TYPE_FUNCTION") ) { return ::hx::Val( TYPE_FUNCTION ); }
		if (HX_FIELD_EQ(inName,"CONDITION__IF") ) { return ::hx::Val( CONDITION__IF ); }
		if (HX_FIELD_EQ(inName,"SUBTRACT_SIGN") ) { return ::hx::Val( SUBTRACT_SIGN ); }
		if (HX_FIELD_EQ(inName,"MULTIPLY_SIGN") ) { return ::hx::Val( MULTIPLY_SIGN ); }
		if (HX_FIELD_EQ(inName,"POSITIVE_SIGN") ) { return ::hx::Val( POSITIVE_SIGN ); }
		if (HX_FIELD_EQ(inName,"FOR_LOOP_FROM") ) { return ::hx::Val( FOR_LOOP_FROM ); }
		if (HX_FIELD_EQ(inName,"FOR_LOOP_JUMP") ) { return ::hx::Val( FOR_LOOP_JUMP ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"TYPE_CONDITION") ) { return ::hx::Val( TYPE_CONDITION ); }
		if (HX_FIELD_EQ(inName,"FACTORIAL_SIGN") ) { return ::hx::Val( FACTORIAL_SIGN ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"FUNCTION_RETURN") ) { return ::hx::Val( FUNCTION_RETURN ); }
		if (HX_FIELD_EQ(inName,"CONDITION__ELSE") ) { return ::hx::Val( CONDITION__ELSE ); }
		if (HX_FIELD_EQ(inName,"NOT_EQUALS_SIGN") ) { return ::hx::Val( NOT_EQUALS_SIGN ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"MAIN_MODULE_NAME") ) { return ::hx::Val( MAIN_MODULE_NAME ); }
		if (HX_FIELD_EQ(inName,"CONDITION__AFTER") ) { return ::hx::Val( CONDITION__AFTER ); }
		if (HX_FIELD_EQ(inName,"RECOGNIZED_SIGNS") ) { return ::hx::Val( RECOGNIZED_SIGNS ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"TYPE_DECL_OR_CAST") ) { return ::hx::Val( TYPE_DECL_OR_CAST ); }
		if (HX_FIELD_EQ(inName,"STDLIB__ARRAY_get") ) { return ::hx::Val( STDLIB__ARRAY_get ); }
		if (HX_FIELD_EQ(inName,"STDLIB__ARRAY_set") ) { return ::hx::Val( STDLIB__ARRAY_set ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"READ_FUNCTION_NAME") ) { return ::hx::Val( READ_FUNCTION_NAME ); }
		if (HX_FIELD_EQ(inName,"LARGER_EQUALS_SIGN") ) { return ::hx::Val( LARGER_EQUALS_SIGN ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"PRINT_FUNCTION_NAME") ) { return ::hx::Val( PRINT_FUNCTION_NAME ); }
		if (HX_FIELD_EQ(inName,"CONDITION__FOR_LOOP") ) { return ::hx::Val( CONDITION__FOR_LOOP ); }
		if (HX_FIELD_EQ(inName,"CONDITION__WHENEVER") ) { return ::hx::Val( CONDITION__WHENEVER ); }
		if (HX_FIELD_EQ(inName,"SMALLER_EQUALS_SIGN") ) { return ::hx::Val( SMALLER_EQUALS_SIGN ); }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_trim") ) { return ::hx::Val( STDLIB__STRING_trim ); }
		if (HX_FIELD_EQ(inName,"STDLIB__MEMORY_free") ) { return ::hx::Val( STDLIB__MEMORY_free ); }
		if (HX_FIELD_EQ(inName,"STDLIB__MEMORY_read") ) { return ::hx::Val( STDLIB__MEMORY_read ); }
		if (HX_FIELD_EQ(inName,"STDLIB__MEMORY_size") ) { return ::hx::Val( STDLIB__MEMORY_size ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"VARIABLE_DECLARATION") ) { return ::hx::Val( VARIABLE_DECLARATION ); }
		if (HX_FIELD_EQ(inName,"FUNCTION_DECLARATION") ) { return ::hx::Val( FUNCTION_DECLARATION ); }
		if (HX_FIELD_EQ(inName,"PROPERTY_ACCESS_SIGN") ) { return ::hx::Val( PROPERTY_ACCESS_SIGN ); }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_split") ) { return ::hx::Val( STDLIB__STRING_split ); }
		if (HX_FIELD_EQ(inName,"STDLIB__ARRAY_length") ) { return ::hx::Val( STDLIB__ARRAY_length ); }
		if (HX_FIELD_EQ(inName,"STDLIB__MEMORY_write") ) { return ::hx::Val( STDLIB__MEMORY_write ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"CONDITION__WHILE_LOOP") ) { return ::hx::Val( CONDITION__WHILE_LOOP ); }
		if (HX_FIELD_EQ(inName,"STDLIB__FLOAT_isWhole") ) { return ::hx::Val( STDLIB__FLOAT_isWhole ); }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_length") ) { return ::hx::Val( STDLIB__STRING_length ); }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_charAt") ) { return ::hx::Val( STDLIB__STRING_charAt ); }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_remove") ) { return ::hx::Val( STDLIB__STRING_remove ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"RUN_CODE_FUNCTION_NAME") ) { return ::hx::Val( RUN_CODE_FUNCTION_NAME ); }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_replace") ) { return ::hx::Val( STDLIB__STRING_replace ); }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_indexOf") ) { return ::hx::Val( STDLIB__STRING_indexOf ); }
		if (HX_FIELD_EQ(inName,"STDLIB__MEMORY_maxSize") ) { return ::hx::Val( STDLIB__MEMORY_maxSize ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_contains") ) { return ::hx::Val( STDLIB__STRING_contains ); }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_endsWith") ) { return ::hx::Val( STDLIB__STRING_endsWith ); }
		if (HX_FIELD_EQ(inName,"STDLIB__MEMORY_allocate") ) { return ::hx::Val( STDLIB__MEMORY_allocate ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_substring") ) { return ::hx::Val( STDLIB__STRING_substring ); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"OBJECT_TYPE_PROPERTY_NAME") ) { return ::hx::Val( OBJECT_TYPE_PROPERTY_NAME ); }
		if (HX_FIELD_EQ(inName,"RAISE_ERROR_FUNCTION_NAME") ) { return ::hx::Val( RAISE_ERROR_FUNCTION_NAME ); }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_startsWith") ) { return ::hx::Val( STDLIB__STRING_startsWith ); }
		if (HX_FIELD_EQ(inName,"STDLIB__ARRAY_elementType") ) { return ::hx::Val( STDLIB__ARRAY_elementType ); }
		if (HX_FIELD_EQ(inName,"TYPE_CAST_FUNCTION_PREFIX") ) { return ::hx::Val( TYPE_CAST_FUNCTION_PREFIX ); }
		if (HX_FIELD_EQ(inName,"INSTANTIATE_FUNCTION_NAME") ) { return ::hx::Val( INSTANTIATE_FUNCTION_NAME ); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_toLowerCase") ) { return ::hx::Val( STDLIB__STRING_toLowerCase ); }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_toUpperCase") ) { return ::hx::Val( STDLIB__STRING_toUpperCase ); }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_lastIndexOf") ) { return ::hx::Val( STDLIB__STRING_lastIndexOf ); }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_fromCharCode") ) { return ::hx::Val( STDLIB__STRING_fromCharCode ); }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"OBJECT_ADDRESS_PROPERTY_NAME") ) { return ::hx::Val( OBJECT_ADDRESS_PROPERTY_NAME ); }
		break;
	case 29:
		if (HX_FIELD_EQ(inName,"CONDITION_BODY_PARAMETER_NAME") ) { return ::hx::Val( CONDITION_BODY_PARAMETER_NAME ); }
		break;
	case 32:
		if (HX_FIELD_EQ(inName,"CONDITION_PATTERN_PARAMETER_NAME") ) { return ::hx::Val( CONDITION_PATTERN_PARAMETER_NAME ); }
	}
	return super::__Field(inName,inCallProp);
}

bool KeywordConfig_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 13:
		if (HX_FIELD_EQ(inName,"defaultConfig") ) { outValue = ( defaultConfig ); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"recognizedOperators") ) { outValue = ( recognizedOperators ); return true; }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"whiteSpacePrefixedOperators") ) { outValue = ( whiteSpacePrefixedOperators ); return true; }
		if (HX_FIELD_EQ(inName,"whiteSpaceSuffixedOperators") ) { outValue = ( whiteSpaceSuffixedOperators ); return true; }
	}
	return false;
}

::hx::Val KeywordConfig_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"OR_SIGN") ) { OR_SIGN=inValue.Cast< ::String >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"TYPE_INT") ) { TYPE_INT=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"XOR_SIGN") ) { XOR_SIGN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"AND_SIGN") ) { AND_SIGN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"NOT_SIGN") ) { NOT_SIGN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ADD_SIGN") ) { ADD_SIGN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"MOD_SIGN") ) { MOD_SIGN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"POW_SIGN") ) { POW_SIGN=inValue.Cast< ::String >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"TYPE_SIGN") ) { TYPE_SIGN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"SQRT_SIGN") ) { SQRT_SIGN=inValue.Cast< ::String >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"NULL_VALUE") ) { NULL_VALUE=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"TRUE_VALUE") ) { TRUE_VALUE=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"TYPE_FLOAT") ) { TYPE_FLOAT=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"TYPE_ARRAY") ) { TYPE_ARRAY=inValue.Cast< ::String >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"FALSE_VALUE") ) { FALSE_VALUE=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"TYPE_STRING") ) { TYPE_STRING=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"TYPE_OBJECT") ) { TYPE_OBJECT=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"TYPE_MEMORY") ) { TYPE_MEMORY=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"TYPE_MODULE") ) { TYPE_MODULE=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"EQUALS_SIGN") ) { EQUALS_SIGN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"LARGER_SIGN") ) { LARGER_SIGN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"DIVIDE_SIGN") ) { DIVIDE_SIGN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"NEGATE_SIGN") ) { NEGATE_SIGN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"FOR_LOOP_TO") ) { FOR_LOOP_TO=inValue.Cast< ::String >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"TYPE_DYNAMIC") ) { TYPE_DYNAMIC=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"TYPE_BOOLEAN") ) { TYPE_BOOLEAN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"TYPE_UNKNOWN") ) { TYPE_UNKNOWN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"SMALLER_SIGN") ) { SMALLER_SIGN=inValue.Cast< ::String >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"TYPE_FUNCTION") ) { TYPE_FUNCTION=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"CONDITION__IF") ) { CONDITION__IF=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"SUBTRACT_SIGN") ) { SUBTRACT_SIGN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"MULTIPLY_SIGN") ) { MULTIPLY_SIGN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"POSITIVE_SIGN") ) { POSITIVE_SIGN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"FOR_LOOP_FROM") ) { FOR_LOOP_FROM=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"FOR_LOOP_JUMP") ) { FOR_LOOP_JUMP=inValue.Cast< ::String >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"TYPE_CONDITION") ) { TYPE_CONDITION=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"FACTORIAL_SIGN") ) { FACTORIAL_SIGN=inValue.Cast< ::String >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"FUNCTION_RETURN") ) { FUNCTION_RETURN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"CONDITION__ELSE") ) { CONDITION__ELSE=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"NOT_EQUALS_SIGN") ) { NOT_EQUALS_SIGN=inValue.Cast< ::String >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"MAIN_MODULE_NAME") ) { MAIN_MODULE_NAME=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"CONDITION__AFTER") ) { CONDITION__AFTER=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"RECOGNIZED_SIGNS") ) { RECOGNIZED_SIGNS=inValue.Cast< ::Array< ::String > >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"TYPE_DECL_OR_CAST") ) { TYPE_DECL_OR_CAST=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__ARRAY_get") ) { STDLIB__ARRAY_get=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__ARRAY_set") ) { STDLIB__ARRAY_set=inValue.Cast< ::String >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"READ_FUNCTION_NAME") ) { READ_FUNCTION_NAME=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"LARGER_EQUALS_SIGN") ) { LARGER_EQUALS_SIGN=inValue.Cast< ::String >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"PRINT_FUNCTION_NAME") ) { PRINT_FUNCTION_NAME=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"CONDITION__FOR_LOOP") ) { CONDITION__FOR_LOOP=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"CONDITION__WHENEVER") ) { CONDITION__WHENEVER=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"SMALLER_EQUALS_SIGN") ) { SMALLER_EQUALS_SIGN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_trim") ) { STDLIB__STRING_trim=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__MEMORY_free") ) { STDLIB__MEMORY_free=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__MEMORY_read") ) { STDLIB__MEMORY_read=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__MEMORY_size") ) { STDLIB__MEMORY_size=inValue.Cast< ::String >(); return inValue; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"VARIABLE_DECLARATION") ) { VARIABLE_DECLARATION=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"FUNCTION_DECLARATION") ) { FUNCTION_DECLARATION=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"PROPERTY_ACCESS_SIGN") ) { PROPERTY_ACCESS_SIGN=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_split") ) { STDLIB__STRING_split=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__ARRAY_length") ) { STDLIB__ARRAY_length=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__MEMORY_write") ) { STDLIB__MEMORY_write=inValue.Cast< ::String >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"CONDITION__WHILE_LOOP") ) { CONDITION__WHILE_LOOP=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__FLOAT_isWhole") ) { STDLIB__FLOAT_isWhole=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_length") ) { STDLIB__STRING_length=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_charAt") ) { STDLIB__STRING_charAt=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_remove") ) { STDLIB__STRING_remove=inValue.Cast< ::String >(); return inValue; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"RUN_CODE_FUNCTION_NAME") ) { RUN_CODE_FUNCTION_NAME=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_replace") ) { STDLIB__STRING_replace=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_indexOf") ) { STDLIB__STRING_indexOf=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__MEMORY_maxSize") ) { STDLIB__MEMORY_maxSize=inValue.Cast< ::String >(); return inValue; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_contains") ) { STDLIB__STRING_contains=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_endsWith") ) { STDLIB__STRING_endsWith=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__MEMORY_allocate") ) { STDLIB__MEMORY_allocate=inValue.Cast< ::String >(); return inValue; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_substring") ) { STDLIB__STRING_substring=inValue.Cast< ::String >(); return inValue; }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"OBJECT_TYPE_PROPERTY_NAME") ) { OBJECT_TYPE_PROPERTY_NAME=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"RAISE_ERROR_FUNCTION_NAME") ) { RAISE_ERROR_FUNCTION_NAME=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_startsWith") ) { STDLIB__STRING_startsWith=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__ARRAY_elementType") ) { STDLIB__ARRAY_elementType=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"TYPE_CAST_FUNCTION_PREFIX") ) { TYPE_CAST_FUNCTION_PREFIX=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"INSTANTIATE_FUNCTION_NAME") ) { INSTANTIATE_FUNCTION_NAME=inValue.Cast< ::String >(); return inValue; }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_toLowerCase") ) { STDLIB__STRING_toLowerCase=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_toUpperCase") ) { STDLIB__STRING_toUpperCase=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_lastIndexOf") ) { STDLIB__STRING_lastIndexOf=inValue.Cast< ::String >(); return inValue; }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"STDLIB__STRING_fromCharCode") ) { STDLIB__STRING_fromCharCode=inValue.Cast< ::String >(); return inValue; }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"OBJECT_ADDRESS_PROPERTY_NAME") ) { OBJECT_ADDRESS_PROPERTY_NAME=inValue.Cast< ::String >(); return inValue; }
		break;
	case 29:
		if (HX_FIELD_EQ(inName,"CONDITION_BODY_PARAMETER_NAME") ) { CONDITION_BODY_PARAMETER_NAME=inValue.Cast< ::String >(); return inValue; }
		break;
	case 32:
		if (HX_FIELD_EQ(inName,"CONDITION_PATTERN_PARAMETER_NAME") ) { CONDITION_PATTERN_PARAMETER_NAME=inValue.Cast< ::String >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool KeywordConfig_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 13:
		if (HX_FIELD_EQ(inName,"defaultConfig") ) { defaultConfig=ioValue.Cast<  ::little::KeywordConfig >(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"recognizedOperators") ) { recognizedOperators=ioValue.Cast< ::Array< ::String > >(); return true; }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"whiteSpacePrefixedOperators") ) { whiteSpacePrefixedOperators=ioValue.Cast< ::Array< ::String > >(); return true; }
		if (HX_FIELD_EQ(inName,"whiteSpaceSuffixedOperators") ) { whiteSpaceSuffixedOperators=ioValue.Cast< ::Array< ::String > >(); return true; }
	}
	return false;
}

void KeywordConfig_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("VARIABLE_DECLARATION",17,eb,73,20));
	outFields->push(HX_("FUNCTION_DECLARATION",f3,5d,29,5b));
	outFields->push(HX_("TYPE_DECL_OR_CAST",6b,56,23,ff));
	outFields->push(HX_("FUNCTION_RETURN",37,3a,57,a4));
	outFields->push(HX_("NULL_VALUE",59,84,bf,9f));
	outFields->push(HX_("TRUE_VALUE",60,dc,59,88));
	outFields->push(HX_("FALSE_VALUE",55,f0,96,1b));
	outFields->push(HX_("TYPE_DYNAMIC",9a,d1,1b,42));
	outFields->push(HX_("TYPE_INT",8a,8d,b9,2f));
	outFields->push(HX_("TYPE_FLOAT",f7,c6,d5,ff));
	outFields->push(HX_("TYPE_BOOLEAN",c3,1c,05,8a));
	outFields->push(HX_("TYPE_STRING",f6,56,12,ab));
	outFields->push(HX_("TYPE_OBJECT",e4,ac,21,af));
	outFields->push(HX_("TYPE_MEMORY",26,f9,a1,9e));
	outFields->push(HX_("TYPE_ARRAY",f4,6e,ce,22));
	outFields->push(HX_("TYPE_FUNCTION",7d,50,b8,8d));
	outFields->push(HX_("TYPE_CONDITION",76,fc,be,bb));
	outFields->push(HX_("TYPE_MODULE",d1,62,b5,5a));
	outFields->push(HX_("TYPE_SIGN",22,97,3a,99));
	outFields->push(HX_("MAIN_MODULE_NAME",b8,25,0e,dd));
	outFields->push(HX_("OBJECT_TYPE_PROPERTY_NAME",f0,d2,6a,5c));
	outFields->push(HX_("OBJECT_ADDRESS_PROPERTY_NAME",ca,85,55,fa));
	outFields->push(HX_("PRINT_FUNCTION_NAME",20,81,02,92));
	outFields->push(HX_("RAISE_ERROR_FUNCTION_NAME",c8,cf,6c,48));
	outFields->push(HX_("READ_FUNCTION_NAME",29,d2,f0,84));
	outFields->push(HX_("RUN_CODE_FUNCTION_NAME",14,aa,a9,ea));
	outFields->push(HX_("CONDITION_PATTERN_PARAMETER_NAME",f4,59,90,be));
	outFields->push(HX_("CONDITION_BODY_PARAMETER_NAME",3a,7c,31,f4));
	outFields->push(HX_("CONDITION__FOR_LOOP",15,8f,a3,67));
	outFields->push(HX_("CONDITION__WHILE_LOOP",2d,22,5d,92));
	outFields->push(HX_("CONDITION__IF",f8,cd,89,68));
	outFields->push(HX_("CONDITION__ELSE",94,37,73,f6));
	outFields->push(HX_("CONDITION__WHENEVER",33,1f,d8,0f));
	outFields->push(HX_("CONDITION__AFTER",c1,92,cc,5c));
	outFields->push(HX_("TYPE_UNKNOWN",a5,55,81,ed));
	outFields->push(HX_("RECOGNIZED_SIGNS",cd,67,e6,59));
	outFields->push(HX_("PROPERTY_ACCESS_SIGN",ce,f1,0c,67));
	outFields->push(HX_("EQUALS_SIGN",7d,55,9d,95));
	outFields->push(HX_("NOT_EQUALS_SIGN",f1,98,f7,56));
	outFields->push(HX_("LARGER_SIGN",65,9c,f3,6b));
	outFields->push(HX_("SMALLER_SIGN",c8,56,36,6a));
	outFields->push(HX_("LARGER_EQUALS_SIGN",55,66,d0,a0));
	outFields->push(HX_("SMALLER_EQUALS_SIGN",52,0e,3b,94));
	outFields->push(HX_("XOR_SIGN",c1,ea,df,31));
	outFields->push(HX_("OR_SIGN",19,b0,88,88));
	outFields->push(HX_("AND_SIGN",05,26,c3,4b));
	outFields->push(HX_("NOT_SIGN",49,2e,9e,c2));
	outFields->push(HX_("ADD_SIGN",7b,82,ec,ab));
	outFields->push(HX_("SUBTRACT_SIGN",88,86,1f,3d));
	outFields->push(HX_("MULTIPLY_SIGN",78,bf,ce,08));
	outFields->push(HX_("DIVIDE_SIGN",03,62,45,c9));
	outFields->push(HX_("MOD_SIGN",3a,f6,b5,23));
	outFields->push(HX_("POW_SIGN",a4,27,15,68));
	outFields->push(HX_("FACTORIAL_SIGN",f7,bd,42,83));
	outFields->push(HX_("SQRT_SIGN",3c,f4,3a,4f));
	outFields->push(HX_("NEGATE_SIGN",1a,67,6a,44));
	outFields->push(HX_("POSITIVE_SIGN",c3,3e,27,b3));
	outFields->push(HX_("STDLIB__FLOAT_isWhole",88,e8,98,c0));
	outFields->push(HX_("STDLIB__STRING_length",72,be,1d,37));
	outFields->push(HX_("STDLIB__STRING_toLowerCase",4a,07,50,ac));
	outFields->push(HX_("STDLIB__STRING_toUpperCase",2b,eb,e8,2c));
	outFields->push(HX_("STDLIB__STRING_trim",6e,0b,38,5c));
	outFields->push(HX_("STDLIB__STRING_substring",45,48,db,72));
	outFields->push(HX_("STDLIB__STRING_charAt",f5,a2,8b,4f));
	outFields->push(HX_("STDLIB__STRING_split",ce,36,1b,c0));
	outFields->push(HX_("STDLIB__STRING_replace",28,79,76,26));
	outFields->push(HX_("STDLIB__STRING_remove",d0,c5,9e,9c));
	outFields->push(HX_("STDLIB__STRING_contains",ab,fe,97,95));
	outFields->push(HX_("STDLIB__STRING_indexOf",bd,79,0d,5c));
	outFields->push(HX_("STDLIB__STRING_lastIndexOf",07,b8,56,89));
	outFields->push(HX_("STDLIB__STRING_startsWith",03,a0,c7,5e));
	outFields->push(HX_("STDLIB__STRING_endsWith",ea,1e,d3,44));
	outFields->push(HX_("STDLIB__STRING_fromCharCode",39,15,93,b6));
	outFields->push(HX_("STDLIB__ARRAY_length",4e,cf,3c,04));
	outFields->push(HX_("STDLIB__ARRAY_elementType",2e,e8,30,d3));
	outFields->push(HX_("STDLIB__ARRAY_get",2e,35,da,e2));
	outFields->push(HX_("STDLIB__ARRAY_set",3a,50,e3,e2));
	outFields->push(HX_("STDLIB__MEMORY_allocate",19,0f,6a,ca));
	outFields->push(HX_("STDLIB__MEMORY_free",08,7b,9d,1a));
	outFields->push(HX_("STDLIB__MEMORY_read",b2,29,82,22));
	outFields->push(HX_("STDLIB__MEMORY_write",03,1f,01,f9));
	outFields->push(HX_("STDLIB__MEMORY_size",1d,7f,2e,23));
	outFields->push(HX_("STDLIB__MEMORY_maxSize",a9,7c,17,34));
	outFields->push(HX_("FOR_LOOP_FROM",4f,6c,13,f9));
	outFields->push(HX_("FOR_LOOP_TO",20,55,3a,ff));
	outFields->push(HX_("FOR_LOOP_JUMP",d3,8b,ba,fb));
	outFields->push(HX_("TYPE_CAST_FUNCTION_PREFIX",3e,5f,ed,f6));
	outFields->push(HX_("INSTANTIATE_FUNCTION_NAME",5d,40,6a,b0));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo KeywordConfig_obj_sMemberStorageInfo[] = {
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,VARIABLE_DECLARATION),HX_("VARIABLE_DECLARATION",17,eb,73,20)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,FUNCTION_DECLARATION),HX_("FUNCTION_DECLARATION",f3,5d,29,5b)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TYPE_DECL_OR_CAST),HX_("TYPE_DECL_OR_CAST",6b,56,23,ff)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,FUNCTION_RETURN),HX_("FUNCTION_RETURN",37,3a,57,a4)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,NULL_VALUE),HX_("NULL_VALUE",59,84,bf,9f)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TRUE_VALUE),HX_("TRUE_VALUE",60,dc,59,88)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,FALSE_VALUE),HX_("FALSE_VALUE",55,f0,96,1b)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TYPE_DYNAMIC),HX_("TYPE_DYNAMIC",9a,d1,1b,42)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TYPE_INT),HX_("TYPE_INT",8a,8d,b9,2f)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TYPE_FLOAT),HX_("TYPE_FLOAT",f7,c6,d5,ff)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TYPE_BOOLEAN),HX_("TYPE_BOOLEAN",c3,1c,05,8a)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TYPE_STRING),HX_("TYPE_STRING",f6,56,12,ab)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TYPE_OBJECT),HX_("TYPE_OBJECT",e4,ac,21,af)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TYPE_MEMORY),HX_("TYPE_MEMORY",26,f9,a1,9e)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TYPE_ARRAY),HX_("TYPE_ARRAY",f4,6e,ce,22)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TYPE_FUNCTION),HX_("TYPE_FUNCTION",7d,50,b8,8d)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TYPE_CONDITION),HX_("TYPE_CONDITION",76,fc,be,bb)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TYPE_MODULE),HX_("TYPE_MODULE",d1,62,b5,5a)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TYPE_SIGN),HX_("TYPE_SIGN",22,97,3a,99)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,MAIN_MODULE_NAME),HX_("MAIN_MODULE_NAME",b8,25,0e,dd)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,OBJECT_TYPE_PROPERTY_NAME),HX_("OBJECT_TYPE_PROPERTY_NAME",f0,d2,6a,5c)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,OBJECT_ADDRESS_PROPERTY_NAME),HX_("OBJECT_ADDRESS_PROPERTY_NAME",ca,85,55,fa)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,PRINT_FUNCTION_NAME),HX_("PRINT_FUNCTION_NAME",20,81,02,92)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,RAISE_ERROR_FUNCTION_NAME),HX_("RAISE_ERROR_FUNCTION_NAME",c8,cf,6c,48)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,READ_FUNCTION_NAME),HX_("READ_FUNCTION_NAME",29,d2,f0,84)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,RUN_CODE_FUNCTION_NAME),HX_("RUN_CODE_FUNCTION_NAME",14,aa,a9,ea)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,CONDITION_PATTERN_PARAMETER_NAME),HX_("CONDITION_PATTERN_PARAMETER_NAME",f4,59,90,be)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,CONDITION_BODY_PARAMETER_NAME),HX_("CONDITION_BODY_PARAMETER_NAME",3a,7c,31,f4)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,CONDITION__FOR_LOOP),HX_("CONDITION__FOR_LOOP",15,8f,a3,67)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,CONDITION__WHILE_LOOP),HX_("CONDITION__WHILE_LOOP",2d,22,5d,92)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,CONDITION__IF),HX_("CONDITION__IF",f8,cd,89,68)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,CONDITION__ELSE),HX_("CONDITION__ELSE",94,37,73,f6)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,CONDITION__WHENEVER),HX_("CONDITION__WHENEVER",33,1f,d8,0f)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,CONDITION__AFTER),HX_("CONDITION__AFTER",c1,92,cc,5c)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TYPE_UNKNOWN),HX_("TYPE_UNKNOWN",a5,55,81,ed)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(KeywordConfig_obj,RECOGNIZED_SIGNS),HX_("RECOGNIZED_SIGNS",cd,67,e6,59)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,PROPERTY_ACCESS_SIGN),HX_("PROPERTY_ACCESS_SIGN",ce,f1,0c,67)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,EQUALS_SIGN),HX_("EQUALS_SIGN",7d,55,9d,95)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,NOT_EQUALS_SIGN),HX_("NOT_EQUALS_SIGN",f1,98,f7,56)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,LARGER_SIGN),HX_("LARGER_SIGN",65,9c,f3,6b)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,SMALLER_SIGN),HX_("SMALLER_SIGN",c8,56,36,6a)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,LARGER_EQUALS_SIGN),HX_("LARGER_EQUALS_SIGN",55,66,d0,a0)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,SMALLER_EQUALS_SIGN),HX_("SMALLER_EQUALS_SIGN",52,0e,3b,94)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,XOR_SIGN),HX_("XOR_SIGN",c1,ea,df,31)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,OR_SIGN),HX_("OR_SIGN",19,b0,88,88)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,AND_SIGN),HX_("AND_SIGN",05,26,c3,4b)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,NOT_SIGN),HX_("NOT_SIGN",49,2e,9e,c2)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,ADD_SIGN),HX_("ADD_SIGN",7b,82,ec,ab)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,SUBTRACT_SIGN),HX_("SUBTRACT_SIGN",88,86,1f,3d)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,MULTIPLY_SIGN),HX_("MULTIPLY_SIGN",78,bf,ce,08)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,DIVIDE_SIGN),HX_("DIVIDE_SIGN",03,62,45,c9)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,MOD_SIGN),HX_("MOD_SIGN",3a,f6,b5,23)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,POW_SIGN),HX_("POW_SIGN",a4,27,15,68)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,FACTORIAL_SIGN),HX_("FACTORIAL_SIGN",f7,bd,42,83)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,SQRT_SIGN),HX_("SQRT_SIGN",3c,f4,3a,4f)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,NEGATE_SIGN),HX_("NEGATE_SIGN",1a,67,6a,44)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,POSITIVE_SIGN),HX_("POSITIVE_SIGN",c3,3e,27,b3)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__FLOAT_isWhole),HX_("STDLIB__FLOAT_isWhole",88,e8,98,c0)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__STRING_length),HX_("STDLIB__STRING_length",72,be,1d,37)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__STRING_toLowerCase),HX_("STDLIB__STRING_toLowerCase",4a,07,50,ac)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__STRING_toUpperCase),HX_("STDLIB__STRING_toUpperCase",2b,eb,e8,2c)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__STRING_trim),HX_("STDLIB__STRING_trim",6e,0b,38,5c)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__STRING_substring),HX_("STDLIB__STRING_substring",45,48,db,72)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__STRING_charAt),HX_("STDLIB__STRING_charAt",f5,a2,8b,4f)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__STRING_split),HX_("STDLIB__STRING_split",ce,36,1b,c0)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__STRING_replace),HX_("STDLIB__STRING_replace",28,79,76,26)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__STRING_remove),HX_("STDLIB__STRING_remove",d0,c5,9e,9c)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__STRING_contains),HX_("STDLIB__STRING_contains",ab,fe,97,95)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__STRING_indexOf),HX_("STDLIB__STRING_indexOf",bd,79,0d,5c)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__STRING_lastIndexOf),HX_("STDLIB__STRING_lastIndexOf",07,b8,56,89)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__STRING_startsWith),HX_("STDLIB__STRING_startsWith",03,a0,c7,5e)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__STRING_endsWith),HX_("STDLIB__STRING_endsWith",ea,1e,d3,44)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__STRING_fromCharCode),HX_("STDLIB__STRING_fromCharCode",39,15,93,b6)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__ARRAY_length),HX_("STDLIB__ARRAY_length",4e,cf,3c,04)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__ARRAY_elementType),HX_("STDLIB__ARRAY_elementType",2e,e8,30,d3)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__ARRAY_get),HX_("STDLIB__ARRAY_get",2e,35,da,e2)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__ARRAY_set),HX_("STDLIB__ARRAY_set",3a,50,e3,e2)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__MEMORY_allocate),HX_("STDLIB__MEMORY_allocate",19,0f,6a,ca)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__MEMORY_free),HX_("STDLIB__MEMORY_free",08,7b,9d,1a)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__MEMORY_read),HX_("STDLIB__MEMORY_read",b2,29,82,22)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__MEMORY_write),HX_("STDLIB__MEMORY_write",03,1f,01,f9)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__MEMORY_size),HX_("STDLIB__MEMORY_size",1d,7f,2e,23)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,STDLIB__MEMORY_maxSize),HX_("STDLIB__MEMORY_maxSize",a9,7c,17,34)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,FOR_LOOP_FROM),HX_("FOR_LOOP_FROM",4f,6c,13,f9)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,FOR_LOOP_TO),HX_("FOR_LOOP_TO",20,55,3a,ff)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,FOR_LOOP_JUMP),HX_("FOR_LOOP_JUMP",d3,8b,ba,fb)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,TYPE_CAST_FUNCTION_PREFIX),HX_("TYPE_CAST_FUNCTION_PREFIX",3e,5f,ed,f6)},
	{::hx::fsString,(int)offsetof(KeywordConfig_obj,INSTANTIATE_FUNCTION_NAME),HX_("INSTANTIATE_FUNCTION_NAME",5d,40,6a,b0)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo KeywordConfig_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::little::KeywordConfig */ ,(void *) &KeywordConfig_obj::defaultConfig,HX_("defaultConfig",63,2a,4b,c2)},
	{::hx::fsObject /* ::Array< ::String > */ ,(void *) &KeywordConfig_obj::recognizedOperators,HX_("recognizedOperators",d9,36,40,43)},
	{::hx::fsObject /* ::Array< ::String > */ ,(void *) &KeywordConfig_obj::whiteSpacePrefixedOperators,HX_("whiteSpacePrefixedOperators",81,dd,9f,8d)},
	{::hx::fsObject /* ::Array< ::String > */ ,(void *) &KeywordConfig_obj::whiteSpaceSuffixedOperators,HX_("whiteSpaceSuffixedOperators",a2,6e,07,01)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String KeywordConfig_obj_sMemberFields[] = {
	HX_("change",70,91,72,b7),
	HX_("VARIABLE_DECLARATION",17,eb,73,20),
	HX_("FUNCTION_DECLARATION",f3,5d,29,5b),
	HX_("TYPE_DECL_OR_CAST",6b,56,23,ff),
	HX_("FUNCTION_RETURN",37,3a,57,a4),
	HX_("NULL_VALUE",59,84,bf,9f),
	HX_("TRUE_VALUE",60,dc,59,88),
	HX_("FALSE_VALUE",55,f0,96,1b),
	HX_("TYPE_DYNAMIC",9a,d1,1b,42),
	HX_("TYPE_INT",8a,8d,b9,2f),
	HX_("TYPE_FLOAT",f7,c6,d5,ff),
	HX_("TYPE_BOOLEAN",c3,1c,05,8a),
	HX_("TYPE_STRING",f6,56,12,ab),
	HX_("TYPE_OBJECT",e4,ac,21,af),
	HX_("TYPE_MEMORY",26,f9,a1,9e),
	HX_("TYPE_ARRAY",f4,6e,ce,22),
	HX_("TYPE_FUNCTION",7d,50,b8,8d),
	HX_("TYPE_CONDITION",76,fc,be,bb),
	HX_("TYPE_MODULE",d1,62,b5,5a),
	HX_("TYPE_SIGN",22,97,3a,99),
	HX_("MAIN_MODULE_NAME",b8,25,0e,dd),
	HX_("OBJECT_TYPE_PROPERTY_NAME",f0,d2,6a,5c),
	HX_("OBJECT_ADDRESS_PROPERTY_NAME",ca,85,55,fa),
	HX_("PRINT_FUNCTION_NAME",20,81,02,92),
	HX_("RAISE_ERROR_FUNCTION_NAME",c8,cf,6c,48),
	HX_("READ_FUNCTION_NAME",29,d2,f0,84),
	HX_("RUN_CODE_FUNCTION_NAME",14,aa,a9,ea),
	HX_("CONDITION_PATTERN_PARAMETER_NAME",f4,59,90,be),
	HX_("CONDITION_BODY_PARAMETER_NAME",3a,7c,31,f4),
	HX_("CONDITION__FOR_LOOP",15,8f,a3,67),
	HX_("CONDITION__WHILE_LOOP",2d,22,5d,92),
	HX_("CONDITION__IF",f8,cd,89,68),
	HX_("CONDITION__ELSE",94,37,73,f6),
	HX_("CONDITION__WHENEVER",33,1f,d8,0f),
	HX_("CONDITION__AFTER",c1,92,cc,5c),
	HX_("TYPE_UNKNOWN",a5,55,81,ed),
	HX_("RECOGNIZED_SIGNS",cd,67,e6,59),
	HX_("PROPERTY_ACCESS_SIGN",ce,f1,0c,67),
	HX_("EQUALS_SIGN",7d,55,9d,95),
	HX_("NOT_EQUALS_SIGN",f1,98,f7,56),
	HX_("LARGER_SIGN",65,9c,f3,6b),
	HX_("SMALLER_SIGN",c8,56,36,6a),
	HX_("LARGER_EQUALS_SIGN",55,66,d0,a0),
	HX_("SMALLER_EQUALS_SIGN",52,0e,3b,94),
	HX_("XOR_SIGN",c1,ea,df,31),
	HX_("OR_SIGN",19,b0,88,88),
	HX_("AND_SIGN",05,26,c3,4b),
	HX_("NOT_SIGN",49,2e,9e,c2),
	HX_("ADD_SIGN",7b,82,ec,ab),
	HX_("SUBTRACT_SIGN",88,86,1f,3d),
	HX_("MULTIPLY_SIGN",78,bf,ce,08),
	HX_("DIVIDE_SIGN",03,62,45,c9),
	HX_("MOD_SIGN",3a,f6,b5,23),
	HX_("POW_SIGN",a4,27,15,68),
	HX_("FACTORIAL_SIGN",f7,bd,42,83),
	HX_("SQRT_SIGN",3c,f4,3a,4f),
	HX_("NEGATE_SIGN",1a,67,6a,44),
	HX_("POSITIVE_SIGN",c3,3e,27,b3),
	HX_("STDLIB__FLOAT_isWhole",88,e8,98,c0),
	HX_("STDLIB__STRING_length",72,be,1d,37),
	HX_("STDLIB__STRING_toLowerCase",4a,07,50,ac),
	HX_("STDLIB__STRING_toUpperCase",2b,eb,e8,2c),
	HX_("STDLIB__STRING_trim",6e,0b,38,5c),
	HX_("STDLIB__STRING_substring",45,48,db,72),
	HX_("STDLIB__STRING_charAt",f5,a2,8b,4f),
	HX_("STDLIB__STRING_split",ce,36,1b,c0),
	HX_("STDLIB__STRING_replace",28,79,76,26),
	HX_("STDLIB__STRING_remove",d0,c5,9e,9c),
	HX_("STDLIB__STRING_contains",ab,fe,97,95),
	HX_("STDLIB__STRING_indexOf",bd,79,0d,5c),
	HX_("STDLIB__STRING_lastIndexOf",07,b8,56,89),
	HX_("STDLIB__STRING_startsWith",03,a0,c7,5e),
	HX_("STDLIB__STRING_endsWith",ea,1e,d3,44),
	HX_("STDLIB__STRING_fromCharCode",39,15,93,b6),
	HX_("STDLIB__ARRAY_length",4e,cf,3c,04),
	HX_("STDLIB__ARRAY_elementType",2e,e8,30,d3),
	HX_("STDLIB__ARRAY_get",2e,35,da,e2),
	HX_("STDLIB__ARRAY_set",3a,50,e3,e2),
	HX_("STDLIB__MEMORY_allocate",19,0f,6a,ca),
	HX_("STDLIB__MEMORY_free",08,7b,9d,1a),
	HX_("STDLIB__MEMORY_read",b2,29,82,22),
	HX_("STDLIB__MEMORY_write",03,1f,01,f9),
	HX_("STDLIB__MEMORY_size",1d,7f,2e,23),
	HX_("STDLIB__MEMORY_maxSize",a9,7c,17,34),
	HX_("FOR_LOOP_FROM",4f,6c,13,f9),
	HX_("FOR_LOOP_TO",20,55,3a,ff),
	HX_("FOR_LOOP_JUMP",d3,8b,ba,fb),
	HX_("TYPE_CAST_FUNCTION_PREFIX",3e,5f,ed,f6),
	HX_("INSTANTIATE_FUNCTION_NAME",5d,40,6a,b0),
	::String(null()) };

static void KeywordConfig_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(KeywordConfig_obj::defaultConfig,"defaultConfig");
	HX_MARK_MEMBER_NAME(KeywordConfig_obj::recognizedOperators,"recognizedOperators");
	HX_MARK_MEMBER_NAME(KeywordConfig_obj::whiteSpacePrefixedOperators,"whiteSpacePrefixedOperators");
	HX_MARK_MEMBER_NAME(KeywordConfig_obj::whiteSpaceSuffixedOperators,"whiteSpaceSuffixedOperators");
};

#ifdef HXCPP_VISIT_ALLOCS
static void KeywordConfig_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(KeywordConfig_obj::defaultConfig,"defaultConfig");
	HX_VISIT_MEMBER_NAME(KeywordConfig_obj::recognizedOperators,"recognizedOperators");
	HX_VISIT_MEMBER_NAME(KeywordConfig_obj::whiteSpacePrefixedOperators,"whiteSpacePrefixedOperators");
	HX_VISIT_MEMBER_NAME(KeywordConfig_obj::whiteSpaceSuffixedOperators,"whiteSpaceSuffixedOperators");
};

#endif

::hx::Class KeywordConfig_obj::__mClass;

static ::String KeywordConfig_obj_sStaticFields[] = {
	HX_("defaultConfig",63,2a,4b,c2),
	HX_("recognizedOperators",d9,36,40,43),
	HX_("whiteSpacePrefixedOperators",81,dd,9f,8d),
	HX_("whiteSpaceSuffixedOperators",a2,6e,07,01),
	::String(null())
};

void KeywordConfig_obj::__register()
{
	KeywordConfig_obj _hx_dummy;
	KeywordConfig_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("little.KeywordConfig",f3,78,e8,90);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &KeywordConfig_obj::__GetStatic;
	__mClass->mSetStaticField = &KeywordConfig_obj::__SetStatic;
	__mClass->mMarkFunc = KeywordConfig_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(KeywordConfig_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(KeywordConfig_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< KeywordConfig_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = KeywordConfig_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = KeywordConfig_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = KeywordConfig_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void KeywordConfig_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_affab903f7db177c_17_boot)
HXDLIN(  17)		defaultConfig =  ::little::KeywordConfig_obj::__alloc( HX_CTX ,null(),null());
            	}
{
            	HX_STACKFRAME(&_hx_pos_affab903f7db177c_26_boot)
HXDLIN(  26)		recognizedOperators = ::Array_obj< ::String >::fromData( _hx_array_data_90e878f3_6,31);
            	}
{
            	HX_STACKFRAME(&_hx_pos_affab903f7db177c_32_boot)
HXDLIN(  32)		whiteSpacePrefixedOperators = ::Array_obj< ::String >::fromData( _hx_array_data_90e878f3_8,14);
            	}
{
            	HX_STACKFRAME(&_hx_pos_affab903f7db177c_38_boot)
HXDLIN(  38)		whiteSpaceSuffixedOperators = ::Array_obj< ::String >::fromData( _hx_array_data_90e878f3_10,14);
            	}
}

} // end namespace little
