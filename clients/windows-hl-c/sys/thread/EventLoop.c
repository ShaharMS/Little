// Generated by HLC 4.3.4 (HL v5)
#define HLC_BOOT
#include <hlc.h>
#include <sys/thread/EventLoop.h>
#include <hl/natives.h>
extern hl_type t$sys_thread__EventLoop_RegularEvent;
hl__types__ArrayObj hl_types_ArrayObj_alloc(varray*);
extern hl_type t$fun_7b48b4f;
extern hl_type t$_f64;
bool sys_thread_Lock_wait(sys__thread__Lock,vdynamic*);
void hl_types_ArrayObj___expand(hl__types__ArrayObj,int);
extern hl_type t$_dyn;
double haxe_MainLoop_tick(void);
bool haxe_MainLoop_hasEvents(void);
double Math_max(double,double);
extern hl_type t$sys_thread_Lock;
void sys_thread_Lock_new(sys__thread__Lock);
extern hl_type t$hl_types_ArrayObj;
void hl_types_ArrayObj_new(hl__types__ArrayObj);
hl_mutex* sys_thread__Mutex_Mutex_Impl___new(void);
extern sys__thread__$EventLoop g$_sys_thread_EventLoop;

void sys_thread_EventLoop_loop(sys__thread__EventLoop r0) {
	hl__types__ArrayObj r1, r6, r9, r18, r27, r28;
	hl_type *r3;
	bool r7, r34, r37;
	sys__thread___EventLoop__RegularEvent r15, r16, r21;
	sys__thread__Lock r12;
	hl_mutex *r11;
	vclosure *r26, *r29, *r30;
	double r8, r10, r13, r17, r35, r36;
	vdynamic *r14, *r25;
	int r4, r19, r20, r22, r23, r24, r31, r32, r33;
	varray *r2;
	r3 = &t$sys_thread__EventLoop_RegularEvent;
	r4 = 0;
	r2 = hl_alloc_array(r3,r4);
	r1 = hl_types_ArrayObj_alloc(r2);
	r3 = &t$fun_7b48b4f;
	r4 = 0;
	r2 = hl_alloc_array(r3,r4);
	r6 = hl_types_ArrayObj_alloc(r2);
	label$93e7ec3_1_8:
	r7 = true;
	if( !r7 ) goto label$93e7ec3_1_210;
	r8 = hl_sys_time();
	r9 = r1;
	r4 = 0;
	r10 = -1.;
	r11 = r0->mutex;
	hl_mutex_acquire(r11);
	label$93e7ec3_1_17:
	r12 = r0->waitLock;
	if( r12 == NULL ) hl_null_access();
	r13 = 0.;
	r14 = hl_alloc_dynamic(&t$_f64);
	r14->v.d = r13;
	r7 = sys_thread_Lock_wait(r12,r14);
	if( !r7 ) goto label$93e7ec3_1_25;
	goto label$93e7ec3_1_17;
	label$93e7ec3_1_25:
	r15 = r0->regularEvents;
	label$93e7ec3_1_26:
	if( !r15 ) goto label$93e7ec3_1_55;
	if( r15 == NULL ) hl_null_access();
	r13 = r15->nextRunTime;
	if( !(r8 >= r13) ) goto label$93e7ec3_1_46;
	if( r9 == NULL ) hl_null_access();
	r19 = r4;
	++r4;
	r20 = r9->length;
	if( ((unsigned)r19) < ((unsigned)r20) ) goto label$93e7ec3_1_37;
	hl_types_ArrayObj___expand(r9,r19);
	label$93e7ec3_1_37:
	r2 = r9->array;
	((sys__thread___EventLoop__RegularEvent*)(r2 + 1))[r19] = r15;
	r13 = r15->nextRunTime;
	r17 = r15->interval;
	r13 = r13 + r17;
	r15->nextRunTime = r13;
	r13 = -2.;
	r10 = r13;
	goto label$93e7ec3_1_52;
	label$93e7ec3_1_46:
	r17 = -1.;
	if( r10 == r17 ) goto label$93e7ec3_1_50;
	r13 = r15->nextRunTime;
	if( !(r13 < r10) ) goto label$93e7ec3_1_52;
	label$93e7ec3_1_50:
	r13 = r15->nextRunTime;
	r10 = r13;
	label$93e7ec3_1_52:
	r16 = r15->next;
	r15 = r16;
	goto label$93e7ec3_1_26;
	label$93e7ec3_1_55:
	r11 = r0->mutex;
	hl_mutex_release(r11);
	r19 = 0;
	r20 = r4;
	label$93e7ec3_1_59:
	if( r19 >= r20 ) goto label$93e7ec3_1_98;
	r22 = r19;
	++r19;
	if( r9 == NULL ) hl_null_access();
	r24 = r9->length;
	if( ((unsigned)r22) < ((unsigned)r24) ) goto label$93e7ec3_1_68;
	r16 = NULL;
	goto label$93e7ec3_1_74;
	label$93e7ec3_1_68:
	r2 = r9->array;
	r25 = ((vdynamic**)(r2 + 1))[r22];
	r16 = (sys__thread___EventLoop__RegularEvent)r25;
	r21 = (sys__thread___EventLoop__RegularEvent)hl_dyn_castp(&r25,&t$_dyn,&t$sys_thread__EventLoop_RegularEvent);
	if( r16 == r21 ) goto label$93e7ec3_1_74;
	hl_assert();
	label$93e7ec3_1_74:
	if( r16 == NULL ) hl_null_access();
	r7 = r16->cancelled;
	if( r7 ) goto label$93e7ec3_1_91;
	r24 = r9->length;
	if( ((unsigned)r22) < ((unsigned)r24) ) goto label$93e7ec3_1_81;
	r16 = NULL;
	goto label$93e7ec3_1_87;
	label$93e7ec3_1_81:
	r2 = r9->array;
	r25 = ((vdynamic**)(r2 + 1))[r22];
	r16 = (sys__thread___EventLoop__RegularEvent)r25;
	r21 = (sys__thread___EventLoop__RegularEvent)hl_dyn_castp(&r25,&t$_dyn,&t$sys_thread__EventLoop_RegularEvent);
	if( r16 == r21 ) goto label$93e7ec3_1_87;
	hl_assert();
	label$93e7ec3_1_87:
	if( r16 == NULL ) hl_null_access();
	r26 = r16->run;
	if( r26 == NULL ) hl_null_access();
	r26->hasValue ? ((void (*)(vdynamic*))r26->fun)((vdynamic*)r26->value) : ((void (*)(void))r26->fun)();
	label$93e7ec3_1_91:
	r16 = NULL;
	r24 = r9->length;
	if( ((unsigned)r22) < ((unsigned)r24) ) goto label$93e7ec3_1_95;
	hl_types_ArrayObj___expand(r9,r22);
	label$93e7ec3_1_95:
	r2 = r9->array;
	((sys__thread___EventLoop__RegularEvent*)(r2 + 1))[r22] = r16;
	goto label$93e7ec3_1_59;
	label$93e7ec3_1_98:
	r22 = 0;
	r4 = r22;
	r18 = r6;
	r11 = r0->mutex;
	hl_mutex_acquire(r11);
	r22 = 0;
	r27 = r0->oneTimeEvents;
	label$93e7ec3_1_105:
	if( r27 == NULL ) hl_null_access();
	r24 = r27->length;
	if( r22 >= r24 ) goto label$93e7ec3_1_140;
	r24 = r27->length;
	if( ((unsigned)r22) < ((unsigned)r24) ) goto label$93e7ec3_1_113;
	r26 = NULL;
	goto label$93e7ec3_1_119;
	label$93e7ec3_1_113:
	r2 = r27->array;
	r25 = ((vdynamic**)(r2 + 1))[r22];
	r26 = (vclosure*)r25;
	r29 = (vclosure*)hl_dyn_castp(&r25,&t$_dyn,&t$fun_7b48b4f);
	{ int i = hl_dyn_compare((vdynamic*)r26,(vdynamic*)r29); if( i == 0 ) goto label$93e7ec3_1_119; };
	hl_assert();
	label$93e7ec3_1_119:
	r23 = r22;
	++r22;
	if( r26 ) goto label$93e7ec3_1_123;
	goto label$93e7ec3_1_140;
	label$93e7ec3_1_123:
	if( r18 == NULL ) hl_null_access();
	r31 = r4;
	++r4;
	r32 = r18->length;
	if( ((unsigned)r31) < ((unsigned)r32) ) goto label$93e7ec3_1_129;
	hl_types_ArrayObj___expand(r18,r31);
	label$93e7ec3_1_129:
	r2 = r18->array;
	((vclosure**)(r2 + 1))[r31] = r26;
	r28 = r0->oneTimeEvents;
	if( r28 == NULL ) hl_null_access();
	r30 = NULL;
	r32 = r28->length;
	if( ((unsigned)r23) < ((unsigned)r32) ) goto label$93e7ec3_1_137;
	hl_types_ArrayObj___expand(r28,r23);
	label$93e7ec3_1_137:
	r2 = r28->array;
	((vclosure**)(r2 + 1))[r23] = r30;
	goto label$93e7ec3_1_105;
	label$93e7ec3_1_140:
	r23 = 0;
	r0->oneTimeEventsIdx = r23;
	r23 = r0->promisedEventsCount;
	r24 = 0;
	if( r23 > r24 ) goto label$93e7ec3_1_147;
	r7 = false;
	goto label$93e7ec3_1_148;
	label$93e7ec3_1_147:
	r7 = true;
	label$93e7ec3_1_148:
	r11 = r0->mutex;
	hl_mutex_release(r11);
	r23 = 0;
	r24 = r4;
	label$93e7ec3_1_152:
	if( r23 >= r24 ) goto label$93e7ec3_1_176;
	r31 = r23;
	++r23;
	if( r18 == NULL ) hl_null_access();
	r33 = r18->length;
	if( ((unsigned)r31) < ((unsigned)r33) ) goto label$93e7ec3_1_161;
	r26 = NULL;
	goto label$93e7ec3_1_167;
	label$93e7ec3_1_161:
	r2 = r18->array;
	r25 = ((vdynamic**)(r2 + 1))[r31];
	r26 = (vclosure*)r25;
	r29 = (vclosure*)hl_dyn_castp(&r25,&t$_dyn,&t$fun_7b48b4f);
	{ int i = hl_dyn_compare((vdynamic*)r26,(vdynamic*)r29); if( i == 0 ) goto label$93e7ec3_1_167; };
	hl_assert();
	label$93e7ec3_1_167:
	if( r26 == NULL ) hl_null_access();
	r26->hasValue ? ((void (*)(vdynamic*))r26->fun)((vdynamic*)r26->value) : ((void (*)(void))r26->fun)();
	r26 = NULL;
	r33 = r18->length;
	if( ((unsigned)r31) < ((unsigned)r33) ) goto label$93e7ec3_1_173;
	hl_types_ArrayObj___expand(r18,r31);
	label$93e7ec3_1_173:
	r2 = r18->array;
	((vclosure**)(r2 + 1))[r31] = r26;
	goto label$93e7ec3_1_152;
	label$93e7ec3_1_176:
	r34 = r0->isMainThread;
	if( !r34 ) goto label$93e7ec3_1_184;
	r13 = haxe_MainLoop_tick();
	r34 = haxe_MainLoop_hasEvents();
	if( !r34 ) goto label$93e7ec3_1_184;
	++r4;
	if( !(r13 < r10) ) goto label$93e7ec3_1_184;
	r10 = r13;
	label$93e7ec3_1_184:
	r32 = 0;
	if( r32 >= r4 ) goto label$93e7ec3_1_188;
	r13 = -2.;
	r10 = r13;
	label$93e7ec3_1_188:
	r35 = -2.;
	if( r35 == r10 ) goto label$93e7ec3_1_201;
	r35 = -1.;
	if( r35 == r10 ) goto label$93e7ec3_1_202;
	r36 = hl_sys_time();
	r35 = r10 - r36;
	r12 = r0->waitLock;
	if( r12 == NULL ) hl_null_access();
	r36 = 0.;
	r36 = Math_max(r36,r35);
	r14 = hl_alloc_dynamic(&t$_f64);
	r14->v.d = r36;
	r37 = sys_thread_Lock_wait(r12,r14);
	goto label$93e7ec3_1_209;
	label$93e7ec3_1_201:
	goto label$93e7ec3_1_209;
	label$93e7ec3_1_202:
	if( !r7 ) goto label$93e7ec3_1_208;
	r12 = r0->waitLock;
	if( r12 == NULL ) hl_null_access();
	r14 = NULL;
	r37 = sys_thread_Lock_wait(r12,r14);
	goto label$93e7ec3_1_209;
	label$93e7ec3_1_208:
	goto label$93e7ec3_1_210;
	label$93e7ec3_1_209:
	goto label$93e7ec3_1_8;
	label$93e7ec3_1_210:
	return;
}

void sys_thread_EventLoop_new(sys__thread__EventLoop r0) {
	hl__types__ArrayObj r4;
	bool r6;
	sys__thread__$EventLoop r7;
	sys__thread__Lock r2;
	hl_mutex *r5;
	int r1;
	r1 = 0;
	r0->promisedEventsCount = r1;
	r2 = (sys__thread__Lock)hl_alloc_obj(&t$sys_thread_Lock);
	sys_thread_Lock_new(r2);
	r0->waitLock = r2;
	r1 = 0;
	r0->oneTimeEventsIdx = r1;
	r4 = (hl__types__ArrayObj)hl_alloc_obj(&t$hl_types_ArrayObj);
	hl_types_ArrayObj_new(r4);
	r0->oneTimeEvents = r4;
	r5 = sys_thread__Mutex_Mutex_Impl___new();
	r0->mutex = r5;
	r7 = (sys__thread__$EventLoop)g$_sys_thread_EventLoop;
	r6 = r7->CREATED;
	r6 = !r6;
	r0->isMainThread = r6;
	r6 = true;
	r7 = (sys__thread__$EventLoop)g$_sys_thread_EventLoop;
	r7->CREATED = r6;
	return;
}

