// Generated by HLC 4.3.4 (HL v5)
#define HLC_BOOT
#include <hlc.h>


void hl_init_hashes() {
	hl_hash((vbyte*)USTR("__type__"));
	hl_hash((vbyte*)USTR("__meta__"));
	hl_hash((vbyte*)USTR("__implementedBy__"));
	hl_hash((vbyte*)USTR("check"));
	hl_hash((vbyte*)USTR("__name__"));
	hl_hash((vbyte*)USTR("__constructor__"));
	hl_hash((vbyte*)USTR("bytes"));
	hl_hash((vbyte*)USTR("length"));
	hl_hash((vbyte*)USTR("toUpperCase"));
	hl_hash((vbyte*)USTR("toLowerCase"));
	hl_hash((vbyte*)USTR("charAt"));
	hl_hash((vbyte*)USTR("charCodeAt"));
	hl_hash((vbyte*)USTR("findChar"));
	hl_hash((vbyte*)USTR("indexOf"));
	hl_hash((vbyte*)USTR("lastIndexOf"));
	hl_hash((vbyte*)USTR("split"));
	hl_hash((vbyte*)USTR("substr"));
	hl_hash((vbyte*)USTR("substring"));
	hl_hash((vbyte*)USTR("toString"));
	hl_hash((vbyte*)USTR("toUtf8"));
	hl_hash((vbyte*)USTR("__string"));
	hl_hash((vbyte*)USTR("__compare"));
	hl_hash((vbyte*)USTR("fromCharCode"));
	hl_hash((vbyte*)USTR("__alloc__"));
	hl_hash((vbyte*)USTR("call_toString"));
	hl_hash((vbyte*)USTR("fromUCS2"));
	hl_hash((vbyte*)USTR("fromUTF8"));
	hl_hash((vbyte*)USTR("__add__"));
	hl_hash((vbyte*)USTR("fromTime"));
	hl_hash((vbyte*)USTR("fromString"));
	hl_hash((vbyte*)USTR("t"));
	hl_hash((vbyte*)USTR("getTime"));
	hl_hash((vbyte*)USTR("allocI32"));
	hl_hash((vbyte*)USTR("allocUI16"));
	hl_hash((vbyte*)USTR("allocF32"));
	hl_hash((vbyte*)USTR("allocF64"));
	hl_hash((vbyte*)USTR("getDyn"));
	hl_hash((vbyte*)USTR("setDyn"));
	hl_hash((vbyte*)USTR("blit"));
	hl_hash((vbyte*)USTR("pushDyn"));
	hl_hash((vbyte*)USTR("popDyn"));
	hl_hash((vbyte*)USTR("shiftDyn"));
	hl_hash((vbyte*)USTR("unshiftDyn"));
	hl_hash((vbyte*)USTR("insertDyn"));
	hl_hash((vbyte*)USTR("containsDyn"));
	hl_hash((vbyte*)USTR("removeDyn"));
	hl_hash((vbyte*)USTR("sortDyn"));
	hl_hash((vbyte*)USTR("slice"));
	hl_hash((vbyte*)USTR("splice"));
	hl_hash((vbyte*)USTR("join"));
	hl_hash((vbyte*)USTR("reverse"));
	hl_hash((vbyte*)USTR("resize"));
	hl_hash((vbyte*)USTR("__cast"));
	hl_hash((vbyte*)USTR("isArrayObj"));
	hl_hash((vbyte*)USTR("size"));
	hl_hash((vbyte*)USTR("concat"));
	hl_hash((vbyte*)USTR("pop"));
	hl_hash((vbyte*)USTR("push"));
	hl_hash((vbyte*)USTR("shift"));
	hl_hash((vbyte*)USTR("sort"));
	hl_hash((vbyte*)USTR("unshift"));
	hl_hash((vbyte*)USTR("insert"));
	hl_hash((vbyte*)USTR("contains"));
	hl_hash((vbyte*)USTR("remove"));
	hl_hash((vbyte*)USTR("copy"));
	hl_hash((vbyte*)USTR("iterator"));
	hl_hash((vbyte*)USTR("keyValueIterator"));
	hl_hash((vbyte*)USTR("map"));
	hl_hash((vbyte*)USTR("filter"));
	hl_hash((vbyte*)USTR("__expand"));
	hl_hash((vbyte*)USTR("caught"));
	hl_hash((vbyte*)USTR("__exceptionMessage"));
	hl_hash((vbyte*)USTR("__exceptionStack"));
	hl_hash((vbyte*)USTR("__nativeStack"));
	hl_hash((vbyte*)USTR("__skipStack"));
	hl_hash((vbyte*)USTR("__nativeException"));
	hl_hash((vbyte*)USTR("__previousException"));
	hl_hash((vbyte*)USTR("details"));
	hl_hash((vbyte*)USTR("__shiftStack"));
	hl_hash((vbyte*)USTR("__unshiftStack"));
	hl_hash((vbyte*)USTR("get_message"));
	hl_hash((vbyte*)USTR("get_previous"));
	hl_hash((vbyte*)USTR("get_stack"));
	hl_hash((vbyte*)USTR("array"));
	hl_hash((vbyte*)USTR("__ename__"));
	hl_hash((vbyte*)USTR("__emap__"));
	hl_hash((vbyte*)USTR("__constructs__"));
	hl_hash((vbyte*)USTR("__evalues__"));
	hl_hash((vbyte*)USTR("alloc"));
	hl_hash((vbyte*)USTR("ofString"));
	hl_hash((vbyte*)USTR("b"));
	hl_hash((vbyte*)USTR("get"));
	hl_hash((vbyte*)USTR("set"));
	hl_hash((vbyte*)USTR("fill"));
	hl_hash((vbyte*)USTR("sub"));
	hl_hash((vbyte*)USTR("getDouble"));
	hl_hash((vbyte*)USTR("setDouble"));
	hl_hash((vbyte*)USTR("getInt32"));
	hl_hash((vbyte*)USTR("setInt32"));
	hl_hash((vbyte*)USTR("getString"));
	hl_hash((vbyte*)USTR("KEY_SIZE"));
	hl_hash((vbyte*)USTR("__noTypeCreation"));
	hl_hash((vbyte*)USTR("combosHas"));
	hl_hash((vbyte*)USTR("containsCombo"));
	hl_hash((vbyte*)USTR("defaultConfig"));
	hl_hash((vbyte*)USTR("recognizedOperators"));
	hl_hash((vbyte*)USTR("VARIABLE_DECLARATION"));
	hl_hash((vbyte*)USTR("FUNCTION_DECLARATION"));
	hl_hash((vbyte*)USTR("TYPE_DECL_OR_CAST"));
	hl_hash((vbyte*)USTR("FUNCTION_RETURN"));
	hl_hash((vbyte*)USTR("NULL_VALUE"));
	hl_hash((vbyte*)USTR("TRUE_VALUE"));
	hl_hash((vbyte*)USTR("FALSE_VALUE"));
	hl_hash((vbyte*)USTR("TYPE_DYNAMIC"));
	hl_hash((vbyte*)USTR("TYPE_INT"));
	hl_hash((vbyte*)USTR("TYPE_FLOAT"));
	hl_hash((vbyte*)USTR("TYPE_BOOLEAN"));
	hl_hash((vbyte*)USTR("TYPE_STRING"));
	hl_hash((vbyte*)USTR("TYPE_OBJECT"));
	hl_hash((vbyte*)USTR("TYPE_MEMORY"));
	hl_hash((vbyte*)USTR("TYPE_ARRAY"));
	hl_hash((vbyte*)USTR("TYPE_FUNCTION"));
	hl_hash((vbyte*)USTR("TYPE_CONDITION"));
	hl_hash((vbyte*)USTR("TYPE_MODULE"));
	hl_hash((vbyte*)USTR("TYPE_SIGN"));
	hl_hash((vbyte*)USTR("MAIN_MODULE_NAME"));
	hl_hash((vbyte*)USTR("OBJECT_TYPE_PROPERTY_NAME"));
	hl_hash((vbyte*)USTR("OBJECT_ADDRESS_PROPERTY_NAME"));
	hl_hash((vbyte*)USTR("PRINT_FUNCTION_NAME"));
	hl_hash((vbyte*)USTR("RAISE_ERROR_FUNCTION_NAME"));
	hl_hash((vbyte*)USTR("READ_FUNCTION_NAME"));
	hl_hash((vbyte*)USTR("RUN_CODE_FUNCTION_NAME"));
	hl_hash((vbyte*)USTR("CONDITION_PATTERN_PARAMETER_NAME"));
	hl_hash((vbyte*)USTR("CONDITION_BODY_PARAMETER_NAME"));
	hl_hash((vbyte*)USTR("CONDITION__FOR_LOOP"));
	hl_hash((vbyte*)USTR("CONDITION__WHILE_LOOP"));
	hl_hash((vbyte*)USTR("CONDITION__IF"));
	hl_hash((vbyte*)USTR("CONDITION__ELSE"));
	hl_hash((vbyte*)USTR("CONDITION__WHENEVER"));
	hl_hash((vbyte*)USTR("CONDITION__AFTER"));
	hl_hash((vbyte*)USTR("TYPE_UNKNOWN"));
	hl_hash((vbyte*)USTR("RECOGNIZED_SIGNS"));
	hl_hash((vbyte*)USTR("PROPERTY_ACCESS_SIGN"));
	hl_hash((vbyte*)USTR("EQUALS_SIGN"));
	hl_hash((vbyte*)USTR("NOT_EQUALS_SIGN"));
	hl_hash((vbyte*)USTR("LARGER_SIGN"));
	hl_hash((vbyte*)USTR("SMALLER_SIGN"));
	hl_hash((vbyte*)USTR("LARGER_EQUALS_SIGN"));
	hl_hash((vbyte*)USTR("SMALLER_EQUALS_SIGN"));
	hl_hash((vbyte*)USTR("XOR_SIGN"));
	hl_hash((vbyte*)USTR("OR_SIGN"));
	hl_hash((vbyte*)USTR("AND_SIGN"));
	hl_hash((vbyte*)USTR("NOT_SIGN"));
	hl_hash((vbyte*)USTR("ADD_SIGN"));
	hl_hash((vbyte*)USTR("SUBTRACT_SIGN"));
	hl_hash((vbyte*)USTR("MULTIPLY_SIGN"));
	hl_hash((vbyte*)USTR("DIVIDE_SIGN"));
	hl_hash((vbyte*)USTR("MOD_SIGN"));
	hl_hash((vbyte*)USTR("POW_SIGN"));
	hl_hash((vbyte*)USTR("FACTORIAL_SIGN"));
	hl_hash((vbyte*)USTR("SQRT_SIGN"));
	hl_hash((vbyte*)USTR("NEGATE_SIGN"));
	hl_hash((vbyte*)USTR("POSITIVE_SIGN"));
	hl_hash((vbyte*)USTR("STDLIB__FLOAT_isWhole"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_length"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_toLowerCase"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_toUpperCase"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_trim"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_substring"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_charAt"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_split"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_replace"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_remove"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_contains"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_indexOf"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_lastIndexOf"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_startsWith"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_endsWith"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_fromCharCode"));
	hl_hash((vbyte*)USTR("STDLIB__ARRAY_length"));
	hl_hash((vbyte*)USTR("STDLIB__ARRAY_elementType"));
	hl_hash((vbyte*)USTR("STDLIB__ARRAY_get"));
	hl_hash((vbyte*)USTR("STDLIB__ARRAY_set"));
	hl_hash((vbyte*)USTR("STDLIB__MEMORY_allocate"));
	hl_hash((vbyte*)USTR("STDLIB__MEMORY_free"));
	hl_hash((vbyte*)USTR("STDLIB__MEMORY_read"));
	hl_hash((vbyte*)USTR("STDLIB__MEMORY_write"));
	hl_hash((vbyte*)USTR("STDLIB__MEMORY_size"));
	hl_hash((vbyte*)USTR("STDLIB__MEMORY_maxSize"));
	hl_hash((vbyte*)USTR("FOR_LOOP_FROM"));
	hl_hash((vbyte*)USTR("FOR_LOOP_TO"));
	hl_hash((vbyte*)USTR("FOR_LOOP_JUMP"));
	hl_hash((vbyte*)USTR("TYPE_CAST_FUNCTION_PREFIX"));
	hl_hash((vbyte*)USTR("INSTANTIATE_FUNCTION_NAME"));
	hl_hash((vbyte*)USTR("change"));
	hl_hash((vbyte*)USTR("keywords"));
	hl_hash((vbyte*)USTR("runtime"));
	hl_hash((vbyte*)USTR("memory"));
	hl_hash((vbyte*)USTR("plugin"));
	hl_hash((vbyte*)USTR("queue"));
	hl_hash((vbyte*)USTR("debug"));
	hl_hash((vbyte*)USTR("version"));
	hl_hash((vbyte*)USTR("loadModule"));
	hl_hash((vbyte*)USTR("run"));
	hl_hash((vbyte*)USTR("compile"));
	hl_hash((vbyte*)USTR("format"));
	hl_hash((vbyte*)USTR("reset"));
	hl_hash((vbyte*)USTR("line"));
	hl_hash((vbyte*)USTR("linePart"));
	hl_hash((vbyte*)USTR("currentToken"));
	hl_hash((vbyte*)USTR("module"));
	hl_hash((vbyte*)USTR("previousToken"));
	hl_hash((vbyte*)USTR("exitCode"));
	hl_hash((vbyte*)USTR("errorThrown"));
	hl_hash((vbyte*)USTR("errorToken"));
	hl_hash((vbyte*)USTR("onLineChanged"));
	hl_hash((vbyte*)USTR("onModuleChanged"));
	hl_hash((vbyte*)USTR("onLineSplit"));
	hl_hash((vbyte*)USTR("onTokenInterpreted"));
	hl_hash((vbyte*)USTR("onErrorThrown"));
	hl_hash((vbyte*)USTR("onWarningPrinted"));
	hl_hash((vbyte*)USTR("onWriteValue"));
	hl_hash((vbyte*)USTR("onFunctionCalled"));
	hl_hash((vbyte*)USTR("onConditionCalled"));
	hl_hash((vbyte*)USTR("onFieldDeclared"));
	hl_hash((vbyte*)USTR("onTypeCast"));
	hl_hash((vbyte*)USTR("stdout"));
	hl_hash((vbyte*)USTR("callStack"));
	hl_hash((vbyte*)USTR("broadcast"));
	hl_hash((vbyte*)USTR("__broadcast"));
	hl_hash((vbyte*)USTR("throwError"));
	hl_hash((vbyte*)USTR("warn"));
	hl_hash((vbyte*)USTR("print"));
	hl_hash((vbyte*)USTR("__print"));
	hl_hash((vbyte*)USTR("h"));
	hl_hash((vbyte*)USTR(""));
	hl_hash((vbyte*)USTR("exists"));
	hl_hash((vbyte*)USTR("keys"));
	hl_hash((vbyte*)USTR("hasNext"));
	hl_hash((vbyte*)USTR("next"));
	hl_hash((vbyte*)USTR("_ks"));
	hl_hash((vbyte*)USTR("_vs"));
	hl_hash((vbyte*)USTR("get_length"));
	hl_hash((vbyte*)USTR("iremove"));
	hl_hash((vbyte*)USTR("clear"));
	hl_hash((vbyte*)USTR("has"));
	hl_hash((vbyte*)USTR("allowReinterpret"));
	hl_hash((vbyte*)USTR("__get_field"));
	hl_hash((vbyte*)USTR("output"));
	hl_hash((vbyte*)USTR("stdoutTokens"));
	hl_hash((vbyte*)USTR("storage"));
	hl_hash((vbyte*)USTR("referrer"));
	hl_hash((vbyte*)USTR("externs"));
	hl_hash((vbyte*)USTR("constants"));
	hl_hash((vbyte*)USTR("operators"));
	hl_hash((vbyte*)USTR("memoryChunkSize"));
	hl_hash((vbyte*)USTR("maxMemorySize"));
	hl_hash((vbyte*)USTR("get_currentMemorySize"));
	hl_hash((vbyte*)USTR("store"));
	hl_hash((vbyte*)USTR("retrieve"));
	hl_hash((vbyte*)USTR("valueFromType"));
	hl_hash((vbyte*)USTR("read"));
	hl_hash((vbyte*)USTR("readFrom"));
	hl_hash((vbyte*)USTR("write"));
	hl_hash((vbyte*)USTR("allocate"));
	hl_hash((vbyte*)USTR("free"));
	hl_hash((vbyte*)USTR("sizeOf"));
	hl_hash((vbyte*)USTR("getTypeInformation"));
	hl_hash((vbyte*)USTR("getTypeName"));
	hl_hash((vbyte*)USTR("parent"));
	hl_hash((vbyte*)USTR("reserved"));
	hl_hash((vbyte*)USTR("requestMemory"));
	hl_hash((vbyte*)USTR("storeByte"));
	hl_hash((vbyte*)USTR("setByte"));
	hl_hash((vbyte*)USTR("readByte"));
	hl_hash((vbyte*)USTR("freeByte"));
	hl_hash((vbyte*)USTR("storeBytes"));
	hl_hash((vbyte*)USTR("setBytes"));
	hl_hash((vbyte*)USTR("readBytes"));
	hl_hash((vbyte*)USTR("freeBytes"));
	hl_hash((vbyte*)USTR("storeArray"));
	hl_hash((vbyte*)USTR("setArray"));
	hl_hash((vbyte*)USTR("readArray"));
	hl_hash((vbyte*)USTR("freeArray"));
	hl_hash((vbyte*)USTR("storeInt16"));
	hl_hash((vbyte*)USTR("setInt16"));
	hl_hash((vbyte*)USTR("readInt16"));
	hl_hash((vbyte*)USTR("freeInt16"));
	hl_hash((vbyte*)USTR("storeUInt16"));
	hl_hash((vbyte*)USTR("setUInt16"));
	hl_hash((vbyte*)USTR("readUInt16"));
	hl_hash((vbyte*)USTR("freeUInt16"));
	hl_hash((vbyte*)USTR("storeInt32"));
	hl_hash((vbyte*)USTR("readInt32"));
	hl_hash((vbyte*)USTR("freeInt32"));
	hl_hash((vbyte*)USTR("storeUInt32"));
	hl_hash((vbyte*)USTR("setUInt32"));
	hl_hash((vbyte*)USTR("readUInt32"));
	hl_hash((vbyte*)USTR("freeUInt32"));
	hl_hash((vbyte*)USTR("storeDouble"));
	hl_hash((vbyte*)USTR("readDouble"));
	hl_hash((vbyte*)USTR("freeDouble"));
	hl_hash((vbyte*)USTR("storePointer"));
	hl_hash((vbyte*)USTR("setPointer"));
	hl_hash((vbyte*)USTR("readPointer"));
	hl_hash((vbyte*)USTR("freePointer"));
	hl_hash((vbyte*)USTR("storeString"));
	hl_hash((vbyte*)USTR("setString"));
	hl_hash((vbyte*)USTR("readString"));
	hl_hash((vbyte*)USTR("freeString"));
	hl_hash((vbyte*)USTR("storeCodeBlock"));
	hl_hash((vbyte*)USTR("setCodeBlock"));
	hl_hash((vbyte*)USTR("readCodeBlock"));
	hl_hash((vbyte*)USTR("freeCodeBlock"));
	hl_hash((vbyte*)USTR("storeCondition"));
	hl_hash((vbyte*)USTR("setCondition"));
	hl_hash((vbyte*)USTR("readCondition"));
	hl_hash((vbyte*)USTR("freeCondition"));
	hl_hash((vbyte*)USTR("storeSign"));
	hl_hash((vbyte*)USTR("setSign"));
	hl_hash((vbyte*)USTR("readSign"));
	hl_hash((vbyte*)USTR("freeSign"));
	hl_hash((vbyte*)USTR("storeStatic"));
	hl_hash((vbyte*)USTR("storeObject"));
	hl_hash((vbyte*)USTR("setObject"));
	hl_hash((vbyte*)USTR("readObject"));
	hl_hash((vbyte*)USTR("freeObject"));
	hl_hash((vbyte*)USTR("storeType"));
	hl_hash((vbyte*)USTR("setType"));
	hl_hash((vbyte*)USTR("readType"));
	hl_hash((vbyte*)USTR("freeType"));
	hl_hash((vbyte*)USTR("currentScopeStart"));
	hl_hash((vbyte*)USTR("currentScopeLength"));
	hl_hash((vbyte*)USTR("get_currentScopeStart"));
	hl_hash((vbyte*)USTR("get_currentScopeLength"));
	hl_hash((vbyte*)USTR("pushScope"));
	hl_hash((vbyte*)USTR("popScope"));
	hl_hash((vbyte*)USTR("reference"));
	hl_hash((vbyte*)USTR("dereference"));
	hl_hash((vbyte*)USTR("externToPointer"));
	hl_hash((vbyte*)USTR("pointerToExtern"));
	hl_hash((vbyte*)USTR("instanceProperties"));
	hl_hash((vbyte*)USTR("globalProperties"));
	hl_hash((vbyte*)USTR("get_pointerToExtern"));
	hl_hash((vbyte*)USTR("createPathFor"));
	hl_hash((vbyte*)USTR("createAllPathsFor"));
	hl_hash((vbyte*)USTR("hasGlobal"));
	hl_hash((vbyte*)USTR("hasInstance"));
	hl_hash((vbyte*)USTR("getGlobal"));
	hl_hash((vbyte*)USTR("getter"));
	hl_hash((vbyte*)USTR("doc"));
	hl_hash((vbyte*)USTR("type"));
	hl_hash((vbyte*)USTR("properties"));
	hl_hash((vbyte*)USTR("objectAddress"));
	hl_hash((vbyte*)USTR("objectValue"));
	hl_hash((vbyte*)USTR("capacity"));
	hl_hash((vbyte*)USTR("NULL"));
	hl_hash((vbyte*)USTR("FALSE"));
	hl_hash((vbyte*)USTR("TRUE"));
	hl_hash((vbyte*)USTR("ZERO"));
	hl_hash((vbyte*)USTR("INT"));
	hl_hash((vbyte*)USTR("FLOAT"));
	hl_hash((vbyte*)USTR("BOOL"));
	hl_hash((vbyte*)USTR("DYNAMIC"));
	hl_hash((vbyte*)USTR("TYPE"));
	hl_hash((vbyte*)USTR("UNKNOWN"));
	hl_hash((vbyte*)USTR("ERROR"));
	hl_hash((vbyte*)USTR("EXTERN"));
	hl_hash((vbyte*)USTR("EMPTY_STRING"));
	hl_hash((vbyte*)USTR("getFromPointer"));
	hl_hash((vbyte*)USTR("hasPointer"));
	hl_hash((vbyte*)USTR("hasType"));
	hl_hash((vbyte*)USTR("getType"));
	hl_hash((vbyte*)USTR("priority"));
	hl_hash((vbyte*)USTR("standard"));
	hl_hash((vbyte*)USTR("rhsOnly"));
	hl_hash((vbyte*)USTR("lhsOnly"));
	hl_hash((vbyte*)USTR("setPriority"));
	hl_hash((vbyte*)USTR("getPriority"));
	hl_hash((vbyte*)USTR("iterateByPriority"));
	hl_hash((vbyte*)USTR("add"));
	hl_hash((vbyte*)USTR("signPosToObject"));
	hl_hash((vbyte*)USTR("registerType"));
	hl_hash((vbyte*)USTR("registerVariable"));
	hl_hash((vbyte*)USTR("registerFunction"));
	hl_hash((vbyte*)USTR("registerCondition"));
	hl_hash((vbyte*)USTR("registerInstanceVariable"));
	hl_hash((vbyte*)USTR("registerInstanceFunction"));
	hl_hash((vbyte*)USTR("registerOperator"));
	hl_hash((vbyte*)USTR("first"));
	hl_hash((vbyte*)USTR("dequeue"));
	hl_hash((vbyte*)USTR("enqueue"));
	hl_hash((vbyte*)USTR("get_last"));
	hl_hash((vbyte*)USTR("set_last"));
	hl_hash((vbyte*)USTR("previous"));
	hl_hash((vbyte*)USTR("value"));
	hl_hash((vbyte*)USTR("getValue"));
	hl_hash((vbyte*)USTR("additionalParsingLevels"));
	hl_hash((vbyte*)USTR("parse"));
	hl_hash((vbyte*)USTR("convert"));
	hl_hash((vbyte*)USTR("mergeBlocks"));
	hl_hash((vbyte*)USTR("mergeExpressions"));
	hl_hash((vbyte*)USTR("mergePropertyOperations"));
	hl_hash((vbyte*)USTR("mergeTypeDecls"));
	hl_hash((vbyte*)USTR("mergeComplexStructures"));
	hl_hash((vbyte*)USTR("mergeCalls"));
	hl_hash((vbyte*)USTR("mergeWrites"));
	hl_hash((vbyte*)USTR("mergeValuesWithTypeDecls"));
	hl_hash((vbyte*)USTR("mergeNonBlockBodies"));
	hl_hash((vbyte*)USTR("mergeElses"));
	hl_hash((vbyte*)USTR("get_line"));
	hl_hash((vbyte*)USTR("set_line"));
	hl_hash((vbyte*)USTR("get_module"));
	hl_hash((vbyte*)USTR("set_module"));
	hl_hash((vbyte*)USTR("setLine"));
	hl_hash((vbyte*)USTR("nextPart"));
	hl_hash((vbyte*)USTR("resetLines"));
	hl_hash((vbyte*)USTR("rnd"));
	hl_hash((vbyte*)USTR("toStringDepth"));
	hl_hash((vbyte*)USTR("isOfType"));
	hl_hash((vbyte*)USTR("string"));
	hl_hash((vbyte*)USTR("parseInt"));
	hl_hash((vbyte*)USTR("parseFloat"));
	hl_hash((vbyte*)USTR("random"));
	hl_hash((vbyte*)USTR("min"));
	hl_hash((vbyte*)USTR("max"));
	hl_hash((vbyte*)USTR("PI"));
	hl_hash((vbyte*)USTR("NaN"));
	hl_hash((vbyte*)USTR("POSITIVE_INFINITY"));
	hl_hash((vbyte*)USTR("NEGATIVE_INFINITY"));
	hl_hash((vbyte*)USTR("winMetaCharacters"));
	hl_hash((vbyte*)USTR("quoteUnixArg"));
	hl_hash((vbyte*)USTR("quoteWinArg"));
	hl_hash((vbyte*)USTR("utf8Path"));
	hl_hash((vbyte*)USTR("getPath"));
	hl_hash((vbyte*)USTR("println"));
	hl_hash((vbyte*)USTR("stdin"));
	hl_hash((vbyte*)USTR("systemName"));
	hl_hash((vbyte*)USTR("command"));
	hl_hash((vbyte*)USTR("readLine"));
	hl_hash((vbyte*)USTR("CREATED"));
	hl_hash((vbyte*)USTR("mainThread"));
	hl_hash((vbyte*)USTR("threads"));
	hl_hash((vbyte*)USTR("threadsMutex"));
	hl_hash((vbyte*)USTR("current"));
	hl_hash((vbyte*)USTR("create"));
	hl_hash((vbyte*)USTR("dropThread"));
	hl_hash((vbyte*)USTR("events"));
	hl_hash((vbyte*)USTR("handle"));
	hl_hash((vbyte*)USTR("mutex"));
	hl_hash((vbyte*)USTR("oneTimeEvents"));
	hl_hash((vbyte*)USTR("oneTimeEventsIdx"));
	hl_hash((vbyte*)USTR("waitLock"));
	hl_hash((vbyte*)USTR("promisedEventsCount"));
	hl_hash((vbyte*)USTR("regularEvents"));
	hl_hash((vbyte*)USTR("isMainThread"));
	hl_hash((vbyte*)USTR("loop"));
	hl_hash((vbyte*)USTR("wait"));
	hl_hash((vbyte*)USTR("nextRunTime"));
	hl_hash((vbyte*)USTR("interval"));
	hl_hash((vbyte*)USTR("cancelled"));
	hl_hash((vbyte*)USTR("pending"));
	hl_hash((vbyte*)USTR("hasEvents"));
	hl_hash((vbyte*)USTR("sortEvents"));
	hl_hash((vbyte*)USTR("tick"));
	hl_hash((vbyte*)USTR("f"));
	hl_hash((vbyte*)USTR("prev"));
	hl_hash((vbyte*)USTR("isBlocking"));
	hl_hash((vbyte*)USTR("nextRun"));
	hl_hash((vbyte*)USTR("content"));
	hl_hash((vbyte*)USTR("USE_CACHE"));
	hl_hash((vbyte*)USTR("USE_ENUM_INDEX"));
	hl_hash((vbyte*)USTR("BASE64"));
	hl_hash((vbyte*)USTR("BASE64_CODES"));
	hl_hash((vbyte*)USTR("DEFAULT_RESOLVER"));
	hl_hash((vbyte*)USTR("CODES"));
	hl_hash((vbyte*)USTR("initCodes"));
	hl_hash((vbyte*)USTR("resolveClass"));
	hl_hash((vbyte*)USTR("resolveEnum"));
	hl_hash((vbyte*)USTR("m"));
	hl_hash((vbyte*)USTR("hash"));
	hl_hash((vbyte*)USTR("fonts"));
	hl_hash((vbyte*)USTR("replaceLast"));
	hl_hash((vbyte*)USTR("replaceIfLast"));
	hl_hash((vbyte*)USTR("replaceFirst"));
	hl_hash((vbyte*)USTR("splitOnFirst"));
	hl_hash((vbyte*)USTR("splitOnLast"));
	hl_hash((vbyte*)USTR("splitOnParagraph"));
	hl_hash((vbyte*)USTR("indexesOf"));
	hl_hash((vbyte*)USTR("indexesOfSubs"));
	hl_hash((vbyte*)USTR("indexesFromArray"));
	hl_hash((vbyte*)USTR("indexesFromEReg"));
	hl_hash((vbyte*)USTR("multiply"));
	hl_hash((vbyte*)USTR("subtract"));
	hl_hash((vbyte*)USTR("loremIpsum"));
	hl_hash((vbyte*)USTR("sortByLength"));
	hl_hash((vbyte*)USTR("sortByValue"));
	hl_hash((vbyte*)USTR("sortByIntValue"));
	hl_hash((vbyte*)USTR("getLineIndexOfChar"));
	hl_hash((vbyte*)USTR("countOccurrencesOf"));
	hl_hash((vbyte*)USTR("replace"));
	hl_hash((vbyte*)USTR("parseBool"));
	hl_hash((vbyte*)USTR("containsAny"));
	hl_hash((vbyte*)USTR("loremIpsumText"));
	hl_hash((vbyte*)USTR("sans"));
	hl_hash((vbyte*)USTR("serif"));
	hl_hash((vbyte*)USTR("r"));
	hl_hash((vbyte*)USTR("last"));
	hl_hash((vbyte*)USTR("global"));
	hl_hash((vbyte*)USTR("match"));
	hl_hash((vbyte*)USTR("matched"));
	hl_hash((vbyte*)USTR("matchedPos"));
	hl_hash((vbyte*)USTR("formatOutput"));
	hl_hash((vbyte*)USTR("trace"));
	hl_hash((vbyte*)USTR("className"));
	hl_hash((vbyte*)USTR("customParams"));
	hl_hash((vbyte*)USTR("fileName"));
	hl_hash((vbyte*)USTR("lineNumber"));
	hl_hash((vbyte*)USTR("methodName"));
	hl_hash((vbyte*)USTR("MASK"));
	hl_hash((vbyte*)USTR("prepared"));
	hl_hash((vbyte*)USTR("addTypes"));
	hl_hash((vbyte*)USTR("addFunctions"));
	hl_hash((vbyte*)USTR("addProps"));
	hl_hash((vbyte*)USTR("addSigns"));
	hl_hash((vbyte*)USTR("addConditions"));
	hl_hash((vbyte*)USTR("OBJECT_HASH_TABLE_CELL_SIZE"));
	hl_hash((vbyte*)USTR("generateObjectHashTable"));
	hl_hash((vbyte*)USTR("readObjectHashTable"));
	hl_hash((vbyte*)USTR("hashTableHasKey"));
	hl_hash((vbyte*)USTR("hashTableGetKey"));
	hl_hash((vbyte*)USTR("objectAddKey"));
	hl_hash((vbyte*)USTR("objectSetKey"));
	hl_hash((vbyte*)USTR("objectGetKey"));
	hl_hash((vbyte*)USTR("getHashTableOf"));
	hl_hash((vbyte*)USTR("key"));
	hl_hash((vbyte*)USTR("keyPointer"));
	hl_hash((vbyte*)USTR("printParserAst"));
	hl_hash((vbyte*)USTR("printInterpreterAst"));
	hl_hash((vbyte*)USTR("prefixFA"));
	hl_hash((vbyte*)USTR("pushIndex"));
	hl_hash((vbyte*)USTR("s"));
	hl_hash((vbyte*)USTR("l"));
	hl_hash((vbyte*)USTR("getTree_PARSER"));
	hl_hash((vbyte*)USTR("getTree_INTERP"));
	hl_hash((vbyte*)USTR("indent"));
	hl_hash((vbyte*)USTR("stringifyParser"));
	hl_hash((vbyte*)USTR("stringifyInterpreter"));
	hl_hash((vbyte*)USTR("prettyPrintOperatorPriority"));
	hl_hash((vbyte*)USTR("from2Points"));
	hl_hash((vbyte*)USTR("x"));
	hl_hash((vbyte*)USTR("y"));
	hl_hash((vbyte*)USTR("distanceTo"));
	hl_hash((vbyte*)USTR("degreesTo"));
	hl_hash((vbyte*)USTR("radiansTo"));
	hl_hash((vbyte*)USTR("point"));
	hl_hash((vbyte*)USTR("slope"));
	hl_hash((vbyte*)USTR("degrees"));
	hl_hash((vbyte*)USTR("radians"));
	hl_hash((vbyte*)USTR("getPointAtX"));
	hl_hash((vbyte*)USTR("getPointAtY"));
	hl_hash((vbyte*)USTR("intersect"));
	hl_hash((vbyte*)USTR("set_slope"));
	hl_hash((vbyte*)USTR("set_degrees"));
	hl_hash((vbyte*)USTR("set_radians"));
	hl_hash((vbyte*)USTR("get_yIntercept"));
	hl_hash((vbyte*)USTR("get_xIntercept"));
	hl_hash((vbyte*)USTR("fromRay2D"));
	hl_hash((vbyte*)USTR("start"));
	hl_hash((vbyte*)USTR("end"));
	hl_hash((vbyte*)USTR("toRay2D"));
	hl_hash((vbyte*)USTR("set_start"));
	hl_hash((vbyte*)USTR("set_end"));
	hl_hash((vbyte*)USTR("get_middle"));
	hl_hash((vbyte*)USTR("set_middle"));
	hl_hash((vbyte*)USTR("OFFSET"));
	hl_hash((vbyte*)USTR("WIDTH_BYTES"));
	hl_hash((vbyte*)USTR("VIEW_XY_BYTES"));
	hl_hash((vbyte*)USTR("VIEW_WH_BYTES"));
	hl_hash((vbyte*)USTR("VIEW_SHAPE_BYTES"));
	hl_hash((vbyte*)USTR("DATA_GAP"));
	hl_hash((vbyte*)USTR("get_underlying"));
	hl_hash((vbyte*)USTR("get_width"));
	hl_hash((vbyte*)USTR("get_height"));
	hl_hash((vbyte*)USTR("get_view"));
	hl_hash((vbyte*)USTR("set_view"));
	hl_hash((vbyte*)USTR("_new"));
	hl_hash((vbyte*)USTR("getColorFromStartingBytePos"));
	hl_hash((vbyte*)USTR("setColorFromStartingBytePos"));
	hl_hash((vbyte*)USTR("getPixel"));
	hl_hash((vbyte*)USTR("getSafePixel"));
	hl_hash((vbyte*)USTR("getUnsafePixel"));
	hl_hash((vbyte*)USTR("getFloatingPixel"));
	hl_hash((vbyte*)USTR("setPixel"));
	hl_hash((vbyte*)USTR("setSafePixel"));
	hl_hash((vbyte*)USTR("setFloatingPixel"));
	hl_hash((vbyte*)USTR("setUnsafePixel"));
	hl_hash((vbyte*)USTR("paintPixel"));
	hl_hash((vbyte*)USTR("paintFloatingPixel"));
	hl_hash((vbyte*)USTR("paintSafePixel"));
	hl_hash((vbyte*)USTR("paintUnsafePixel"));
	hl_hash((vbyte*)USTR("hasPixel"));
	hl_hash((vbyte*)USTR("movePixel"));
	hl_hash((vbyte*)USTR("moveSafePixel"));
	hl_hash((vbyte*)USTR("moveFloatingPixel"));
	hl_hash((vbyte*)USTR("moveUnsafePixel"));
	hl_hash((vbyte*)USTR("copyPixelFrom"));
	hl_hash((vbyte*)USTR("copyPixelTo"));
	hl_hash((vbyte*)USTR("getImagePortion"));
	hl_hash((vbyte*)USTR("setImagePortion"));
	hl_hash((vbyte*)USTR("drawLine"));
	hl_hash((vbyte*)USTR("drawRay2D"));
	hl_hash((vbyte*)USTR("drawLine2D"));
	hl_hash((vbyte*)USTR("fillRect"));
	hl_hash((vbyte*)USTR("drawRect"));
	hl_hash((vbyte*)USTR("drawQuadraticBezier"));
	hl_hash((vbyte*)USTR("drawCubicBezier"));
	hl_hash((vbyte*)USTR("fillCircle"));
	hl_hash((vbyte*)USTR("drawCircle"));
	hl_hash((vbyte*)USTR("drawEllipse"));
	hl_hash((vbyte*)USTR("fillColorRecursive"));
	hl_hash((vbyte*)USTR("fillColor"));
	hl_hash((vbyte*)USTR("fillUntilColor"));
	hl_hash((vbyte*)USTR("clone"));
	hl_hash((vbyte*)USTR("mirror"));
	hl_hash((vbyte*)USTR("flip"));
	hl_hash((vbyte*)USTR("stamp"));
	hl_hash((vbyte*)USTR("rotate"));
	hl_hash((vbyte*)USTR("forEachPixel"));
	hl_hash((vbyte*)USTR("forEachPixelInView"));
	hl_hash((vbyte*)USTR("center"));
	hl_hash((vbyte*)USTR("hasView"));
	hl_hash((vbyte*)USTR("setView"));
	hl_hash((vbyte*)USTR("getView"));
	hl_hash((vbyte*)USTR("removeView"));
	hl_hash((vbyte*)USTR("hasPixelInView"));
	hl_hash((vbyte*)USTR("from2DArray"));
	hl_hash((vbyte*)USTR("to2DArray"));
	hl_hash((vbyte*)USTR("fromBytes"));
	hl_hash((vbyte*)USTR("image_or_image"));
	hl_hash((vbyte*)USTR("image_xor_image"));
	hl_hash((vbyte*)USTR("image_and_image"));
	hl_hash((vbyte*)USTR("width"));
	hl_hash((vbyte*)USTR("height"));
	hl_hash((vbyte*)USTR("shape"));
	hl_hash((vbyte*)USTR("color"));
	hl_hash((vbyte*)USTR("TRANSPARENT"));
	hl_hash((vbyte*)USTR("WHITE"));
	hl_hash((vbyte*)USTR("GRAY"));
	hl_hash((vbyte*)USTR("BLACK"));
	hl_hash((vbyte*)USTR("GREEN"));
	hl_hash((vbyte*)USTR("YELLOW"));
	hl_hash((vbyte*)USTR("ORANGE"));
	hl_hash((vbyte*)USTR("RED"));
	hl_hash((vbyte*)USTR("PURPLE"));
	hl_hash((vbyte*)USTR("BLUE"));
	hl_hash((vbyte*)USTR("BROWN"));
	hl_hash((vbyte*)USTR("PINK"));
	hl_hash((vbyte*)USTR("MAGENTA"));
	hl_hash((vbyte*)USTR("CYAN"));
	hl_hash((vbyte*)USTR("SILVER"));
	hl_hash((vbyte*)USTR("GOLD"));
	hl_hash((vbyte*)USTR("OLIVE"));
	hl_hash((vbyte*)USTR("MAROON"));
	hl_hash((vbyte*)USTR("BORDEAUX"));
	hl_hash((vbyte*)USTR("NAVY"));
	hl_hash((vbyte*)USTR("TEAL"));
	hl_hash((vbyte*)USTR("FUCHSIA"));
	hl_hash((vbyte*)USTR("AQUA"));
	hl_hash((vbyte*)USTR("LIME"));
	hl_hash((vbyte*)USTR("CHARCOAL"));
	hl_hash((vbyte*)USTR("ONYX"));
	hl_hash((vbyte*)USTR("JET"));
	hl_hash((vbyte*)USTR("JET_BLACK"));
	hl_hash((vbyte*)USTR("ROYAL_BLUE"));
	hl_hash((vbyte*)USTR("COLOR_REGEX"));
	hl_hash((vbyte*)USTR("fromInt"));
	hl_hash((vbyte*)USTR("fromRGBA"));
	hl_hash((vbyte*)USTR("from8Bit"));
	hl_hash((vbyte*)USTR("fromRGBAFloat"));
	hl_hash((vbyte*)USTR("fromCMYK"));
	hl_hash((vbyte*)USTR("fromHSB"));
	hl_hash((vbyte*)USTR("fromHSL"));
	hl_hash((vbyte*)USTR("getHSBColorWheel"));
	hl_hash((vbyte*)USTR("interpolate"));
	hl_hash((vbyte*)USTR("gradient"));
	hl_hash((vbyte*)USTR("makeRandom"));
	hl_hash((vbyte*)USTR("divide"));
	hl_hash((vbyte*)USTR("getComplementHarmony"));
	hl_hash((vbyte*)USTR("getAnalogousHarmony"));
	hl_hash((vbyte*)USTR("getSplitComplementHarmony"));
	hl_hash((vbyte*)USTR("getTriadicHarmony"));
	hl_hash((vbyte*)USTR("to24Bit"));
	hl_hash((vbyte*)USTR("toHexString"));
	hl_hash((vbyte*)USTR("toWebString"));
	hl_hash((vbyte*)USTR("darken"));
	hl_hash((vbyte*)USTR("lighten"));
	hl_hash((vbyte*)USTR("invert"));
	hl_hash((vbyte*)USTR("setRGBA"));
	hl_hash((vbyte*)USTR("setRGBAFloat"));
	hl_hash((vbyte*)USTR("setCMYK"));
	hl_hash((vbyte*)USTR("setHSB"));
	hl_hash((vbyte*)USTR("setHSL"));
	hl_hash((vbyte*)USTR("setHSChromaMatch"));
	hl_hash((vbyte*)USTR("grayscale"));
	hl_hash((vbyte*)USTR("blackOrWhite"));
	hl_hash((vbyte*)USTR("getThis"));
	hl_hash((vbyte*)USTR("validate"));
	hl_hash((vbyte*)USTR("get_red"));
	hl_hash((vbyte*)USTR("get_green"));
	hl_hash((vbyte*)USTR("get_blue"));
	hl_hash((vbyte*)USTR("get_alpha"));
	hl_hash((vbyte*)USTR("get_redFloat"));
	hl_hash((vbyte*)USTR("get_greenFloat"));
	hl_hash((vbyte*)USTR("get_blueFloat"));
	hl_hash((vbyte*)USTR("get_alphaFloat"));
	hl_hash((vbyte*)USTR("set_red"));
	hl_hash((vbyte*)USTR("set_green"));
	hl_hash((vbyte*)USTR("set_blue"));
	hl_hash((vbyte*)USTR("set_alpha"));
	hl_hash((vbyte*)USTR("set_redFloat"));
	hl_hash((vbyte*)USTR("set_greenFloat"));
	hl_hash((vbyte*)USTR("set_blueFloat"));
	hl_hash((vbyte*)USTR("set_alphaFloat"));
	hl_hash((vbyte*)USTR("get_cyan"));
	hl_hash((vbyte*)USTR("get_magenta"));
	hl_hash((vbyte*)USTR("get_yellow"));
	hl_hash((vbyte*)USTR("get_black"));
	hl_hash((vbyte*)USTR("set_cyan"));
	hl_hash((vbyte*)USTR("set_magenta"));
	hl_hash((vbyte*)USTR("set_yellow"));
	hl_hash((vbyte*)USTR("set_black"));
	hl_hash((vbyte*)USTR("get_hue"));
	hl_hash((vbyte*)USTR("get_brightness"));
	hl_hash((vbyte*)USTR("get_saturation"));
	hl_hash((vbyte*)USTR("get_lightness"));
	hl_hash((vbyte*)USTR("set_hue"));
	hl_hash((vbyte*)USTR("set_saturation"));
	hl_hash((vbyte*)USTR("set_brightness"));
	hl_hash((vbyte*)USTR("set_lightness"));
	hl_hash((vbyte*)USTR("set_rgb"));
	hl_hash((vbyte*)USTR("get_rgb"));
	hl_hash((vbyte*)USTR("maxColor"));
	hl_hash((vbyte*)USTR("minColor"));
	hl_hash((vbyte*)USTR("boundChannel"));
	hl_hash((vbyte*)USTR("toInt"));
	hl_hash((vbyte*)USTR("color_greater_than_color"));
	hl_hash((vbyte*)USTR("color_greater_than_int"));
	hl_hash((vbyte*)USTR("int_greater_than_color"));
	hl_hash((vbyte*)USTR("color_greater_than_float"));
	hl_hash((vbyte*)USTR("float_greater_than_color"));
	hl_hash((vbyte*)USTR("color_greater_than_equal_color"));
	hl_hash((vbyte*)USTR("color_greater_than_equal_int"));
	hl_hash((vbyte*)USTR("int_greater_than_equal_color"));
	hl_hash((vbyte*)USTR("color_greater_than_equal_float"));
	hl_hash((vbyte*)USTR("float_greater_than_equal_color"));
	hl_hash((vbyte*)USTR("color_less_than_color"));
	hl_hash((vbyte*)USTR("color_less_than_int"));
	hl_hash((vbyte*)USTR("int_less_than_color"));
	hl_hash((vbyte*)USTR("color_less_than_float"));
	hl_hash((vbyte*)USTR("float_less_than_color"));
	hl_hash((vbyte*)USTR("color_less_than_equal_color"));
	hl_hash((vbyte*)USTR("color_less_than_equal_int"));
	hl_hash((vbyte*)USTR("int_less_than_equal_color"));
	hl_hash((vbyte*)USTR("color_less_than_equal_float"));
	hl_hash((vbyte*)USTR("float_less_than_equal_color"));
	hl_hash((vbyte*)USTR("color_equal_color"));
	hl_hash((vbyte*)USTR("color_equal_int"));
	hl_hash((vbyte*)USTR("int_equal_color"));
	hl_hash((vbyte*)USTR("color_equal_float"));
	hl_hash((vbyte*)USTR("float_equal_color"));
	hl_hash((vbyte*)USTR("color_not_equal_color"));
	hl_hash((vbyte*)USTR("color_not_equal_int"));
	hl_hash((vbyte*)USTR("int_not_equal_color"));
	hl_hash((vbyte*)USTR("color_not_equal_float"));
	hl_hash((vbyte*)USTR("float_not_equal_color"));
	hl_hash((vbyte*)USTR("color_bitwise_and_color"));
	hl_hash((vbyte*)USTR("color_bitwise_and_int"));
	hl_hash((vbyte*)USTR("int_bitwise_and_color"));
	hl_hash((vbyte*)USTR("color_bitwise_or_color"));
	hl_hash((vbyte*)USTR("color_bitwise_or_int"));
	hl_hash((vbyte*)USTR("int_bitwise_or_color"));
	hl_hash((vbyte*)USTR("color_bitwise_xor_color"));
	hl_hash((vbyte*)USTR("color_bitwise_xor_int"));
	hl_hash((vbyte*)USTR("int_bitwise_xor_color"));
	hl_hash((vbyte*)USTR("color_bitwise_left_shift_color"));
	hl_hash((vbyte*)USTR("color_bitwise_left_shift_int"));
	hl_hash((vbyte*)USTR("int_bitwise_left_shift_color"));
	hl_hash((vbyte*)USTR("color_bitwise_right_shift_color"));
	hl_hash((vbyte*)USTR("color_bitwise_right_shift_int"));
	hl_hash((vbyte*)USTR("int_bitwise_right_shift_color"));
	hl_hash((vbyte*)USTR("color_bitwise_unsigned_right_shift_color"));
	hl_hash((vbyte*)USTR("color_bitwise_unsigned_right_shift_int"));
	hl_hash((vbyte*)USTR("int_bitwise_unsigned_right_shift_color"));
	hl_hash((vbyte*)USTR("colder"));
	hl_hash((vbyte*)USTR("original"));
	hl_hash((vbyte*)USTR("warmer"));
	hl_hash((vbyte*)USTR("color1"));
	hl_hash((vbyte*)USTR("color2"));
	hl_hash((vbyte*)USTR("color3"));
	hl_hash((vbyte*)USTR("defaultResizeAlgorithm"));
	hl_hash((vbyte*)USTR("loadFromFile"));
	hl_hash((vbyte*)USTR("saveToFile"));
	hl_hash((vbyte*)USTR("addToScreen"));
	hl_hash((vbyte*)USTR("getNeighborsOfPixel"));
	hl_hash((vbyte*)USTR("grayscalePixel"));
	hl_hash((vbyte*)USTR("xUnits"));
	hl_hash((vbyte*)USTR("yUnits"));
	hl_hash((vbyte*)USTR("zIndex"));
	hl_hash((vbyte*)USTR("inner"));
	hl_hash((vbyte*)USTR("setMultiple"));
	hl_hash((vbyte*)USTR("row"));
	hl_hash((vbyte*)USTR("column"));
	hl_hash((vbyte*)USTR("set_length"));
	hl_hash((vbyte*)USTR("set_width"));
	hl_hash((vbyte*)USTR("set_height"));
	hl_hash((vbyte*)USTR("get_item"));
	hl_hash((vbyte*)USTR("set_item"));
	hl_hash((vbyte*)USTR("errorByType"));
	hl_hash((vbyte*)USTR("getInclusionMethod"));
	hl_hash((vbyte*)USTR("COUNT"));
	hl_hash((vbyte*)USTR("underlying"));
	hl_hash((vbyte*)USTR("job"));
	hl_hash((vbyte*)USTR("onFailed"));
	hl_hash((vbyte*)USTR("onDone"));
	hl_hash((vbyte*)USTR("jobDone"));
	hl_hash((vbyte*)USTR("relaunchEvents"));
	hl_hash((vbyte*)USTR("count"));
	hl_hash((vbyte*)USTR("onFailedWrapper"));
	hl_hash((vbyte*)USTR("set_onFailed"));
	hl_hash((vbyte*)USTR("set_onDone"));
	hl_hash((vbyte*)USTR("main"));
	hl_hash((vbyte*)USTR("field"));
	hl_hash((vbyte*)USTR("setField"));
	hl_hash((vbyte*)USTR("getProperty"));
	hl_hash((vbyte*)USTR("fields"));
	hl_hash((vbyte*)USTR("startsWith"));
	hl_hash((vbyte*)USTR("endsWith"));
	hl_hash((vbyte*)USTR("isSpace"));
	hl_hash((vbyte*)USTR("ltrim"));
	hl_hash((vbyte*)USTR("rtrim"));
	hl_hash((vbyte*)USTR("trim"));
	hl_hash((vbyte*)USTR("hex"));
	hl_hash((vbyte*)USTR("init"));
	hl_hash((vbyte*)USTR("initClass"));
	hl_hash((vbyte*)USTR("initEnum"));
	hl_hash((vbyte*)USTR("register"));
	hl_hash((vbyte*)USTR("getClass"));
	hl_hash((vbyte*)USTR("getEnum"));
	hl_hash((vbyte*)USTR("getClassName"));
	hl_hash((vbyte*)USTR("getEnumName"));
	hl_hash((vbyte*)USTR("createEmptyInstance"));
	hl_hash((vbyte*)USTR("createEnum"));
	hl_hash((vbyte*)USTR("createEnumIndex"));
	hl_hash((vbyte*)USTR("getInstanceFields"));
	hl_hash((vbyte*)USTR("getEnumConstructs"));
	hl_hash((vbyte*)USTR("typeof"));
	hl_hash((vbyte*)USTR("enumConstructor"));
	hl_hash((vbyte*)USTR("enumParameters"));
	hl_hash((vbyte*)USTR("enumIndex"));
	hl_hash((vbyte*)USTR("equalItems"));
	hl_hash((vbyte*)USTR("itemToString"));
	hl_hash((vbyte*)USTR("pos"));
	hl_hash((vbyte*)USTR("addSub"));
	hl_hash((vbyte*)USTR("addChar"));
	hl_hash((vbyte*)USTR("processEvents"));
	hl_hash((vbyte*)USTR("saveStack"));
	hl_hash((vbyte*)USTR("exceptionStack"));
	hl_hash((vbyte*)USTR("toHaxe"));
	hl_hash((vbyte*)USTR("rec"));
	hl_hash((vbyte*)USTR("doMerge"));
	hl_hash((vbyte*)USTR("gcd"));
	hl_hash((vbyte*)USTR("upper"));
	hl_hash((vbyte*)USTR("lower"));
	hl_hash((vbyte*)USTR("swap"));
	hl_hash((vbyte*)USTR("decompile"));
	hl_hash((vbyte*)USTR("error"));
	hl_hash((vbyte*)USTR("assert"));
	hl_hash((vbyte*)USTR("setModule"));
	hl_hash((vbyte*)USTR("splitLine"));
	hl_hash((vbyte*)USTR("declareVariable"));
	hl_hash((vbyte*)USTR("declareFunction"));
	hl_hash((vbyte*)USTR("condition"));
	hl_hash((vbyte*)USTR("call"));
	hl_hash((vbyte*)USTR("typeCast"));
	hl_hash((vbyte*)USTR("evaluate"));
	hl_hash((vbyte*)USTR("calculate"));
	hl_hash((vbyte*)USTR("group"));
	hl_hash((vbyte*)USTR("POINTER_SIZE"));
	hl_hash((vbyte*)USTR("get_rawLocation"));
	hl_hash((vbyte*)USTR("set_rawLocation"));
	hl_hash((vbyte*)USTR("toArray"));
	hl_hash((vbyte*)USTR("toBytes"));
	hl_hash((vbyte*)USTR("lex"));
	hl_hash((vbyte*)USTR("separateBooleanIdentifiers"));
	hl_hash((vbyte*)USTR("mergeOrSplitKnownSigns"));
	hl_hash((vbyte*)USTR("tokenize"));
	hl_hash((vbyte*)USTR("eval"));
	hl_hash((vbyte*)USTR("passedByValue"));
	hl_hash((vbyte*)USTR("passedByReference"));
	hl_hash((vbyte*)USTR("staticallyStorable"));
	hl_hash((vbyte*)USTR("extractIdentifier"));
	hl_hash((vbyte*)USTR("asStringPath"));
	hl_hash((vbyte*)USTR("asJoinedStringPath"));
	hl_hash((vbyte*)USTR("asObjectToken"));
	hl_hash((vbyte*)USTR("asEmptyObject"));
	hl_hash((vbyte*)USTR("asTokenPath"));
	hl_hash((vbyte*)USTR("extractValue"));
	hl_hash((vbyte*)USTR("writeInPlace"));
	hl_hash((vbyte*)USTR("toIdentifierPath"));
	hl_hash((vbyte*)USTR("extractHaxeType"));
	hl_hash((vbyte*)USTR("toLittleValue"));
	hl_hash((vbyte*)USTR("toHaxeValue"));
	hl_hash((vbyte*)USTR("toLittleType"));
	hl_hash((vbyte*)USTR("LEXER"));
	hl_hash((vbyte*)USTR("PARSER"));
	hl_hash((vbyte*)USTR("PARSER_MACRO"));
	hl_hash((vbyte*)USTR("INTERPRETER"));
	hl_hash((vbyte*)USTR("INTERPRETER_VALUE_EVALUATOR"));
	hl_hash((vbyte*)USTR("INTERPRETER_EXPRESSION_EVALUATOR"));
	hl_hash((vbyte*)USTR("INTERPRETER_TOKEN_VALUE_STRINGIFIER"));
	hl_hash((vbyte*)USTR("INTERPRETER_TOKEN_IDENTIFIER_STRINGIFIER"));
	hl_hash((vbyte*)USTR("MEMORY"));
	hl_hash((vbyte*)USTR("MEMORY_REFERRER"));
	hl_hash((vbyte*)USTR("MEMORY_STORAGE"));
	hl_hash((vbyte*)USTR("MEMORY_EXTERNAL_INTERFACING"));
	hl_hash((vbyte*)USTR("MEMORY_SIZE_EVALUATOR"));
	hl_hash((vbyte*)USTR("MEMORY_GARBAGE_COLLECTOR"));
	hl_hash((vbyte*)USTR("getIndexOf"));
	hl_hash((vbyte*)USTR("interpolateMissingPixels"));
	hl_hash((vbyte*)USTR("solveVariablesFor"));
	hl_hash((vbyte*)USTR("createIdentityMatrix"));
	hl_hash((vbyte*)USTR("augmentMatrix"));
	hl_hash((vbyte*)USTR("swapRows"));
	hl_hash((vbyte*)USTR("extractMatrix"));
	hl_hash((vbyte*)USTR("generateMatrix"));
	hl_hash((vbyte*)USTR("getMax"));
	hl_hash((vbyte*)USTR("countingSort"));
	hl_hash((vbyte*)USTR("setUInt8"));
	hl_hash((vbyte*)USTR("getUInt8"));
	hl_hash((vbyte*)USTR("getUInt32"));
	hl_hash((vbyte*)USTR("setInt8"));
	hl_hash((vbyte*)USTR("getInt8"));
	hl_hash((vbyte*)USTR("getBytes"));
	hl_hash((vbyte*)USTR("isEmpty"));
	hl_hash((vbyte*)USTR("get_y"));
	hl_hash((vbyte*)USTR("get_x"));
	hl_hash((vbyte*)USTR("set_y"));
	hl_hash((vbyte*)USTR("set_x"));
	hl_hash((vbyte*)USTR("toPoint2D"));
	hl_hash((vbyte*)USTR("fromPoint2D"));
	hl_hash((vbyte*)USTR("set_underlying"));
	hl_hash((vbyte*)USTR("get_rows"));
	hl_hash((vbyte*)USTR("set_rows"));
	hl_hash((vbyte*)USTR("get_columns"));
	hl_hash((vbyte*)USTR("set_columns"));
	hl_hash((vbyte*)USTR("getDeterminant"));
	hl_hash((vbyte*)USTR("getTrace"));
	hl_hash((vbyte*)USTR("multiplyWithScalar"));
	hl_hash((vbyte*)USTR("getSubMatrix"));
	hl_hash((vbyte*)USTR("getColumn"));
	hl_hash((vbyte*)USTR("getRow"));
	hl_hash((vbyte*)USTR("setColumn"));
	hl_hash((vbyte*)USTR("setRow"));
	hl_hash((vbyte*)USTR("insertColumn"));
	hl_hash((vbyte*)USTR("insertRow"));
	hl_hash((vbyte*)USTR("removeColumn"));
	hl_hash((vbyte*)USTR("removeRow"));
	hl_hash((vbyte*)USTR("IDENTITY"));
	hl_hash((vbyte*)USTR("ROTATION"));
	hl_hash((vbyte*)USTR("TRANSLATION"));
	hl_hash((vbyte*)USTR("SCALE"));
	hl_hash((vbyte*)USTR("SHEAR"));
	hl_hash((vbyte*)USTR("REFLECTION"));
	hl_hash((vbyte*)USTR("PERSPECTIVE"));
	hl_hash((vbyte*)USTR("DEPTH"));
	hl_hash((vbyte*)USTR("createFilled"));
	hl_hash((vbyte*)USTR("createTransformation"));
	hl_hash((vbyte*)USTR("multiplyMatrices"));
	hl_hash((vbyte*)USTR("addMatrices"));
	hl_hash((vbyte*)USTR("subtractMatrices"));
	hl_hash((vbyte*)USTR("divideMatrices"));
	hl_hash((vbyte*)USTR("to_array_array_float"));
	hl_hash((vbyte*)USTR("from_array_array_float"));
	hl_hash((vbyte*)USTR("from_array_array_int"));
	hl_hash((vbyte*)USTR("ARGB"));
	hl_hash((vbyte*)USTR("RGBA"));
	hl_hash((vbyte*)USTR("ABGR"));
	hl_hash((vbyte*)USTR("BGRA"));
	hl_hash((vbyte*)USTR("RGB"));
	hl_hash((vbyte*)USTR("BGR"));
	hl_hash((vbyte*)USTR("convertPixelFormat"));
	hl_hash((vbyte*)USTR("get_a"));
	hl_hash((vbyte*)USTR("set_a"));
	hl_hash((vbyte*)USTR("get_b"));
	hl_hash((vbyte*)USTR("set_b"));
	hl_hash((vbyte*)USTR("get_c"));
	hl_hash((vbyte*)USTR("set_c"));
	hl_hash((vbyte*)USTR("get_d"));
	hl_hash((vbyte*)USTR("set_d"));
	hl_hash((vbyte*)USTR("get_e"));
	hl_hash((vbyte*)USTR("set_e"));
	hl_hash((vbyte*)USTR("get_f"));
	hl_hash((vbyte*)USTR("set_f"));
	hl_hash((vbyte*)USTR("get_tx"));
	hl_hash((vbyte*)USTR("set_tx"));
	hl_hash((vbyte*)USTR("get_ty"));
	hl_hash((vbyte*)USTR("set_ty"));
	hl_hash((vbyte*)USTR("fromMatrix2D"));
	hl_hash((vbyte*)USTR("reportDependencies"));
	hl_hash((vbyte*)USTR("drawTextOnImage"));
	hl_hash((vbyte*)USTR("distanceFromRayToPoint2D"));
	hl_hash((vbyte*)USTR("intersectionBetweenRay2Ds"));
	hl_hash((vbyte*)USTR("distanceBetweenRays2D"));
	hl_hash((vbyte*)USTR("findPointAtDistanceUsingX"));
	hl_hash((vbyte*)USTR("findPointAtDistanceUsingY"));
	hl_hash((vbyte*)USTR("distanceFromLineToPoint2D"));
	hl_hash((vbyte*)USTR("distanceBetweenLines2D"));
	hl_hash((vbyte*)USTR("radiansFromLineToPoint2D"));
	hl_hash((vbyte*)USTR("intersectionBetweenLine2Ds"));
	hl_hash((vbyte*)USTR("mirrorInsideRectangle"));
	hl_hash((vbyte*)USTR("flipInsideRectangle"));
	hl_hash((vbyte*)USTR("invertInsideRectangle"));
	hl_hash((vbyte*)USTR("clamp"));
	hl_hash((vbyte*)USTR("isBetweenRanges"));
	hl_hash((vbyte*)USTR("isBetweenRange"));
	hl_hash((vbyte*)USTR("wrapInt"));
	hl_hash((vbyte*)USTR("wrapFloat"));
	hl_hash((vbyte*)USTR("boundInt"));
	hl_hash((vbyte*)USTR("boundFloat"));
	hl_hash((vbyte*)USTR("gamma"));
	hl_hash((vbyte*)USTR("factorial"));
	hl_hash((vbyte*)USTR("slopeToDegrees"));
	hl_hash((vbyte*)USTR("slopeToRadians"));
	hl_hash((vbyte*)USTR("degreesToSlope"));
	hl_hash((vbyte*)USTR("degreesToRadians"));
	hl_hash((vbyte*)USTR("radiansToDegrees"));
	hl_hash((vbyte*)USTR("radiansToSlope"));
	hl_hash((vbyte*)USTR("cotan"));
	hl_hash((vbyte*)USTR("cosec"));
	hl_hash((vbyte*)USTR("sec"));
	hl_hash((vbyte*)USTR("sind"));
	hl_hash((vbyte*)USTR("cosd"));
	hl_hash((vbyte*)USTR("tand"));
	hl_hash((vbyte*)USTR("cotand"));
	hl_hash((vbyte*)USTR("cosecd"));
	hl_hash((vbyte*)USTR("secd"));
	hl_hash((vbyte*)USTR("truncate"));
	hl_hash((vbyte*)USTR("cropDecimal"));
	hl_hash((vbyte*)USTR("isInt"));
	hl_hash((vbyte*)USTR("get_NEGATIVE_INFINITY"));
	hl_hash((vbyte*)USTR("get_POSITIVE_INFINITY"));
	hl_hash((vbyte*)USTR("get_NaN"));
	hl_hash((vbyte*)USTR("get_PI_OVER_2"));
	hl_hash((vbyte*)USTR("get_PI"));
	hl_hash((vbyte*)USTR("abs"));
	hl_hash((vbyte*)USTR("acos"));
	hl_hash((vbyte*)USTR("asin"));
	hl_hash((vbyte*)USTR("atan"));
	hl_hash((vbyte*)USTR("atan2"));
	hl_hash((vbyte*)USTR("ceil"));
	hl_hash((vbyte*)USTR("cos"));
	hl_hash((vbyte*)USTR("exp"));
	hl_hash((vbyte*)USTR("floor"));
	hl_hash((vbyte*)USTR("log"));
	hl_hash((vbyte*)USTR("pow"));
	hl_hash((vbyte*)USTR("round"));
	hl_hash((vbyte*)USTR("sin"));
	hl_hash((vbyte*)USTR("sqrt"));
	hl_hash((vbyte*)USTR("tan"));
	hl_hash((vbyte*)USTR("ffloor"));
	hl_hash((vbyte*)USTR("fceil"));
	hl_hash((vbyte*)USTR("fround"));
	hl_hash((vbyte*)USTR("isFinite"));
	hl_hash((vbyte*)USTR("isNaN"));
	hl_hash((vbyte*)USTR("len"));
	hl_hash((vbyte*)USTR("msg"));
	hl_hash((vbyte*)USTR("__f"));
	hl_hash((vbyte*)USTR("name"));
	hl_hash((vbyte*)USTR("data"));
	hl_hash((vbyte*)USTR("buf"));
	hl_hash((vbyte*)USTR("cache"));
	hl_hash((vbyte*)USTR("shash"));
	hl_hash((vbyte*)USTR("scount"));
	hl_hash((vbyte*)USTR("useCache"));
	hl_hash((vbyte*)USTR("useEnumIndex"));
	hl_hash((vbyte*)USTR("serializeString"));
	hl_hash((vbyte*)USTR("serializeRef"));
	hl_hash((vbyte*)USTR("serializeFields"));
	hl_hash((vbyte*)USTR("serialize"));
	hl_hash((vbyte*)USTR("q"));
	hl_hash((vbyte*)USTR("item"));
	hl_hash((vbyte*)USTR("scache"));
	hl_hash((vbyte*)USTR("resolver"));
	hl_hash((vbyte*)USTR("readDigits"));
	hl_hash((vbyte*)USTR("readFloat"));
	hl_hash((vbyte*)USTR("unserializeObject"));
	hl_hash((vbyte*)USTR("unserializeEnum"));
	hl_hash((vbyte*)USTR("unserialize"));
	hl_hash((vbyte*)USTR("arr"));
	hl_hash((vbyte*)USTR("posInfos"));
	hl_hash((vbyte*)USTR("argument"));
	hl_hash((vbyte*)USTR("a"));
	hl_hash((vbyte*)USTR("endIndex"));
	hl_hash((vbyte*)USTR("startIndex"));
	hl_hash((vbyte*)USTR("objectTypeName"));
	hl_hash((vbyte*)USTR("address"));
	hl_hash((vbyte*)USTR("defaultInstanceSize"));
	hl_hash((vbyte*)USTR("instanceFields"));
	hl_hash((vbyte*)USTR("isExternal"));
	hl_hash((vbyte*)USTR("pointer"));
	hl_hash((vbyte*)USTR("staticFields"));
	hl_hash((vbyte*)USTR("typeName"));
	hl_hash((vbyte*)USTR("documentation"));
	hl_hash((vbyte*)USTR("c"));
	hl_hash((vbyte*)USTR("is"));
	hl_hash((vbyte*)USTR("side"));
	hl_hash((vbyte*)USTR("sign"));
	hl_hash((vbyte*)USTR("lhs"));
	hl_hash((vbyte*)USTR("rhs"));
	hl_hash((vbyte*)USTR("allowedTypeCombos"));
	hl_hash((vbyte*)USTR("callback"));
	hl_hash((vbyte*)USTR("lhsAllowedTypes"));
	hl_hash((vbyte*)USTR("operatorType"));
	hl_hash((vbyte*)USTR("rhsAllowedTypes"));
	hl_hash((vbyte*)USTR("singleSidedOperatorCallback"));
	hl_hash((vbyte*)USTR("token"));
	hl_hash((vbyte*)USTR("karray"));
	hl_hash((vbyte*)USTR("varray"));
	hl_hash((vbyte*)USTR("parameter"));
	hl_hash((vbyte*)USTR("i"));
	hl_hash((vbyte*)USTR("img"));
	hl_hash((vbyte*)USTR("from"));
	hl_hash((vbyte*)USTR("to"));
	hl_hash((vbyte*)USTR("z"));
	hl_hash((vbyte*)USTR("roundedDown"));
	hl_hash((vbyte*)USTR("image"));
	hl_hash((vbyte*)USTR("X"));
	hl_hash((vbyte*)USTR("Y"));
	hl_hash((vbyte*)USTR("circular"));
	hl_hash((vbyte*)USTR("getParameters"));
	hl_hash((vbyte*)USTR("hxUnserialize"));
	hl_hash((vbyte*)USTR("hxSerialize"));
}
