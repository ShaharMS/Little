// Generated by HLC 4.3.4 (HL v5)
#define HLC_BOOT
#include <hlc.h>


void hl_init_hashes() {
	hl_hash((vbyte*)USTR("__type__"));
	hl_hash((vbyte*)USTR("__meta__"));
	hl_hash((vbyte*)USTR("__implementedBy__"));
	hl_hash((vbyte*)USTR("check"));
	hl_hash((vbyte*)USTR("__name__"));
	hl_hash((vbyte*)USTR("__constructor__"));
	hl_hash((vbyte*)USTR("bytes"));
	hl_hash((vbyte*)USTR("length"));
	hl_hash((vbyte*)USTR("toUpperCase"));
	hl_hash((vbyte*)USTR("toLowerCase"));
	hl_hash((vbyte*)USTR("charAt"));
	hl_hash((vbyte*)USTR("charCodeAt"));
	hl_hash((vbyte*)USTR("findChar"));
	hl_hash((vbyte*)USTR("indexOf"));
	hl_hash((vbyte*)USTR("lastIndexOf"));
	hl_hash((vbyte*)USTR("split"));
	hl_hash((vbyte*)USTR("substr"));
	hl_hash((vbyte*)USTR("substring"));
	hl_hash((vbyte*)USTR("toString"));
	hl_hash((vbyte*)USTR("toUtf8"));
	hl_hash((vbyte*)USTR("__string"));
	hl_hash((vbyte*)USTR("__compare"));
	hl_hash((vbyte*)USTR("fromCharCode"));
	hl_hash((vbyte*)USTR("__alloc__"));
	hl_hash((vbyte*)USTR("call_toString"));
	hl_hash((vbyte*)USTR("fromUCS2"));
	hl_hash((vbyte*)USTR("fromUTF8"));
	hl_hash((vbyte*)USTR("__add__"));
	hl_hash((vbyte*)USTR("fromTime"));
	hl_hash((vbyte*)USTR("fromString"));
	hl_hash((vbyte*)USTR("t"));
	hl_hash((vbyte*)USTR("getTime"));
	hl_hash((vbyte*)USTR("allocI32"));
	hl_hash((vbyte*)USTR("allocUI16"));
	hl_hash((vbyte*)USTR("allocF32"));
	hl_hash((vbyte*)USTR("allocF64"));
	hl_hash((vbyte*)USTR("getDyn"));
	hl_hash((vbyte*)USTR("setDyn"));
	hl_hash((vbyte*)USTR("blit"));
	hl_hash((vbyte*)USTR("pushDyn"));
	hl_hash((vbyte*)USTR("popDyn"));
	hl_hash((vbyte*)USTR("shiftDyn"));
	hl_hash((vbyte*)USTR("unshiftDyn"));
	hl_hash((vbyte*)USTR("insertDyn"));
	hl_hash((vbyte*)USTR("containsDyn"));
	hl_hash((vbyte*)USTR("removeDyn"));
	hl_hash((vbyte*)USTR("sortDyn"));
	hl_hash((vbyte*)USTR("slice"));
	hl_hash((vbyte*)USTR("splice"));
	hl_hash((vbyte*)USTR("join"));
	hl_hash((vbyte*)USTR("reverse"));
	hl_hash((vbyte*)USTR("resize"));
	hl_hash((vbyte*)USTR("__cast"));
	hl_hash((vbyte*)USTR("isArrayObj"));
	hl_hash((vbyte*)USTR("size"));
	hl_hash((vbyte*)USTR("concat"));
	hl_hash((vbyte*)USTR("pop"));
	hl_hash((vbyte*)USTR("push"));
	hl_hash((vbyte*)USTR("shift"));
	hl_hash((vbyte*)USTR("sort"));
	hl_hash((vbyte*)USTR("unshift"));
	hl_hash((vbyte*)USTR("insert"));
	hl_hash((vbyte*)USTR("contains"));
	hl_hash((vbyte*)USTR("remove"));
	hl_hash((vbyte*)USTR("copy"));
	hl_hash((vbyte*)USTR("iterator"));
	hl_hash((vbyte*)USTR("keyValueIterator"));
	hl_hash((vbyte*)USTR("map"));
	hl_hash((vbyte*)USTR("filter"));
	hl_hash((vbyte*)USTR("__expand"));
	hl_hash((vbyte*)USTR("__ename__"));
	hl_hash((vbyte*)USTR("__emap__"));
	hl_hash((vbyte*)USTR("__constructs__"));
	hl_hash((vbyte*)USTR("__evalues__"));
	hl_hash((vbyte*)USTR("array"));
	hl_hash((vbyte*)USTR("alloc"));
	hl_hash((vbyte*)USTR("ofString"));
	hl_hash((vbyte*)USTR("b"));
	hl_hash((vbyte*)USTR("get"));
	hl_hash((vbyte*)USTR("set"));
	hl_hash((vbyte*)USTR("fill"));
	hl_hash((vbyte*)USTR("getDouble"));
	hl_hash((vbyte*)USTR("setDouble"));
	hl_hash((vbyte*)USTR("getInt32"));
	hl_hash((vbyte*)USTR("setInt32"));
	hl_hash((vbyte*)USTR("getString"));
	hl_hash((vbyte*)USTR("KEY_SIZE"));
	hl_hash((vbyte*)USTR("__noTypeCreation"));
	hl_hash((vbyte*)USTR("containsCombo"));
	hl_hash((vbyte*)USTR("defaultConfig"));
	hl_hash((vbyte*)USTR("recognizedOperators"));
	hl_hash((vbyte*)USTR("VARIABLE_DECLARATION"));
	hl_hash((vbyte*)USTR("FUNCTION_DECLARATION"));
	hl_hash((vbyte*)USTR("TYPE_DECL_OR_CAST"));
	hl_hash((vbyte*)USTR("FUNCTION_RETURN"));
	hl_hash((vbyte*)USTR("NULL_VALUE"));
	hl_hash((vbyte*)USTR("TRUE_VALUE"));
	hl_hash((vbyte*)USTR("FALSE_VALUE"));
	hl_hash((vbyte*)USTR("TYPE_DYNAMIC"));
	hl_hash((vbyte*)USTR("TYPE_INT"));
	hl_hash((vbyte*)USTR("TYPE_FLOAT"));
	hl_hash((vbyte*)USTR("TYPE_BOOLEAN"));
	hl_hash((vbyte*)USTR("TYPE_STRING"));
	hl_hash((vbyte*)USTR("TYPE_OBJECT"));
	hl_hash((vbyte*)USTR("TYPE_MEMORY"));
	hl_hash((vbyte*)USTR("TYPE_ARRAY"));
	hl_hash((vbyte*)USTR("TYPE_FUNCTION"));
	hl_hash((vbyte*)USTR("TYPE_CONDITION"));
	hl_hash((vbyte*)USTR("TYPE_MODULE"));
	hl_hash((vbyte*)USTR("TYPE_SIGN"));
	hl_hash((vbyte*)USTR("MAIN_MODULE_NAME"));
	hl_hash((vbyte*)USTR("OBJECT_TYPE_PROPERTY_NAME"));
	hl_hash((vbyte*)USTR("OBJECT_ADDRESS_PROPERTY_NAME"));
	hl_hash((vbyte*)USTR("PRINT_FUNCTION_NAME"));
	hl_hash((vbyte*)USTR("RAISE_ERROR_FUNCTION_NAME"));
	hl_hash((vbyte*)USTR("READ_FUNCTION_NAME"));
	hl_hash((vbyte*)USTR("RUN_CODE_FUNCTION_NAME"));
	hl_hash((vbyte*)USTR("CONDITION_PATTERN_PARAMETER_NAME"));
	hl_hash((vbyte*)USTR("CONDITION_BODY_PARAMETER_NAME"));
	hl_hash((vbyte*)USTR("CONDITION__FOR_LOOP"));
	hl_hash((vbyte*)USTR("CONDITION__WHILE_LOOP"));
	hl_hash((vbyte*)USTR("CONDITION__IF"));
	hl_hash((vbyte*)USTR("CONDITION__ELSE"));
	hl_hash((vbyte*)USTR("CONDITION__WHENEVER"));
	hl_hash((vbyte*)USTR("CONDITION__AFTER"));
	hl_hash((vbyte*)USTR("TYPE_UNKNOWN"));
	hl_hash((vbyte*)USTR("RECOGNIZED_SIGNS"));
	hl_hash((vbyte*)USTR("PROPERTY_ACCESS_SIGN"));
	hl_hash((vbyte*)USTR("EQUALS_SIGN"));
	hl_hash((vbyte*)USTR("NOT_EQUALS_SIGN"));
	hl_hash((vbyte*)USTR("LARGER_SIGN"));
	hl_hash((vbyte*)USTR("SMALLER_SIGN"));
	hl_hash((vbyte*)USTR("LARGER_EQUALS_SIGN"));
	hl_hash((vbyte*)USTR("SMALLER_EQUALS_SIGN"));
	hl_hash((vbyte*)USTR("XOR_SIGN"));
	hl_hash((vbyte*)USTR("OR_SIGN"));
	hl_hash((vbyte*)USTR("AND_SIGN"));
	hl_hash((vbyte*)USTR("NOT_SIGN"));
	hl_hash((vbyte*)USTR("ADD_SIGN"));
	hl_hash((vbyte*)USTR("SUBTRACT_SIGN"));
	hl_hash((vbyte*)USTR("MULTIPLY_SIGN"));
	hl_hash((vbyte*)USTR("DIVIDE_SIGN"));
	hl_hash((vbyte*)USTR("POW_SIGN"));
	hl_hash((vbyte*)USTR("FACTORIAL_SIGN"));
	hl_hash((vbyte*)USTR("SQRT_SIGN"));
	hl_hash((vbyte*)USTR("NEGATE_SIGN"));
	hl_hash((vbyte*)USTR("POSITIVE_SIGN"));
	hl_hash((vbyte*)USTR("STDLIB__FLOAT_isWhole"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_length"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_toLowerCase"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_toUpperCase"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_trim"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_substring"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_charAt"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_replace"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_remove"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_contains"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_indexOf"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_lastIndexOf"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_startsWith"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_endsWith"));
	hl_hash((vbyte*)USTR("STDLIB__STRING_fromCharCode"));
	hl_hash((vbyte*)USTR("STDLIB__ARRAY_length"));
	hl_hash((vbyte*)USTR("STDLIB__ARRAY_elementType"));
	hl_hash((vbyte*)USTR("STDLIB__ARRAY_get"));
	hl_hash((vbyte*)USTR("STDLIB__ARRAY_set"));
	hl_hash((vbyte*)USTR("STDLIB__MEMORY_allocate"));
	hl_hash((vbyte*)USTR("STDLIB__MEMORY_free"));
	hl_hash((vbyte*)USTR("STDLIB__MEMORY_read"));
	hl_hash((vbyte*)USTR("STDLIB__MEMORY_write"));
	hl_hash((vbyte*)USTR("STDLIB__MEMORY_size"));
	hl_hash((vbyte*)USTR("STDLIB__MEMORY_maxSize"));
	hl_hash((vbyte*)USTR("FOR_LOOP_FROM"));
	hl_hash((vbyte*)USTR("FOR_LOOP_TO"));
	hl_hash((vbyte*)USTR("FOR_LOOP_JUMP"));
	hl_hash((vbyte*)USTR("TYPE_CAST_FUNCTION_PREFIX"));
	hl_hash((vbyte*)USTR("INSTANTIATE_FUNCTION_NAME"));
	hl_hash((vbyte*)USTR("keywords"));
	hl_hash((vbyte*)USTR("runtime"));
	hl_hash((vbyte*)USTR("memory"));
	hl_hash((vbyte*)USTR("plugin"));
	hl_hash((vbyte*)USTR("queue"));
	hl_hash((vbyte*)USTR("debug"));
	hl_hash((vbyte*)USTR("version"));
	hl_hash((vbyte*)USTR("loadModule"));
	hl_hash((vbyte*)USTR("run"));
	hl_hash((vbyte*)USTR("compile"));
	hl_hash((vbyte*)USTR("format"));
	hl_hash((vbyte*)USTR("reset"));
	hl_hash((vbyte*)USTR("line"));
	hl_hash((vbyte*)USTR("linePart"));
	hl_hash((vbyte*)USTR("currentToken"));
	hl_hash((vbyte*)USTR("module"));
	hl_hash((vbyte*)USTR("previousToken"));
	hl_hash((vbyte*)USTR("exitCode"));
	hl_hash((vbyte*)USTR("errorThrown"));
	hl_hash((vbyte*)USTR("errorToken"));
	hl_hash((vbyte*)USTR("onLineChanged"));
	hl_hash((vbyte*)USTR("onModuleChanged"));
	hl_hash((vbyte*)USTR("onLineSplit"));
	hl_hash((vbyte*)USTR("onTokenInterpreted"));
	hl_hash((vbyte*)USTR("onErrorThrown"));
	hl_hash((vbyte*)USTR("onWriteValue"));
	hl_hash((vbyte*)USTR("onFunctionCalled"));
	hl_hash((vbyte*)USTR("onConditionCalled"));
	hl_hash((vbyte*)USTR("onFieldDeclared"));
	hl_hash((vbyte*)USTR("onTypeCast"));
	hl_hash((vbyte*)USTR("stdout"));
	hl_hash((vbyte*)USTR("callStack"));
	hl_hash((vbyte*)USTR("throwError"));
	hl_hash((vbyte*)USTR("__print"));
	hl_hash((vbyte*)USTR("h"));
	hl_hash((vbyte*)USTR(""));
	hl_hash((vbyte*)USTR("exists"));
	hl_hash((vbyte*)USTR("keys"));
	hl_hash((vbyte*)USTR("hasNext"));
	hl_hash((vbyte*)USTR("next"));
	hl_hash((vbyte*)USTR("_ks"));
	hl_hash((vbyte*)USTR("_vs"));
	hl_hash((vbyte*)USTR("allowReinterpret"));
	hl_hash((vbyte*)USTR("get_length"));
	hl_hash((vbyte*)USTR("__get_field"));
	hl_hash((vbyte*)USTR("clear"));
	hl_hash((vbyte*)USTR("output"));
	hl_hash((vbyte*)USTR("stdoutTokens"));
	hl_hash((vbyte*)USTR("storage"));
	hl_hash((vbyte*)USTR("referrer"));
	hl_hash((vbyte*)USTR("externs"));
	hl_hash((vbyte*)USTR("constants"));
	hl_hash((vbyte*)USTR("operators"));
	hl_hash((vbyte*)USTR("memoryChunkSize"));
	hl_hash((vbyte*)USTR("maxMemorySize"));
	hl_hash((vbyte*)USTR("get_currentMemorySize"));
	hl_hash((vbyte*)USTR("store"));
	hl_hash((vbyte*)USTR("retrieve"));
	hl_hash((vbyte*)USTR("valueFromType"));
	hl_hash((vbyte*)USTR("read"));
	hl_hash((vbyte*)USTR("readFrom"));
	hl_hash((vbyte*)USTR("write"));
	hl_hash((vbyte*)USTR("allocate"));
	hl_hash((vbyte*)USTR("free"));
	hl_hash((vbyte*)USTR("getTypeInformation"));
	hl_hash((vbyte*)USTR("getTypeName"));
	hl_hash((vbyte*)USTR("parent"));
	hl_hash((vbyte*)USTR("reserved"));
	hl_hash((vbyte*)USTR("requestMemory"));
	hl_hash((vbyte*)USTR("storeByte"));
	hl_hash((vbyte*)USTR("setByte"));
	hl_hash((vbyte*)USTR("storeBytes"));
	hl_hash((vbyte*)USTR("setBytes"));
	hl_hash((vbyte*)USTR("readBytes"));
	hl_hash((vbyte*)USTR("freeBytes"));
	hl_hash((vbyte*)USTR("storeArray"));
	hl_hash((vbyte*)USTR("readArray"));
	hl_hash((vbyte*)USTR("storeInt32"));
	hl_hash((vbyte*)USTR("readInt32"));
	hl_hash((vbyte*)USTR("storeDouble"));
	hl_hash((vbyte*)USTR("readDouble"));
	hl_hash((vbyte*)USTR("setPointer"));
	hl_hash((vbyte*)USTR("readPointer"));
	hl_hash((vbyte*)USTR("storeString"));
	hl_hash((vbyte*)USTR("setString"));
	hl_hash((vbyte*)USTR("readString"));
	hl_hash((vbyte*)USTR("storeCodeBlock"));
	hl_hash((vbyte*)USTR("setCodeBlock"));
	hl_hash((vbyte*)USTR("readCodeBlock"));
	hl_hash((vbyte*)USTR("storeCondition"));
	hl_hash((vbyte*)USTR("setCondition"));
	hl_hash((vbyte*)USTR("readCondition"));
	hl_hash((vbyte*)USTR("storeSign"));
	hl_hash((vbyte*)USTR("setSign"));
	hl_hash((vbyte*)USTR("readSign"));
	hl_hash((vbyte*)USTR("storeStatic"));
	hl_hash((vbyte*)USTR("storeObject"));
	hl_hash((vbyte*)USTR("setObject"));
	hl_hash((vbyte*)USTR("readObject"));
	hl_hash((vbyte*)USTR("readType"));
	hl_hash((vbyte*)USTR("currentScopeStart"));
	hl_hash((vbyte*)USTR("currentScopeLength"));
	hl_hash((vbyte*)USTR("get_currentScopeStart"));
	hl_hash((vbyte*)USTR("get_currentScopeLength"));
	hl_hash((vbyte*)USTR("pushScope"));
	hl_hash((vbyte*)USTR("popScope"));
	hl_hash((vbyte*)USTR("reference"));
	hl_hash((vbyte*)USTR("externToPointer"));
	hl_hash((vbyte*)USTR("pointerToExtern"));
	hl_hash((vbyte*)USTR("instanceProperties"));
	hl_hash((vbyte*)USTR("globalProperties"));
	hl_hash((vbyte*)USTR("get_pointerToExtern"));
	hl_hash((vbyte*)USTR("createPathFor"));
	hl_hash((vbyte*)USTR("hasGlobal"));
	hl_hash((vbyte*)USTR("hasInstance"));
	hl_hash((vbyte*)USTR("getGlobal"));
	hl_hash((vbyte*)USTR("getter"));
	hl_hash((vbyte*)USTR("doc"));
	hl_hash((vbyte*)USTR("type"));
	hl_hash((vbyte*)USTR("properties"));
	hl_hash((vbyte*)USTR("objectAddress"));
	hl_hash((vbyte*)USTR("objectValue"));
	hl_hash((vbyte*)USTR("capacity"));
	hl_hash((vbyte*)USTR("NULL"));
	hl_hash((vbyte*)USTR("FALSE"));
	hl_hash((vbyte*)USTR("TRUE"));
	hl_hash((vbyte*)USTR("ZERO"));
	hl_hash((vbyte*)USTR("INT"));
	hl_hash((vbyte*)USTR("FLOAT"));
	hl_hash((vbyte*)USTR("BOOL"));
	hl_hash((vbyte*)USTR("DYNAMIC"));
	hl_hash((vbyte*)USTR("TYPE"));
	hl_hash((vbyte*)USTR("UNKNOWN"));
	hl_hash((vbyte*)USTR("ERROR_TOKEN"));
	hl_hash((vbyte*)USTR("EXTERN"));
	hl_hash((vbyte*)USTR("EMPTY_STRING"));
	hl_hash((vbyte*)USTR("getFromPointer"));
	hl_hash((vbyte*)USTR("hasPointer"));
	hl_hash((vbyte*)USTR("hasType"));
	hl_hash((vbyte*)USTR("getType"));
	hl_hash((vbyte*)USTR("priority"));
	hl_hash((vbyte*)USTR("standard"));
	hl_hash((vbyte*)USTR("rhsOnly"));
	hl_hash((vbyte*)USTR("lhsOnly"));
	hl_hash((vbyte*)USTR("setPriority"));
	hl_hash((vbyte*)USTR("iterateByPriority"));
	hl_hash((vbyte*)USTR("add"));
	hl_hash((vbyte*)USTR("signPosToObject"));
	hl_hash((vbyte*)USTR("registerType"));
	hl_hash((vbyte*)USTR("registerFunction"));
	hl_hash((vbyte*)USTR("registerCondition"));
	hl_hash((vbyte*)USTR("registerInstanceVariable"));
	hl_hash((vbyte*)USTR("registerOperator"));
	hl_hash((vbyte*)USTR("first"));
	hl_hash((vbyte*)USTR("enqueue"));
	hl_hash((vbyte*)USTR("previous"));
	hl_hash((vbyte*)USTR("value"));
	hl_hash((vbyte*)USTR("additionalParsingLevels"));
	hl_hash((vbyte*)USTR("parse"));
	hl_hash((vbyte*)USTR("convert"));
	hl_hash((vbyte*)USTR("mergeBlocks"));
	hl_hash((vbyte*)USTR("mergeExpressions"));
	hl_hash((vbyte*)USTR("mergePropertyOperations"));
	hl_hash((vbyte*)USTR("mergeTypeDecls"));
	hl_hash((vbyte*)USTR("mergeComplexStructures"));
	hl_hash((vbyte*)USTR("mergeCalls"));
	hl_hash((vbyte*)USTR("mergeWrites"));
	hl_hash((vbyte*)USTR("mergeValuesWithTypeDecls"));
	hl_hash((vbyte*)USTR("mergeNonBlockBodies"));
	hl_hash((vbyte*)USTR("mergeElses"));
	hl_hash((vbyte*)USTR("get_line"));
	hl_hash((vbyte*)USTR("set_line"));
	hl_hash((vbyte*)USTR("get_module"));
	hl_hash((vbyte*)USTR("set_module"));
	hl_hash((vbyte*)USTR("setLine"));
	hl_hash((vbyte*)USTR("nextPart"));
	hl_hash((vbyte*)USTR("resetLines"));
	hl_hash((vbyte*)USTR("max"));
	hl_hash((vbyte*)USTR("PI"));
	hl_hash((vbyte*)USTR("NaN"));
	hl_hash((vbyte*)USTR("POSITIVE_INFINITY"));
	hl_hash((vbyte*)USTR("NEGATIVE_INFINITY"));
	hl_hash((vbyte*)USTR("winMetaCharacters"));
	hl_hash((vbyte*)USTR("quoteUnixArg"));
	hl_hash((vbyte*)USTR("quoteWinArg"));
	hl_hash((vbyte*)USTR("utf8Path"));
	hl_hash((vbyte*)USTR("getPath"));
	hl_hash((vbyte*)USTR("print"));
	hl_hash((vbyte*)USTR("println"));
	hl_hash((vbyte*)USTR("stdin"));
	hl_hash((vbyte*)USTR("systemName"));
	hl_hash((vbyte*)USTR("command"));
	hl_hash((vbyte*)USTR("readByte"));
	hl_hash((vbyte*)USTR("readLine"));
	hl_hash((vbyte*)USTR("CREATED"));
	hl_hash((vbyte*)USTR("mainThread"));
	hl_hash((vbyte*)USTR("threads"));
	hl_hash((vbyte*)USTR("threadsMutex"));
	hl_hash((vbyte*)USTR("current"));
	hl_hash((vbyte*)USTR("events"));
	hl_hash((vbyte*)USTR("handle"));
	hl_hash((vbyte*)USTR("mutex"));
	hl_hash((vbyte*)USTR("oneTimeEvents"));
	hl_hash((vbyte*)USTR("oneTimeEventsIdx"));
	hl_hash((vbyte*)USTR("waitLock"));
	hl_hash((vbyte*)USTR("promisedEventsCount"));
	hl_hash((vbyte*)USTR("regularEvents"));
	hl_hash((vbyte*)USTR("isMainThread"));
	hl_hash((vbyte*)USTR("loop"));
	hl_hash((vbyte*)USTR("wait"));
	hl_hash((vbyte*)USTR("nextRunTime"));
	hl_hash((vbyte*)USTR("interval"));
	hl_hash((vbyte*)USTR("cancelled"));
	hl_hash((vbyte*)USTR("caught"));
	hl_hash((vbyte*)USTR("__exceptionMessage"));
	hl_hash((vbyte*)USTR("__exceptionStack"));
	hl_hash((vbyte*)USTR("__nativeStack"));
	hl_hash((vbyte*)USTR("__skipStack"));
	hl_hash((vbyte*)USTR("__nativeException"));
	hl_hash((vbyte*)USTR("__previousException"));
	hl_hash((vbyte*)USTR("details"));
	hl_hash((vbyte*)USTR("__shiftStack"));
	hl_hash((vbyte*)USTR("__unshiftStack"));
	hl_hash((vbyte*)USTR("get_message"));
	hl_hash((vbyte*)USTR("get_previous"));
	hl_hash((vbyte*)USTR("get_stack"));
	hl_hash((vbyte*)USTR("pending"));
	hl_hash((vbyte*)USTR("hasEvents"));
	hl_hash((vbyte*)USTR("sortEvents"));
	hl_hash((vbyte*)USTR("tick"));
	hl_hash((vbyte*)USTR("f"));
	hl_hash((vbyte*)USTR("prev"));
	hl_hash((vbyte*)USTR("isBlocking"));
	hl_hash((vbyte*)USTR("nextRun"));
	hl_hash((vbyte*)USTR("content"));
	hl_hash((vbyte*)USTR("USE_CACHE"));
	hl_hash((vbyte*)USTR("USE_ENUM_INDEX"));
	hl_hash((vbyte*)USTR("BASE64"));
	hl_hash((vbyte*)USTR("BASE64_CODES"));
	hl_hash((vbyte*)USTR("DEFAULT_RESOLVER"));
	hl_hash((vbyte*)USTR("CODES"));
	hl_hash((vbyte*)USTR("initCodes"));
	hl_hash((vbyte*)USTR("resolveClass"));
	hl_hash((vbyte*)USTR("resolveEnum"));
	hl_hash((vbyte*)USTR("rnd"));
	hl_hash((vbyte*)USTR("toStringDepth"));
	hl_hash((vbyte*)USTR("isOfType"));
	hl_hash((vbyte*)USTR("string"));
	hl_hash((vbyte*)USTR("parseInt"));
	hl_hash((vbyte*)USTR("parseFloat"));
	hl_hash((vbyte*)USTR("formatOutput"));
	hl_hash((vbyte*)USTR("trace"));
	hl_hash((vbyte*)USTR("className"));
	hl_hash((vbyte*)USTR("customParams"));
	hl_hash((vbyte*)USTR("fileName"));
	hl_hash((vbyte*)USTR("lineNumber"));
	hl_hash((vbyte*)USTR("methodName"));
	hl_hash((vbyte*)USTR("prepared"));
	hl_hash((vbyte*)USTR("addTypes"));
	hl_hash((vbyte*)USTR("addFunctions"));
	hl_hash((vbyte*)USTR("addProps"));
	hl_hash((vbyte*)USTR("addSigns"));
	hl_hash((vbyte*)USTR("addConditions"));
	hl_hash((vbyte*)USTR("OBJECT_HASH_TABLE_CELL_SIZE"));
	hl_hash((vbyte*)USTR("generateObjectHashTable"));
	hl_hash((vbyte*)USTR("readObjectHashTable"));
	hl_hash((vbyte*)USTR("hashTableHasKey"));
	hl_hash((vbyte*)USTR("hashTableGetKey"));
	hl_hash((vbyte*)USTR("objectAddKey"));
	hl_hash((vbyte*)USTR("objectSetKey"));
	hl_hash((vbyte*)USTR("getHashTableOf"));
	hl_hash((vbyte*)USTR("key"));
	hl_hash((vbyte*)USTR("keyPointer"));
	hl_hash((vbyte*)USTR("MASK"));
	hl_hash((vbyte*)USTR("printInterpreterAst"));
	hl_hash((vbyte*)USTR("prefixFA"));
	hl_hash((vbyte*)USTR("pushIndex"));
	hl_hash((vbyte*)USTR("s"));
	hl_hash((vbyte*)USTR("l"));
	hl_hash((vbyte*)USTR("getTree_INTERP"));
	hl_hash((vbyte*)USTR("indent"));
	hl_hash((vbyte*)USTR("stringifyParser"));
	hl_hash((vbyte*)USTR("stringifyInterpreter"));
	hl_hash((vbyte*)USTR("main"));
	hl_hash((vbyte*)USTR("field"));
	hl_hash((vbyte*)USTR("setField"));
	hl_hash((vbyte*)USTR("getProperty"));
	hl_hash((vbyte*)USTR("fields"));
	hl_hash((vbyte*)USTR("startsWith"));
	hl_hash((vbyte*)USTR("endsWith"));
	hl_hash((vbyte*)USTR("isSpace"));
	hl_hash((vbyte*)USTR("ltrim"));
	hl_hash((vbyte*)USTR("rtrim"));
	hl_hash((vbyte*)USTR("trim"));
	hl_hash((vbyte*)USTR("replace"));
	hl_hash((vbyte*)USTR("sub"));
	hl_hash((vbyte*)USTR("init"));
	hl_hash((vbyte*)USTR("initClass"));
	hl_hash((vbyte*)USTR("initEnum"));
	hl_hash((vbyte*)USTR("register"));
	hl_hash((vbyte*)USTR("getClass"));
	hl_hash((vbyte*)USTR("getEnum"));
	hl_hash((vbyte*)USTR("getClassName"));
	hl_hash((vbyte*)USTR("getEnumName"));
	hl_hash((vbyte*)USTR("createEmptyInstance"));
	hl_hash((vbyte*)USTR("createEnum"));
	hl_hash((vbyte*)USTR("createEnumIndex"));
	hl_hash((vbyte*)USTR("getInstanceFields"));
	hl_hash((vbyte*)USTR("getEnumConstructs"));
	hl_hash((vbyte*)USTR("typeof"));
	hl_hash((vbyte*)USTR("enumConstructor"));
	hl_hash((vbyte*)USTR("enumParameters"));
	hl_hash((vbyte*)USTR("enumIndex"));
	hl_hash((vbyte*)USTR("subtract"));
	hl_hash((vbyte*)USTR("equalItems"));
	hl_hash((vbyte*)USTR("itemToString"));
	hl_hash((vbyte*)USTR("pos"));
	hl_hash((vbyte*)USTR("addChar"));
	hl_hash((vbyte*)USTR("processEvents"));
	hl_hash((vbyte*)USTR("_new"));
	hl_hash((vbyte*)USTR("saveStack"));
	hl_hash((vbyte*)USTR("exceptionStack"));
	hl_hash((vbyte*)USTR("toHaxe"));
	hl_hash((vbyte*)USTR("rec"));
	hl_hash((vbyte*)USTR("doMerge"));
	hl_hash((vbyte*)USTR("rotate"));
	hl_hash((vbyte*)USTR("gcd"));
	hl_hash((vbyte*)USTR("upper"));
	hl_hash((vbyte*)USTR("lower"));
	hl_hash((vbyte*)USTR("swap"));
	hl_hash((vbyte*)USTR("hash"));
	hl_hash((vbyte*)USTR("replaceLast"));
	hl_hash((vbyte*)USTR("replaceIfLast"));
	hl_hash((vbyte*)USTR("replaceFirst"));
	hl_hash((vbyte*)USTR("multiply"));
	hl_hash((vbyte*)USTR("sortByLength"));
	hl_hash((vbyte*)USTR("countOccurrencesOf"));
	hl_hash((vbyte*)USTR("containsAny"));
	hl_hash((vbyte*)USTR("decompile"));
	hl_hash((vbyte*)USTR("error"));
	hl_hash((vbyte*)USTR("assert"));
	hl_hash((vbyte*)USTR("setModule"));
	hl_hash((vbyte*)USTR("splitLine"));
	hl_hash((vbyte*)USTR("declareVariable"));
	hl_hash((vbyte*)USTR("declareFunction"));
	hl_hash((vbyte*)USTR("condition"));
	hl_hash((vbyte*)USTR("call"));
	hl_hash((vbyte*)USTR("typeCast"));
	hl_hash((vbyte*)USTR("evaluate"));
	hl_hash((vbyte*)USTR("calculate"));
	hl_hash((vbyte*)USTR("group"));
	hl_hash((vbyte*)USTR("fromInt"));
	hl_hash((vbyte*)USTR("toInt"));
	hl_hash((vbyte*)USTR("lex"));
	hl_hash((vbyte*)USTR("separateBooleanIdentifiers"));
	hl_hash((vbyte*)USTR("mergeOrSplitKnownSigns"));
	hl_hash((vbyte*)USTR("asStringPath"));
	hl_hash((vbyte*)USTR("asJoinedStringPath"));
	hl_hash((vbyte*)USTR("asObjectToken"));
	hl_hash((vbyte*)USTR("asEmptyObject"));
	hl_hash((vbyte*)USTR("asTokenPath"));
	hl_hash((vbyte*)USTR("extractValue"));
	hl_hash((vbyte*)USTR("writeInPlace"));
	hl_hash((vbyte*)USTR("toIdentifierPath"));
	hl_hash((vbyte*)USTR("toArray"));
	hl_hash((vbyte*)USTR("toLittleValue"));
	hl_hash((vbyte*)USTR("toHaxeValue"));
	hl_hash((vbyte*)USTR("toLittleType"));
	hl_hash((vbyte*)USTR("getIndexOf"));
	hl_hash((vbyte*)USTR("isEmpty"));
	hl_hash((vbyte*)USTR("gamma"));
	hl_hash((vbyte*)USTR("factorial"));
	hl_hash((vbyte*)USTR("r"));
	hl_hash((vbyte*)USTR("last"));
	hl_hash((vbyte*)USTR("global"));
	hl_hash((vbyte*)USTR("match"));
	hl_hash((vbyte*)USTR("matched"));
	hl_hash((vbyte*)USTR("msg"));
	hl_hash((vbyte*)USTR("__f"));
	hl_hash((vbyte*)USTR("name"));
	hl_hash((vbyte*)USTR("data"));
	hl_hash((vbyte*)USTR("buf"));
	hl_hash((vbyte*)USTR("cache"));
	hl_hash((vbyte*)USTR("shash"));
	hl_hash((vbyte*)USTR("scount"));
	hl_hash((vbyte*)USTR("useCache"));
	hl_hash((vbyte*)USTR("useEnumIndex"));
	hl_hash((vbyte*)USTR("serializeString"));
	hl_hash((vbyte*)USTR("serializeRef"));
	hl_hash((vbyte*)USTR("serializeFields"));
	hl_hash((vbyte*)USTR("serialize"));
	hl_hash((vbyte*)USTR("q"));
	hl_hash((vbyte*)USTR("item"));
	hl_hash((vbyte*)USTR("scache"));
	hl_hash((vbyte*)USTR("resolver"));
	hl_hash((vbyte*)USTR("readDigits"));
	hl_hash((vbyte*)USTR("readFloat"));
	hl_hash((vbyte*)USTR("unserializeObject"));
	hl_hash((vbyte*)USTR("unserializeEnum"));
	hl_hash((vbyte*)USTR("unserialize"));
	hl_hash((vbyte*)USTR("arr"));
	hl_hash((vbyte*)USTR("posInfos"));
	hl_hash((vbyte*)USTR("argument"));
	hl_hash((vbyte*)USTR("getBytes"));
	hl_hash((vbyte*)USTR("a"));
	hl_hash((vbyte*)USTR("objectTypeName"));
	hl_hash((vbyte*)USTR("address"));
	hl_hash((vbyte*)USTR("defaultInstanceSize"));
	hl_hash((vbyte*)USTR("instanceFields"));
	hl_hash((vbyte*)USTR("isExternal"));
	hl_hash((vbyte*)USTR("passedByReference"));
	hl_hash((vbyte*)USTR("pointer"));
	hl_hash((vbyte*)USTR("staticFields"));
	hl_hash((vbyte*)USTR("typeName"));
	hl_hash((vbyte*)USTR("documentation"));
	hl_hash((vbyte*)USTR("is"));
	hl_hash((vbyte*)USTR("side"));
	hl_hash((vbyte*)USTR("sign"));
	hl_hash((vbyte*)USTR("lhs"));
	hl_hash((vbyte*)USTR("rhs"));
	hl_hash((vbyte*)USTR("allowedTypeCombos"));
	hl_hash((vbyte*)USTR("callback"));
	hl_hash((vbyte*)USTR("lhsAllowedTypes"));
	hl_hash((vbyte*)USTR("operatorType"));
	hl_hash((vbyte*)USTR("rhsAllowedTypes"));
	hl_hash((vbyte*)USTR("singleSidedOperatorCallback"));
	hl_hash((vbyte*)USTR("token"));
	hl_hash((vbyte*)USTR("karray"));
	hl_hash((vbyte*)USTR("varray"));
	hl_hash((vbyte*)USTR("parameter"));
	hl_hash((vbyte*)USTR("slope"));
	hl_hash((vbyte*)USTR("degrees"));
	hl_hash((vbyte*)USTR("radians"));
	hl_hash((vbyte*)USTR("start"));
	hl_hash((vbyte*)USTR("end"));
	hl_hash((vbyte*)USTR("x"));
	hl_hash((vbyte*)USTR("y"));
	hl_hash((vbyte*)USTR("getParameters"));
	hl_hash((vbyte*)USTR("hxUnserialize"));
	hl_hash((vbyte*)USTR("hxSerialize"));
}
