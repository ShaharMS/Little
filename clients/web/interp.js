// Generated by Haxe 4.3.3
(function ($hx_exports, $global) { "use strict";
$hx_exports["little"] = $hx_exports["little"] || {};
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
$hxClasses["EReg"] = EReg;
EReg.__name__ = "EReg";
EReg.prototype = {
	r: null
	,match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,split: function(s) {
		var d = "#__delim__#";
		return s.replace(this.r,d).split(d);
	}
	,__class__: EReg
};
var HxOverrides = function() { };
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = "HxOverrides";
HxOverrides.dateStr = function(date) {
	var m = date.getMonth() + 1;
	var d = date.getDate();
	var h = date.getHours();
	var mi = date.getMinutes();
	var s = date.getSeconds();
	return date.getFullYear() + "-" + (m < 10 ? "0" + m : "" + m) + "-" + (d < 10 ? "0" + d : "" + d) + " " + (h < 10 ? "0" + h : "" + h) + ":" + (mi < 10 ? "0" + mi : "" + mi) + ":" + (s < 10 ? "0" + s : "" + s);
};
HxOverrides.strDate = function(s) {
	switch(s.length) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d["setTime"](0);
		d["setUTCHours"](k[0]);
		d["setUTCMinutes"](k[1]);
		d["setUTCSeconds"](k[2]);
		return d;
	case 10:
		var k = s.split("-");
		return new Date(k[0],k[1] - 1,k[2],0,0,0);
	case 19:
		var k = s.split(" ");
		var y = k[0].split("-");
		var t = k[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw haxe_Exception.thrown("Invalid date format : " + s);
	}
};
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var haxe_IMap = function() { };
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
haxe_IMap.prototype = {
	get: null
	,exists: null
	,keys: null
	,__class__: haxe_IMap
};
var IOrderedMap = function() { };
$hxClasses["IOrderedMap"] = IOrderedMap;
IOrderedMap.__name__ = "IOrderedMap";
IOrderedMap.__isInterface__ = true;
IOrderedMap.__interfaces__ = [haxe_IMap];
IOrderedMap.prototype = {
	get_length: null
	,get_orderedKeys: null
	,get_innerMap: null
	,get: null
	,set: null
	,exists: null
	,remove: null
	,keys: null
	,iterator: null
	,keyValueIterator: null
	,copy: null
	,toString: null
	,orderedKeys: null
	,innerMap: null
	,keysCopy: null
	,clear: null
	,__class__: IOrderedMap
	,__properties__: {get_innerMap:"get_innerMap",get_orderedKeys:"get_orderedKeys",get_length:"get_length"}
};
var Main = function() { };
$hxClasses["Main"] = Main;
Main.__name__ = "Main";
Main.main = function() {
	new js_$example_JsExample();
};
Math.__name__ = "Math";
var OrderedEnumValueMap = {};
OrderedEnumValueMap._new = function() {
	return new OrderedEnumValueMapImpl();
};
OrderedEnumValueMap._get = function(this1,key) {
	return this1._innerMap.get(key);
};
OrderedEnumValueMap._set = function(this1,key,value) {
	this1.set(key,value);
	return value;
};
var OrderedEnumValueMapImpl = function() {
	this._innerMap = new haxe_ds_EnumValueMap();
	this._orderedKeys = [];
};
$hxClasses["OrderedEnumValueMapImpl"] = OrderedEnumValueMapImpl;
OrderedEnumValueMapImpl.__name__ = "OrderedEnumValueMapImpl";
OrderedEnumValueMapImpl.__interfaces__ = [IOrderedMap];
OrderedEnumValueMapImpl.prototype = {
	_orderedKeys: null
	,_innerMap: null
	,set: function(key,value) {
		if(!this._innerMap.exists(key)) {
			this._orderedKeys.push(key);
		}
		this._innerMap.set(key,value);
	}
	,get: function(key) {
		return this._innerMap.get(key);
	}
	,exists: function(key) {
		return this._innerMap.exists(key);
	}
	,remove: function(key) {
		var removed = this._innerMap.remove(key);
		if(removed) {
			HxOverrides.remove(this._orderedKeys,key);
		}
		return removed;
	}
	,keys: function() {
		return new haxe_iterators_ArrayIterator(this._orderedKeys);
	}
	,iterator: function() {
		return new OrderedEnumValueMapIterator(this);
	}
	,keyValueIterator: function() {
		return new haxe_iterators_MapKeyValueIterator(this);
	}
	,copy: function() {
		var clone = new OrderedEnumValueMapImpl();
		clone._orderedKeys = this._orderedKeys.slice();
		clone._innerMap = this._innerMap.copy();
		return clone;
	}
	,get_length: function() {
		return this._orderedKeys.length;
	}
	,orderedKeys: null
	,get_orderedKeys: function() {
		return this._orderedKeys;
	}
	,innerMap: null
	,get_innerMap: function() {
		return this._innerMap;
	}
	,keysCopy: function() {
		return this._orderedKeys.slice();
	}
	,clear: function() {
		this._orderedKeys = [];
		this._innerMap = new haxe_ds_EnumValueMap();
	}
	,toString: function() {
		var k;
		var len = this._orderedKeys.length;
		var str = "[";
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			k = this._orderedKeys[i];
			str += Std.string(k) + " => " + Std.string(this._innerMap.get(k)) + (i != len - 1 ? ", " : "");
		}
		return str + "]";
	}
	,__class__: OrderedEnumValueMapImpl
	,__properties__: {get_innerMap:"get_innerMap",get_orderedKeys:"get_orderedKeys",get_length:"get_length"}
};
var OrderedEnumValueMapIterator = function(omap) {
	this.index = 0;
	this.map = omap;
};
$hxClasses["OrderedEnumValueMapIterator"] = OrderedEnumValueMapIterator;
OrderedEnumValueMapIterator.__name__ = "OrderedEnumValueMapIterator";
OrderedEnumValueMapIterator.prototype = {
	map: null
	,index: null
	,hasNext: function() {
		return this.index < this.map._orderedKeys.length;
	}
	,next: function() {
		return this.map._innerMap.get(this.map._orderedKeys[this.index++]);
	}
	,__class__: OrderedEnumValueMapIterator
};
var OrderedIntMap = {};
OrderedIntMap._new = function() {
	return new OrderedIntMapImpl();
};
OrderedIntMap._get = function(this1,key) {
	return this1._innerMap.h[key];
};
OrderedIntMap._set = function(this1,key,value) {
	this1.set(key,value);
	return value;
};
var OrderedIntMapImpl = function() {
	this._innerMap = new haxe_ds_IntMap();
	this._orderedKeys = [];
};
$hxClasses["OrderedIntMapImpl"] = OrderedIntMapImpl;
OrderedIntMapImpl.__name__ = "OrderedIntMapImpl";
OrderedIntMapImpl.__interfaces__ = [IOrderedMap];
OrderedIntMapImpl.prototype = {
	_orderedKeys: null
	,_innerMap: null
	,set: function(key,value) {
		if(!this._innerMap.h.hasOwnProperty(key)) {
			this._orderedKeys.push(key);
		}
		this._innerMap.h[key] = value;
	}
	,get: function(key) {
		return this._innerMap.h[key];
	}
	,exists: function(key) {
		return this._innerMap.h.hasOwnProperty(key);
	}
	,remove: function(key) {
		var removed = this._innerMap.remove(key);
		if(removed) {
			HxOverrides.remove(this._orderedKeys,key);
		}
		return removed;
	}
	,keys: function() {
		return new haxe_iterators_ArrayIterator(this._orderedKeys);
	}
	,iterator: function() {
		return new OrderedIntMapIterator(this);
	}
	,keyValueIterator: function() {
		return new haxe_iterators_MapKeyValueIterator(this);
	}
	,copy: function() {
		var clone = new OrderedIntMapImpl();
		clone._orderedKeys = this._orderedKeys.slice();
		clone._innerMap = this._innerMap.copy();
		return clone;
	}
	,get_length: function() {
		return this._orderedKeys.length;
	}
	,get_orderedKeys: function() {
		return this._orderedKeys;
	}
	,innerMap: null
	,get_innerMap: function() {
		return this._innerMap;
	}
	,keysCopy: function() {
		return this._orderedKeys.slice();
	}
	,clear: function() {
		this._orderedKeys = [];
		this._innerMap = new haxe_ds_IntMap();
	}
	,toString: function() {
		var k;
		var len = this._orderedKeys.length;
		var str = "[";
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			k = this._orderedKeys[i];
			str += k + " => " + Std.string(this._innerMap.h[k]) + (i != len - 1 ? ", " : "");
		}
		return str + "]";
	}
	,__class__: OrderedIntMapImpl
	,__properties__: {get_innerMap:"get_innerMap",get_orderedKeys:"get_orderedKeys",get_length:"get_length"}
};
var OrderedIntMapIterator = function(omap) {
	this.index = 0;
	this.map = omap;
};
$hxClasses["OrderedIntMapIterator"] = OrderedIntMapIterator;
OrderedIntMapIterator.__name__ = "OrderedIntMapIterator";
OrderedIntMapIterator.prototype = {
	map: null
	,index: null
	,hasNext: function() {
		return this.index < this.map._orderedKeys.length;
	}
	,next: function() {
		return this.map._innerMap.h[this.map._orderedKeys[this.index++]];
	}
	,__class__: OrderedIntMapIterator
};
var OrderedMap = {};
OrderedMap.__properties__ = {get_innerMap:"get_innerMap",get_orderedKeys:"get_orderedKeys",get_length:"get_length"};
OrderedMap.set = function(this1,key,value) {
	this1.set(key,value);
};
OrderedMap.get = function(this1,key) {
	return this1.get(key);
};
OrderedMap.exists = function(this1,key) {
	return this1.exists(key);
};
OrderedMap.remove = function(this1,key) {
	return this1.remove(key);
};
OrderedMap.keys = function(this1) {
	return this1.keys();
};
OrderedMap.iterator = function(this1) {
	return this1.iterator();
};
OrderedMap.keyValueIterator = function(this1) {
	return this1.keyValueIterator();
};
OrderedMap.copy = function(this1) {
	return this1.copy();
};
OrderedMap.get_length = function(this1) {
	return this1.get_length();
};
OrderedMap.get_orderedKeys = function(this1) {
	return this1.get_orderedKeys();
};
OrderedMap.get_innerMap = function(this1) {
	return this1.get_innerMap();
};
OrderedMap.keysCopy = function(this1) {
	return this1.keysCopy();
};
OrderedMap.clear = function(this1) {
	this1.clear();
};
OrderedMap.toString = function(this1) {
	return this1.toString();
};
OrderedMap.arrayWrite = function(this1,k,v) {
	this1.set(k,v);
	return v;
};
OrderedMap.toOrderedStringMap = function(t) {
	return new OrderedStringMapImpl();
};
OrderedMap.toOrderedIntMap = function(t) {
	return new OrderedIntMapImpl();
};
OrderedMap.toOrderedEnumValueMap = function(t) {
	return new OrderedEnumValueMapImpl();
};
OrderedMap.toOrderedObjectMap = function(t) {
	return new OrderedObjectMapImpl();
};
OrderedMap.fromOrderedStringMap = function(map) {
	return map;
};
OrderedMap.fromOrderedIntMap = function(map) {
	return map;
};
OrderedMap.fromOrderedObjectMap = function(map) {
	return map;
};
var OrderedObjectMap = {};
OrderedObjectMap._new = function() {
	return new OrderedObjectMapImpl();
};
OrderedObjectMap._get = function(this1,key) {
	return this1._innerMap.h[key.__id__];
};
OrderedObjectMap._set = function(this1,key,value) {
	this1.set(key,value);
	return value;
};
var OrderedObjectMapImpl = function() {
	this._innerMap = new haxe_ds_ObjectMap();
	this._orderedKeys = [];
};
$hxClasses["OrderedObjectMapImpl"] = OrderedObjectMapImpl;
OrderedObjectMapImpl.__name__ = "OrderedObjectMapImpl";
OrderedObjectMapImpl.__interfaces__ = [IOrderedMap];
OrderedObjectMapImpl.prototype = {
	_orderedKeys: null
	,_innerMap: null
	,set: function(key,value) {
		if(this._innerMap.h.__keys__[key.__id__] == null) {
			this._orderedKeys.push(key);
		}
		this._innerMap.set(key,value);
	}
	,get: function(key) {
		return this._innerMap.h[key.__id__];
	}
	,exists: function(key) {
		return this._innerMap.h.__keys__[key.__id__] != null;
	}
	,remove: function(key) {
		var removed = this._innerMap.remove(key);
		if(removed) {
			HxOverrides.remove(this._orderedKeys,key);
		}
		return removed;
	}
	,keys: function() {
		return new haxe_iterators_ArrayIterator(this._orderedKeys);
	}
	,iterator: function() {
		return new OrderedObjectMapIterator(this);
	}
	,keyValueIterator: function() {
		return new haxe_iterators_MapKeyValueIterator(this);
	}
	,copy: function() {
		var clone = new OrderedObjectMapImpl();
		clone._orderedKeys = this._orderedKeys.slice();
		clone._innerMap = this._innerMap.copy();
		return clone;
	}
	,get_length: function() {
		return this._orderedKeys.length;
	}
	,orderedKeys: null
	,get_orderedKeys: function() {
		return this._orderedKeys;
	}
	,innerMap: null
	,get_innerMap: function() {
		return this._innerMap;
	}
	,keysCopy: function() {
		return this._orderedKeys.slice();
	}
	,clear: function() {
		this._orderedKeys = [];
		this._innerMap = new haxe_ds_ObjectMap();
	}
	,toString: function() {
		var k;
		var len = this._orderedKeys.length;
		var str = "[";
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			k = this._orderedKeys[i];
			str += Std.string(k) + " => " + Std.string(this._innerMap.h[k.__id__]) + (i != len - 1 ? ", " : "");
		}
		return str + "]";
	}
	,__class__: OrderedObjectMapImpl
	,__properties__: {get_innerMap:"get_innerMap",get_orderedKeys:"get_orderedKeys",get_length:"get_length"}
};
var OrderedObjectMapIterator = function(omap) {
	this.index = 0;
	this.map = omap;
};
$hxClasses["OrderedObjectMapIterator"] = OrderedObjectMapIterator;
OrderedObjectMapIterator.__name__ = "OrderedObjectMapIterator";
OrderedObjectMapIterator.prototype = {
	map: null
	,index: null
	,hasNext: function() {
		return this.index < this.map._orderedKeys.length;
	}
	,next: function() {
		return this.map._innerMap.h[this.map._orderedKeys[this.index++].__id__];
	}
	,__class__: OrderedObjectMapIterator
};
var OrderedStringMap = {};
OrderedStringMap._new = function() {
	return new OrderedStringMapImpl();
};
OrderedStringMap._get = function(this1,key) {
	return this1._innerMap.h[key];
};
OrderedStringMap._set = function(this1,key,value) {
	this1.set(key,value);
	return value;
};
var OrderedStringMapImpl = function() {
	this._innerMap = new haxe_ds_StringMap();
	this._orderedKeys = [];
};
$hxClasses["OrderedStringMapImpl"] = OrderedStringMapImpl;
OrderedStringMapImpl.__name__ = "OrderedStringMapImpl";
OrderedStringMapImpl.__interfaces__ = [IOrderedMap];
OrderedStringMapImpl.prototype = {
	_orderedKeys: null
	,_innerMap: null
	,set: function(key,value) {
		if(!Object.prototype.hasOwnProperty.call(this._innerMap.h,key)) {
			this._orderedKeys.push(key);
		}
		this._innerMap.h[key] = value;
	}
	,get: function(key) {
		return this._innerMap.h[key];
	}
	,exists: function(key) {
		return Object.prototype.hasOwnProperty.call(this._innerMap.h,key);
	}
	,remove: function(key) {
		var _this = this._innerMap;
		var removed;
		if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
			delete(_this.h[key]);
			removed = true;
		} else {
			removed = false;
		}
		if(removed) {
			HxOverrides.remove(this._orderedKeys,key);
		}
		return removed;
	}
	,keys: function() {
		return new haxe_iterators_ArrayIterator(this._orderedKeys);
	}
	,iterator: function() {
		return new OrderedStringMapIterator(this);
	}
	,keyValueIterator: function() {
		return new haxe_iterators_MapKeyValueIterator(this);
	}
	,copy: function() {
		var clone = new OrderedStringMapImpl();
		clone._orderedKeys = this._orderedKeys.slice();
		clone._innerMap = haxe_ds_StringMap.createCopy(this._innerMap.h);
		return clone;
	}
	,get_length: function() {
		return this._orderedKeys.length;
	}
	,orderedKeys: null
	,get_orderedKeys: function() {
		return this._orderedKeys;
	}
	,innerMap: null
	,get_innerMap: function() {
		return this._innerMap;
	}
	,keysCopy: function() {
		return this._orderedKeys.slice();
	}
	,clear: function() {
		this._orderedKeys = [];
		this._innerMap = new haxe_ds_StringMap();
	}
	,toString: function() {
		var k;
		var len = this._orderedKeys.length;
		var str = "[";
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			k = this._orderedKeys[i];
			str += k + " => " + Std.string(this._innerMap.h[k]) + (i != len - 1 ? ", " : "");
		}
		return str + "]";
	}
	,__class__: OrderedStringMapImpl
	,__properties__: {get_innerMap:"get_innerMap",get_orderedKeys:"get_orderedKeys",get_length:"get_length"}
};
var OrderedStringMapIterator = function(omap) {
	this.index = 0;
	this.map = omap;
};
$hxClasses["OrderedStringMapIterator"] = OrderedStringMapIterator;
OrderedStringMapIterator.__name__ = "OrderedStringMapIterator";
OrderedStringMapIterator.prototype = {
	map: null
	,index: null
	,hasNext: function() {
		return this.index < this.map._orderedKeys.length;
	}
	,next: function() {
		return this.map._innerMap.h[this.map._orderedKeys[this.index++]];
	}
	,__class__: OrderedStringMapIterator
};
var ReadOnlyMap = {};
ReadOnlyMap.get = function(this1,k) {
	return this1.get(k);
};
ReadOnlyMap.arrayWrite = function(this1,k,v) {
	throw haxe_Exception.thrown("Cannot modify a ReadOnlyMap.");
};
ReadOnlyMap.set = function(this1,k,v) {
	throw haxe_Exception.thrown("Cannot modify a ReadOnlyMap.");
};
ReadOnlyMap.remove = function(this1,k) {
	throw haxe_Exception.thrown("Cannot modify a ReadOnlyMap.");
};
var Reflect = function() { };
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = "Reflect";
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		return null;
	}
};
Reflect.getProperty = function(o,field) {
	var tmp;
	if(o == null) {
		return null;
	} else {
		var tmp1;
		if(o.__properties__) {
			tmp = o.__properties__["get_" + field];
			tmp1 = tmp;
		} else {
			tmp1 = false;
		}
		if(tmp1) {
			return o[tmp]();
		} else {
			return o[field];
		}
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
Reflect.isEnumValue = function(v) {
	if(v != null) {
		return v.__enum__ != null;
	} else {
		return false;
	}
};
Reflect.deleteField = function(o,field) {
	if(!Object.prototype.hasOwnProperty.call(o,field)) {
		return false;
	}
	delete(o[field]);
	return true;
};
var Std = function() { };
$hxClasses["Std"] = Std;
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringBuf = function() {
	this.b = "";
};
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = "StringBuf";
StringBuf.prototype = {
	b: null
	,__class__: StringBuf
};
var StringTools = function() { };
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = "StringTools";
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return s.indexOf(end,slen - elen) == slen - elen;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	do {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
	} while(n > 0);
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var ValueType = $hxEnums["ValueType"] = { __ename__:"ValueType",__constructs__:null
	,TNull: {_hx_name:"TNull",_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_name:"TObject",_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_name:"TFunction",_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TClass",$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TEnum",$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_name:"TUnknown",_hx_index:8,__enum__:"ValueType",toString:$estr}
};
ValueType.__constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TClass,ValueType.TEnum,ValueType.TUnknown];
var Type = function() { };
$hxClasses["Type"] = Type;
Type.__name__ = "Type";
Type.createEnum = function(e,constr,params) {
	var f = Reflect.field(e,constr);
	if(f == null) {
		throw haxe_Exception.thrown("No such constructor " + constr);
	}
	if(Reflect.isFunction(f)) {
		if(params == null) {
			throw haxe_Exception.thrown("Constructor " + constr + " need parameters");
		}
		return f.apply(e,params);
	}
	if(params != null && params.length != 0) {
		throw haxe_Exception.thrown("Constructor " + constr + " does not need parameters");
	}
	return f;
};
Type.getInstanceFields = function(c) {
	var a = [];
	for(var i in c.prototype) a.push(i);
	HxOverrides.remove(a,"__class__");
	HxOverrides.remove(a,"__properties__");
	return a;
};
Type.typeof = function(v) {
	switch(typeof(v)) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum($hxEnums[e]);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		var e = a.__enum__;
		if(e == null || e != b.__enum__) {
			return false;
		}
		if(a._hx_index != b._hx_index) {
			return false;
		}
		var enm = $hxEnums[e];
		var params = enm.__constructs__[a._hx_index].__params__;
		var _g = 0;
		while(_g < params.length) {
			var f = params[_g];
			++_g;
			if(!Type.enumEq(a[f],b[f])) {
				return false;
			}
		}
	} catch( _g ) {
		return false;
	}
	return true;
};
Type.enumParameters = function(e) {
	var enm = $hxEnums[e.__enum__];
	var params = enm.__constructs__[e._hx_index].__params__;
	if(params != null) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < params.length) {
			var p = params[_g1];
			++_g1;
			_g.push(e[p]);
		}
		return _g;
	} else {
		return [];
	}
};
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__:"haxe.StackItem",__constructs__:null
	,CFunction: {_hx_name:"CFunction",_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Module",$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="FilePos",$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Method",$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="LocalFunction",$_.__params__ = ["v"],$_)
};
haxe_StackItem.__constructs__ = [haxe_StackItem.CFunction,haxe_StackItem.Module,haxe_StackItem.FilePos,haxe_StackItem.Method,haxe_StackItem.LocalFunction];
var haxe_CallStack = {};
haxe_CallStack.toString = function(stack) {
	var b = new StringBuf();
	var _g = 0;
	var _g1 = stack;
	while(_g < _g1.length) {
		var s = _g1[_g];
		++_g;
		b.b += "\nCalled from ";
		haxe_CallStack.itemToString(b,s);
	}
	return b.b;
};
haxe_CallStack.subtract = function(this1,stack) {
	var startIndex = -1;
	var i = -1;
	while(++i < this1.length) {
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var j = _g++;
			if(haxe_CallStack.equalItems(this1[i],stack[j])) {
				if(startIndex < 0) {
					startIndex = i;
				}
				++i;
				if(i >= this1.length) {
					break;
				}
			} else {
				startIndex = -1;
			}
		}
		if(startIndex >= 0) {
			break;
		}
	}
	if(startIndex >= 0) {
		return this1.slice(0,startIndex);
	} else {
		return this1;
	}
};
haxe_CallStack.equalItems = function(item1,item2) {
	if(item1 == null) {
		if(item2 == null) {
			return true;
		} else {
			return false;
		}
	} else {
		switch(item1._hx_index) {
		case 0:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 0) {
				return true;
			} else {
				return false;
			}
			break;
		case 1:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 1) {
				var m2 = item2.m;
				var m1 = item1.m;
				return m1 == m2;
			} else {
				return false;
			}
			break;
		case 2:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 2) {
				var item21 = item2.s;
				var file2 = item2.file;
				var line2 = item2.line;
				var col2 = item2.column;
				var col1 = item1.column;
				var line1 = item1.line;
				var file1 = item1.file;
				var item11 = item1.s;
				if(file1 == file2 && line1 == line2 && col1 == col2) {
					return haxe_CallStack.equalItems(item11,item21);
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 3:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 3) {
				var class2 = item2.classname;
				var method2 = item2.method;
				var method1 = item1.method;
				var class1 = item1.classname;
				if(class1 == class2) {
					return method1 == method2;
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 4:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 4) {
				var v2 = item2.v;
				var v1 = item1.v;
				return v1 == v2;
			} else {
				return false;
			}
			break;
		}
	}
};
haxe_CallStack.itemToString = function(b,s) {
	switch(s._hx_index) {
	case 0:
		b.b += "a C function";
		break;
	case 1:
		var m = s.m;
		b.b += "module ";
		b.b += m == null ? "null" : "" + m;
		break;
	case 2:
		var s1 = s.s;
		var file = s.file;
		var line = s.line;
		var col = s.column;
		if(s1 != null) {
			haxe_CallStack.itemToString(b,s1);
			b.b += " (";
		}
		b.b += file == null ? "null" : "" + file;
		b.b += " line ";
		b.b += line == null ? "null" : "" + line;
		if(col != null) {
			b.b += " column ";
			b.b += col == null ? "null" : "" + col;
		}
		if(s1 != null) {
			b.b += ")";
		}
		break;
	case 3:
		var cname = s.classname;
		var meth = s.method;
		b.b += Std.string(cname == null ? "<unknown>" : cname);
		b.b += ".";
		b.b += meth == null ? "null" : "" + meth;
		break;
	case 4:
		var n = s.v;
		b.b += "local function #";
		b.b += n == null ? "null" : "" + n;
		break;
	}
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
	this.__skipStack = 0;
	var old = Error.prepareStackTrace;
	Error.prepareStackTrace = function(e) { return e.stack; }
	if(((native) instanceof Error)) {
		this.stack = native.stack;
	} else {
		var e = null;
		if(Error.captureStackTrace) {
			Error.captureStackTrace(this,haxe_Exception);
			e = this;
		} else {
			e = new Error();
			if(typeof(e.stack) == "undefined") {
				try { throw e; } catch(_) {}
				this.__skipStack++;
			}
		}
		this.stack = e.stack;
	}
	Error.prepareStackTrace = old;
};
$hxClasses["haxe.Exception"] = haxe_Exception;
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		e.__skipStack++;
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	__skipStack: null
	,__nativeException: null
	,__previousException: null
	,unwrap: function() {
		return this.__nativeException;
	}
	,toString: function() {
		return this.get_message();
	}
	,details: function() {
		if(this.get_previous() == null) {
			var tmp = "Exception: " + this.toString();
			var tmp1 = this.get_stack();
			return tmp + (tmp1 == null ? "null" : haxe_CallStack.toString(tmp1));
		} else {
			var result = "";
			var e = this;
			var prev = null;
			while(e != null) {
				if(prev == null) {
					var result1 = "Exception: " + e.get_message();
					var tmp = e.get_stack();
					result = result1 + (tmp == null ? "null" : haxe_CallStack.toString(tmp)) + result;
				} else {
					var prevStack = haxe_CallStack.subtract(e.get_stack(),prev.get_stack());
					result = "Exception: " + e.get_message() + (prevStack == null ? "null" : haxe_CallStack.toString(prevStack)) + "\n\nNext " + result;
				}
				prev = e;
				e = e.get_previous();
			}
			return result;
		}
	}
	,__shiftStack: function() {
		this.__skipStack++;
	}
	,get_message: function() {
		return this.message;
	}
	,get_previous: function() {
		return this.__previousException;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,get_stack: function() {
		var _g = this.__exceptionStack;
		if(_g == null) {
			var value = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.normalize(this.stack),this.__skipStack);
			this.setProperty("__exceptionStack",value);
			return value;
		} else {
			var s = _g;
			return s;
		}
	}
	,setProperty: function(name,value) {
		try {
			Object.defineProperty(this,name,{ value : value});
		} catch( _g ) {
			this[name] = value;
		}
	}
	,__class__: haxe_Exception
	,__properties__: {get_native:"get_native",get_previous:"get_previous",get_stack:"get_stack",get_message:"get_message"}
});
var haxe_Int32 = {};
haxe_Int32.ucompare = function(a,b) {
	if(a < 0) {
		if(b < 0) {
			return ~b - ~a | 0;
		} else {
			return 1;
		}
	}
	if(b < 0) {
		return -1;
	} else {
		return a - b | 0;
	}
};
var haxe_Int64 = {};
haxe_Int64.divMod = function(dividend,divisor) {
	if(divisor.high == 0) {
		switch(divisor.low) {
		case 0:
			throw haxe_Exception.thrown("divide by zero");
		case 1:
			return { quotient : new haxe__$Int64__$_$_$Int64(dividend.high,dividend.low), modulus : new haxe__$Int64__$_$_$Int64(0,0)};
		}
	}
	var divSign = dividend.high < 0 != divisor.high < 0;
	var modulus;
	if(dividend.high < 0) {
		var high = ~dividend.high;
		var low = ~dividend.low + 1 | 0;
		if(low == 0) {
			var ret = high++;
			high = high | 0;
		}
		modulus = new haxe__$Int64__$_$_$Int64(high,low);
	} else {
		modulus = new haxe__$Int64__$_$_$Int64(dividend.high,dividend.low);
	}
	if(divisor.high < 0) {
		var high = ~divisor.high;
		var low = ~divisor.low + 1 | 0;
		if(low == 0) {
			var ret = high++;
			high = high | 0;
		}
		divisor = new haxe__$Int64__$_$_$Int64(high,low);
	}
	var quotient = new haxe__$Int64__$_$_$Int64(0,0);
	var mask = new haxe__$Int64__$_$_$Int64(0,1);
	while(!(divisor.high < 0)) {
		var v = haxe_Int32.ucompare(divisor.high,modulus.high);
		var cmp = v != 0 ? v : haxe_Int32.ucompare(divisor.low,modulus.low);
		var b = 1;
		b &= 63;
		divisor = b == 0 ? new haxe__$Int64__$_$_$Int64(divisor.high,divisor.low) : b < 32 ? new haxe__$Int64__$_$_$Int64(divisor.high << b | divisor.low >>> 32 - b,divisor.low << b) : new haxe__$Int64__$_$_$Int64(divisor.low << b - 32,0);
		var b1 = 1;
		b1 &= 63;
		mask = b1 == 0 ? new haxe__$Int64__$_$_$Int64(mask.high,mask.low) : b1 < 32 ? new haxe__$Int64__$_$_$Int64(mask.high << b1 | mask.low >>> 32 - b1,mask.low << b1) : new haxe__$Int64__$_$_$Int64(mask.low << b1 - 32,0);
		if(cmp >= 0) {
			break;
		}
	}
	while(true) {
		var b_high = 0;
		var b_low = 0;
		if(!(mask.high != b_high || mask.low != b_low)) {
			break;
		}
		var v = haxe_Int32.ucompare(modulus.high,divisor.high);
		if((v != 0 ? v : haxe_Int32.ucompare(modulus.low,divisor.low)) >= 0) {
			quotient = new haxe__$Int64__$_$_$Int64(quotient.high | mask.high,quotient.low | mask.low);
			var high = modulus.high - divisor.high | 0;
			var low = modulus.low - divisor.low | 0;
			if(haxe_Int32.ucompare(modulus.low,divisor.low) < 0) {
				var ret = high--;
				high = high | 0;
			}
			modulus = new haxe__$Int64__$_$_$Int64(high,low);
		}
		var b = 1;
		b &= 63;
		mask = b == 0 ? new haxe__$Int64__$_$_$Int64(mask.high,mask.low) : b < 32 ? new haxe__$Int64__$_$_$Int64(mask.high >>> b,mask.high << 32 - b | mask.low >>> b) : new haxe__$Int64__$_$_$Int64(0,mask.high >>> b - 32);
		var b1 = 1;
		b1 &= 63;
		divisor = b1 == 0 ? new haxe__$Int64__$_$_$Int64(divisor.high,divisor.low) : b1 < 32 ? new haxe__$Int64__$_$_$Int64(divisor.high >>> b1,divisor.high << 32 - b1 | divisor.low >>> b1) : new haxe__$Int64__$_$_$Int64(0,divisor.high >>> b1 - 32);
	}
	if(divSign) {
		var high = ~quotient.high;
		var low = ~quotient.low + 1 | 0;
		if(low == 0) {
			var ret = high++;
			high = high | 0;
		}
		quotient = new haxe__$Int64__$_$_$Int64(high,low);
	}
	if(dividend.high < 0) {
		var high = ~modulus.high;
		var low = ~modulus.low + 1 | 0;
		if(low == 0) {
			var ret = high++;
			high = high | 0;
		}
		modulus = new haxe__$Int64__$_$_$Int64(high,low);
	}
	return { quotient : quotient, modulus : modulus};
};
var haxe__$Int64__$_$_$Int64 = function(high,low) {
	this.high = high;
	this.low = low;
};
$hxClasses["haxe._Int64.___Int64"] = haxe__$Int64__$_$_$Int64;
haxe__$Int64__$_$_$Int64.__name__ = "haxe._Int64.___Int64";
haxe__$Int64__$_$_$Int64.prototype = {
	high: null
	,low: null
	,__class__: haxe__$Int64__$_$_$Int64
};
var haxe_Log = function() { };
$hxClasses["haxe.Log"] = haxe_Log;
haxe_Log.__name__ = "haxe.Log";
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_NativeStackTrace = function() { };
$hxClasses["haxe.NativeStackTrace"] = haxe_NativeStackTrace;
haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace";
haxe_NativeStackTrace.toHaxe = function(s,skip) {
	if(skip == null) {
		skip = 0;
	}
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var i = _g++;
			if(skip > i) {
				continue;
			}
			var line = stack[i];
			var matched = line.match(/^    at ([$A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
			if(matched != null) {
				var path = matched[1].split(".");
				if(path[0] == "$hxClasses") {
					path.shift();
				}
				var meth = path.pop();
				var file = matched[2];
				var line1 = Std.parseInt(matched[3]);
				var column = Std.parseInt(matched[4]);
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1,column));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else if(skip > 0 && Array.isArray(s)) {
		return s.slice(skip);
	} else {
		return s;
	}
};
haxe_NativeStackTrace.normalize = function(stack,skipItems) {
	if(skipItems == null) {
		skipItems = 0;
	}
	if(Array.isArray(stack) && skipItems > 0) {
		return stack.slice(skipItems);
	} else if(typeof(stack) == "string") {
		switch(stack.substring(0,6)) {
		case "Error\n":case "Error:":
			++skipItems;
			break;
		default:
		}
		return haxe_NativeStackTrace.skipLines(stack,skipItems);
	} else {
		return stack;
	}
};
haxe_NativeStackTrace.skipLines = function(stack,skip,pos) {
	if(pos == null) {
		pos = 0;
	}
	if(skip > 0) {
		pos = stack.indexOf("\n",pos);
		if(pos < 0) {
			return "";
		} else {
			return haxe_NativeStackTrace.skipLines(stack,--skip,pos + 1);
		}
	} else {
		return stack.substring(pos);
	}
};
var haxe_Serializer = function() {
	this.buf = new StringBuf();
	this.cache = [];
	this.useCache = haxe_Serializer.USE_CACHE;
	this.useEnumIndex = haxe_Serializer.USE_ENUM_INDEX;
	this.shash = new haxe_ds_StringMap();
	this.scount = 0;
};
$hxClasses["haxe.Serializer"] = haxe_Serializer;
haxe_Serializer.__name__ = "haxe.Serializer";
haxe_Serializer.run = function(v) {
	var s = new haxe_Serializer();
	s.serialize(v);
	return s.toString();
};
haxe_Serializer.prototype = {
	buf: null
	,cache: null
	,shash: null
	,scount: null
	,useCache: null
	,useEnumIndex: null
	,toString: function() {
		return this.buf.b;
	}
	,serializeString: function(s) {
		var x = this.shash.h[s];
		if(x != null) {
			this.buf.b += "R";
			this.buf.b += x == null ? "null" : "" + x;
			return;
		}
		this.shash.h[s] = this.scount++;
		this.buf.b += "y";
		s = encodeURIComponent(s);
		this.buf.b += Std.string(s.length);
		this.buf.b += ":";
		this.buf.b += s == null ? "null" : "" + s;
	}
	,serializeRef: function(v) {
		var vt = typeof(v);
		var _g = 0;
		var _g1 = this.cache.length;
		while(_g < _g1) {
			var i = _g++;
			var ci = this.cache[i];
			if(typeof(ci) == vt && ci == v) {
				this.buf.b += "r";
				this.buf.b += i == null ? "null" : "" + i;
				return true;
			}
		}
		this.cache.push(v);
		return false;
	}
	,serializeFields: function(v) {
		var _g = 0;
		var _g1 = Reflect.fields(v);
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.serializeString(f);
			this.serialize(Reflect.field(v,f));
		}
		this.buf.b += "g";
	}
	,serialize: function(v) {
		var _g = Type.typeof(v);
		switch(_g._hx_index) {
		case 0:
			this.buf.b += "n";
			break;
		case 1:
			var v1 = v;
			if(v1 == 0) {
				this.buf.b += "z";
				return;
			}
			this.buf.b += "i";
			this.buf.b += v1 == null ? "null" : "" + v1;
			break;
		case 2:
			var v1 = v;
			if(isNaN(v1)) {
				this.buf.b += "k";
			} else if(!isFinite(v1)) {
				this.buf.b += v1 < 0 ? "m" : "p";
			} else {
				this.buf.b += "d";
				this.buf.b += v1 == null ? "null" : "" + v1;
			}
			break;
		case 3:
			this.buf.b += v ? "t" : "f";
			break;
		case 4:
			if(js_Boot.__instanceof(v,Class)) {
				var className = v.__name__;
				this.buf.b += "A";
				this.serializeString(className);
			} else if(js_Boot.__instanceof(v,Enum)) {
				this.buf.b += "B";
				this.serializeString(v.__ename__);
			} else {
				if(this.useCache && this.serializeRef(v)) {
					return;
				}
				this.buf.b += "o";
				this.serializeFields(v);
			}
			break;
		case 5:
			throw haxe_Exception.thrown("Cannot serialize function");
		case 6:
			var c = _g.c;
			if(c == String) {
				this.serializeString(v);
				return;
			}
			if(this.useCache && this.serializeRef(v)) {
				return;
			}
			switch(c) {
			case Array:
				var ucount = 0;
				this.buf.b += "a";
				var l = v["length"];
				var _g1 = 0;
				var _g2 = l;
				while(_g1 < _g2) {
					var i = _g1++;
					if(v[i] == null) {
						++ucount;
					} else {
						if(ucount > 0) {
							if(ucount == 1) {
								this.buf.b += "n";
							} else {
								this.buf.b += "u";
								this.buf.b += ucount == null ? "null" : "" + ucount;
							}
							ucount = 0;
						}
						this.serialize(v[i]);
					}
				}
				if(ucount > 0) {
					if(ucount == 1) {
						this.buf.b += "n";
					} else {
						this.buf.b += "u";
						this.buf.b += ucount == null ? "null" : "" + ucount;
					}
				}
				this.buf.b += "h";
				break;
			case Date:
				var d = v;
				this.buf.b += "v";
				this.buf.b += Std.string(d.getTime());
				break;
			case haxe_ds_IntMap:
				this.buf.b += "q";
				var v1 = v;
				var k = v1.keys();
				while(k.hasNext()) {
					var k1 = k.next();
					this.buf.b += ":";
					this.buf.b += k1 == null ? "null" : "" + k1;
					this.serialize(v1.h[k1]);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_List:
				this.buf.b += "l";
				var v1 = v;
				var _g_head = v1.h;
				while(_g_head != null) {
					var val = _g_head.item;
					_g_head = _g_head.next;
					var i = val;
					this.serialize(i);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_ObjectMap:
				this.buf.b += "M";
				var v1 = v;
				var k = v1.keys();
				while(k.hasNext()) {
					var k1 = k.next();
					var id = Reflect.field(k1,"__id__");
					Reflect.deleteField(k1,"__id__");
					this.serialize(k1);
					k1["__id__"] = id;
					this.serialize(v1.h[k1.__id__]);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_StringMap:
				this.buf.b += "b";
				var v1 = v;
				var h = v1.h;
				var _g_h = h;
				var _g_keys = Object.keys(h);
				var _g_length = _g_keys.length;
				var _g_current = 0;
				while(_g_current < _g_length) {
					var k = _g_keys[_g_current++];
					this.serializeString(k);
					this.serialize(v1.h[k]);
				}
				this.buf.b += "h";
				break;
			case haxe_io_Bytes:
				var v1 = v;
				this.buf.b += "s";
				this.buf.b += Std.string(Math.ceil(v1.length * 8 / 6));
				this.buf.b += ":";
				var i = 0;
				var max = v1.length - 2;
				var b64 = haxe_Serializer.BASE64_CODES;
				if(b64 == null) {
					b64 = new Array(haxe_Serializer.BASE64.length);
					var _g1 = 0;
					var _g2 = haxe_Serializer.BASE64.length;
					while(_g1 < _g2) {
						var i1 = _g1++;
						b64[i1] = HxOverrides.cca(haxe_Serializer.BASE64,i1);
					}
					haxe_Serializer.BASE64_CODES = b64;
				}
				while(i < max) {
					var b1 = v1.b[i++];
					var b2 = v1.b[i++];
					var b3 = v1.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[(b1 << 4 | b2 >> 4) & 63]);
					this.buf.b += String.fromCodePoint(b64[(b2 << 2 | b3 >> 6) & 63]);
					this.buf.b += String.fromCodePoint(b64[b3 & 63]);
				}
				if(i == max) {
					var b1 = v1.b[i++];
					var b2 = v1.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[(b1 << 4 | b2 >> 4) & 63]);
					this.buf.b += String.fromCodePoint(b64[b2 << 2 & 63]);
				} else if(i == max + 1) {
					var b1 = v1.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[b1 << 4 & 63]);
				}
				break;
			default:
				if(this.useCache) {
					this.cache.pop();
				}
				if(v.hxSerialize != null) {
					this.buf.b += "C";
					this.serializeString(c.__name__);
					if(this.useCache) {
						this.cache.push(v);
					}
					v.hxSerialize(this);
					this.buf.b += "g";
				} else {
					this.buf.b += "c";
					this.serializeString(c.__name__);
					if(this.useCache) {
						this.cache.push(v);
					}
					this.serializeFields(v);
				}
			}
			break;
		case 7:
			var e = _g.e;
			if(this.useCache) {
				if(this.serializeRef(v)) {
					return;
				}
				this.cache.pop();
			}
			this.buf.b += Std.string(this.useEnumIndex ? "j" : "w");
			this.serializeString(e.__ename__);
			if(this.useEnumIndex) {
				this.buf.b += ":";
				this.buf.b += Std.string(v._hx_index);
			} else {
				var e = v;
				this.serializeString($hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name);
			}
			this.buf.b += ":";
			var params = Type.enumParameters(v);
			this.buf.b += Std.string(params.length);
			var _g = 0;
			while(_g < params.length) {
				var p = params[_g];
				++_g;
				this.serialize(p);
			}
			if(this.useCache) {
				this.cache.push(v);
			}
			break;
		default:
			throw haxe_Exception.thrown("Cannot serialize " + Std.string(v));
		}
	}
	,__class__: haxe_Serializer
};
var haxe__$Unserializer_DefaultResolver = function() {
};
$hxClasses["haxe._Unserializer.DefaultResolver"] = haxe__$Unserializer_DefaultResolver;
haxe__$Unserializer_DefaultResolver.__name__ = "haxe._Unserializer.DefaultResolver";
haxe__$Unserializer_DefaultResolver.prototype = {
	resolveClass: function(name) {
		return $hxClasses[name];
	}
	,resolveEnum: function(name) {
		return $hxEnums[name];
	}
	,__class__: haxe__$Unserializer_DefaultResolver
};
var haxe_Unserializer = function(buf) {
	this.buf = buf;
	this.length = this.buf.length;
	this.pos = 0;
	this.scache = [];
	this.cache = [];
	var r = haxe_Unserializer.DEFAULT_RESOLVER;
	if(r == null) {
		r = new haxe__$Unserializer_DefaultResolver();
		haxe_Unserializer.DEFAULT_RESOLVER = r;
	}
	this.resolver = r;
};
$hxClasses["haxe.Unserializer"] = haxe_Unserializer;
haxe_Unserializer.__name__ = "haxe.Unserializer";
haxe_Unserializer.initCodes = function() {
	var codes = [];
	var _g = 0;
	var _g1 = haxe_Unserializer.BASE64.length;
	while(_g < _g1) {
		var i = _g++;
		codes[haxe_Unserializer.BASE64.charCodeAt(i)] = i;
	}
	return codes;
};
haxe_Unserializer.run = function(v) {
	return new haxe_Unserializer(v).unserialize();
};
haxe_Unserializer.prototype = {
	buf: null
	,pos: null
	,length: null
	,cache: null
	,scache: null
	,resolver: null
	,readDigits: function() {
		var k = 0;
		var s = false;
		var fpos = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c == 45) {
				if(this.pos != fpos) {
					break;
				}
				s = true;
				this.pos++;
				continue;
			}
			if(c < 48 || c > 57) {
				break;
			}
			k = k * 10 + (c - 48);
			this.pos++;
		}
		if(s) {
			k *= -1;
		}
		return k;
	}
	,readFloat: function() {
		var p1 = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c >= 43 && c < 58 || c == 101 || c == 69) {
				this.pos++;
			} else {
				break;
			}
		}
		return parseFloat(HxOverrides.substr(this.buf,p1,this.pos - p1));
	}
	,unserializeObject: function(o) {
		while(true) {
			if(this.pos >= this.length) {
				throw haxe_Exception.thrown("Invalid object");
			}
			if(this.buf.charCodeAt(this.pos) == 103) {
				break;
			}
			var k = this.unserialize();
			if(typeof(k) != "string") {
				throw haxe_Exception.thrown("Invalid object key");
			}
			var v = this.unserialize();
			o[k] = v;
		}
		this.pos++;
	}
	,unserializeEnum: function(edecl,tag) {
		if(this.buf.charCodeAt(this.pos++) != 58) {
			throw haxe_Exception.thrown("Invalid enum format");
		}
		var nargs = this.readDigits();
		if(nargs == 0) {
			return Type.createEnum(edecl,tag);
		}
		var args = [];
		while(nargs-- > 0) args.push(this.unserialize());
		return Type.createEnum(edecl,tag,args);
	}
	,unserialize: function() {
		switch(this.buf.charCodeAt(this.pos++)) {
		case 65:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			return cl;
		case 66:
			var name = this.unserialize();
			var e = this.resolver.resolveEnum(name);
			if(e == null) {
				throw haxe_Exception.thrown("Enum not found " + name);
			}
			return e;
		case 67:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			var o = Object.create(cl.prototype);
			this.cache.push(o);
			o.hxUnserialize(this);
			if(this.buf.charCodeAt(this.pos++) != 103) {
				throw haxe_Exception.thrown("Invalid custom data");
			}
			return o;
		case 77:
			var h = new haxe_ds_ObjectMap();
			this.cache.push(h);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s = this.unserialize();
				h.set(s,this.unserialize());
			}
			this.pos++;
			return h;
		case 82:
			var n = this.readDigits();
			if(n < 0 || n >= this.scache.length) {
				throw haxe_Exception.thrown("Invalid string reference");
			}
			return this.scache[n];
		case 97:
			var buf = this.buf;
			var a = [];
			this.cache.push(a);
			while(true) {
				var c = this.buf.charCodeAt(this.pos);
				if(c == 104) {
					this.pos++;
					break;
				}
				if(c == 117) {
					this.pos++;
					var n = this.readDigits();
					a[a.length + n - 1] = null;
				} else {
					a.push(this.unserialize());
				}
			}
			return a;
		case 98:
			var h = new haxe_ds_StringMap();
			this.cache.push(h);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s = this.unserialize();
				var value = this.unserialize();
				h.h[s] = value;
			}
			this.pos++;
			return h;
		case 99:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			var o = Object.create(cl.prototype);
			this.cache.push(o);
			this.unserializeObject(o);
			return o;
		case 100:
			return this.readFloat();
		case 102:
			return false;
		case 105:
			return this.readDigits();
		case 106:
			var name = this.unserialize();
			var edecl = this.resolver.resolveEnum(name);
			if(edecl == null) {
				throw haxe_Exception.thrown("Enum not found " + name);
			}
			this.pos++;
			var index = this.readDigits();
			var _this = edecl.__constructs__;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = _this[i]._hx_name;
			}
			var tag = result[index];
			if(tag == null) {
				throw haxe_Exception.thrown("Unknown enum index " + name + "@" + index);
			}
			var e = this.unserializeEnum(edecl,tag);
			this.cache.push(e);
			return e;
		case 107:
			return NaN;
		case 108:
			var l = new haxe_ds_List();
			this.cache.push(l);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) l.add(this.unserialize());
			this.pos++;
			return l;
		case 109:
			return -Infinity;
		case 110:
			return null;
		case 111:
			var o = { };
			this.cache.push(o);
			this.unserializeObject(o);
			return o;
		case 112:
			return Infinity;
		case 113:
			var h = new haxe_ds_IntMap();
			this.cache.push(h);
			var buf = this.buf;
			var c = this.buf.charCodeAt(this.pos++);
			while(c == 58) {
				var i = this.readDigits();
				var value = this.unserialize();
				h.h[i] = value;
				c = this.buf.charCodeAt(this.pos++);
			}
			if(c != 104) {
				throw haxe_Exception.thrown("Invalid IntMap format");
			}
			return h;
		case 114:
			var n = this.readDigits();
			if(n < 0 || n >= this.cache.length) {
				throw haxe_Exception.thrown("Invalid reference");
			}
			return this.cache[n];
		case 115:
			var len = this.readDigits();
			var buf = this.buf;
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len) {
				throw haxe_Exception.thrown("Invalid bytes length");
			}
			var codes = haxe_Unserializer.CODES;
			if(codes == null) {
				codes = haxe_Unserializer.initCodes();
				haxe_Unserializer.CODES = codes;
			}
			var i = this.pos;
			var rest = len & 3;
			var size = (len >> 2) * 3 + (rest >= 2 ? rest - 1 : 0);
			var max = i + (len - rest);
			var bytes = new haxe_io_Bytes(new ArrayBuffer(size));
			var bpos = 0;
			while(i < max) {
				var c1 = codes[buf.charCodeAt(i++)];
				var c2 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c1 << 2 | c2 >> 4;
				var c3 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c2 << 4 | c3 >> 2;
				var c4 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c3 << 6 | c4;
			}
			if(rest >= 2) {
				var c1 = codes[buf.charCodeAt(i++)];
				var c2 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c1 << 2 | c2 >> 4;
				if(rest == 3) {
					var c3 = codes[buf.charCodeAt(i++)];
					bytes.b[bpos++] = c2 << 4 | c3 >> 2;
				}
			}
			this.pos += len;
			this.cache.push(bytes);
			return bytes;
		case 116:
			return true;
		case 118:
			var d;
			if(this.buf.charCodeAt(this.pos) >= 48 && this.buf.charCodeAt(this.pos) <= 57 && this.buf.charCodeAt(this.pos + 1) >= 48 && this.buf.charCodeAt(this.pos + 1) <= 57 && this.buf.charCodeAt(this.pos + 2) >= 48 && this.buf.charCodeAt(this.pos + 2) <= 57 && this.buf.charCodeAt(this.pos + 3) >= 48 && this.buf.charCodeAt(this.pos + 3) <= 57 && this.buf.charCodeAt(this.pos + 4) == 45) {
				d = HxOverrides.strDate(HxOverrides.substr(this.buf,this.pos,19));
				this.pos += 19;
			} else {
				d = new Date(this.readFloat());
			}
			this.cache.push(d);
			return d;
		case 119:
			var name = this.unserialize();
			var edecl = this.resolver.resolveEnum(name);
			if(edecl == null) {
				throw haxe_Exception.thrown("Enum not found " + name);
			}
			var e = this.unserializeEnum(edecl,this.unserialize());
			this.cache.push(e);
			return e;
		case 120:
			throw haxe_Exception.thrown(this.unserialize());
		case 121:
			var len = this.readDigits();
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len) {
				throw haxe_Exception.thrown("Invalid string length");
			}
			var s = HxOverrides.substr(this.buf,this.pos,len);
			this.pos += len;
			s = decodeURIComponent(s.split("+").join(" "));
			this.scache.push(s);
			return s;
		case 122:
			return 0;
		default:
		}
		this.pos--;
		throw haxe_Exception.thrown("Invalid char " + this.buf.charAt(this.pos) + " at position " + this.pos);
	}
	,__class__: haxe_Unserializer
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
	this.__skipStack++;
};
$hxClasses["haxe.ValueException"] = haxe_ValueException;
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	value: null
	,unwrap: function() {
		return this.value;
	}
	,__class__: haxe_ValueException
});
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
$hxClasses["haxe.io.Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	length: null
	,b: null
	,data: null
	,blit: function(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	,fill: function(pos,len,value) {
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			this.b[pos++] = value;
		}
	}
	,sub: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	,getDouble: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat64(pos,true);
	}
	,setDouble: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setFloat64(pos,v,true);
	}
	,getUInt16: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getUint16(pos,true);
	}
	,setUInt16: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setUint16(pos,v,true);
	}
	,getInt32: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getInt32(pos,true);
	}
	,setInt32: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setInt32(pos,v,true);
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:"haxe.io.Encoding",__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_ds_ArraySort = function() { };
$hxClasses["haxe.ds.ArraySort"] = haxe_ds_ArraySort;
haxe_ds_ArraySort.__name__ = "haxe.ds.ArraySort";
haxe_ds_ArraySort.sort = function(a,cmp) {
	haxe_ds_ArraySort.rec(a,cmp,0,a.length);
};
haxe_ds_ArraySort.rec = function(a,cmp,from,to) {
	var middle = from + to >> 1;
	if(to - from < 12) {
		if(to <= from) {
			return;
		}
		var _g = from + 1;
		var _g1 = to;
		while(_g < _g1) {
			var i = _g++;
			var j = i;
			while(j > from) {
				if(cmp(a[j],a[j - 1]) < 0) {
					haxe_ds_ArraySort.swap(a,j - 1,j);
				} else {
					break;
				}
				--j;
			}
		}
		return;
	}
	haxe_ds_ArraySort.rec(a,cmp,from,middle);
	haxe_ds_ArraySort.rec(a,cmp,middle,to);
	haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
};
haxe_ds_ArraySort.doMerge = function(a,cmp,from,pivot,to,len1,len2) {
	var first_cut;
	var second_cut;
	var len11;
	var len22;
	if(len1 == 0 || len2 == 0) {
		return;
	}
	if(len1 + len2 == 2) {
		if(cmp(a[pivot],a[from]) < 0) {
			haxe_ds_ArraySort.swap(a,pivot,from);
		}
		return;
	}
	if(len1 > len2) {
		len11 = len1 >> 1;
		first_cut = from + len11;
		second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
		len22 = second_cut - pivot;
	} else {
		len22 = len2 >> 1;
		second_cut = pivot + len22;
		first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
		len11 = first_cut - from;
	}
	haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
	var new_mid = first_cut + len22;
	haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
	haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
};
haxe_ds_ArraySort.rotate = function(a,cmp,from,mid,to) {
	if(from == mid || mid == to) {
		return;
	}
	var n = haxe_ds_ArraySort.gcd(to - from,mid - from);
	while(n-- != 0) {
		var val = a[from + n];
		var shift = mid - from;
		var p1 = from + n;
		var p2 = from + n + shift;
		while(p2 != from + n) {
			a[p1] = a[p2];
			p1 = p2;
			if(to - p2 > shift) {
				p2 += shift;
			} else {
				p2 = from + (shift - (to - p2));
			}
		}
		a[p1] = val;
	}
};
haxe_ds_ArraySort.gcd = function(m,n) {
	while(n != 0) {
		var t = m % n;
		m = n;
		n = t;
	}
	return m;
};
haxe_ds_ArraySort.upper = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[val],a[mid]) < 0) {
			len = half;
		} else {
			from = mid + 1;
			len = len - half - 1;
		}
	}
	return from;
};
haxe_ds_ArraySort.lower = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[mid],a[val]) < 0) {
			from = mid + 1;
			len = len - half - 1;
		} else {
			len = half;
		}
	}
	return from;
};
haxe_ds_ArraySort.swap = function(a,i,j) {
	var tmp = a[i];
	a[i] = a[j];
	a[j] = tmp;
};
var haxe_ds_BalancedTree = function() {
};
$hxClasses["haxe.ds.BalancedTree"] = haxe_ds_BalancedTree;
haxe_ds_BalancedTree.__name__ = "haxe.ds.BalancedTree";
haxe_ds_BalancedTree.__interfaces__ = [haxe_IMap];
haxe_ds_BalancedTree.prototype = {
	root: null
	,set: function(key,value) {
		this.root = this.setLoop(key,value,this.root);
	}
	,get: function(key) {
		var node = this.root;
		while(node != null) {
			var c = this.compare(key,node.key);
			if(c == 0) {
				return node.value;
			}
			if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return null;
	}
	,remove: function(key) {
		try {
			this.root = this.removeLoop(key,this.root);
			return true;
		} catch( _g ) {
			if(typeof(haxe_Exception.caught(_g).unwrap()) == "string") {
				return false;
			} else {
				throw _g;
			}
		}
	}
	,exists: function(key) {
		var node = this.root;
		while(node != null) {
			var c = this.compare(key,node.key);
			if(c == 0) {
				return true;
			} else if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return false;
	}
	,keys: function() {
		var ret = [];
		this.keysLoop(this.root,ret);
		return new haxe_iterators_ArrayIterator(ret);
	}
	,setLoop: function(k,v,node) {
		if(node == null) {
			return new haxe_ds_TreeNode(null,k,v,null);
		}
		var c = this.compare(k,node.key);
		if(c == 0) {
			return new haxe_ds_TreeNode(node.left,k,v,node.right,node == null ? 0 : node._height);
		} else if(c < 0) {
			var nl = this.setLoop(k,v,node.left);
			return this.balance(nl,node.key,node.value,node.right);
		} else {
			var nr = this.setLoop(k,v,node.right);
			return this.balance(node.left,node.key,node.value,nr);
		}
	}
	,removeLoop: function(k,node) {
		if(node == null) {
			throw haxe_Exception.thrown("Not_found");
		}
		var c = this.compare(k,node.key);
		if(c == 0) {
			return this.merge(node.left,node.right);
		} else if(c < 0) {
			return this.balance(this.removeLoop(k,node.left),node.key,node.value,node.right);
		} else {
			return this.balance(node.left,node.key,node.value,this.removeLoop(k,node.right));
		}
	}
	,keysLoop: function(node,acc) {
		if(node != null) {
			this.keysLoop(node.left,acc);
			acc.push(node.key);
			this.keysLoop(node.right,acc);
		}
	}
	,merge: function(t1,t2) {
		if(t1 == null) {
			return t2;
		}
		if(t2 == null) {
			return t1;
		}
		var t = this.minBinding(t2);
		return this.balance(t1,t.key,t.value,this.removeMinBinding(t2));
	}
	,minBinding: function(t) {
		if(t == null) {
			throw haxe_Exception.thrown("Not_found");
		} else if(t.left == null) {
			return t;
		} else {
			return this.minBinding(t.left);
		}
	}
	,removeMinBinding: function(t) {
		if(t.left == null) {
			return t.right;
		} else {
			return this.balance(this.removeMinBinding(t.left),t.key,t.value,t.right);
		}
	}
	,balance: function(l,k,v,r) {
		var hl = l == null ? 0 : l._height;
		var hr = r == null ? 0 : r._height;
		if(hl > hr + 2) {
			var _this = l.left;
			var _this1 = l.right;
			if((_this == null ? 0 : _this._height) >= (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(l.left,l.key,l.value,new haxe_ds_TreeNode(l.right,k,v,r));
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,new haxe_ds_TreeNode(l.right.right,k,v,r));
			}
		} else if(hr > hl + 2) {
			var _this = r.right;
			var _this1 = r.left;
			if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right);
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,new haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right));
			}
		} else {
			return new haxe_ds_TreeNode(l,k,v,r,(hl > hr ? hl : hr) + 1);
		}
	}
	,compare: function(k1,k2) {
		return Reflect.compare(k1,k2);
	}
	,__class__: haxe_ds_BalancedTree
};
var haxe_ds_TreeNode = function(l,k,v,r,h) {
	if(h == null) {
		h = -1;
	}
	this.left = l;
	this.key = k;
	this.value = v;
	this.right = r;
	if(h == -1) {
		var tmp;
		var _this = this.left;
		var _this1 = this.right;
		if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
			var _this = this.left;
			tmp = _this == null ? 0 : _this._height;
		} else {
			var _this = this.right;
			tmp = _this == null ? 0 : _this._height;
		}
		this._height = tmp + 1;
	} else {
		this._height = h;
	}
};
$hxClasses["haxe.ds.TreeNode"] = haxe_ds_TreeNode;
haxe_ds_TreeNode.__name__ = "haxe.ds.TreeNode";
haxe_ds_TreeNode.prototype = {
	left: null
	,right: null
	,key: null
	,value: null
	,_height: null
	,__class__: haxe_ds_TreeNode
};
var haxe_ds_EnumValueMap = function() {
	haxe_ds_BalancedTree.call(this);
};
$hxClasses["haxe.ds.EnumValueMap"] = haxe_ds_EnumValueMap;
haxe_ds_EnumValueMap.__name__ = "haxe.ds.EnumValueMap";
haxe_ds_EnumValueMap.__interfaces__ = [haxe_IMap];
haxe_ds_EnumValueMap.__super__ = haxe_ds_BalancedTree;
haxe_ds_EnumValueMap.prototype = $extend(haxe_ds_BalancedTree.prototype,{
	compare: function(k1,k2) {
		var d = k1._hx_index - k2._hx_index;
		if(d != 0) {
			return d;
		}
		var p1 = Type.enumParameters(k1);
		var p2 = Type.enumParameters(k2);
		if(p1.length == 0 && p2.length == 0) {
			return 0;
		}
		return this.compareArgs(p1,p2);
	}
	,compareArgs: function(a1,a2) {
		var ld = a1.length - a2.length;
		if(ld != 0) {
			return ld;
		}
		var _g = 0;
		var _g1 = a1.length;
		while(_g < _g1) {
			var i = _g++;
			var d = this.compareArg(a1[i],a2[i]);
			if(d != 0) {
				return d;
			}
		}
		return 0;
	}
	,compareArg: function(v1,v2) {
		if(Reflect.isEnumValue(v1) && Reflect.isEnumValue(v2)) {
			return this.compare(v1,v2);
		} else if(((v1) instanceof Array) && ((v2) instanceof Array)) {
			return this.compareArgs(v1,v2);
		} else {
			return Reflect.compare(v1,v2);
		}
	}
	,copy: function() {
		var copied = new haxe_ds_EnumValueMap();
		copied.root = this.root;
		return copied;
	}
	,__class__: haxe_ds_EnumValueMap
});
var haxe_ds_IntMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	h: null
	,get: function(key) {
		return this.h[key];
	}
	,exists: function(key) {
		return this.h.hasOwnProperty(key);
	}
	,remove: function(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(+key);
		return new haxe_iterators_ArrayIterator(a);
	}
	,copy: function() {
		var copied = new haxe_ds_IntMap();
		var key = this.keys();
		while(key.hasNext()) {
			var key1 = key.next();
			copied.h[key1] = this.h[key1];
		}
		return copied;
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_List = function() {
	this.length = 0;
};
$hxClasses["haxe.ds.List"] = haxe_ds_List;
haxe_ds_List.__name__ = "haxe.ds.List";
haxe_ds_List.prototype = {
	h: null
	,q: null
	,length: null
	,add: function(item) {
		var x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,push: function(item) {
		var x = new haxe_ds__$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	,pop: function() {
		if(this.h == null) {
			return null;
		}
		var x = this.h.item;
		this.h = this.h.next;
		if(this.h == null) {
			this.q = null;
		}
		this.length--;
		return x;
	}
	,clear: function() {
		this.h = null;
		this.q = null;
		this.length = 0;
	}
	,__class__: haxe_ds_List
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
$hxClasses["haxe.ds._List.ListNode"] = haxe_ds__$List_ListNode;
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
haxe_ds__$List_ListNode.prototype = {
	item: null
	,next: null
	,__class__: haxe_ds__$List_ListNode
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
$hxClasses["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap;
haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap";
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	h: null
	,set: function(key,value) {
		var id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,get: function(key) {
		return this.h[key.__id__];
	}
	,exists: function(key) {
		return this.h.__keys__[key.__id__] != null;
	}
	,remove: function(key) {
		var id = key.__id__;
		if(this.h.__keys__[id] == null) {
			return false;
		}
		delete(this.h[id]);
		delete(this.h.__keys__[id]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return new haxe_iterators_ArrayIterator(a);
	}
	,copy: function() {
		var copied = new haxe_ds_ObjectMap();
		var key = this.keys();
		while(key.hasNext()) {
			var key1 = key.next();
			copied.set(key1,this.h[key1.__id__]);
		}
		return copied;
	}
	,toString: function() {
		var s_b = "";
		s_b += "[";
		var it = this.keys();
		var i = it;
		while(i.hasNext()) {
			var i1 = i.next();
			s_b += Std.string(Std.string(i1));
			s_b += " => ";
			s_b += Std.string(Std.string(this.h[i1.__id__]));
			if(it.hasNext()) {
				s_b += ", ";
			}
		}
		s_b += "]";
		return s_b;
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.createCopy = function(h) {
	var copy = new haxe_ds_StringMap();
	for (var key in h) copy.h[key] = h[key];
	return copy;
};
haxe_ds_StringMap.prototype = {
	h: null
	,exists: function(key) {
		return Object.prototype.hasOwnProperty.call(this.h,key);
	}
	,get: function(key) {
		return this.h[key];
	}
	,keys: function() {
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.h);
	}
	,__class__: haxe_ds_StringMap
};
var haxe_ds__$StringMap_StringMapKeyIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
$hxClasses["haxe.ds._StringMap.StringMapKeyIterator"] = haxe_ds__$StringMap_StringMapKeyIterator;
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
haxe_ds__$StringMap_StringMapKeyIterator.prototype = {
	h: null
	,keys: null
	,length: null
	,current: null
	,hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.keys[this.current++];
	}
	,__class__: haxe_ds__$StringMap_StringMapKeyIterator
};
var haxe_ds__$StringMap_StringMapKeyValueIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
$hxClasses["haxe.ds._StringMap.StringMapKeyValueIterator"] = haxe_ds__$StringMap_StringMapKeyValueIterator;
haxe_ds__$StringMap_StringMapKeyValueIterator.__name__ = "haxe.ds._StringMap.StringMapKeyValueIterator";
haxe_ds__$StringMap_StringMapKeyValueIterator.prototype = {
	h: null
	,keys: null
	,length: null
	,current: null
	,hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		var key = this.keys[this.current++];
		return { key : key, value : this.h[key]};
	}
	,__class__: haxe_ds__$StringMap_StringMapKeyValueIterator
};
var haxe_exceptions_PosException = function(message,previous,pos) {
	haxe_Exception.call(this,message,previous);
	if(pos == null) {
		this.posInfos = { fileName : "(unknown)", lineNumber : 0, className : "(unknown)", methodName : "(unknown)"};
	} else {
		this.posInfos = pos;
	}
	this.__skipStack++;
};
$hxClasses["haxe.exceptions.PosException"] = haxe_exceptions_PosException;
haxe_exceptions_PosException.__name__ = "haxe.exceptions.PosException";
haxe_exceptions_PosException.__super__ = haxe_Exception;
haxe_exceptions_PosException.prototype = $extend(haxe_Exception.prototype,{
	posInfos: null
	,toString: function() {
		return "" + haxe_Exception.prototype.toString.call(this) + " in " + this.posInfos.className + "." + this.posInfos.methodName + " at " + this.posInfos.fileName + ":" + this.posInfos.lineNumber;
	}
	,__class__: haxe_exceptions_PosException
});
var haxe_exceptions_ArgumentException = function(argument,message,previous,pos) {
	haxe_exceptions_PosException.call(this,message == null ? "Invalid argument \"" + argument + "\"" : message,previous,pos);
	this.argument = argument;
	this.__skipStack++;
};
$hxClasses["haxe.exceptions.ArgumentException"] = haxe_exceptions_ArgumentException;
haxe_exceptions_ArgumentException.__name__ = "haxe.exceptions.ArgumentException";
haxe_exceptions_ArgumentException.__super__ = haxe_exceptions_PosException;
haxe_exceptions_ArgumentException.prototype = $extend(haxe_exceptions_PosException.prototype,{
	argument: null
	,__class__: haxe_exceptions_ArgumentException
});
var haxe_hash_Murmur1 = function() {
};
$hxClasses["haxe.hash.Murmur1"] = haxe_hash_Murmur1;
haxe_hash_Murmur1.__name__ = "haxe.hash.Murmur1";
haxe_hash_Murmur1.hash = function(b,seed) {
	if(seed == null) {
		seed = 0;
	}
	var length = b.length;
	var h = seed ^ haxe_Int32._mul(length,-962287725);
	var quarterLength = length >> 2;
	var _g = 0;
	var _g1 = quarterLength;
	while(_g < _g1) {
		var i = _g++;
		var pos = i << 2;
		var k = b.b[pos];
		k |= b.b[pos + 1] << 8;
		k |= b.b[pos + 2] << 16;
		k |= b.b[pos + 3] << 24;
		h = h + k | 0;
		h = haxe_Int32._mul(h,-962287725);
		h ^= h >>> 16;
	}
	var offset = quarterLength << 2;
	var rlen = length & 3;
	if(rlen == 3) {
		h = h + (b.b[offset + 2] << 16) | 0;
	}
	if(rlen >= 2) {
		h = h + (b.b[offset + 1] << 8) | 0;
	}
	if(rlen >= 1) {
		h = h + b.b[offset] | 0;
		h = haxe_Int32._mul(h,-962287725);
		h ^= h >>> 16;
	}
	h = haxe_Int32._mul(h,-962287725);
	h ^= h >>> 10;
	h = haxe_Int32._mul(h,-962287725);
	h ^= h >>> 17;
	return h;
};
haxe_hash_Murmur1.prototype = {
	__class__: haxe_hash_Murmur1
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:"haxe.io.Error",__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
$hxClasses["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator;
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	array: null
	,current: null
	,hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_iterators_MapKeyValueIterator = function(map) {
	this.map = map;
	this.keys = map.keys();
};
$hxClasses["haxe.iterators.MapKeyValueIterator"] = haxe_iterators_MapKeyValueIterator;
haxe_iterators_MapKeyValueIterator.__name__ = "haxe.iterators.MapKeyValueIterator";
haxe_iterators_MapKeyValueIterator.prototype = {
	map: null
	,keys: null
	,hasNext: function() {
		return this.keys.hasNext();
	}
	,next: function() {
		var key = this.keys.next();
		return { value : this.map.get(key), key : key};
	}
	,__class__: haxe_iterators_MapKeyValueIterator
};
var js_Boot = function() { };
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = "js.Boot";
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_lib__$ArrayBuffer_ArrayBufferCompat = function() { };
$hxClasses["js.lib._ArrayBuffer.ArrayBufferCompat"] = js_lib__$ArrayBuffer_ArrayBufferCompat;
js_lib__$ArrayBuffer_ArrayBufferCompat.__name__ = "js.lib._ArrayBuffer.ArrayBufferCompat";
js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var resultArray = new Uint8Array(u.byteLength);
	resultArray.set(u);
	return resultArray.buffer;
};
var js_$example_JsExample = function() {
	this.d = window.document;
	var _gthis = this;
	var input = this.d.getElementById("input");
	var ast = this.d.getElementById("ast");
	var output = this.d.getElementById("output");
	var version = this.d.getElementById("version");
	var buildDate = this.d.getElementById("build-date");
	var buildNumber = this.d.getElementById("build-number");
	haxe_Log.trace(input,{ fileName : "src/js_example/JsExample.js.hx", lineNumber : 31, className : "js_example.JsExample", methodName : "new", customParams : [ast,output]});
	input.addEventListener("keyup",function(_) {
		try {
			haxe_Log.trace(input.value,{ fileName : "src/js_example/JsExample.js.hx", lineNumber : 34, className : "js_example.JsExample", methodName : "new"});
			var tmp = little_interpreter_Interpreter.convert.apply(null,little_parser_Parser.parse(little_lexer_Lexer.lex(input.value)));
			ast.value = little_tools_PrettyPrinter.printInterpreterAst(tmp);
		} catch( _g ) {
		}
		try {
			haxe_Log.trace(input.value,{ fileName : "src/js_example/JsExample.js.hx", lineNumber : 39, className : "js_example.JsExample", methodName : "new"});
			little_Little.reset();
			little_Little.run(input.value,true);
			output.value = little_Little.runtime.stdout.output;
		} catch( _g ) {
		}
	});
	input.onkeydown = function(e) {
		if(e.key == "Tab") {
			e.preventDefault();
			var start = input.selectionStart;
			var end = input.selectionEnd;
			input.value = input.value.substring(0,start) + "\t" + input.value.substring(end);
			input.selectionStart = input.selectionEnd = start + 1;
		}
	};
	var keywordTable = this.d.getElementById("k-table-body");
	var update = function() {
		var firstRow = true;
		var _g = 0;
		var _g1 = keywordTable.rows;
		while(_g < _g1.length) {
			var row = _g1[_g];
			++_g;
			if(firstRow) {
				firstRow = false;
				continue;
			}
			var p = row.getElementsByTagName("p")[0];
			var input = row.getElementsByTagName("input")[0];
			p.innerText = _gthis.getCodeExample(input.id);
			p.onchange();
		}
	};
	var _g = 0;
	var _g1 = ["VARIABLE_DECLARATION","FUNCTION_DECLARATION","NULL_VALUE","RUN_CODE_FUNCTION_NAME","TYPE_DECL_OR_CAST","TYPE_FLOAT","TYPE_BOOLEAN","TYPE_STRING","TYPE_MODULE","FUNCTION_RETURN","READ_FUNCTION_NAME","TYPE_DYNAMIC","PROPERTY_ACCESS_SIGN","TRUE_VALUE","TYPE_INT","FALSE_VALUE","RAISE_ERROR_FUNCTION_NAME","TYPE_SIGN","PRINT_FUNCTION_NAME","TYPE_CAST_FUNCTION_PREFIX","EQUALS_SIGN","NOT_EQUALS_SIGN","LARGER_SIGN","SMALLER_SIGN","LARGER_EQUALS_SIGN","SMALLER_EQUALS_SIGN","AND_SIGN","OR_SIGN","XOR_SIGN"];
	while(_g < _g1.length) {
		var keyword = [_g1[_g]];
		++_g;
		var row = this.d.createElement("tr");
		var usage = this.d.createTextNode(js_$example_JsExample.snakeToTitleCase(keyword[0]));
		var input1 = [this.d.createElement("input")];
		input1[0].id = keyword[0];
		input1[0].placeholder = "single word, e.g. " + Std.string(Reflect.field(little_Little.keywords,keyword[0]));
		input1[0].onchange = (function(input,keyword) {
			return function() {
				little_Little.keywords[keyword[0]] = input[0].value != null ? input[0].value != "" ? input[0].value : Reflect.field(little_Little.keywords,keyword[0]) : Reflect.field(little_Little.keywords,keyword[0]);
				update();
			};
		})(input1,keyword);
		var p = this.d.createElement("p");
		var td1 = this.d.createElement("td");
		td1.appendChild(usage);
		var td2 = this.d.createElement("td");
		td2.appendChild(input1[0]);
		var td3 = this.d.createElement("td");
		td3.appendChild(p);
		row.appendChild(td1);
		row.appendChild(td2);
		row.appendChild(td3);
		keywordTable.appendChild(row);
	}
	Highlighter.registerOnParagraphs();
	document.getElementById("input").dispatchEvent(new Event("onkeyup"));
	update();
};
$hxClasses["js_example.JsExample"] = js_$example_JsExample;
js_$example_JsExample.__name__ = "js_example.JsExample";
js_$example_JsExample.snakeToTitleCase = function(str) {
	var words = str.split("_");
	var _g = 0;
	var _g1 = words.length;
	while(_g < _g1) {
		var i = _g++;
		var word = words[i];
		if(word.length > 0) {
			var firstChar = word.charAt(0);
			var rest = HxOverrides.substr(word,1,null);
			words[i] = firstChar.toUpperCase() + rest.toLowerCase();
		}
	}
	return words.join(" ");
};
js_$example_JsExample.prototype = {
	d: null
	,getCodeExample: function(keyword) {
		switch(keyword) {
		case "AND_SIGN":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x = " + little_Little.keywords.TRUE_VALUE + " " + little_Little.keywords.AND_SIGN + " " + little_Little.keywords.TRUE_VALUE + "\nif (x " + little_Little.keywords.AND_SIGN + " " + little_Little.keywords.TRUE_VALUE + ") {}";
		case "EQUALS_SIGN":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x = " + little_Little.keywords.TRUE_VALUE + " " + little_Little.keywords.EQUALS_SIGN + " " + little_Little.keywords.TRUE_VALUE + "\nif (x " + little_Little.keywords.EQUALS_SIGN + " " + little_Little.keywords.TRUE_VALUE + ") {}";
		case "FALSE_VALUE":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_Little.keywords.TYPE_BOOLEAN + " = " + little_Little.keywords.TRUE_VALUE + " " + little_Little.keywords.AND_SIGN + " " + little_Little.keywords.FALSE_VALUE + "\nif (" + little_Little.keywords.FALSE_VALUE + ") {}";
		case "FUNCTION_DECLARATION":
			return "" + little_Little.keywords.FUNCTION_DECLARATION + " y(" + little_Little.keywords.VARIABLE_DECLARATION + " parameter, " + little_Little.keywords.VARIABLE_DECLARATION + " times " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_Little.keywords.TYPE_INT + ") " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_Little.keywords.TYPE_STRING + " =  {\n&nbsp;&nbsp;&nbsp;&nbsp;" + little_Little.keywords.FUNCTION_RETURN + " parameter * times\n}\n" + little_Little.keywords.PRINT_FUNCTION_NAME + "(y(\"Hey\", 3))";
		case "FUNCTION_RETURN":
			return "" + little_Little.keywords.FUNCTION_DECLARATION + " y() = {\n&nbsp;&nbsp;&nbsp;&nbsp;" + little_Little.keywords.FUNCTION_RETURN + " 8\n}";
		case "LARGER_EQUALS_SIGN":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x = 5\nif (x " + little_Little.keywords.LARGER_EQUALS_SIGN + " 1 + 4) {}";
		case "LARGER_SIGN":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x = 5\nif (x " + little_Little.keywords.LARGER_SIGN + " 1) {}";
		case "NOT_EQUALS_SIGN":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x = " + little_Little.keywords.TRUE_VALUE + " " + little_Little.keywords.NOT_EQUALS_SIGN + " " + little_Little.keywords.TRUE_VALUE + "\nif (x " + little_Little.keywords.NOT_EQUALS_SIGN + " " + little_Little.keywords.TRUE_VALUE + ") {}";
		case "NULL_VALUE":
			return "if (x == " + little_Little.keywords.NULL_VALUE + ") {}\n" + little_Little.keywords.VARIABLE_DECLARATION + " x = " + little_Little.keywords.NULL_VALUE;
		case "OR_SIGN":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x = " + little_Little.keywords.TRUE_VALUE + " " + little_Little.keywords.OR_SIGN + " " + little_Little.keywords.TRUE_VALUE + "\nif (x " + little_Little.keywords.OR_SIGN + " " + little_Little.keywords.TRUE_VALUE + ") {}";
		case "PRINT_FUNCTION_NAME":
			return "" + little_Little.keywords.PRINT_FUNCTION_NAME + "(\"Hello World\")";
		case "PROPERTY_ACCESS_SIGN":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " len = 8" + little_Little.keywords.PROPERTY_ACCESS_SIGN + "type" + little_Little.keywords.PROPERTY_ACCESS_SIGN + "length\n" + little_Little.keywords.PRINT_FUNCTION_NAME + "(len" + little_Little.keywords.PROPERTY_ACCESS_SIGN + "type) //" + little_Little.keywords.TYPE_INT;
		case "RAISE_ERROR_FUNCTION_NAME":
			return "" + little_Little.keywords.RAISE_ERROR_FUNCTION_NAME + "(\"My Own Custom Error! :D\")";
		case "READ_FUNCTION_NAME":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x = 3\n" + little_Little.keywords.READ_FUNCTION_NAME + "(\"x\")";
		case "RUN_CODE_FUNCTION_NAME":
			return "" + little_Little.keywords.RUN_CODE_FUNCTION_NAME + "(\"" + little_Little.keywords.PRINT_FUNCTION_NAME + "(5 + 3)\")";
		case "SMALLER_EQUALS_SIGN":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x = 5\nif (x " + little_Little.keywords.SMALLER_EQUALS_SIGN + " -(1 + 4)) {}";
		case "SMALLER_SIGN":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x = -5\nif (x " + little_Little.keywords.SMALLER_SIGN + " 1) {}";
		case "TRUE_VALUE":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_Little.keywords.TYPE_BOOLEAN + " = " + little_Little.keywords.TRUE_VALUE + " " + little_Little.keywords.OR_SIGN + " " + little_Little.keywords.FALSE_VALUE + "\nif (" + little_Little.keywords.TRUE_VALUE + ") {}";
		case "TYPE_BOOLEAN":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_Little.keywords.TYPE_BOOLEAN + " = " + little_Little.keywords.TRUE_VALUE + " || " + little_Little.keywords.FALSE_VALUE;
		case "TYPE_CAST_FUNCTION_PREFIX":
			return "if (1" + little_Little.keywords.PROPERTY_ACCESS_SIGN + little_Little.keywords.TYPE_CAST_FUNCTION_PREFIX + little_Little.keywords.TYPE_BOOLEAN + "()) {\n&nbsp;&nbsp;&nbsp;&nbsp;" + little_Little.keywords.PRINT_FUNCTION_NAME + "(\"" + little_Little.keywords.TRUE_VALUE + "\"" + little_Little.keywords.PROPERTY_ACCESS_SIGN + little_Little.keywords.TYPE_CAST_FUNCTION_PREFIX + little_Little.keywords.TYPE_BOOLEAN + "()" + little_Little.keywords.PROPERTY_ACCESS_SIGN + little_Little.keywords.TYPE_CAST_FUNCTION_PREFIX + little_Little.keywords.TYPE_INT + "())\n}";
		case "TYPE_DECL_OR_CAST":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_Little.keywords.TYPE_STRING + "\nx = " + little_Little.keywords.TRUE_VALUE + " " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_Little.keywords.TYPE_STRING + " //\"" + little_Little.keywords.TRUE_VALUE + "\"";
		case "TYPE_DYNAMIC":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_Little.keywords.TYPE_DYNAMIC + " = nothing";
		case "TYPE_FLOAT":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_Little.keywords.TYPE_FLOAT + " = 8.8";
		case "TYPE_INT":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_Little.keywords.TYPE_INT + " = 8";
		case "TYPE_MODULE":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_Little.keywords.TYPE_MODULE + " = " + little_Little.keywords.TYPE_BOOLEAN;
		case "TYPE_SIGN":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_Little.keywords.TYPE_SIGN + " = +";
		case "TYPE_STRING":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_Little.keywords.TYPE_STRING + " = \"Hey There!\"";
		case "VARIABLE_DECLARATION":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_Little.keywords.TYPE_INT + " = 8";
		case "XOR_SIGN":
			return "" + little_Little.keywords.VARIABLE_DECLARATION + " x = " + little_Little.keywords.TRUE_VALUE + " " + little_Little.keywords.XOR_SIGN + " " + little_Little.keywords.TRUE_VALUE + "\nif (x " + little_Little.keywords.XOR_SIGN + " " + little_Little.keywords.TRUE_VALUE + ") {}";
		default:
			return "Unknown Keyword";
		}
	}
	,__class__: js_$example_JsExample
};
var little_tools__$TextTools_MultilangFonts = function() {
	this.serif = "assets/texter/TextTools/serif.ttf";
	this.sans = "assets/texter/TextTools/sans.ttf";
};
$hxClasses["little.tools._TextTools.MultilangFonts"] = little_tools__$TextTools_MultilangFonts;
little_tools__$TextTools_MultilangFonts.__name__ = "little.tools._TextTools.MultilangFonts";
little_tools__$TextTools_MultilangFonts.prototype = {
	sans: null
	,serif: null
	,__class__: little_tools__$TextTools_MultilangFonts
};
var little_tools_TextTools = function() { };
$hxClasses["little.tools.TextTools"] = little_tools_TextTools;
little_tools_TextTools.__name__ = "little.tools.TextTools";
little_tools_TextTools.replaceLast = function(string,replace,by) {
	var place = string.lastIndexOf(replace);
	var result = string.substring(0,place) + by + string.substring(place + replace.length);
	return result;
};
little_tools_TextTools.replaceFirst = function(string,replace,by) {
	var place = string.indexOf(replace);
	var result = string.substring(0,place) + by + string.substring(place + replace.length);
	return result;
};
little_tools_TextTools.splitOnFirst = function(string,delimiter) {
	var place = string.indexOf(delimiter);
	var result = [];
	result.push(string.substring(0,place));
	result.push(string.substring(place + delimiter.length));
	return result;
};
little_tools_TextTools.splitOnLast = function(string,delimiter) {
	var place = string.lastIndexOf(delimiter);
	var result = [];
	result.push(string.substring(0,place));
	result.push(string.substring(place + delimiter.length));
	return result;
};
little_tools_TextTools.splitOnParagraph = function(text) {
	return new EReg("<p>|</p>|\n\n|\r\n\r\n","g").split(text);
};
little_tools_TextTools.filter = function(text,filter) {
	if(((filter) instanceof EReg)) {
		var pattern = filter;
		text = text.replace(pattern.r,"");
		return text;
	}
	var patternType = filter;
	if(little_tools_TextTools.replaceFirst(text,"/","") != patternType) {
		var regexDetector = new EReg("^~?/(.*)/(.*)$","s");
		regexDetector.match(patternType);
		return filter(text,new EReg(regexDetector.matched(1),regexDetector.matched(2)));
	}
	switch(patternType.toLowerCase()) {
	case "alpha":
		return filter(text,new EReg("[^a-zA-Z]","g"));
	case "alphanumeric":
		return filter(text,new EReg("[^a-zA-Z0-9]","g"));
	case "numeric":
		return filter(text,new EReg("[^0-9]","g"));
	}
	return text;
};
little_tools_TextTools.indexesOf = function(string,sub) {
	var indexArray = [];
	var removedLength = 0;
	var index = string.indexOf(sub);
	while(index != -1) {
		indexArray.push({ startIndex : index + removedLength, endIndex : index + sub.length + removedLength - 1});
		removedLength += sub.length;
		string = string.substring(0,index) + string.substring(index + sub.length,string.length);
		index = string.indexOf(sub);
	}
	return indexArray;
};
little_tools_TextTools.indexesOfSubs = function(string,subs) {
	var indexArray = [];
	var orgString = string;
	var _g = 0;
	while(_g < subs.length) {
		var sub = subs[_g];
		++_g;
		var removedLength = 0;
		var index = string.indexOf(sub);
		while(index != -1) {
			indexArray.push({ startIndex : index + removedLength, endIndex : index + sub.length + removedLength});
			removedLength += sub.length;
			string = string.substring(0,index) + string.substring(index + sub.length,string.length);
			index = string.indexOf(sub);
		}
		string = orgString;
	}
	return indexArray;
};
little_tools_TextTools.indexesFromArray = function(string,subs) {
	return little_tools_TextTools.indexesOfSubs(string,subs);
};
little_tools_TextTools.indexesFromEReg = function(string,ereg) {
	var indexArray = [];
	while(ereg.match(string)) {
		var info = ereg.matchedPos();
		var by = little_tools_TextTools.multiply("",info.len);
		string = string.replace(ereg.r,by);
		indexArray.push({ startIndex : info.pos, endIndex : info.pos + info.len});
	}
	return indexArray;
};
little_tools_TextTools.multiply = function(string,times) {
	var stringcopy = string;
	if(times <= 0) {
		return "";
	}
	while(--times > 0) string += stringcopy;
	return string;
};
little_tools_TextTools.subtract = function(string,by) {
	return little_tools_TextTools.replaceLast(string,by,"");
};
little_tools_TextTools.loremIpsum = function(paragraphs,length) {
	if(length == null) {
		length = -1;
	}
	if(paragraphs == null) {
		paragraphs = 1;
	}
	var text = StringTools.replace(little_tools_TextTools.loremIpsumText,"\t","");
	var loremArray = new EReg("<p>|</p>|\n\n|\r\n\r\n","g").split(text);
	var loremText = loremArray.join("\n\n");
	if(paragraphs > loremArray.length) {
		var multiplier = Math.ceil(paragraphs / loremArray.length);
		loremText = little_tools_TextTools.multiply(little_tools_TextTools.loremIpsumText,multiplier);
		loremArray = new EReg("<p>|</p>|\n\n|\r\n\r\n","g").split(loremText);
	}
	while(loremArray.length > paragraphs) loremArray.pop();
	var loremString = loremArray.join("\n\n");
	if(length != -1) {
		return loremString.substring(0,length);
	}
	return loremString;
};
little_tools_TextTools.sortByLength = function(array) {
	array.sort(function(a,b) {
		return a.length - b.length;
	});
	return array;
};
little_tools_TextTools.sortByValue = function(array) {
	array.sort(function(a,b) {
		return a - b | 0;
	});
	return array;
};
little_tools_TextTools.sortByIntValue = function(array) {
	array.sort(function(a,b) {
		return a - b;
	});
	return array;
};
little_tools_TextTools.getLineIndexOfChar = function(string,index) {
	var lines = string.split("\n");
	var lineIndex = 0;
	var _g = 0;
	var _g1 = lines.length;
	while(_g < _g1) {
		var i = _g++;
		if(index < lines[i].length) {
			lineIndex = i;
			break;
		}
		index -= lines[i].length;
	}
	return lineIndex;
};
little_tools_TextTools.countOccurrencesOf = function(string,sub) {
	var count = 0;
	while(little_tools_TextTools.contains(string,sub)) {
		++count;
		string = little_tools_TextTools.replaceFirst(string,sub,"");
	}
	return count;
};
little_tools_TextTools.contains = function(string,contains) {
	if(string == null) {
		return false;
	}
	return string.indexOf(contains) != -1;
};
little_tools_TextTools.remove = function(string,sub) {
	return little_tools_TextTools.replace(string,sub,"");
};
little_tools_TextTools.replace = function(string,replace,$with) {
	if(replace == null || $with == null) {
		return string;
	}
	return StringTools.replace(string,replace,$with);
};
little_tools_TextTools.reverse = function(string) {
	var returnedString = "";
	var _g = 1;
	var _g1 = string.length + 1;
	while(_g < _g1) {
		var i = _g++;
		returnedString += string.charAt(string.length - 1);
	}
	return returnedString;
};
little_tools_TextTools.insert = function(string,substring,at) {
	return string.substring(0,at + 1) + substring + string.substring(at + 1);
};
little_tools_TextTools.parseBool = function(string) {
	if(string == "true" || parseFloat(string) != null && parseFloat(string) != 0) {
		return true;
	} else if(string == "false") {
		return false;
	} else {
		return null;
	}
};
little_tools_TextTools.containsAny = function(string,from) {
	var _g = 0;
	while(_g < from.length) {
		var i = from[_g];
		++_g;
		if(string.indexOf(i) != -1) {
			return true;
		}
	}
	return false;
};
var little_KeywordConfig = function(config,nullifyDefaults) {
	if(nullifyDefaults == null) {
		nullifyDefaults = true;
	}
	this.ELSE = "else";
	this.TYPE_CAST_FUNCTION_PREFIX = "to";
	this.FOR_LOOP_JUMP = "jump";
	this.FOR_LOOP_TO = "to";
	this.FOR_LOOP_FROM = "from";
	this.AND_SIGN = "&&";
	this.OR_SIGN = "||";
	this.XOR_SIGN = "^^";
	this.SMALLER_EQUALS_SIGN = "<=";
	this.LARGER_EQUALS_SIGN = ">=";
	this.SMALLER_SIGN = "<";
	this.LARGER_SIGN = ">";
	this.NOT_EQUALS_SIGN = "!=";
	this.EQUALS_SIGN = "==";
	this.PROPERTY_ACCESS_SIGN = ".";
	this.RECOGNIZED_SIGNS = [];
	this.CONDITION_TYPES = [];
	this.TYPE_UNKNOWN = "Unknown";
	this.THIS = "self";
	this.CONDITION_BODY_PARAMETER_NAME = "code";
	this.CONDITION_PATTERN_PARAMETER_NAME = "pattern";
	this.RUN_CODE_FUNCTION_NAME = "run";
	this.READ_FUNCTION_NAME = "read";
	this.RAISE_ERROR_FUNCTION_NAME = "error";
	this.PRINT_FUNCTION_NAME = "print";
	this.TO_STRING_PROPERTY_NAME = "toString";
	this.OBJECT_DOC_PROPERTY_NAME = "documentation";
	this.OBJECT_ADDRESS_PROPERTY_NAME = "address";
	this.OBJECT_TYPE_PROPERTY_NAME = "type";
	this.REGISTERED_MODULE_NAME = "Registered";
	this.MAIN_MODULE_NAME = "Main";
	this.TYPE_SIGN = "Sign";
	this.TYPE_MODULE = "Type";
	this.TYPE_CONDITION = "Condition";
	this.TYPE_FUNCTION = "Action";
	this.TYPE_STRING = "Characters";
	this.TYPE_BOOLEAN = "Boolean";
	this.TYPE_FLOAT = "Decimal";
	this.TYPE_INT = "Number";
	this.TYPE_DYNAMIC = "Anything";
	this.FALSE_VALUE = "false";
	this.TRUE_VALUE = "true";
	this.NULL_VALUE = "nothing";
	this.FUNCTION_RETURN = "return";
	this.TYPE_DECL_OR_CAST = "as";
	this.FUNCTION_DECLARATION = "action";
	this.VARIABLE_DECLARATION = "define";
	if(config == null) {
		return;
	}
	if(nullifyDefaults) {
		var fields = Type.getInstanceFields(little_KeywordConfig);
		HxOverrides.remove(fields,"defaultConfig");
		var _g = 0;
		while(_g < fields.length) {
			var field = fields[_g];
			++_g;
			var configValue = Reflect.field(config,field);
			if(configValue.length == 0) {
				throw new haxe_exceptions_ArgumentException("config." + field,"Keywords of length 0 are not allowed.",null,{ fileName : "src/little/KeywordConfig.hx", lineNumber : 45, className : "little.KeywordConfig", methodName : "new"});
			}
			if(little_tools_TextTools.contains(configValue," ")) {
				throw new haxe_exceptions_ArgumentException("config." + field,"Keywords cannot contain whitespaces.",null,{ fileName : "src/little/KeywordConfig.hx", lineNumber : 47, className : "little.KeywordConfig", methodName : "new"});
			}
			if(little_tools_TextTools.containsAny(configValue,little_KeywordConfig.recognizedOperators)) {
				throw new haxe_exceptions_ArgumentException("config." + field,"Keywords cannot contain operators/signs.",null,{ fileName : "src/little/KeywordConfig.hx", lineNumber : 49, className : "little.KeywordConfig", methodName : "new"});
			}
			if(new EReg("[0-9]","").match(configValue.charAt(0))) {
				throw new haxe_exceptions_ArgumentException("config." + field,"Keywords cannot start with numbers.",null,{ fileName : "src/little/KeywordConfig.hx", lineNumber : 51, className : "little.KeywordConfig", methodName : "new"});
			}
			if(configValue == Reflect.field(little_KeywordConfig.defaultConfig,field)) {
				this[field] = null;
			} else {
				this[field] = configValue;
			}
		}
	}
};
$hxClasses["little.KeywordConfig"] = little_KeywordConfig;
little_KeywordConfig.__name__ = "little.KeywordConfig";
little_KeywordConfig.prototype = {
	change: function(config) {
		var fields = Type.getInstanceFields(little_KeywordConfig);
		HxOverrides.remove(fields,"defaultConfig");
		var _g = 0;
		while(_g < fields.length) {
			var field = fields[_g];
			++_g;
			var configValue = Reflect.field(config,field);
			if(configValue == null) {
				continue;
			}
			this[field] = configValue;
		}
	}
	,VARIABLE_DECLARATION: null
	,FUNCTION_DECLARATION: null
	,TYPE_DECL_OR_CAST: null
	,FUNCTION_RETURN: null
	,NULL_VALUE: null
	,TRUE_VALUE: null
	,FALSE_VALUE: null
	,TYPE_DYNAMIC: null
	,TYPE_INT: null
	,TYPE_FLOAT: null
	,TYPE_BOOLEAN: null
	,TYPE_STRING: null
	,TYPE_FUNCTION: null
	,TYPE_CONDITION: null
	,TYPE_MODULE: null
	,TYPE_SIGN: null
	,MAIN_MODULE_NAME: null
	,REGISTERED_MODULE_NAME: null
	,OBJECT_TYPE_PROPERTY_NAME: null
	,OBJECT_ADDRESS_PROPERTY_NAME: null
	,OBJECT_DOC_PROPERTY_NAME: null
	,TO_STRING_PROPERTY_NAME: null
	,PRINT_FUNCTION_NAME: null
	,RAISE_ERROR_FUNCTION_NAME: null
	,READ_FUNCTION_NAME: null
	,RUN_CODE_FUNCTION_NAME: null
	,CONDITION_PATTERN_PARAMETER_NAME: null
	,CONDITION_BODY_PARAMETER_NAME: null
	,THIS: null
	,TYPE_UNKNOWN: null
	,CONDITION_TYPES: null
	,RECOGNIZED_SIGNS: null
	,PROPERTY_ACCESS_SIGN: null
	,EQUALS_SIGN: null
	,NOT_EQUALS_SIGN: null
	,LARGER_SIGN: null
	,SMALLER_SIGN: null
	,LARGER_EQUALS_SIGN: null
	,SMALLER_EQUALS_SIGN: null
	,XOR_SIGN: null
	,OR_SIGN: null
	,AND_SIGN: null
	,FOR_LOOP_FROM: null
	,FOR_LOOP_TO: null
	,FOR_LOOP_JUMP: null
	,TYPE_CAST_FUNCTION_PREFIX: null
	,ELSE: null
	,__class__: little_KeywordConfig
};
var little_interpreter_memory_Memory = function() {
	this.maxMemorySize = 2097152;
	this.memoryChunkSize = 512;
	this.storage = new little_interpreter_memory_Storage(this);
	this.referrer = new little_interpreter_memory_Referrer(this);
	this.constants = new little_interpreter_memory_ConstantPool(this);
	this.externs = new little_interpreter_memory_ExternalInterfacing(this);
};
$hxClasses["little.interpreter.memory.Memory"] = little_interpreter_memory_Memory;
little_interpreter_memory_Memory.__name__ = "little.interpreter.memory.Memory";
little_interpreter_memory_Memory.prototype = {
	storage: null
	,referrer: null
	,externs: null
	,constants: null
	,memoryChunkSize: null
	,maxMemorySize: null
	,get_currentMemorySize: function() {
		return this.storage.reserved.length + this.referrer.bytes.length;
	}
	,reset: function() {
		this.storage = new little_interpreter_memory_Storage(this);
		this.referrer = new little_interpreter_memory_Referrer(this);
		this.externs = new little_interpreter_memory_ExternalInterfacing(this);
	}
	,store: function(token) {
		var _this = [little_tools_InterpTokensSimple.TRUE_VALUE,little_tools_InterpTokensSimple.FALSE_VALUE,little_tools_InterpTokensSimple.NULL_VALUE].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1) {
			return this.constants.get(token);
		} else {
			var tmp;
			var _this = [little_tools_InterpTokensSimple.TRUE_VALUE,little_tools_InterpTokensSimple.FALSE_VALUE,little_tools_InterpTokensSimple.NULL_VALUE,little_tools_InterpTokensSimple.NUMBER,little_tools_InterpTokensSimple.DECIMAL,little_tools_InterpTokensSimple.SIGN,little_tools_InterpTokensSimple.CHARACTERS].slice();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) == -1) {
				var _this = [little_tools_InterpTokensSimple.CHARACTERS].slice();
				var result = new Array(_this.length);
				var _g = 0;
				var _g1 = _this.length;
				while(_g < _g1) {
					var i = _g++;
					var x = _this[i];
					result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
				}
				tmp = result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1;
			} else {
				tmp = true;
			}
			if(tmp) {
				return this.storage.storeStatic(token);
			} else {
				var _this = [little_tools_InterpTokensSimple.OBJECT].slice();
				var result = new Array(_this.length);
				var _g = 0;
				var _g1 = _this.length;
				while(_g < _g1) {
					var i = _g++;
					var x = _this[i];
					result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
				}
				if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1) {
					return this.storage.storeObject(token);
				} else {
					var _this = [little_tools_InterpTokensSimple.FUNCTION_CODE,little_tools_InterpTokensSimple.BLOCK].slice();
					var result = new Array(_this.length);
					var _g = 0;
					var _g1 = _this.length;
					while(_g < _g1) {
						var i = _g++;
						var x = _this[i];
						result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
					}
					if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1) {
						return this.storage.storeCodeBlock(token);
					} else {
						var _this = [little_tools_InterpTokensSimple.CONDITION_CODE].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1) {
							return this.storage.storeCondition(token);
						} else {
							var _this = [little_tools_InterpTokensSimple.CLASS_POINTER].slice();
							var result = new Array(_this.length);
							var _g = 0;
							var _g1 = _this.length;
							while(_g < _g1) {
								var i = _g++;
								var x = _this[i];
								result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
							}
							if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1) {
								return Type.enumParameters(token)[0];
							}
						}
					}
				}
			}
		}
		little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Unable to allocate memory for token `" + Std.string(token) + "`."),"Memory, Storage");
		return this.constants.NULL;
	}
	,retrieve: function(token) {
		var tmp;
		var _this = [little_tools_InterpTokensSimple.TRUE_VALUE,little_tools_InterpTokensSimple.FALSE_VALUE,little_tools_InterpTokensSimple.NULL_VALUE,little_tools_InterpTokensSimple.OBJECT,little_tools_InterpTokensSimple.FUNCTION_CODE,little_tools_InterpTokensSimple.BLOCK,little_tools_InterpTokensSimple.CONDITION_CODE,little_tools_InterpTokensSimple.CLASS_POINTER].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) == -1) {
			var _this = [little_tools_InterpTokensSimple.TRUE_VALUE,little_tools_InterpTokensSimple.FALSE_VALUE,little_tools_InterpTokensSimple.NULL_VALUE,little_tools_InterpTokensSimple.NUMBER,little_tools_InterpTokensSimple.DECIMAL,little_tools_InterpTokensSimple.SIGN,little_tools_InterpTokensSimple.CHARACTERS].slice();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			tmp = result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1;
		} else {
			tmp = true;
		}
		if(tmp) {
			return this.store(token);
		} else {
			switch(token._hx_index) {
			case 11:
				var _g = token.parts;
				var _g = token.type;
				var result = little_interpreter_Interpreter.evaluate(token);
				switch(result._hx_index) {
				case 14:
					var _g = result.name;
					var _g = result.property;
					this.retrieve(result);
					break;
				case 24:
					var _g = result.word;
					this.retrieve(result);
					break;
				default:
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Code block returned a value that cannot be read from (for value: " + little_tools_PrettyPrinter.stringifyInterpreter(null,result) + ")"));
					throw haxe_Exception.thrown("Unable to retrieve a pointer to token " + Std.string(result));
				}
				break;
			case 12:
				var _g = token.body;
				var _g = token.type;
				var result = little_interpreter_Interpreter.evaluate(token);
				switch(result._hx_index) {
				case 14:
					var _g = result.name;
					var _g = result.property;
					this.retrieve(result);
					break;
				case 24:
					var _g = result.word;
					this.retrieve(result);
					break;
				default:
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Code block returned a value that cannot be read from (for value: " + little_tools_PrettyPrinter.stringifyInterpreter(null,result) + ")"));
					throw haxe_Exception.thrown("Unable to retrieve a pointer to token " + Std.string(result));
				}
				break;
			case 14:
				var _g = token.name;
				var _g = token.property;
				var path = little_tools_Extensions.asStringPath(token);
				var cell = ($_=this,$_.read.apply($_,path));
				var token1 = cell.objectValue;
				var _this = [little_tools_InterpTokensSimple.TRUE_VALUE,little_tools_InterpTokensSimple.FALSE_VALUE,little_tools_InterpTokensSimple.NULL_VALUE,little_tools_InterpTokensSimple.NUMBER,little_tools_InterpTokensSimple.DECIMAL,little_tools_InterpTokensSimple.SIGN,little_tools_InterpTokensSimple.CHARACTERS].slice();
				var result = new Array(_this.length);
				var _g = 0;
				var _g1 = _this.length;
				while(_g < _g1) {
					var i = _g++;
					var x = _this[i];
					result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
				}
				if(result.indexOf($hxEnums[token1.__enum__].__constructs__[token1._hx_index]._hx_name.toLowerCase()) != -1) {
					return this.store(cell.objectValue);
				}
				return cell.objectAddress;
			case 24:
				var _g = token.word;
				var path = little_tools_Extensions.asStringPath(token);
				var cell = ($_=this,$_.read.apply($_,path));
				var token1 = cell.objectValue;
				var _this = [little_tools_InterpTokensSimple.TRUE_VALUE,little_tools_InterpTokensSimple.FALSE_VALUE,little_tools_InterpTokensSimple.NULL_VALUE,little_tools_InterpTokensSimple.NUMBER,little_tools_InterpTokensSimple.DECIMAL,little_tools_InterpTokensSimple.SIGN,little_tools_InterpTokensSimple.CHARACTERS].slice();
				var result = new Array(_this.length);
				var _g = 0;
				var _g1 = _this.length;
				while(_g < _g1) {
					var i = _g++;
					var x = _this[i];
					result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
				}
				if(result.indexOf($hxEnums[token1.__enum__].__constructs__[token1._hx_index]._hx_name.toLowerCase()) != -1) {
					return this.store(cell.objectValue);
				}
				return cell.objectAddress;
			default:
			}
		}
		little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Unable to retrieve a pointer to token " + Std.string(token)));
		return this.constants.NULL;
	}
	,valueFromType: function(address,type,fullPath) {
		var $l=arguments.length;
		var currentPath = new Array($l>3?$l-3:0);
		for(var $i=3;$i<$l;++$i){currentPath[$i-3]=arguments[$i];}
		var _hx_tmp;
		var _hx_tmp1;
		var _hx_tmp2;
		var _hx_tmp3;
		var _hx_tmp4;
		var _hx_tmp5;
		var _hx_tmp6;
		var _hx_tmp7;
		var _hx_tmp8;
		if(type == little_Little.keywords.TYPE_STRING == true) {
			return little_interpreter_InterpTokens.Characters(this.storage.readString(address));
		} else {
			_hx_tmp8 = type == little_Little.keywords.TYPE_INT;
			if(_hx_tmp8 == true) {
				return little_interpreter_InterpTokens.Number(this.storage.readInt32(address));
			} else {
				_hx_tmp7 = type == little_Little.keywords.TYPE_FLOAT;
				if(_hx_tmp7 == true) {
					return little_interpreter_InterpTokens.Decimal(this.storage.readDouble(address));
				} else {
					_hx_tmp6 = type == little_Little.keywords.TYPE_BOOLEAN;
					if(_hx_tmp6 == true) {
						return this.constants.getFromPointer(address);
					} else {
						_hx_tmp5 = type == little_Little.keywords.TYPE_FUNCTION;
						if(_hx_tmp5 == true) {
							return this.storage.readCodeBlock(address);
						} else {
							_hx_tmp4 = type == little_Little.keywords.TYPE_CONDITION;
							if(_hx_tmp4 == true) {
								return this.storage.readCondition(address);
							} else {
								_hx_tmp3 = type == little_Little.keywords.TYPE_MODULE;
								if(_hx_tmp3 == true) {
									return little_interpreter_InterpTokens.ClassPointer(address);
								} else {
									_hx_tmp2 = (type == little_Little.keywords.TYPE_DYNAMIC || type == little_Little.keywords.TYPE_UNKNOWN) && this.constants.hasPointer(address) && Type.enumEq(this.constants.getFromPointer(address),little_interpreter_InterpTokens.NullValue);
									if(_hx_tmp2 == true) {
										return little_interpreter_InterpTokens.NullValue;
									} else {
										_hx_tmp1 = type == little_Little.keywords.TYPE_SIGN;
										if(_hx_tmp1 == true) {
											return this.storage.readSign(address);
										} else {
											_hx_tmp = type == little_Little.keywords.TYPE_UNKNOWN;
											if(_hx_tmp == true) {
												return little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Could not get the value at " + fullPath.join(little_Little.keywords.PROPERTY_ACCESS_SIGN) + " - field " + currentPath.slice().join(little_Little.keywords.PROPERTY_ACCESS_SIGN) + " was declared, but has no value/type."),"Memory, Storage");
											} else {
												return this.storage.readObject(address);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	,read: function() {
		var $l=arguments.length;
		var path = new Array($l>0?$l-0:0);
		for(var $i=0;$i<$l;++$i){path[$i-0]=arguments[$i];}
		if(path.length == 0) {
			return { objectValue : null, objectTypeName : null, objectAddress : null};
		}
		var current = null;
		var currentAddress = null;
		var currentType = null;
		var processed = path.slice();
		var wentThroughPath = [];
		if(this.externs.hasGlobal(processed[0])) {
			if(($_=this.externs,$_.hasGlobal.apply($_,path))) {
				var object = ($_=this.externs,$_.getGlobal.apply($_,path));
				var typeName = this.getTypeName(($_=this.externs,$_.createPathFor.apply($_,[this.externs.globalProperties].concat(path))).type);
				return { objectValue : object.objectValue, objectTypeName : typeName, objectAddress : object.objectAddress};
			} else {
				var external = [processed.shift()];
				wentThroughPath.push(external[0]);
				while(($_=this.externs,$_.hasGlobal.apply($_,external.concat([processed[0]])))) {
					external.push(processed.shift());
					wentThroughPath.push(external[external.length - 1]);
				}
				var object = ($_=this.externs,$_.getGlobal.apply($_,external));
				current = object.objectValue;
				currentAddress = object.objectAddress;
				currentType = this.getTypeName(($_=this.externs,$_.createPathFor.apply($_,[this.externs.globalProperties].concat(external))).type);
			}
		} else {
			if(!this.referrer.exists(path[0])) {
				little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Variable `" + path[0] + "` does not exist"),"Memory, Referrer");
			}
			var data = this.referrer.get(path[0]);
			current = this.valueFromType(data.address,data.type,path.slice(),path[0]);
			currentAddress = data.address;
			currentType = data.type;
			wentThroughPath.push(processed.shift());
		}
		while(processed.length > 0) {
			var identifier = processed.shift();
			wentThroughPath.push(identifier);
			var typeName = little_tools_Extensions.type(current);
			if(($_=this.externs,$_.hasInstance.apply($_,typeName.split(little_Little.keywords.PROPERTY_ACCESS_SIGN)))) {
				var classProperties = this.externs.instanceProperties.properties.h[typeName];
				if(Object.prototype.hasOwnProperty.call(classProperties.properties.h,identifier)) {
					var newCurrent = classProperties.properties.h[identifier].getter(current,currentAddress);
					current = newCurrent.objectValue;
					currentAddress = newCurrent.objectAddress;
					continue;
				}
			}
			if(($_=this.externs,$_.hasInstance.apply($_,little_Little.keywords.TYPE_DYNAMIC.split(little_Little.keywords.PROPERTY_ACCESS_SIGN)))) {
				var classProperties1 = this.externs.instanceProperties.properties.h[little_Little.keywords.TYPE_DYNAMIC];
				if(Object.prototype.hasOwnProperty.call(classProperties1.properties.h,identifier)) {
					var newCurrent1 = classProperties1.properties.h[identifier].getter(current,currentAddress);
					current = newCurrent1.objectValue;
					currentAddress = newCurrent1.objectAddress;
					continue;
				}
			}
			var _this = [little_tools_InterpTokensSimple.OBJECT].slice();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			if(result.indexOf($hxEnums[current.__enum__].__constructs__[current._hx_index]._hx_name.toLowerCase()) != -1) {
				var objectHashTableBytes = little_interpreter_memory_HashTables.getHashTableOf(currentAddress,this.storage);
				if(little_interpreter_memory_HashTables.hashTableHasKey(objectHashTableBytes,identifier,this.storage)) {
					var keyData = little_interpreter_memory_HashTables.hashTableGetKey(objectHashTableBytes,identifier,this.storage);
					current = ($_=this,$_.valueFromType.apply($_,[keyData.value,this.getTypeName(keyData.type),path.slice()].concat(wentThroughPath)));
					currentAddress = keyData.value;
				}
			} else {
				wentThroughPath.pop();
				var p = wentThroughPath.join(little_Little.keywords.PROPERTY_ACCESS_SIGN);
				var tmp = little_Little.runtime;
				var tmp1 = "Field `" + identifier + "` does not exist on `" + p + "` ";
				var _this1 = [little_tools_InterpTokensSimple.NULL_VALUE].slice();
				var result1 = new Array(_this1.length);
				var _g2 = 0;
				var _g3 = _this1.length;
				while(_g2 < _g3) {
					var i1 = _g2++;
					var x1 = _this1[i1];
					result1[i1] = little_tools_TextTools.remove($hxEnums[x1.__enum__].__constructs__[x1._hx_index]._hx_name,"_").toLowerCase();
				}
				tmp.throwError(little_interpreter_InterpTokens.ErrorMessage(tmp1 + (result1.indexOf($hxEnums[current.__enum__].__constructs__[current._hx_index]._hx_name.toLowerCase()) != -1 ? "(`" + p + "` is `" + little_Little.keywords.NULL_VALUE + "`)" : "")));
				return { objectValue : little_interpreter_InterpTokens.NullValue, objectAddress : this.constants.NULL, objectTypeName : little_Little.keywords.TYPE_DYNAMIC};
			}
		}
		return { objectValue : current, objectAddress : currentAddress, objectTypeName : little_tools_Extensions.type(current)};
	}
	,readFrom: function(value) {
		var $l=arguments.length;
		var path = new Array($l>1?$l-1:0);
		for(var $i=1;$i<$l;++$i){path[$i-1]=arguments[$i];}
		var current = value.objectValue;
		var currentAddress = value.objectAddress;
		var processed = path.slice();
		var wentThroughPath = [];
		while(processed.length > 0) {
			var identifier = processed.shift();
			wentThroughPath.push(identifier);
			var typeName = little_tools_Extensions.type(current);
			if(($_=this.externs,$_.hasInstance.apply($_,typeName.split(little_Little.keywords.PROPERTY_ACCESS_SIGN)))) {
				var classProperties = this.externs.instanceProperties.properties.h[typeName];
				if(Object.prototype.hasOwnProperty.call(classProperties.properties.h,identifier)) {
					var newCurrent = classProperties.properties.h[identifier].getter(current,currentAddress);
					current = newCurrent.objectValue;
					currentAddress = newCurrent.objectAddress;
					continue;
				}
			}
			if(($_=this.externs,$_.hasInstance.apply($_,little_Little.keywords.TYPE_DYNAMIC.split(little_Little.keywords.PROPERTY_ACCESS_SIGN)))) {
				var classProperties1 = this.externs.instanceProperties.properties.h[little_Little.keywords.TYPE_DYNAMIC];
				if(Object.prototype.hasOwnProperty.call(classProperties1.properties.h,identifier)) {
					var newCurrent1 = classProperties1.properties.h[identifier].getter(current,currentAddress);
					current = newCurrent1.objectValue;
					currentAddress = newCurrent1.objectAddress;
					continue;
				}
			}
			var _this = [little_tools_InterpTokensSimple.OBJECT].slice();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			if(result.indexOf($hxEnums[current.__enum__].__constructs__[current._hx_index]._hx_name.toLowerCase()) != -1) {
				var objectHashTableBytesLength = this.storage.readInt32(currentAddress);
				var objectHashTableBytes = this.storage.readBytes(little_interpreter_memory_MemoryPointer.fromInt(currentAddress + 4),objectHashTableBytesLength);
				if(little_interpreter_memory_HashTables.hashTableHasKey(objectHashTableBytes,identifier,this.storage)) {
					var keyData = little_interpreter_memory_HashTables.hashTableGetKey(objectHashTableBytes,identifier,this.storage);
					current = ($_=this,$_.valueFromType.apply($_,[keyData.value,this.getTypeName(keyData.type),[little_tools_PrettyPrinter.stringifyInterpreter(null,value.objectValue)].concat(path.slice())].concat(wentThroughPath)));
					currentAddress = keyData.value;
				}
			} else {
				wentThroughPath.pop();
				var p = wentThroughPath.join(little_Little.keywords.PROPERTY_ACCESS_SIGN);
				var tmp = little_Little.runtime;
				var tmp1 = "Field `" + identifier + "` does not exist on `" + p + "` ";
				var _this1 = [little_tools_InterpTokensSimple.NULL_VALUE].slice();
				var result1 = new Array(_this1.length);
				var _g2 = 0;
				var _g3 = _this1.length;
				while(_g2 < _g3) {
					var i1 = _g2++;
					var x1 = _this1[i1];
					result1[i1] = little_tools_TextTools.remove($hxEnums[x1.__enum__].__constructs__[x1._hx_index]._hx_name,"_").toLowerCase();
				}
				tmp.throwError(little_interpreter_InterpTokens.ErrorMessage(tmp1 + (result1.indexOf($hxEnums[current.__enum__].__constructs__[current._hx_index]._hx_name.toLowerCase()) != -1 ? "(`" + p + "` is `" + little_Little.keywords.NULL_VALUE + "`)" : "")));
				return { objectValue : little_interpreter_InterpTokens.NullValue, objectAddress : this.constants.NULL, objectTypeName : little_Little.keywords.TYPE_DYNAMIC};
			}
		}
		return { objectValue : current, objectAddress : currentAddress, objectTypeName : little_tools_Extensions.type(current)};
	}
	,write: function(path,value,type,doc) {
		if(path.length == 0) {
			little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot write to an empty path"));
		}
		if(path.length == 1) {
			this.referrer.reference(path[0],this.retrieve(value),type);
		} else {
			var pathCopy = path.slice(0,path.length - 1);
			var wentThroughPath = [path[0]];
			var current = this.referrer.get(pathCopy.shift());
			while(pathCopy.length > 0) {
				if(!this.getTypeInformation(current.type).passedByReference) {
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot write to a static type. Only objects can have dynamic properties (" + wentThroughPath.join(little_Little.keywords.PROPERTY_ACCESS_SIGN) + " is `" + current.type + "`)"));
				}
				if(!little_interpreter_memory_HashTables.hashTableHasKey(little_interpreter_memory_HashTables.getHashTableOf(current.address,this.storage),pathCopy[0],this.storage)) {
					var a = wentThroughPath.concat([pathCopy[0]]).join(little_Little.keywords.PROPERTY_ACCESS_SIGN);
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot write a property to " + a + ", since " + pathCopy[0] + " does not exist (did you forget to define " + a + "?)"));
				}
				var hashTableKey = little_interpreter_memory_HashTables.hashTableGetKey(little_interpreter_memory_HashTables.getHashTableOf(current.address,this.storage),pathCopy[0],this.storage);
				current = { address : hashTableKey.value, type : this.getTypeName(hashTableKey.type)};
				wentThroughPath.push(pathCopy.shift());
			}
			if(!this.getTypeInformation(current.type).passedByReference) {
				little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot write to a property to values of a static type. Only objects can have dynamic properties (" + wentThroughPath.join(little_Little.keywords.PROPERTY_ACCESS_SIGN) + " is `" + current.type + "`)"));
			}
			if(!little_interpreter_memory_HashTables.hashTableHasKey(little_interpreter_memory_HashTables.getHashTableOf(current.address,this.storage),path[path.length - 1],this.storage)) {
				little_interpreter_memory_HashTables.objectAddKey(current.address,path[path.length - 1],this.retrieve(value),this.getTypeInformation(type).pointer,this.storage.storeString(doc),this.storage);
			} else if(Object.prototype.hasOwnProperty.call(this.externs.instanceProperties.properties.h,path[path.length - 1])) {
				little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot write to an extern property (" + path[path.length - 1] + ")"));
			} else {
				little_interpreter_memory_HashTables.objectSetKey(current.address,path[path.length - 1],{ value : value != null ? this.retrieve(value) : null, type : type != null ? this.getTypeInformation(type).pointer : null, doc : doc != null ? this.storage.storeString(doc) : null},this.storage);
			}
		}
	}
	,set: function(path,value,type,doc) {
		if(path.length == 0) {
			little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot set the value of an empty path"));
		}
		if(path.length == 1) {
			if(this.referrer.exists(path[0])) {
				this.referrer.set(path[0],{ address : value != null ? this.retrieve(value) : null, type : type != null ? type : null});
			} else {
				little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Variable/function " + path[0] + " does not exist"));
			}
		} else {
			var pathCopy = path.slice(0,path.length - 1);
			var wentThroughPath = [path[0]];
			var current = this.referrer.get(pathCopy.shift());
			while(pathCopy.length > 0) {
				if(!this.getTypeInformation(current.type).passedByReference) {
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot set properties to values of a static type. Only objects can have dynamic properties (" + wentThroughPath.join(little_Little.keywords.PROPERTY_ACCESS_SIGN) + " is `" + current.type + "`)"));
				}
				if(!little_interpreter_memory_HashTables.hashTableHasKey(little_interpreter_memory_HashTables.getHashTableOf(current.address,this.storage),pathCopy[0],this.storage)) {
					var a = wentThroughPath.concat([pathCopy[0]]).join(little_Little.keywords.PROPERTY_ACCESS_SIGN);
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot set a property of " + a + ", since " + pathCopy[0] + " does not exist (did you forget to define " + a + "?)"));
				}
				var hashTableKey = little_interpreter_memory_HashTables.hashTableGetKey(little_interpreter_memory_HashTables.getHashTableOf(current.address,this.storage),pathCopy[0],this.storage);
				current = { address : hashTableKey.value, type : this.getTypeName(hashTableKey.type)};
				wentThroughPath.push(pathCopy.shift());
			}
			if(!this.getTypeInformation(current.type).passedByReference) {
				little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot set properties to values of a static type. Only objects can have dynamic properties (" + wentThroughPath.join(little_Little.keywords.PROPERTY_ACCESS_SIGN) + " is `" + current.type + "`)"));
			}
			if(little_interpreter_memory_HashTables.hashTableHasKey(little_interpreter_memory_HashTables.getHashTableOf(current.address,this.storage),path[path.length - 1],this.storage)) {
				little_interpreter_memory_HashTables.objectSetKey(current.address,path[path.length - 1],{ value : value != null ? this.retrieve(value) : null, type : type != null ? this.getTypeInformation(type).pointer : null, doc : doc != null ? this.storage.storeString(doc) : null},this.storage);
			} else if(Object.prototype.hasOwnProperty.call(this.externs.instanceProperties.properties.h,path[path.length - 1])) {
				little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot set an extern property (" + path[path.length - 1] + ")"));
			} else {
				little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot set the value of " + path.join(little_Little.keywords.PROPERTY_ACCESS_SIGN) + ", since " + path[path.length - 1] + " does not exist."));
			}
		}
	}
	,allocate: function(size) {
		if(size <= 0) {
			little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot allocate " + size + " bytes"));
		}
		return this.storage.storeBytes(size);
	}
	,getTypeInformation: function(name) {
		var p;
		var _hx_tmp;
		var _hx_tmp1;
		var _hx_tmp2;
		var _hx_tmp3;
		var _hx_tmp4;
		if(name == little_Little.keywords.TYPE_INT == true) {
			p = this.constants.INT;
		} else {
			_hx_tmp4 = name == little_Little.keywords.TYPE_FLOAT;
			if(_hx_tmp4 == true) {
				p = this.constants.FLOAT;
			} else {
				_hx_tmp3 = name == little_Little.keywords.TYPE_BOOLEAN;
				if(_hx_tmp3 == true) {
					p = this.constants.BOOL;
				} else {
					_hx_tmp2 = name == little_Little.keywords.TYPE_DYNAMIC;
					if(_hx_tmp2 == true) {
						p = this.constants.DYNAMIC;
					} else {
						_hx_tmp1 = name == little_Little.keywords.TYPE_MODULE;
						if(_hx_tmp1 == true) {
							p = this.constants.TYPE;
						} else {
							_hx_tmp = name == little_Little.keywords.TYPE_UNKNOWN;
							p = _hx_tmp == true ? this.constants.UNKNOWN : little_interpreter_memory_MemoryPointer.fromInt(0);
						}
					}
				}
			}
		}
		if(p != 0) {
			var tmp;
			switch(p) {
			case 11:
				tmp = little_Little.keywords.TYPE_INT;
				break;
			case 12:
				tmp = little_Little.keywords.TYPE_FLOAT;
				break;
			case 13:
				tmp = little_Little.keywords.TYPE_BOOLEAN;
				break;
			case 14:
				tmp = little_Little.keywords.TYPE_DYNAMIC;
				break;
			case 15:
				tmp = little_Little.keywords.TYPE_MODULE;
				break;
			case 16:
				tmp = little_Little.keywords.TYPE_UNKNOWN;
				break;
			default:
				throw haxe_Exception.thrown("How did we get here? 5");
			}
			var tmp1 = p >= 14 && p <= 15;
			var tmp2 = new haxe_ds_StringMap();
			var tmp3 = new haxe_ds_StringMap();
			var tmp4;
			switch(p) {
			case 11:
				tmp4 = 4;
				break;
			case 12:
				tmp4 = 8;
				break;
			case 13:
				tmp4 = 1;
				break;
			case 14:
				tmp4 = -1;
				break;
			case 15:
				tmp4 = -1;
				break;
			case 16:
				tmp4 = -1;
				break;
			default:
				throw haxe_Exception.thrown("How did we get here? 51");
			}
			return { pointer : p, typeName : tmp, passedByReference : tmp1, isExternal : false, instanceFields : tmp2, staticFields : tmp3, defaultInstanceSize : tmp4};
		}
		var tmp;
		if(Object.prototype.hasOwnProperty.call(this.externs.externToPointer.h,name)) {
			var token = this.externs.getGlobal(name).objectValue;
			var _this = [little_tools_InterpTokensSimple.CLASS_POINTER].slice();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			tmp = result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1;
		} else {
			tmp = false;
		}
		if(tmp) {
			var instProps = ($_=this.externs,$_.createPathFor.apply($_,[this.externs.instanceProperties].concat(name.split(little_Little.keywords.PROPERTY_ACCESS_SIGN))));
			var statProps = ($_=this.externs,$_.createPathFor.apply($_,[this.externs.globalProperties].concat(name.split(little_Little.keywords.PROPERTY_ACCESS_SIGN))));
			var instances = new haxe_ds_StringMap();
			var statics = new haxe_ds_StringMap();
			var h = instProps.properties.h;
			var _g_h = h;
			var _g_keys = Object.keys(h);
			var _g_length = _g_keys.length;
			var _g_current = 0;
			while(_g_current < _g_length) {
				var key = _g_keys[_g_current++];
				var _g_key = key;
				var _g_value = _g_h[key];
				var key1 = _g_key;
				var value = _g_value;
				var v = { type : value.type, doc : value.doc};
				instances.h[key1] = v;
			}
			var h = statProps.properties.h;
			var _g_h = h;
			var _g_keys = Object.keys(h);
			var _g_length = _g_keys.length;
			var _g_current = 0;
			while(_g_current < _g_length) {
				var key = _g_keys[_g_current++];
				var _g_key = key;
				var _g_value = _g_h[key];
				var key1 = _g_key;
				var value = _g_value;
				var v = { type : value.type, doc : value.doc};
				statics.h[key1] = v;
			}
			return { pointer : this.externs.externToPointer.h[name], typeName : name, passedByReference : true, isExternal : true, instanceFields : instances, staticFields : statics, defaultInstanceSize : 8};
		}
		var reference = this.referrer.get(name);
		var typeInfo = this.storage.readType(reference.address);
		return typeInfo;
	}
	,getTypeName: function(pointer) {
		var ext = this.externs.get_pointerToExtern().h[pointer];
		var tmp;
		if(ext != null) {
			var token = ($_=this.externs,$_.getGlobal.apply($_,ext.split("."))).objectValue;
			var _this = [little_tools_InterpTokensSimple.CLASS_POINTER].slice();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			tmp = result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1;
		} else {
			tmp = false;
		}
		if(tmp) {
			return this.externs.get_pointerToExtern().h[pointer];
		}
		if(this.constants.hasPointer(pointer)) {
			var token = this.constants.getFromPointer(pointer);
			var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1) {
				return Type.enumParameters(token)[0];
			} else {
				return Type.enumParameters(little_interpreter_Interpreter.run([token]))[0];
			}
		}
		return this.storage.readType(pointer).typeName;
	}
	,__class__: little_interpreter_memory_Memory
	,__properties__: {get_currentMemorySize:"get_currentMemorySize"}
};
var little_interpreter_memory_Storage = function(memory) {
	this.parent = memory;
	var length = this.parent.memoryChunkSize;
	var this1 = new haxe_io_Bytes(new ArrayBuffer(length));
	this1.fill(0,length,0);
	this.storage = this1;
	var length = this.parent.memoryChunkSize;
	var this1 = new haxe_io_Bytes(new ArrayBuffer(length));
	this1.fill(0,length,0);
	this.reserved = this1;
	this.reserved.fill(0,this.parent.memoryChunkSize,0);
};
$hxClasses["little.interpreter.memory.Storage"] = little_interpreter_memory_Storage;
little_interpreter_memory_Storage.__name__ = "little.interpreter.memory.Storage";
little_interpreter_memory_Storage.prototype = {
	parent: null
	,reserved: null
	,storage: null
	,requestMemory: function() {
		if(this.storage.length > this.parent.maxMemorySize) {
			little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Out of memory"),"Memory, Storage");
		}
		var newBytes = new haxe_io_Bytes(new ArrayBuffer(this.storage.length + this.parent.memoryChunkSize));
		var tmp = this.storage;
		var values = [newBytes.length,this.storage.length];
		var min = values[0];
		var _g = 0;
		var _g1 = values.length;
		while(_g < _g1) {
			var i = _g++;
			if(values[i] < min) {
				min = values[i];
			}
		}
		newBytes.blit(0,tmp,0,min);
		this.storage = newBytes;
		var newBytes = new haxe_io_Bytes(new ArrayBuffer(this.reserved.length + this.parent.memoryChunkSize));
		var tmp = this.reserved;
		var values = [newBytes.length,this.reserved.length];
		var min = values[0];
		var _g = 0;
		var _g1 = values.length;
		while(_g < _g1) {
			var i = _g++;
			if(values[i] < min) {
				min = values[i];
			}
		}
		newBytes.blit(0,tmp,0,min);
		this.reserved = newBytes;
	}
	,storeByte: function(b) {
		if(b == 0) {
			return this.parent.constants.ZERO;
		}
		if(b == null) {
			return this.parent.constants.NULL;
		}
		var i = this.parent.constants.capacity;
		while(i < this.reserved.length && this.reserved.b[i] != 0) ++i;
		if(i >= this.reserved.length) {
			this.requestMemory();
		}
		this.storage.b[i] = b;
		this.reserved.b[i] = 1;
		return little_interpreter_memory_MemoryPointer.fromInt(i);
	}
	,setByte: function(address,b) {
		this.storage.b[address] = b;
		this.reserved.b[address] = 1;
	}
	,readByte: function(address) {
		return this.storage.b[address];
	}
	,freeByte: function(address) {
		this.storage.b[address] = 0;
		this.reserved.b[address] = 0;
	}
	,storeBytes: function(size,b) {
		var i = this.parent.constants.capacity;
		while(true) {
			var tmp;
			if(i < this.reserved.length - size) {
				var this1 = this.reserved;
				var this2 = new haxe_io_Bytes(new ArrayBuffer(size));
				this2.fill(0,size,0);
				var array = this2;
				array.blit(0,this1,i,size);
				tmp = !vision_ds_ByteArray.isEmpty(array);
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			++i;
		}
		if(i >= this.reserved.length - size) {
			this.requestMemory();
			i += size;
		}
		var _g = 0;
		var _g1 = size;
		while(_g < _g1) {
			var j = _g++;
			this.storage.b[i + j] = j > b.length ? 0 : b.b[j];
			this.reserved.b[i + j] = 1;
		}
		return little_interpreter_memory_MemoryPointer.fromInt(i);
	}
	,setBytes: function(address,bytes) {
		var _g = 0;
		var _g1 = bytes.length;
		while(_g < _g1) {
			var j = _g++;
			this.storage.b[address + j] = bytes.b[j];
			this.reserved.b[address + j] = 1;
		}
	}
	,readBytes: function(address,size) {
		if(address == this.parent.constants.NULL) {
			return null;
		}
		var this1 = new haxe_io_Bytes(new ArrayBuffer(size));
		this1.fill(0,size,0);
		var bytes = this1;
		var _g = 0;
		var _g1 = size;
		while(_g < _g1) {
			var j = _g++;
			bytes.b[j] = this.storage.b[address + j];
		}
		return bytes;
	}
	,freeBytes: function(address,size) {
		var _g = 0;
		var _g1 = size;
		while(_g < _g1) {
			var j = _g++;
			this.storage.b[address + j] = 0;
			this.reserved.b[address + j] = 0;
		}
	}
	,storeArray: function(length,elementSize,defaultElement) {
		var size = elementSize * length;
		var length1 = size + 4;
		var this1 = new haxe_io_Bytes(new ArrayBuffer(length1));
		this1.fill(0,length1,0);
		var bytes = this1;
		if(!vision_ds_ByteArray.isEmpty(defaultElement)) {
			var _g = 0;
			var _g1 = length;
			while(_g < _g1) {
				var i = _g++;
				bytes.blit(i + 4,defaultElement,0,defaultElement.length);
			}
		}
		bytes.setInt32(0,length);
		return this.storeBytes(bytes.length,bytes);
	}
	,setArray: function(address,length,elementSize,defaultElement) {
		var size = elementSize * length;
		var length1 = size + 4 + 4;
		var this1 = new haxe_io_Bytes(new ArrayBuffer(length1));
		this1.fill(0,length1,0);
		var bytes = this1;
		if(defaultElement != null) {
			var _g = 0;
			var _g1 = length;
			while(_g < _g1) {
				var i = _g++;
				bytes.blit(i + 8,defaultElement,0,defaultElement.length);
			}
		}
		bytes.setInt32(0,length);
		bytes.setInt32(4,elementSize);
		this.setBytes(address,bytes);
	}
	,readArray: function(address) {
		if(address == this.parent.constants.NULL) {
			return null;
		}
		var length = this.readInt32(address);
		var elementSize = this.readInt32(little_interpreter_memory_MemoryPointer.fromInt(address + 4));
		address = address + 8;
		var array = [];
		var _g = 0;
		var _g1 = length;
		while(_g < _g1) {
			var i = _g++;
			array.push(this.readBytes(address,elementSize));
			address = address + elementSize;
		}
		return array;
	}
	,freeArray: function(address) {
		var length = this.readInt32(address);
		var elementSize = this.readInt32(little_interpreter_memory_MemoryPointer.fromInt(address + 4));
		this.freeBytes(address,length * elementSize + 8);
	}
	,storeInt16: function(b) {
		if(b == 0) {
			return this.parent.constants.ZERO;
		}
		if(b == null) {
			return this.parent.constants.NULL;
		}
		var i = this.parent.constants.capacity;
		while(i < this.reserved.length - 1 && this.reserved.b[i] != 0 && this.reserved.b[i + 1] != 0) ++i;
		if(i >= this.reserved.length - 1) {
			this.requestMemory();
			i += 2;
		}
		this.storage.b[i] = b & 255;
		b >>= 8;
		this.reserved.b[i] = 1;
		return little_interpreter_memory_MemoryPointer.fromInt(i);
	}
	,setInt16: function(address,b) {
		this.storage.b[address] = b & 255;
		this.storage.b[address + 1] = b >> 8 & 255;
		this.reserved.b[address] = 1;
		this.reserved.b[address + 1] = 1;
	}
	,readInt16: function(address) {
		if(address == this.parent.constants.NULL) {
			return null;
		}
		return this.storage.b[address] + (this.storage.b[address + 1] << 8) - 32767;
	}
	,freeInt16: function(address) {
		this.storage.b[address] = 0;
		this.storage.b[address + 1] = 0;
		this.reserved.b[address] = 0;
		this.reserved.b[address + 1] = 0;
	}
	,storeUInt16: function(b) {
		return this.storeInt16(b < 0 ? b + 32767 : b);
	}
	,setUInt16: function(address,b) {
		this.setInt16(address,b < 0 ? b + 32767 : b);
	}
	,readUInt16: function(address) {
		if(address == this.parent.constants.NULL) {
			return null;
		}
		return this.storage.b[address] + (this.storage.b[address + 1] << 8);
	}
	,freeUInt16: function(address) {
		this.freeInt16(address);
	}
	,storeInt32: function(b) {
		if(b == 0) {
			return this.parent.constants.ZERO;
		}
		if(b == null) {
			return this.parent.constants.NULL;
		}
		var i = this.parent.constants.capacity;
		while(i < this.reserved.length - 3 && this.reserved.b[i] + this.reserved.b[i + 1] + this.reserved.b[i + 2] + this.reserved.b[i + 3] != 0) ++i;
		if(i >= this.reserved.length - 3) {
			this.requestMemory();
			i += 4;
		}
		this.storage.b[i] = b & 255;
		b >>= 8;
		this.reserved.b[i] = 1;
		this.storage.b[i + 1] = b & 255;
		b >>= 8;
		this.reserved.b[i + 1] = 1;
		this.storage.b[i + 2] = b & 255;
		b >>= 8;
		this.reserved.b[i + 2] = 1;
		this.storage.b[i + 3] = b & 255;
		b >>= 8;
		this.reserved.b[i + 3] = 1;
		return little_interpreter_memory_MemoryPointer.fromInt(i);
	}
	,setInt32: function(address,b) {
		this.storage.b[address] = b & 255;
		this.storage.b[address + 1] = b >> 8 & 255;
		this.storage.b[address + 2] = b >> 16 & 255;
		this.storage.b[address + 3] = b >> 24 & 255;
		this.reserved.b[address] = 1;
		this.reserved.b[address + 1] = 1;
		this.reserved.b[address + 2] = 1;
		this.reserved.b[address + 3] = 1;
	}
	,readInt32: function(address) {
		if(address == this.parent.constants.NULL) {
			return null;
		}
		return this.storage.b[address] + (this.storage.b[address + 1] << 8) + (this.storage.b[address + 2] << 16) + (this.storage.b[address + 3] << 24);
	}
	,freeInt32: function(address) {
		this.storage.b[address] = 0;
		this.reserved.b[address] = 0;
		this.storage.b[address + 1] = 0;
		this.reserved.b[address + 1] = 0;
		this.storage.b[address + 2] = 0;
		this.reserved.b[address + 2] = 0;
		this.storage.b[address + 3] = 0;
		this.reserved.b[address + 3] = 0;
	}
	,storeUInt32: function(b) {
		return this.storeInt32(b);
	}
	,setUInt32: function(address,b) {
		this.setInt32(address,b);
	}
	,readUInt32: function(address) {
		return this.readInt32(address);
	}
	,freeUInt32: function(address) {
		this.freeInt32(address);
	}
	,storeDouble: function(b) {
		if(b == 0) {
			return this.parent.constants.ZERO;
		}
		if(b == null) {
			return this.parent.constants.NULL;
		}
		var i = this.parent.constants.capacity;
		while(i < this.reserved.length - 7 && this.reserved.b[i] + this.reserved.b[i + 1] + this.reserved.b[i + 2] + this.reserved.b[i + 3] + this.reserved.b[i + 4] + this.reserved.b[i + 5] + this.reserved.b[i + 6] + this.reserved.b[i + 7] != 0) ++i;
		if(i >= this.reserved.length - 7) {
			this.requestMemory();
			i += 8;
		}
		var bytes = new haxe_io_Bytes(new ArrayBuffer(8));
		bytes.setDouble(0,b);
		this.storage.b[i] = bytes.b[0];
		this.reserved.b[i] = 1;
		this.storage.b[i + 1] = bytes.b[1];
		this.reserved.b[i + 1] = 1;
		this.storage.b[i + 2] = bytes.b[2];
		this.reserved.b[i + 2] = 1;
		this.storage.b[i + 3] = bytes.b[3];
		this.reserved.b[i + 3] = 1;
		this.storage.b[i + 4] = bytes.b[4];
		this.reserved.b[i + 4] = 1;
		this.storage.b[i + 5] = bytes.b[5];
		this.reserved.b[i + 5] = 1;
		this.storage.b[i + 6] = bytes.b[6];
		this.reserved.b[i + 6] = 1;
		this.storage.b[i + 7] = bytes.b[7];
		this.reserved.b[i + 7] = 1;
		return little_interpreter_memory_MemoryPointer.fromInt(i);
	}
	,setDouble: function(address,b) {
		this.storage.setDouble(address,b);
		this.reserved.b[address] = 1;
		this.reserved.b[address + 1] = 1;
		this.reserved.b[address + 2] = 1;
		this.reserved.b[address + 3] = 1;
		this.reserved.b[address + 4] = 1;
		this.reserved.b[address + 5] = 1;
		this.reserved.b[address + 6] = 1;
		this.reserved.b[address + 7] = 1;
	}
	,readDouble: function(address) {
		if(address == this.parent.constants.NULL) {
			return null;
		}
		return this.storage.getDouble(address);
	}
	,freeDouble: function(address) {
		this.storage.b[address] = 0;
		this.reserved.b[address] = 0;
		this.storage.b[address + 1] = 0;
		this.reserved.b[address + 1] = 0;
		this.storage.b[address + 2] = 0;
		this.reserved.b[address + 2] = 0;
		this.storage.b[address + 3] = 0;
		this.reserved.b[address + 3] = 0;
		this.storage.b[address + 4] = 0;
		this.reserved.b[address + 4] = 0;
		this.storage.b[address + 5] = 0;
		this.reserved.b[address + 5] = 0;
		this.storage.b[address + 6] = 0;
		this.reserved.b[address + 6] = 0;
		this.storage.b[address + 7] = 0;
		this.reserved.b[address + 7] = 0;
	}
	,storePointer: function(p) {
		return this.storeInt32(p);
	}
	,setPointer: function(address,p) {
		this.setInt32(address,p);
	}
	,readPointer: function(address) {
		return little_interpreter_memory_MemoryPointer.fromInt(this.readInt32(address));
	}
	,freePointer: function(address) {
		this.freeInt32(address);
	}
	,storeString: function(b) {
		if(b == "") {
			return this.parent.constants.ZERO;
		}
		if(b == null) {
			return this.parent.constants.NULL;
		}
		var stringBytes = haxe_io_Bytes.ofString(b,haxe_io_Encoding.UTF8);
		var value = stringBytes.length;
		var this1 = new haxe_io_Bytes(new ArrayBuffer(4));
		this1.fill(0,4,0);
		var bytes = this1;
		bytes.setInt32(0,value);
		var this1 = bytes;
		var newBytes = new haxe_io_Bytes(new ArrayBuffer(this1.length + stringBytes.length));
		newBytes.blit(0,this1,0,this1.length);
		newBytes.blit(this1.length,stringBytes,0,stringBytes.length);
		var bytes = newBytes;
		var i = this.parent.constants.capacity;
		while(true) {
			var tmp;
			if(i < this.reserved.length - bytes.length) {
				var this1 = this.reserved;
				var length = bytes.length;
				var this2 = new haxe_io_Bytes(new ArrayBuffer(length));
				this2.fill(0,length,0);
				var array = this2;
				array.blit(0,this1,i,length);
				tmp = !vision_ds_ByteArray.isEmpty(array);
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			++i;
		}
		if(i >= this.reserved.length - bytes.length) {
			this.requestMemory();
			i += bytes.length;
		}
		this.storage.blit(i,bytes,0,bytes.length);
		var this1 = this.reserved;
		var length = bytes.length;
		var fillWith = 1;
		if(fillWith == null) {
			fillWith = 0;
		}
		var this2 = new haxe_io_Bytes(new ArrayBuffer(length));
		this2.fill(0,length,fillWith);
		var array = this2;
		this1.blit(i,array,0,array.length);
		return little_interpreter_memory_MemoryPointer.fromInt(i);
	}
	,setString: function(address,b) {
		var stringBytes = haxe_io_Bytes.ofString(b,haxe_io_Encoding.UTF8);
		var value = stringBytes.length;
		var this1 = new haxe_io_Bytes(new ArrayBuffer(4));
		this1.fill(0,4,0);
		var bytes = this1;
		bytes.setInt32(0,value);
		var this1 = bytes;
		var newBytes = new haxe_io_Bytes(new ArrayBuffer(this1.length + stringBytes.length));
		newBytes.blit(0,this1,0,this1.length);
		newBytes.blit(this1.length,stringBytes,0,stringBytes.length);
		var bytes = newBytes;
		var _g = 0;
		var _g1 = bytes.length;
		while(_g < _g1) {
			var j = _g++;
			this.storage.b[address + j] = bytes.b[j];
			this.reserved.b[address + j] = 1;
		}
	}
	,readString: function(address) {
		if(address == this.parent.constants.NULL) {
			return null;
		}
		var length = this.readInt32(little_interpreter_memory_MemoryPointer.fromInt(address));
		return this.storage.getString(address + 4,length,haxe_io_Encoding.UTF8);
	}
	,freeString: function(address) {
		var len = this.storage.getInt32(address) + 4;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var j = _g++;
			this.storage.b[address + j] = 0;
			this.reserved.b[address + j] = 0;
		}
	}
	,storeCodeBlock: function(caller) {
		switch(caller._hx_index) {
		case 6:
			var requiredParams = caller.requiredParams;
			var body = caller.body;
			return this.storeString(little_interpreter_ByteCode.compile(caller));
		case 12:
			var _g = caller.type;
			var body = caller.body;
			return this.storeString(little_interpreter_ByteCode.compile(little_interpreter_InterpTokens.FunctionCode(new OrderedStringMapImpl(),caller)));
		default:
			throw new haxe_exceptions_ArgumentException("caller","" + Std.string(caller) + " must be a code block",null,{ fileName : "src/little/interpreter/memory/Storage.hx", lineNumber : 602, className : "little.interpreter.memory.Storage", methodName : "storeCodeBlock"});
		}
	}
	,setCodeBlock: function(address,caller) {
		switch(caller._hx_index) {
		case 6:
			var requiredParams = caller.requiredParams;
			var body = caller.body;
			this.setString(address,little_interpreter_ByteCode.compile(caller));
			break;
		case 12:
			var _g = caller.type;
			var body = caller.body;
			this.setString(address,little_interpreter_ByteCode.compile(little_interpreter_InterpTokens.FunctionCode(new OrderedStringMapImpl(),caller)));
			break;
		default:
			throw new haxe_exceptions_ArgumentException("caller","" + Std.string(caller) + " must be a code block",null,{ fileName : "src/little/interpreter/memory/Storage.hx", lineNumber : 617, className : "little.interpreter.memory.Storage", methodName : "setCodeBlock"});
		}
	}
	,readCodeBlock: function(address) {
		return little_interpreter_ByteCode.decompile(this.readString(little_interpreter_memory_MemoryPointer.fromInt(address)))[0];
	}
	,storeCondition: function(caller) {
		if(caller._hx_index == 4) {
			var _g = caller.callers;
			return this.storeString(little_interpreter_ByteCode.compile(caller));
		} else {
			var e = little_interpreter_InterpTokens.ConditionCode(null);
			throw new haxe_exceptions_ArgumentException("caller","" + Std.string(caller) + " must be a token of type " + $hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name,null,{ fileName : "src/little/interpreter/memory/Storage.hx", lineNumber : 638, className : "little.interpreter.memory.Storage", methodName : "storeCondition"});
		}
	}
	,setCondition: function(address,caller) {
		if(caller._hx_index == 4) {
			var _g = caller.callers;
			this.setString(address,little_interpreter_ByteCode.compile(caller));
		} else {
			var e = little_interpreter_InterpTokens.ConditionCode(null);
			throw new haxe_exceptions_ArgumentException("caller","" + Std.string(caller) + " must be a token of type " + $hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name,null,{ fileName : "src/little/interpreter/memory/Storage.hx", lineNumber : 651, className : "little.interpreter.memory.Storage", methodName : "setCondition"});
		}
	}
	,readCondition: function(address) {
		return little_interpreter_ByteCode.decompile(this.readString(little_interpreter_memory_MemoryPointer.fromInt(address)))[0];
	}
	,freeCondition: function(address) {
		this.freeString(address);
	}
	,storeSign: function(sign) {
		return this.storeString(sign);
	}
	,setSign: function(address,sign) {
		this.setString(address,sign);
	}
	,readSign: function(address) {
		if(address == this.parent.constants.NULL) {
			return null;
		}
		return little_interpreter_InterpTokens.Sign(this.readString(address));
	}
	,freeSign: function(address) {
		this.freeString(address);
	}
	,storeStatic: function(token) {
		switch(token._hx_index) {
		case 15:
			var num = token.num;
			return this.storeInt32(num);
		case 16:
			var num = token.num;
			return this.storeDouble(num);
		case 17:
			var string = token.string;
			return this.storeString(string);
		case 20:
			var sign = token.sign;
			return this.storeSign(sign);
		case 21:case 22:case 23:
			return this.parent.constants.get(token);
		default:
			throw new haxe_exceptions_ArgumentException("token","" + Std.string(token) + " cannot be statically stored to the storage",null,{ fileName : "src/little/interpreter/memory/Storage.hx", lineNumber : 719, className : "little.interpreter.memory.Storage", methodName : "storeStatic"});
		}
	}
	,storeObject: function(object) {
		var _this = [little_tools_InterpTokensSimple.NULL_VALUE].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		if(result.indexOf($hxEnums[object.__enum__].__constructs__[object._hx_index]._hx_name.toLowerCase()) != -1) {
			return this.parent.constants.NULL;
		}
		var _this = [little_tools_InterpTokensSimple.OBJECT].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		if(result.indexOf($hxEnums[object.__enum__].__constructs__[object._hx_index]._hx_name.toLowerCase()) == -1) {
			throw new haxe_exceptions_ArgumentException("object","" + Std.string(object) + " is not a dynamic object",null,{ fileName : "src/little/interpreter/memory/Storage.hx", lineNumber : 736, className : "little.interpreter.memory.Storage", methodName : "storeObject"});
		}
		if(object._hx_index == 25) {
			var props = object.props;
			var typeName = object.typeName;
			var quintuples = [];
			var propsC = haxe_ds_StringMap.createCopy(props.h);
			var v = { value : little_interpreter_InterpTokens.Characters(typeName), documentation : "The type of this object, as a " + little_Little.keywords.TYPE_STRING + "."};
			propsC.h[little_Little.keywords.OBJECT_TYPE_PROPERTY_NAME] = v;
			var h = propsC.h;
			var _g_h = h;
			var _g_keys = Object.keys(h);
			var _g_length = _g_keys.length;
			var _g_current = 0;
			while(_g_current < _g_length) {
				var key = _g_keys[_g_current++];
				var _g_key = key;
				var _g_value = _g_h[key];
				var k = _g_key;
				var v = _g_value;
				var key1 = k;
				var keyPointer = this.storeString(key1);
				var value;
				var _g = v.value;
				switch(_g._hx_index) {
				case 6:
					var _g1 = _g.requiredParams;
					var _g2 = _g.body;
					value = this.storeCodeBlock(v.value);
					break;
				case 25:
					var _g3 = _g.props;
					var _g4 = _g.typeName;
					value = this.storeObject(v.value);
					break;
				default:
					value = this.storeStatic(v.value);
				}
				var type;
				var _g5 = v.value;
				switch(_g5._hx_index) {
				case 6:
					var _g6 = _g5.requiredParams;
					var _g7 = _g5.body;
					type = this.parent.getTypeInformation(little_Little.keywords.TYPE_FUNCTION).pointer;
					break;
				case 15:
					var _g8 = _g5.num;
					type = this.parent.getTypeInformation(little_Little.keywords.TYPE_INT).pointer;
					break;
				case 16:
					var _g9 = _g5.num;
					type = this.parent.getTypeInformation(little_Little.keywords.TYPE_FLOAT).pointer;
					break;
				case 17:
					var _g10 = _g5.string;
					type = this.parent.getTypeInformation(little_Little.keywords.TYPE_STRING).pointer;
					break;
				case 21:
					type = this.parent.getTypeInformation(little_Little.keywords.TYPE_DYNAMIC).pointer;
					break;
				case 22:case 23:
					type = this.parent.getTypeInformation(little_Little.keywords.TYPE_BOOLEAN).pointer;
					break;
				case 25:
					var _g11 = _g5.props;
					var t = _g5.typeName;
					type = this.parent.getTypeInformation(t).pointer;
					break;
				default:
					throw haxe_Exception.thrown("Property value must be a static value, a code block or an object (given: `" + Std.string(v) + "`)");
				}
				quintuples.push({ key : key1, keyPointer : keyPointer, value : value, type : type, doc : this.storeString(v.documentation)});
			}
			var bytes = little_interpreter_memory_HashTables.generateObjectHashTable(quintuples);
			var value = bytes.length;
			var this1 = new haxe_io_Bytes(new ArrayBuffer(4));
			this1.fill(0,4,0);
			var bytes1 = this1;
			bytes1.setInt32(0,value);
			var bytesLength = bytes1;
			var bytesPointer = this.storeBytes(bytes.length,bytes);
			var value = bytes.length;
			var this1 = new haxe_io_Bytes(new ArrayBuffer(4));
			this1.fill(0,4,0);
			var bytes = this1;
			bytes.setInt32(0,value);
			var this1 = bytes;
			var this2 = new haxe_io_Bytes(new ArrayBuffer(4));
			this2.fill(0,4,0);
			var bytes = this2;
			bytes.setInt32(0,bytesPointer);
			var array = bytes;
			var newBytes = new haxe_io_Bytes(new ArrayBuffer(this1.length + array.length));
			newBytes.blit(0,this1,0,this1.length);
			newBytes.blit(this1.length,array,0,array.length);
			return this.storeBytes(8,newBytes);
		} else {
			throw new haxe_exceptions_ArgumentException("object","" + Std.string(object) + " must be an `Interpreter.Object`",null,{ fileName : "src/little/interpreter/memory/Storage.hx", lineNumber : 785, className : "little.interpreter.memory.Storage", methodName : "storeObject"});
		}
	}
	,readObject: function(pointer) {
		if(pointer == this.parent.constants.NULL) {
			return null;
		}
		var hashTableBytes = this.readBytes(this.readPointer(little_interpreter_memory_MemoryPointer.fromInt(pointer + 4)),this.readInt32(pointer));
		var table = little_interpreter_memory_HashTables.readObjectHashTable(hashTableBytes,this);
		var map = new haxe_ds_StringMap();
		var _g = 0;
		while(_g < table.length) {
			var entry = table[_g];
			++_g;
			var k = entry.key;
			var v;
			var _g1 = this.parent.getTypeName(entry.type);
			var _hx_tmp;
			var _hx_tmp1;
			var _hx_tmp2;
			var _hx_tmp3;
			var _hx_tmp4;
			if(_g1 == little_Little.keywords.TYPE_STRING == true) {
				v = little_interpreter_InterpTokens.Characters(this.readString(entry.value));
			} else {
				_hx_tmp4 = _g1 == little_Little.keywords.TYPE_INT;
				if(_hx_tmp4 == true) {
					v = little_interpreter_InterpTokens.Number(this.readInt32(entry.value));
				} else {
					_hx_tmp3 = _g1 == little_Little.keywords.TYPE_FLOAT;
					if(_hx_tmp3 == true) {
						v = little_interpreter_InterpTokens.Decimal(this.readDouble(entry.value));
					} else {
						_hx_tmp2 = _g1 == little_Little.keywords.TYPE_BOOLEAN;
						if(_hx_tmp2 == true) {
							v = this.readByte(entry.value) == 1 ? little_interpreter_InterpTokens.TrueValue : little_interpreter_InterpTokens.FalseValue;
						} else {
							_hx_tmp1 = _g1 == little_Little.keywords.TYPE_FUNCTION;
							if(_hx_tmp1 == true) {
								v = this.readCodeBlock(entry.value);
							} else {
								_hx_tmp = _g1 == little_Little.keywords.TYPE_DYNAMIC && Type.enumEq(this.parent.constants.getFromPointer(entry.value),little_interpreter_InterpTokens.NullValue);
								v = _hx_tmp == true ? little_interpreter_InterpTokens.NullValue : this.readObject(entry.value);
							}
						}
					}
				}
			}
			var v1 = { value : v, documentation : this.readString(entry.doc)};
			map.h[k] = v1;
		}
		return little_interpreter_InterpTokens.Object(map,Type.enumParameters(map.h[little_Little.keywords.OBJECT_TYPE_PROPERTY_NAME].value)[0]);
	}
	,freeObject: function(pointer) {
		var hashTableSize = this.readInt32(pointer);
		var hashTablePointer = this.readPointer(little_interpreter_memory_MemoryPointer.fromInt(pointer + 4));
		this.freeBytes(hashTablePointer,hashTableSize);
		this.freeBytes(pointer,8);
	}
	,storeType: function(name,statics,instances) {
		var value = this.storeString(name);
		var this1 = new haxe_io_Bytes(new ArrayBuffer(4));
		this1.fill(0,4,0);
		var bytes = this1;
		bytes.setInt32(0,value);
		var bytes1 = bytes;
		var cellSize = 16;
		cellSize = 16;
		var staticsLength = little_tools_Extensions.toArray(new haxe_ds__$StringMap_StringMapKeyIterator(statics.h)).length;
		var length = Math.floor(staticsLength * cellSize * 3 / 2);
		var this1 = new haxe_io_Bytes(new ArrayBuffer(length));
		this1.fill(0,length,0);
		var staticHashMap = this1;
		var instancesLength = little_tools_Extensions.toArray(new haxe_ds__$StringMap_StringMapKeyIterator(instances.h)).length;
		var length = Math.floor(instancesLength * (cellSize - 4) * 3 / 2);
		var this1 = new haxe_io_Bytes(new ArrayBuffer(length));
		this1.fill(0,length,0);
		var instancesHashMap = this1;
		var _g = 0;
		var _g1 = [{ a : staticsLength, b : staticHashMap, c : statics},{ a : instancesLength, b : instancesHashMap, c : instances}];
		while(_g < _g1.length) {
			var __item = _g1[_g];
			++_g;
			var elements = __item.a;
			var hashTable = __item.b;
			var fields = __item.c;
			var h = fields.h;
			var _g_h = h;
			var _g_keys = Object.keys(h);
			var _g_length = _g_keys.length;
			var _g_current = 0;
			while(_g_current < _g_length) {
				var key = _g_keys[_g_current++];
				var _g_key = key;
				var _g_value = _g_h[key];
				var k = _g_key;
				var v = _g_value;
				var keyHash = haxe_hash_Murmur1.hash(haxe_io_Bytes.ofString(k));
				var khI64_high = 0;
				var khI64_low = keyHash;
				var b_high = cellSize >> 31;
				var b_low = cellSize;
				var mask = 65535;
				var al = khI64_low & mask;
				var ah = khI64_low >>> 16;
				var bl = b_low & mask;
				var bh = b_low >>> 16;
				var p00 = haxe_Int32._mul(al,bl);
				var p10 = haxe_Int32._mul(ah,bl);
				var p01 = haxe_Int32._mul(al,bh);
				var p11 = haxe_Int32._mul(ah,bh);
				var low = p00;
				var high = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
				p01 <<= 16;
				low = low + p01 | 0;
				if(haxe_Int32.ucompare(low,p01) < 0) {
					var ret = high++;
					high = high | 0;
				}
				p10 <<= 16;
				low = low + p10 | 0;
				if(haxe_Int32.ucompare(low,p10) < 0) {
					var ret1 = high++;
					high = high | 0;
				}
				high = high + (haxe_Int32._mul(khI64_low,b_high) + haxe_Int32._mul(khI64_high,b_low) | 0) | 0;
				var keyIndex = haxe_Int64.divMod(new haxe__$Int64__$_$_$Int64(high,low),new haxe__$Int64__$_$_$Int64(elements >> 31,elements)).modulus.low;
				if(hashTable.getInt32(keyIndex) == 0) {
					var address = keyIndex;
					hashTable.setInt32(address,this.storeString(k));
					address = address + 4 | 0;
					if(fields == statics) {
						hashTable.setInt32(address,this.parent.store(v.value));
						address = address + 4 | 0;
					}
					hashTable.setInt32(address,this.parent.getTypeInformation(v.type).pointer);
					address = address + 4 | 0;
					hashTable.setInt32(keyIndex,this.storeString(v.documentation));
				} else {
					var incrementation = 0;
					var i = keyIndex;
					while(hashTable.getInt32(i) != 0) {
						i = i + cellSize | 0;
						incrementation += cellSize;
						if(i >= hashTable.length) {
							i = 0;
						}
						if(incrementation >= hashTable.length) {
							throw haxe_Exception.thrown("Object hash table did not generate. This should never happen. Initial length may be incorrect.");
						}
					}
					var address1 = keyIndex;
					hashTable.setInt32(address1,this.storeString(k));
					address1 = address1 + 4 | 0;
					if(fields == statics) {
						hashTable.setInt32(address1,this.parent.store(v.value));
						address1 = address1 + 4 | 0;
					}
					hashTable.setInt32(address1,this.parent.getTypeInformation(v.type).pointer);
					address1 = address1 + 4 | 0;
					hashTable.setInt32(keyIndex,this.storeString(v.documentation));
				}
			}
			cellSize -= 4;
		}
		var value = staticHashMap.length;
		var this1 = new haxe_io_Bytes(new ArrayBuffer(4));
		this1.fill(0,4,0);
		var bytes = this1;
		bytes.setInt32(0,value);
		var this1 = bytes;
		var newBytes = new haxe_io_Bytes(new ArrayBuffer(this1.length + staticHashMap.length));
		newBytes.blit(0,this1,0,this1.length);
		newBytes.blit(this1.length,staticHashMap,0,staticHashMap.length);
		staticHashMap = newBytes;
		var value = instancesHashMap.length;
		var this1 = new haxe_io_Bytes(new ArrayBuffer(4));
		this1.fill(0,4,0);
		var bytes = this1;
		bytes.setInt32(0,value);
		var this1 = bytes;
		var newBytes = new haxe_io_Bytes(new ArrayBuffer(this1.length + instancesHashMap.length));
		newBytes.blit(0,this1,0,this1.length);
		newBytes.blit(this1.length,instancesHashMap,0,instancesHashMap.length);
		instancesHashMap = newBytes;
		var newBytes = new haxe_io_Bytes(new ArrayBuffer(bytes1.length + staticHashMap.length));
		newBytes.blit(0,bytes1,0,bytes1.length);
		newBytes.blit(bytes1.length,staticHashMap,0,staticHashMap.length);
		var this1 = newBytes;
		var newBytes = new haxe_io_Bytes(new ArrayBuffer(this1.length + instancesHashMap.length));
		newBytes.blit(0,this1,0,this1.length);
		newBytes.blit(this1.length,instancesHashMap,0,instancesHashMap.length);
		bytes1 = newBytes;
		return this.storeBytes(bytes1.length,bytes1);
	}
	,readType: function(pointer) {
		if(pointer == this.parent.constants.NULL) {
			return null;
		}
		var className = this.readString(this.readPointer(little_interpreter_memory_MemoryPointer.fromInt(pointer)));
		var cellSize = 16;
		var statics = new haxe_ds_StringMap();
		var staticsLength = this.readInt32(little_interpreter_memory_MemoryPointer.fromInt(pointer + 4));
		var i = pointer + 4;
		while(i < pointer + 4 + staticsLength) {
			var keyPointer = little_interpreter_memory_MemoryPointer.fromInt(this.readInt32(little_interpreter_memory_MemoryPointer.fromInt(i)));
			var value = little_interpreter_memory_MemoryPointer.fromInt(this.readInt32(little_interpreter_memory_MemoryPointer.fromInt(i + 4)));
			var type = little_interpreter_memory_MemoryPointer.fromInt(this.readInt32(little_interpreter_memory_MemoryPointer.fromInt(i + 8)));
			var doc = little_interpreter_memory_MemoryPointer.fromInt(this.readInt32(little_interpreter_memory_MemoryPointer.fromInt(i + 12)));
			if(keyPointer == 0) {
				i += cellSize;
				continue;
			}
			var k = this.readString(keyPointer);
			var v = { value : value, type : type, doc : doc};
			statics.h[k] = v;
			i += cellSize;
		}
		cellSize -= 4;
		var instances = new haxe_ds_StringMap();
		var instancesLength = this.readInt32(little_interpreter_memory_MemoryPointer.fromInt(i + 4));
		while(i < i + 4 + instancesLength) {
			var keyPointer = this.readPointer(little_interpreter_memory_MemoryPointer.fromInt(i));
			var type = this.readPointer(little_interpreter_memory_MemoryPointer.fromInt(i + 4));
			var doc = this.readPointer(little_interpreter_memory_MemoryPointer.fromInt(i + 8));
			if(keyPointer == 0) {
				i += cellSize;
				continue;
			}
			var k = this.readString(keyPointer);
			var v = { type : type, doc : doc};
			instances.h[k] = v;
			i += cellSize;
		}
		return { typeName : className, pointer : pointer, passedByReference : true, isExternal : false, instanceFields : instances, staticFields : statics, defaultInstanceSize : 8};
	}
	,freeType: function(pointer) {
		this.freeString(pointer);
		var byteCount = this.readInt32(little_interpreter_memory_MemoryPointer.fromInt(pointer + 4));
		byteCount += this.readInt32(little_interpreter_memory_MemoryPointer.fromInt(pointer + 4 + byteCount));
		byteCount += 8;
		this.freeBytes(pointer,byteCount);
	}
	,__class__: little_interpreter_memory_Storage
};
var little_interpreter_memory_Referrer = function(memory) {
	this.parent = memory;
	var this1 = new haxe_io_Bytes(new ArrayBuffer(1024));
	this1.fill(0,1024,0);
	this.bytes = this1;
	this.bytes.setInt32(0,4);
	this.bytes.setUInt16(4,0);
	this.bytes.setUInt16(6,0);
};
$hxClasses["little.interpreter.memory.Referrer"] = little_interpreter_memory_Referrer;
little_interpreter_memory_Referrer.__name__ = "little.interpreter.memory.Referrer";
little_interpreter_memory_Referrer.prototype = {
	parent: null
	,bytes: null
	,currentScopeStart: null
	,get_currentScopeStart: function() {
		return this.bytes.getInt32(0);
	}
	,currentScopeLength: null
	,get_currentScopeLength: function() {
		return this.bytes.getUInt16(this.bytes.getInt32(0) + 2);
	}
	,requestMemory: function() {
		if(this.bytes.length > this.parent.maxMemorySize) {
			little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Too many scopes have been created, referrer's stack has overflown (check for infinite recursion)"),"Memory, Referrer");
		}
		var newBytes = new haxe_io_Bytes(new ArrayBuffer(this.bytes.length + 1024));
		var tmp = this.bytes;
		var values = [newBytes.length,this.bytes.length];
		var min = values[0];
		var _g = 0;
		var _g1 = values.length;
		while(_g < _g1) {
			var i = _g++;
			if(values[i] < min) {
				min = values[i];
			}
		}
		newBytes.blit(0,tmp,0,min);
		this.bytes = newBytes;
	}
	,pushScope: function() {
		var currentScopeLength = this.bytes.getUInt16(this.bytes.getInt32(0) + 2);
		var currentScopeStart = this.bytes.getInt32(0) + 4;
		var this1 = new haxe_io_Bytes(new ArrayBuffer(4));
		this1.fill(0,4,0);
		var header = this1;
		header.setUInt16(0,currentScopeLength);
		header.setUInt16(2,0);
		var writePosition = currentScopeStart + currentScopeLength * little_interpreter_memory_Referrer.KEY_SIZE;
		if(writePosition + 2 + 2 > this.bytes.length) {
			this.requestMemory();
		}
		this.bytes.blit(writePosition,header,0,header.length);
		this.bytes.setInt32(0,writePosition);
	}
	,popScope: function() {
		var currentScopePosition = this.bytes.getInt32(0);
		var previousScopeLength = this.bytes.getUInt16(currentScopePosition);
		var currentScopeLength = this.bytes.getUInt16(currentScopePosition + 2);
		this.bytes.setInt32(0,currentScopePosition - previousScopeLength * little_interpreter_memory_Referrer.KEY_SIZE - 4);
	}
	,reference: function(key,address,type) {
		var keyHash = haxe_hash_Murmur1.hash(haxe_io_Bytes.ofString(haxe_Serializer.run(key)));
		var stringName = this.parent.storage.storeString(key);
		var writePosition = this.get_currentScopeStart() + 4 + this.get_currentScopeLength() * little_interpreter_memory_Referrer.KEY_SIZE;
		if(writePosition + little_interpreter_memory_Referrer.KEY_SIZE > this.bytes.length) {
			this.requestMemory();
		}
		this.bytes.setInt32(writePosition,keyHash);
		this.bytes.setInt32(writePosition + 4,stringName);
		this.bytes.setInt32(writePosition + 4 + 4,address);
		this.bytes.setInt32(writePosition + 4 + 8,this.parent.getTypeInformation(type).pointer);
		this.bytes.setUInt16(this.get_currentScopeStart() + 2,this.bytes.getUInt16(this.get_currentScopeStart() + 2) + 1);
	}
	,dereference: function(key) {
		var keyHash = haxe_hash_Murmur1.hash(haxe_io_Bytes.ofString(haxe_Serializer.run(key)));
		var writePosition = this.get_currentScopeStart() + 4;
		while(true) {
			var currentKeyHash = this.bytes.getInt32(writePosition);
			if(currentKeyHash == keyHash) {
				var stringName = this.parent.storage.readString(little_interpreter_memory_MemoryPointer.fromInt(this.bytes.getInt32(writePosition + 4)));
				if(stringName == key) {
					break;
				}
			}
			writePosition += little_interpreter_memory_Referrer.KEY_SIZE;
			if(writePosition >= this.get_currentScopeStart() + this.get_currentScopeLength() * little_interpreter_memory_Referrer.KEY_SIZE) {
				throw haxe_Exception.thrown("Cannot dereference key that doesn't exist. (key: " + key + ")");
			}
		}
		this.bytes.setUInt16(this.bytes.getInt32(0) + 2,this.bytes.getUInt16(this.bytes.getInt32(0) + 2) - 1);
	}
	,get: function(key) {
		var keyHash = haxe_hash_Murmur1.hash(haxe_io_Bytes.ofString(haxe_Serializer.run(key)));
		var checkingScope = this.get_currentScopeStart();
		var elementCount = this.bytes.getUInt16(this.get_currentScopeStart() + 2);
		var nextScope = this.get_currentScopeStart() - this.bytes.getUInt16(this.get_currentScopeStart()) * little_interpreter_memory_Referrer.KEY_SIZE - 4;
		do {
			var i = checkingScope + 4;
			while(i < checkingScope + elementCount * little_interpreter_memory_Referrer.KEY_SIZE) {
				var testingHash = this.bytes.getInt32(i);
				if(keyHash == testingHash) {
					var stringName = this.parent.storage.readString(little_interpreter_memory_MemoryPointer.fromInt(this.bytes.getInt32(i + 4)));
					if(stringName == key) {
						return { address : little_interpreter_memory_MemoryPointer.fromInt(this.bytes.getInt32(i + 4 + 4)), type : this.parent.getTypeName(little_interpreter_memory_MemoryPointer.fromInt(this.bytes.getInt32(i + 4 + 8)))};
					}
				}
				i += little_interpreter_memory_Referrer.KEY_SIZE;
			}
			checkingScope = nextScope;
			elementCount = this.bytes.getUInt16(nextScope + 2);
			nextScope = nextScope - this.bytes.getUInt16(nextScope) * little_interpreter_memory_Referrer.KEY_SIZE - 4;
		} while(checkingScope != 0);
		throw haxe_Exception.thrown("Key " + key + " does not exist.");
	}
	,set: function(key,value) {
		var keyHash = haxe_hash_Murmur1.hash(haxe_io_Bytes.ofString(haxe_Serializer.run(key)));
		var checkingScope = this.get_currentScopeStart();
		var elementCount = this.bytes.getUInt16(this.get_currentScopeStart() + 2);
		var nextScope = this.get_currentScopeStart() - this.bytes.getUInt16(this.get_currentScopeStart()) * little_interpreter_memory_Referrer.KEY_SIZE - 4;
		do {
			var i = checkingScope + 4;
			while(i < checkingScope + elementCount * little_interpreter_memory_Referrer.KEY_SIZE) {
				var testingHash = this.bytes.getInt32(i);
				if(keyHash == testingHash) {
					var stringName = this.parent.storage.readString(little_interpreter_memory_MemoryPointer.fromInt(this.bytes.getInt32(i + 4)));
					if(stringName == key) {
						if(value.address != null) {
							this.bytes.setInt32(i + 4 + 4,value.address);
						}
						if(value.type != null) {
							this.bytes.setInt32(i + 4 + 8,this.parent.getTypeInformation(value.type).pointer);
						}
						return;
					}
				}
				i += little_interpreter_memory_Referrer.KEY_SIZE;
			}
			checkingScope = nextScope;
			elementCount = this.bytes.getUInt16(nextScope + 2);
			nextScope = nextScope - this.bytes.getUInt16(nextScope) * little_interpreter_memory_Referrer.KEY_SIZE - 4;
		} while(checkingScope != 0);
		throw haxe_Exception.thrown("Cannot set " + key + " -  does not exist.");
	}
	,exists: function(key) {
		var keyHash = haxe_hash_Murmur1.hash(haxe_io_Bytes.ofString(haxe_Serializer.run(key)));
		var checkingScope = this.get_currentScopeStart();
		var elementCount = this.bytes.getUInt16(this.get_currentScopeStart() + 2);
		var nextScope = this.get_currentScopeStart() - this.bytes.getUInt16(this.get_currentScopeStart()) * little_interpreter_memory_Referrer.KEY_SIZE - 4;
		do {
			var i = checkingScope + 4;
			while(i < checkingScope + elementCount * little_interpreter_memory_Referrer.KEY_SIZE) {
				var testingHash = this.bytes.getInt32(i);
				if(keyHash == testingHash) {
					var stringName = this.parent.storage.readString(little_interpreter_memory_MemoryPointer.fromInt(this.bytes.getInt32(i + 4)));
					if(stringName == key) {
						return true;
					}
				}
				i += little_interpreter_memory_Referrer.KEY_SIZE;
			}
			checkingScope = nextScope;
			elementCount = this.bytes.getUInt16(nextScope + 2);
			nextScope = nextScope - this.bytes.getUInt16(nextScope) * little_interpreter_memory_Referrer.KEY_SIZE - 4;
		} while(checkingScope != 0);
		return false;
	}
	,keyValueIterator: function() {
		var map_h = Object.create(null);
		var checkingScope = this.get_currentScopeStart();
		var elementCount = this.bytes.getUInt16(this.get_currentScopeStart() + 2);
		var nextScope = this.get_currentScopeStart() - this.bytes.getUInt16(this.get_currentScopeStart()) * little_interpreter_memory_Referrer.KEY_SIZE - 4;
		do {
			var i = checkingScope;
			while(i < checkingScope + elementCount * little_interpreter_memory_Referrer.KEY_SIZE) {
				var stringName = this.parent.storage.readString(little_interpreter_memory_MemoryPointer.fromInt(this.bytes.getInt32(i + 4)));
				map_h[stringName] = { address : little_interpreter_memory_MemoryPointer.fromInt(this.bytes.getInt32(i + 4 + 4)), type : this.parent.storage.readString(little_interpreter_memory_MemoryPointer.fromInt(this.bytes.getInt32(i + 4 + 8)))};
				i += little_interpreter_memory_Referrer.KEY_SIZE;
			}
			checkingScope = nextScope;
			elementCount = this.bytes.getUInt16(nextScope + 2);
			nextScope = nextScope - this.bytes.getUInt16(nextScope) * little_interpreter_memory_Referrer.KEY_SIZE - 4;
		} while(checkingScope != 0);
		return new haxe_ds__$StringMap_StringMapKeyValueIterator(map_h);
	}
	,__class__: little_interpreter_memory_Referrer
	,__properties__: {get_currentScopeLength:"get_currentScopeLength",get_currentScopeStart:"get_currentScopeStart"}
};
var little_interpreter_memory_ConstantPool = function(memory) {
	this.EMPTY_STRING = little_interpreter_memory_MemoryPointer.fromInt(19);
	this.EXTERN = little_interpreter_memory_MemoryPointer.fromInt(18);
	this.ERROR = little_interpreter_memory_MemoryPointer.fromInt(17);
	this.UNKNOWN = little_interpreter_memory_MemoryPointer.fromInt(16);
	this.TYPE = little_interpreter_memory_MemoryPointer.fromInt(15);
	this.DYNAMIC = little_interpreter_memory_MemoryPointer.fromInt(14);
	this.BOOL = little_interpreter_memory_MemoryPointer.fromInt(13);
	this.FLOAT = little_interpreter_memory_MemoryPointer.fromInt(12);
	this.INT = little_interpreter_memory_MemoryPointer.fromInt(11);
	this.ZERO = little_interpreter_memory_MemoryPointer.fromInt(3);
	this.TRUE = little_interpreter_memory_MemoryPointer.fromInt(2);
	this.FALSE = little_interpreter_memory_MemoryPointer.fromInt(1);
	this.NULL = little_interpreter_memory_MemoryPointer.fromInt(0);
	this.capacity = 24;
	var _g = 0;
	var _g1 = this.capacity;
	while(_g < _g1) {
		var i = _g++;
		memory.storage.reserved.b[i] = 1;
	}
	memory.storage.setByte(this.TRUE,1);
};
$hxClasses["little.interpreter.memory.ConstantPool"] = little_interpreter_memory_ConstantPool;
little_interpreter_memory_ConstantPool.__name__ = "little.interpreter.memory.ConstantPool";
little_interpreter_memory_ConstantPool.prototype = {
	capacity: null
	,NULL: null
	,FALSE: null
	,TRUE: null
	,ZERO: null
	,INT: null
	,FLOAT: null
	,BOOL: null
	,DYNAMIC: null
	,TYPE: null
	,UNKNOWN: null
	,ERROR: null
	,EXTERN: null
	,EMPTY_STRING: null
	,get: function(token) {
		var _hx_tmp;
		var _hx_tmp1;
		var _hx_tmp2;
		var _hx_tmp3;
		var _hx_tmp4;
		var _hx_tmp5;
		switch(token._hx_index) {
		case 6:
			var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_INT);
			_hx_tmp5 = Type.enumEq(token,b);
			if(_hx_tmp5 == true) {
				return this.INT;
			} else {
				var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_FLOAT);
				_hx_tmp4 = Type.enumEq(token,b);
				if(_hx_tmp4 == true) {
					return this.FLOAT;
				} else {
					var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_BOOLEAN);
					_hx_tmp3 = Type.enumEq(token,b);
					if(_hx_tmp3 == true) {
						return this.BOOL;
					} else {
						var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC);
						_hx_tmp2 = Type.enumEq(token,b);
						if(_hx_tmp2 == true) {
							return this.DYNAMIC;
						} else {
							var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_MODULE);
							_hx_tmp1 = Type.enumEq(token,b);
							if(_hx_tmp1 == true) {
								return this.TYPE;
							} else {
								var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_UNKNOWN);
								_hx_tmp = Type.enumEq(token,b);
								if(_hx_tmp == true) {
									return this.UNKNOWN;
								} else if(Type.enumParameters(token.body)[0].filter(function(x) {
									return x.is(little_tools_InterpTokensSimple.HAXE_EXTERN);
								}) == true) {
									var p = token.requiredParams;
									return this.EXTERN;
								} else {
									throw new haxe_exceptions_ArgumentException("token","" + Std.string(token) + " does not exist in the constant pool",null,{ fileName : "src/little/interpreter/memory/ConstantPool.hx", lineNumber : 63, className : "little.interpreter.memory.ConstantPool", methodName : "get"});
								}
							}
						}
					}
				}
			}
			break;
		case 15:
			if(token.num == 0) {
				return this.ZERO;
			} else {
				var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_INT);
				_hx_tmp5 = Type.enumEq(token,b);
				if(_hx_tmp5 == true) {
					return this.INT;
				} else {
					var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_FLOAT);
					_hx_tmp4 = Type.enumEq(token,b);
					if(_hx_tmp4 == true) {
						return this.FLOAT;
					} else {
						var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_BOOLEAN);
						_hx_tmp3 = Type.enumEq(token,b);
						if(_hx_tmp3 == true) {
							return this.BOOL;
						} else {
							var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC);
							_hx_tmp2 = Type.enumEq(token,b);
							if(_hx_tmp2 == true) {
								return this.DYNAMIC;
							} else {
								var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_MODULE);
								_hx_tmp1 = Type.enumEq(token,b);
								if(_hx_tmp1 == true) {
									return this.TYPE;
								} else {
									var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_UNKNOWN);
									_hx_tmp = Type.enumEq(token,b);
									if(_hx_tmp == true) {
										return this.UNKNOWN;
									} else {
										throw new haxe_exceptions_ArgumentException("token","" + Std.string(token) + " does not exist in the constant pool",null,{ fileName : "src/little/interpreter/memory/ConstantPool.hx", lineNumber : 63, className : "little.interpreter.memory.ConstantPool", methodName : "get"});
									}
								}
							}
						}
					}
				}
			}
			break;
		case 16:
			if(token.num == 0.) {
				return this.ZERO;
			} else {
				var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_INT);
				_hx_tmp5 = Type.enumEq(token,b);
				if(_hx_tmp5 == true) {
					return this.INT;
				} else {
					var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_FLOAT);
					_hx_tmp4 = Type.enumEq(token,b);
					if(_hx_tmp4 == true) {
						return this.FLOAT;
					} else {
						var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_BOOLEAN);
						_hx_tmp3 = Type.enumEq(token,b);
						if(_hx_tmp3 == true) {
							return this.BOOL;
						} else {
							var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC);
							_hx_tmp2 = Type.enumEq(token,b);
							if(_hx_tmp2 == true) {
								return this.DYNAMIC;
							} else {
								var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_MODULE);
								_hx_tmp1 = Type.enumEq(token,b);
								if(_hx_tmp1 == true) {
									return this.TYPE;
								} else {
									var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_UNKNOWN);
									_hx_tmp = Type.enumEq(token,b);
									if(_hx_tmp == true) {
										return this.UNKNOWN;
									} else {
										throw new haxe_exceptions_ArgumentException("token","" + Std.string(token) + " does not exist in the constant pool",null,{ fileName : "src/little/interpreter/memory/ConstantPool.hx", lineNumber : 63, className : "little.interpreter.memory.ConstantPool", methodName : "get"});
									}
								}
							}
						}
					}
				}
			}
			break;
		case 17:
			if(token.string == "") {
				return this.EMPTY_STRING;
			} else {
				var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_INT);
				_hx_tmp5 = Type.enumEq(token,b);
				if(_hx_tmp5 == true) {
					return this.INT;
				} else {
					var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_FLOAT);
					_hx_tmp4 = Type.enumEq(token,b);
					if(_hx_tmp4 == true) {
						return this.FLOAT;
					} else {
						var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_BOOLEAN);
						_hx_tmp3 = Type.enumEq(token,b);
						if(_hx_tmp3 == true) {
							return this.BOOL;
						} else {
							var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC);
							_hx_tmp2 = Type.enumEq(token,b);
							if(_hx_tmp2 == true) {
								return this.DYNAMIC;
							} else {
								var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_MODULE);
								_hx_tmp1 = Type.enumEq(token,b);
								if(_hx_tmp1 == true) {
									return this.TYPE;
								} else {
									var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_UNKNOWN);
									_hx_tmp = Type.enumEq(token,b);
									if(_hx_tmp == true) {
										return this.UNKNOWN;
									} else {
										throw new haxe_exceptions_ArgumentException("token","" + Std.string(token) + " does not exist in the constant pool",null,{ fileName : "src/little/interpreter/memory/ConstantPool.hx", lineNumber : 63, className : "little.interpreter.memory.ConstantPool", methodName : "get"});
									}
								}
							}
						}
					}
				}
			}
			break;
		case 21:
			return this.NULL;
		case 22:
			return this.TRUE;
		case 23:
			return this.FALSE;
		case 26:
			var _g = token.msg;
			var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_INT);
			_hx_tmp5 = Type.enumEq(token,b);
			if(_hx_tmp5 == true) {
				return this.INT;
			} else {
				var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_FLOAT);
				_hx_tmp4 = Type.enumEq(token,b);
				if(_hx_tmp4 == true) {
					return this.FLOAT;
				} else {
					var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_BOOLEAN);
					_hx_tmp3 = Type.enumEq(token,b);
					if(_hx_tmp3 == true) {
						return this.BOOL;
					} else {
						var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC);
						_hx_tmp2 = Type.enumEq(token,b);
						if(_hx_tmp2 == true) {
							return this.DYNAMIC;
						} else {
							var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_MODULE);
							_hx_tmp1 = Type.enumEq(token,b);
							if(_hx_tmp1 == true) {
								return this.TYPE;
							} else {
								var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_UNKNOWN);
								_hx_tmp = Type.enumEq(token,b);
								if(_hx_tmp == true) {
									return this.UNKNOWN;
								} else {
									return this.ERROR;
								}
							}
						}
					}
				}
			}
			break;
		default:
			var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_INT);
			_hx_tmp5 = Type.enumEq(token,b);
			if(_hx_tmp5 == true) {
				return this.INT;
			} else {
				var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_FLOAT);
				_hx_tmp4 = Type.enumEq(token,b);
				if(_hx_tmp4 == true) {
					return this.FLOAT;
				} else {
					var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_BOOLEAN);
					_hx_tmp3 = Type.enumEq(token,b);
					if(_hx_tmp3 == true) {
						return this.BOOL;
					} else {
						var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC);
						_hx_tmp2 = Type.enumEq(token,b);
						if(_hx_tmp2 == true) {
							return this.DYNAMIC;
						} else {
							var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_MODULE);
							_hx_tmp1 = Type.enumEq(token,b);
							if(_hx_tmp1 == true) {
								return this.TYPE;
							} else {
								var b = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_UNKNOWN);
								_hx_tmp = Type.enumEq(token,b);
								if(_hx_tmp == true) {
									return this.UNKNOWN;
								} else {
									throw new haxe_exceptions_ArgumentException("token","" + Std.string(token) + " does not exist in the constant pool",null,{ fileName : "src/little/interpreter/memory/ConstantPool.hx", lineNumber : 63, className : "little.interpreter.memory.ConstantPool", methodName : "get"});
								}
							}
						}
					}
				}
			}
		}
	}
	,getFromPointer: function(pointer) {
		switch(pointer) {
		case 0:
			return little_interpreter_InterpTokens.NullValue;
		case 1:
			return little_interpreter_InterpTokens.FalseValue;
		case 2:
			return little_interpreter_InterpTokens.TrueValue;
		case 3:
			return little_interpreter_InterpTokens.Number(0);
		case 11:
			return little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_INT);
		case 12:
			return little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_FLOAT);
		case 13:
			return little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_BOOLEAN);
		case 14:
			return little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC);
		case 15:
			return little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_MODULE);
		case 16:
			return little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_UNKNOWN);
		case 17:
			return little_interpreter_InterpTokens.ErrorMessage("Default value for error message");
		case 18:
			return little_interpreter_InterpTokens.HaxeExtern(function() {
				return little_interpreter_InterpTokens.Characters("Default value for external haxe code");
			});
		case 19:
			return little_interpreter_InterpTokens.Characters("");
		default:
			throw haxe_Exception.thrown("pointer " + (pointer == null ? "null" : little_interpreter_memory_MemoryPointer.toString(pointer)) + " not in constant pool");
		}
	}
	,hasPointer: function(pointer) {
		if(pointer < this.capacity) {
			return pointer >= 0;
		} else {
			return false;
		}
	}
	,__class__: little_interpreter_memory_ConstantPool
};
var little_interpreter_memory_ExternalInterfacing = function(memory) {
	this.globalProperties = new little_interpreter_memory_ExtTree(little_interpreter_memory_MemoryPointer.fromInt(0),null,null,little_interpreter_memory_MemoryPointer.fromInt(0));
	this.instanceProperties = new little_interpreter_memory_ExtTree(little_interpreter_memory_MemoryPointer.fromInt(0),null,null,little_interpreter_memory_MemoryPointer.fromInt(0));
	this.parent = memory;
	this.externToPointer = new haxe_ds_StringMap();
};
$hxClasses["little.interpreter.memory.ExternalInterfacing"] = little_interpreter_memory_ExternalInterfacing;
little_interpreter_memory_ExternalInterfacing.__name__ = "little.interpreter.memory.ExternalInterfacing";
little_interpreter_memory_ExternalInterfacing.prototype = {
	parent: null
	,externToPointer: null
	,pointerToExtern: null
	,get_pointerToExtern: function() {
		var pointerToExtern = new haxe_ds_IntMap();
		var h = this.externToPointer.h;
		var _g_h = h;
		var _g_keys = Object.keys(h);
		var _g_length = _g_keys.length;
		var _g_current = 0;
		while(_g_current < _g_length) {
			var key = _g_keys[_g_current++];
			var _g_key = key;
			var _g_value = _g_h[key];
			var type = _g_key;
			var pointer = _g_value;
			pointerToExtern.h[pointer] = type;
		}
		return pointerToExtern;
	}
	,instanceProperties: null
	,globalProperties: null
	,createPathFor: function(extType) {
		var $l=arguments.length;
		var path = new Array($l>1?$l-1:0);
		for(var $i=1;$i<$l;++$i){path[$i-1]=arguments[$i];}
		var identifiers = path.slice();
		var handle = extType;
		while(identifiers.length > 0) {
			var identifier = identifiers.shift();
			if(Object.prototype.hasOwnProperty.call(handle.properties.h,identifier)) {
				handle = handle.properties.h[identifier];
			} else {
				var this1 = handle.properties;
				var v = new little_interpreter_memory_ExtTree();
				this1.h[identifier] = v;
				handle = handle.properties.h[identifier];
			}
		}
		return handle;
	}
	,createAllPathsFor: function() {
		var $l=arguments.length;
		var path = new Array($l>0?$l-0:0);
		for(var $i=0;$i<$l;++$i){path[$i-0]=arguments[$i];}
		var tree = this.globalProperties;
		($_=this,$_.createPathFor.apply($_,[tree].concat(path)));
		var tree = this.instanceProperties;
		($_=this,$_.createPathFor.apply($_,[tree].concat(path)));
	}
	,hasGlobal: function() {
		var $l=arguments.length;
		var path = new Array($l>0?$l-0:0);
		for(var $i=0;$i<$l;++$i){path[$i-0]=arguments[$i];}
		var identifiers = path.slice();
		var handle = this.globalProperties;
		while(identifiers.length > 0) {
			var identifier = identifiers.shift();
			if(Object.prototype.hasOwnProperty.call(handle.properties.h,identifier)) {
				handle = handle.properties.h[identifier];
			} else {
				return false;
			}
		}
		return true;
	}
	,hasInstance: function() {
		var $l=arguments.length;
		var path = new Array($l>0?$l-0:0);
		for(var $i=0;$i<$l;++$i){path[$i-0]=arguments[$i];}
		var identifiers = path.slice();
		var handle = this.instanceProperties;
		while(identifiers.length > 0) {
			var identifier = identifiers.shift();
			if(Object.prototype.hasOwnProperty.call(handle.properties.h,identifier)) {
				handle = handle.properties.h[identifier];
			} else {
				return false;
			}
		}
		return true;
	}
	,getGlobal: function() {
		var $l=arguments.length;
		var path = new Array($l>0?$l-0:0);
		for(var $i=0;$i<$l;++$i){path[$i-0]=arguments[$i];}
		var identifiers = path.slice();
		var handle = this.globalProperties;
		var _g = 0;
		while(_g < identifiers.length) {
			var ident = identifiers[_g];
			++_g;
			handle = handle.properties.h[ident];
		}
		return handle.getter(null,null);
	}
	,__class__: little_interpreter_memory_ExternalInterfacing
	,__properties__: {get_pointerToExtern:"get_pointerToExtern"}
};
var little_interpreter_memory_Operators = function() {
	this.lhsOnly = new haxe_ds_StringMap();
	this.rhsOnly = new haxe_ds_StringMap();
	this.standard = new haxe_ds_StringMap();
	this.priority = new haxe_ds_IntMap();
};
$hxClasses["little.interpreter.memory.Operators"] = little_interpreter_memory_Operators;
little_interpreter_memory_Operators.__name__ = "little.interpreter.memory.Operators";
little_interpreter_memory_Operators.prototype = {
	priority: null
	,standard: null
	,rhsOnly: null
	,lhsOnly: null
	,setPriority: function(op,type,opPriority) {
		var obj = { sign : op, side : type};
		if(opPriority == "first") {
			if(this.priority.h[-1] == null) {
				var v = [];
				this.priority.h[-1] = v;
			}
			this.priority.h[-1].push(obj);
		} else if(opPriority == "last") {
			var i = -1;
			var key = this.priority.keys();
			while(key.hasNext()) {
				var key1 = key.next();
				if(i < key1) {
					i = key1;
				}
			}
			if(this.priority.h[i + 1] == null) {
				var v = [];
				this.priority.h[i + 1] = v;
			}
			this.priority.h[i + 1].push(obj);
		} else if(new EReg("[0-9]+","").match(opPriority)) {
			var p = Std.parseInt(opPriority);
			if(this.priority.h[p] == null) {
				var v = [];
				this.priority.h[p] = v;
			}
			this.priority.h[p].push(obj);
		} else if(StringTools.startsWith(opPriority,"before") || StringTools.startsWith(opPriority,"after") || StringTools.startsWith(opPriority,"with")) {
			var destinationOp;
			var opSide;
			var signPos = StringTools.trim(little_tools_TextTools.remove(little_tools_TextTools.remove(little_tools_TextTools.remove(opPriority,"before"),"after"),"with"));
			if(little_tools_TextTools.countOccurrencesOf(signPos,"_") != 1) {
				destinationOp = StringTools.replace(signPos,"_","");
				opSide = little_interpreter_memory_OperatorType.LHS_RHS;
			} else if(StringTools.startsWith(signPos,"_")) {
				destinationOp = StringTools.replace(signPos,"_","");
				opSide = little_interpreter_memory_OperatorType.LHS_ONLY;
			} else {
				destinationOp = StringTools.replace(signPos,"_","");
				opSide = little_interpreter_memory_OperatorType.RHS_ONLY;
			}
			var map = this.priority;
			var _g_map = map;
			var _g_keys = map.keys();
			while(_g_keys.hasNext()) {
				var key = _g_keys.next();
				var _g_value = _g_map.get(key);
				var _g_key = key;
				var key1 = _g_key;
				var value = _g_value;
				var _g = [];
				var _g1 = 0;
				var _g2 = value;
				while(_g1 < _g2.length) {
					var v = _g2[_g1];
					++_g1;
					if(v.side == opSide && v.sign == destinationOp) {
						_g.push(v);
					}
				}
				if(_g.length > 0) {
					if(StringTools.startsWith(opPriority,"before")) {
						if(this.priority.h[key1 - 1] == null) {
							var v1 = [];
							this.priority.h[key1 - 1] = v1;
						}
						this.priority.h[key1 - 1].push(obj);
					} else if(StringTools.startsWith(opPriority,"after")) {
						if(this.priority.h[key1 + 1] == null) {
							var v2 = [];
							this.priority.h[key1 + 1] = v2;
						}
						this.priority.h[key1 + 1].push(obj);
					} else {
						this.priority.h[key1].push(obj);
					}
					break;
				}
			}
		} else if(StringTools.startsWith(opPriority,"between")) {
			var signPos = StringTools.trim(little_tools_TextTools.remove(opPriority,"between"));
			var _this = signPos.split(" ");
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = StringTools.trim(_this[i]);
			}
			var signs = result;
			var sign1Data = this.signPosToObject(signs[0]);
			var sign2Data = this.signPosToObject(signs[1]);
			var sign1Level = -1;
			var sign2Level = -1;
			var map = this.priority;
			var _g_map = map;
			var _g_keys = map.keys();
			while(_g_keys.hasNext()) {
				var key = _g_keys.next();
				var _g_value = _g_map.get(key);
				var _g_key = key;
				var key1 = _g_key;
				var value = _g_value;
				var _g = [];
				var _g1 = 0;
				var _g2 = value;
				while(_g1 < _g2.length) {
					var v = _g2[_g1];
					++_g1;
					if(v.side == sign1Data.side && v.sign == sign1Data.sign) {
						_g.push(v);
					}
				}
				if(_g.length > 0) {
					sign1Level = key1;
				}
				var _g3 = [];
				var _g4 = 0;
				var _g5 = value;
				while(_g4 < _g5.length) {
					var v1 = _g5[_g4];
					++_g4;
					if(v1.side == sign2Data.side && v1.sign == sign2Data.sign) {
						_g3.push(v1);
					}
				}
				if(_g3.length > 0) {
					sign2Level = key1;
				}
			}
			if(sign1Level != -1 && sign2Level != -1 && sign1Level != sign2Level && Math.abs(sign1Level - sign2Level) <= 2) {
				if(Math.abs(sign1Level - sign2Level) == 2) {
					var key = (sign1Level + sign2Level) / 2 | 0;
					if(this.priority.h[key] == null) {
						var v = [];
						this.priority.h[key] = v;
					}
					this.priority.h[key].push(obj);
				} else {
					var insert = Math.max(sign1Level,sign2Level) | 0;
					var newMap = new haxe_ds_IntMap();
					var map = this.priority;
					var _g_map = map;
					var _g_keys = map.keys();
					while(_g_keys.hasNext()) {
						var key = _g_keys.next();
						var _g_value = _g_map.get(key);
						var _g_key = key;
						var k = _g_key;
						var v = _g_value;
						if(k < insert) {
							newMap.h[k] = v;
						} else {
							newMap.h[k + 1] = v;
						}
					}
					var v = [obj];
					newMap.h[insert] = v;
					this.priority = newMap;
				}
			}
		}
		var _g = [];
		var x = this.priority.keys();
		while(x.hasNext()) {
			var x1 = x.next();
			_g.push(x1);
		}
		var a = _g;
		if(a.length == 0) {
			return;
		}
		haxe_ds_ArraySort.sort(a,function(x,y) {
			return x - y;
		});
		var minimumKey = a[0];
		if(minimumKey != 0) {
			var diff = 0 - minimumKey;
			var priorityCopy = new haxe_ds_IntMap();
			var map = this.priority;
			var _g_map = map;
			var _g_keys = map.keys();
			while(_g_keys.hasNext()) {
				var key = _g_keys.next();
				var _g_value = _g_map.get(key);
				var _g_key = key;
				var key1 = _g_key;
				var value = _g_value;
				priorityCopy.h[key1 + diff] = value;
			}
			this.priority = priorityCopy;
		}
	}
	,getPriority: function(op,type) {
		var map = this.priority;
		var _g_map = map;
		var _g_keys = map.keys();
		while(_g_keys.hasNext()) {
			var key = _g_keys.next();
			var _g_value = _g_map.get(key);
			var _g_key = key;
			var index = _g_key;
			var key1 = _g_value;
			var _g = [];
			var _g1 = 0;
			var _g2 = key1;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				if(v.sign == op && v.side == type) {
					_g.push(v);
				}
			}
			if(_g.length > 0) {
				return index;
			}
		}
		throw haxe_Exception.thrown("Operator " + op + " not found");
	}
	,iterateByPriority: function() {
		var _g = [];
		var x = this.priority.keys();
		while(x.hasNext()) {
			var x1 = x.next();
			_g.push(x1);
		}
		var a = _g;
		haxe_ds_ArraySort.sort(a,function(x,y) {
			return x - y;
		});
		var _g = [];
		var _g1 = 0;
		while(_g1 < a.length) {
			var x = a[_g1];
			++_g1;
			_g.push(this.priority.h[x]);
		}
		var b = _g;
		var i = 0;
		return { next : function() {
			i += 1;
			return b[i - 1];
		}, hasNext : function() {
			return i < b.length;
		}};
	}
	,add: function(op,operatorType,priority,callback) {
		var _g = 0;
		var _g1 = op.length;
		while(_g < _g1) {
			var i = _g++;
			if(little_KeywordConfig.recognizedOperators.indexOf(op.charAt(i)) == -1) {
				little_KeywordConfig.recognizedOperators.push(op.charAt(i));
			}
		}
		little_Little.keywords.RECOGNIZED_SIGNS.push(op);
		switch(operatorType._hx_index) {
		case 0:
			this.standard.h[op] = callback;
			break;
		case 1:
			this.lhsOnly.h[op] = callback;
			break;
		case 2:
			this.rhsOnly.h[op] = callback;
			break;
		}
		this.setPriority(op,operatorType,priority);
	}
	,signPosToObject: function(signPos) {
		var destinationOp;
		var opSide;
		if(little_tools_TextTools.countOccurrencesOf(signPos,"_") != 1) {
			destinationOp = StringTools.replace(signPos,"_","");
			opSide = little_interpreter_memory_OperatorType.LHS_RHS;
		} else if(StringTools.startsWith(signPos,"_")) {
			destinationOp = StringTools.replace(signPos,"_","");
			opSide = little_interpreter_memory_OperatorType.LHS_ONLY;
		} else {
			destinationOp = StringTools.replace(signPos,"_","");
			opSide = little_interpreter_memory_OperatorType.RHS_ONLY;
		}
		return { sign : destinationOp, side : opSide};
	}
	,__class__: little_interpreter_memory_Operators
};
var little_tools_Plugins = function(memory) {
	this.memory = memory;
};
$hxClasses["little.tools.Plugins"] = little_tools_Plugins;
little_tools_Plugins.__name__ = "little.tools.Plugins";
little_tools_Plugins.combosHas = function(combos,lhs,rhs) {
	var _g = 0;
	while(_g < combos.length) {
		var c = combos[_g];
		++_g;
		if(c.rhs == rhs && c.lhs == lhs) {
			return true;
		}
	}
	return false;
};
little_tools_Plugins.containsCombo = function(array,lhs,rhs) {
	var _g = 0;
	while(_g < array.length) {
		var a = array[_g];
		++_g;
		if(a.lhs == lhs && a.rhs == rhs) {
			return true;
		}
	}
	return false;
};
little_tools_Plugins.prototype = {
	memory: null
	,registerType: function(typeName,fields) {
		var _gthis = this;
		var instances = ($_=this.memory.externs,$_.createPathFor.apply($_,[this.memory.externs.instanceProperties].concat(typeName.split("."))));
		var statics = ($_=this.memory.externs,$_.createPathFor.apply($_,[this.memory.externs.globalProperties].concat(typeName.split("."))));
		instances.type = statics.type = this.memory.getTypeInformation(little_Little.keywords.TYPE_MODULE).pointer;
		if(little_tools_Plugins.__noTypeCreation) {
			little_tools_Plugins.__noTypeCreation = false;
		} else {
			var this1 = this.memory.externs.externToPointer;
			var v = this.memory.storage.storeByte(1);
			this1.h[typeName] = v;
			statics.getter = function(_,_1) {
				return { objectValue : little_interpreter_InterpTokens.ClassPointer(_gthis.memory.externs.externToPointer.h[typeName]), objectAddress : _gthis.memory.externs.externToPointer.h[typeName]};
			};
		}
		var h = fields.h;
		var _g_h = h;
		var _g_keys = Object.keys(h);
		var _g_length = _g_keys.length;
		var _g_current = 0;
		while(_g_current < _g_length) {
			var key = _g_keys[_g_current++];
			var _g_key = key;
			var _g_value = _g_h[key];
			var key1 = _g_key;
			var field = [_g_value];
			var _g = key1.split(" ");
			var _hx_tmp;
			var _hx_tmp1;
			var _hx_tmp2;
			if((_g[0] == "public" && _g.length == 3) == true) {
				var name = key1.split(" ")[2];
				var type = this.memory.getTypeInformation(key1.split(" ")[1]).pointer;
				var this1 = instances.properties;
				var v = new little_interpreter_memory_ExtTree(type,(function(field) {
					return function(value,address) {
						try {
							var result = field[0](value,address);
							if(js_Boot.__instanceof(result,little_interpreter_InterpTokens)) {
								return { objectValue : result, objectAddress : _gthis.memory.store(result)};
							}
							return { objectValue : result.value, objectAddress : result.address};
						} catch( _g ) {
							var e = haxe_Exception.caught(_g);
							return { objectValue : little_interpreter_InterpTokens.ErrorMessage("External Variable Error: " + e.details()), objectAddress : _gthis.memory.constants.ERROR};
						}
					};
				})(field));
				this1.h[name] = v;
			} else {
				_hx_tmp2 = _g[0] == "public";
				if(_hx_tmp2 == true) {
					var name1 = key1.split(" ")[2];
					var type1 = [this.memory.getTypeInformation(key1.split(" ")[1])];
					var params = little_interpreter_Interpreter.convert.apply(null,little_parser_Parser.parse(little_lexer_Lexer.lex(little_tools_TextTools.replaceLast(little_tools_TextTools.replaceFirst(little_tools_TextTools.replaceFirst(key1,"public function " + name1 + " ",""),"(",""),")",""))));
					var paramMap = [new OrderedStringMapImpl()];
					var _g1 = 0;
					while(_g1 < params.length) {
						var entry = params[_g1];
						++_g1;
						var _this = [little_tools_InterpTokensSimple.SPLIT_LINE,little_tools_InterpTokensSimple.SET_LINE].slice();
						var result = new Array(_this.length);
						var _g2 = 0;
						var _g3 = _this.length;
						while(_g2 < _g3) {
							var i = _g2++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						if(result.indexOf($hxEnums[entry.__enum__].__constructs__[entry._hx_index]._hx_name.toLowerCase()) != -1) {
							continue;
						}
						switch(entry._hx_index) {
						case 2:
							var _g4 = entry.name;
							var _g5 = entry.type;
							var _g6 = entry.doc;
							if(_g5 == null) {
								var name2 = _g4;
								var _this1 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
								var result1 = new Array(_this1.length);
								var _g7 = 0;
								var _g8 = _this1.length;
								while(_g7 < _g8) {
									var i1 = _g7++;
									var x1 = _this1[i1];
									result1[i1] = little_tools_TextTools.remove($hxEnums[x1.__enum__].__constructs__[x1._hx_index]._hx_name,"_").toLowerCase();
								}
								var k = result1.indexOf($hxEnums[name2.__enum__].__constructs__[name2._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name2)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name2]))[0];
								var v1 = little_interpreter_InterpTokens.TypeCast(little_interpreter_InterpTokens.NullValue,little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC));
								paramMap[0].set(k,v1);
							} else {
								var type2 = _g5;
								var name3 = _g4;
								var _this2 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
								var result2 = new Array(_this2.length);
								var _g9 = 0;
								var _g10 = _this2.length;
								while(_g9 < _g10) {
									var i2 = _g9++;
									var x2 = _this2[i2];
									result2[i2] = little_tools_TextTools.remove($hxEnums[x2.__enum__].__constructs__[x2._hx_index]._hx_name,"_").toLowerCase();
								}
								var k1 = result2.indexOf($hxEnums[name3.__enum__].__constructs__[name3._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name3)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name3]))[0];
								var v2 = little_interpreter_InterpTokens.TypeCast(little_interpreter_InterpTokens.NullValue,type2);
								paramMap[0].set(k1,v2);
							}
							break;
						case 9:
							var assignees = entry.assignees;
							var value = entry.value;
							var _g11 = assignees[0];
							if(_g11._hx_index == 2) {
								var _g12 = _g11.name;
								var _g13 = _g11.type;
								var _g14 = _g11.doc;
								if(_g13 == null) {
									var name4 = _g12;
									var _this3 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
									var result3 = new Array(_this3.length);
									var _g15 = 0;
									var _g16 = _this3.length;
									while(_g15 < _g16) {
										var i3 = _g15++;
										var x3 = _this3[i3];
										result3[i3] = little_tools_TextTools.remove($hxEnums[x3.__enum__].__constructs__[x3._hx_index]._hx_name,"_").toLowerCase();
									}
									var k2 = result3.indexOf($hxEnums[name4.__enum__].__constructs__[name4._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name4)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name4]))[0];
									var v3 = little_interpreter_InterpTokens.TypeCast(value,little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC));
									paramMap[0].set(k2,v3);
								} else {
									var type3 = _g13;
									var name5 = _g12;
									var _this4 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
									var result4 = new Array(_this4.length);
									var _g17 = 0;
									var _g18 = _this4.length;
									while(_g17 < _g18) {
										var i4 = _g17++;
										var x4 = _this4[i4];
										result4[i4] = little_tools_TextTools.remove($hxEnums[x4.__enum__].__constructs__[x4._hx_index]._hx_name,"_").toLowerCase();
									}
									var k3 = result4.indexOf($hxEnums[name5.__enum__].__constructs__[name5._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name5)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name5]))[0];
									var v4 = little_interpreter_InterpTokens.TypeCast(value,type3);
									paramMap[0].set(k3,v4);
								}
							}
							break;
						default:
						}
					}
					var this2 = instances.properties;
					var v5 = new little_interpreter_memory_ExtTree(this.memory.getTypeInformation(little_Little.keywords.TYPE_FUNCTION).pointer,(function(paramMap,type,field) {
						return function(value,address) {
							var returnType = little_tools_Extensions.asTokenPath(type[0].typeName);
							return { objectValue : little_interpreter_InterpTokens.FunctionCode(paramMap[0],little_interpreter_InterpTokens.Block([little_interpreter_InterpTokens.FunctionReturn(little_interpreter_InterpTokens.HaxeExtern((function(paramMap,field) {
								return function() {
									var field1 = field[0];
									var address1 = address;
									var value1 = value;
									var _this = little_tools_Extensions.toArray(paramMap[0].keys());
									var result = new Array(_this.length);
									var _g = 0;
									var _g1 = _this.length;
									while(_g < _g1) {
										var i = _g++;
										result[i] = little_interpreter_Interpreter.evaluate(_gthis.memory.read(_this[i]).objectValue);
									}
									var result1 = field1(address1,value1,result);
									return result1;
								};
							})(paramMap,field)),returnType)],returnType)), objectAddress : _gthis.memory.constants.EXTERN};
						};
					})(paramMap,type1,field));
					this2.h[name1] = v5;
				} else {
					_hx_tmp1 = _g[0] == "static" && _g.length == 3;
					if(_hx_tmp1 == true) {
						var name6 = key1.split(" ")[2];
						var type4 = this.memory.getTypeInformation(key1.split(" ")[1]).pointer;
						if(((field[0]) instanceof haxe_ds_StringMap)) {
							little_tools_Plugins.__noTypeCreation = true;
							this.registerType(typeName + "." + name6,field[0]);
							continue;
						}
						var this3 = statics.properties;
						var v6 = new little_interpreter_memory_ExtTree(type4,(function(field) {
							return function(_,_1) {
								try {
									var result = field[0]();
									if(js_Boot.__instanceof(result,little_interpreter_InterpTokens)) {
										return { objectValue : result, objectAddress : _gthis.memory.store(result)};
									}
									return { objectValue : result.value, objectAddress : result.address};
								} catch( _g ) {
									var e = haxe_Exception.caught(_g);
									return { objectValue : little_interpreter_InterpTokens.ErrorMessage("External Variable Error: " + e.details()), objectAddress : _gthis.memory.constants.ERROR};
								}
							};
						})(field));
						this3.h[name6] = v6;
					} else {
						_hx_tmp = _g[0] == "static";
						if(_hx_tmp == true) {
							var name7 = key1.split(" ")[2];
							var type5 = [this.memory.getTypeInformation(key1.split(" ")[1])];
							var params1 = little_interpreter_Interpreter.convert.apply(null,little_parser_Parser.parse(little_lexer_Lexer.lex(little_tools_TextTools.replaceLast(little_tools_TextTools.replaceFirst(little_tools_TextTools.replaceFirst(key1,"static function " + name7 + " ",""),"(",""),")",""))));
							var paramMap1 = [new OrderedStringMapImpl()];
							var _g19 = 0;
							while(_g19 < params1.length) {
								var entry1 = params1[_g19];
								++_g19;
								var _this5 = [little_tools_InterpTokensSimple.SPLIT_LINE,little_tools_InterpTokensSimple.SET_LINE].slice();
								var result5 = new Array(_this5.length);
								var _g20 = 0;
								var _g21 = _this5.length;
								while(_g20 < _g21) {
									var i5 = _g20++;
									var x5 = _this5[i5];
									result5[i5] = little_tools_TextTools.remove($hxEnums[x5.__enum__].__constructs__[x5._hx_index]._hx_name,"_").toLowerCase();
								}
								if(result5.indexOf($hxEnums[entry1.__enum__].__constructs__[entry1._hx_index]._hx_name.toLowerCase()) != -1) {
									continue;
								}
								switch(entry1._hx_index) {
								case 2:
									var _g22 = entry1.name;
									var _g23 = entry1.type;
									var _g24 = entry1.doc;
									if(_g23 == null) {
										var name8 = _g22;
										var _this6 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
										var result6 = new Array(_this6.length);
										var _g25 = 0;
										var _g26 = _this6.length;
										while(_g25 < _g26) {
											var i6 = _g25++;
											var x6 = _this6[i6];
											result6[i6] = little_tools_TextTools.remove($hxEnums[x6.__enum__].__constructs__[x6._hx_index]._hx_name,"_").toLowerCase();
										}
										var k4 = result6.indexOf($hxEnums[name8.__enum__].__constructs__[name8._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name8)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name8]))[0];
										var v7 = little_interpreter_InterpTokens.TypeCast(little_interpreter_InterpTokens.NullValue,little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC));
										paramMap1[0].set(k4,v7);
									} else {
										var type6 = _g23;
										var name9 = _g22;
										var _this7 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
										var result7 = new Array(_this7.length);
										var _g27 = 0;
										var _g28 = _this7.length;
										while(_g27 < _g28) {
											var i7 = _g27++;
											var x7 = _this7[i7];
											result7[i7] = little_tools_TextTools.remove($hxEnums[x7.__enum__].__constructs__[x7._hx_index]._hx_name,"_").toLowerCase();
										}
										var k5 = result7.indexOf($hxEnums[name9.__enum__].__constructs__[name9._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name9)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name9]))[0];
										var v8 = little_interpreter_InterpTokens.TypeCast(little_interpreter_InterpTokens.NullValue,type6);
										paramMap1[0].set(k5,v8);
									}
									break;
								case 9:
									var assignees1 = entry1.assignees;
									var value1 = entry1.value;
									var _g29 = assignees1[0];
									if(_g29._hx_index == 2) {
										var _g30 = _g29.name;
										var _g31 = _g29.type;
										var _g32 = _g29.doc;
										if(_g31 == null) {
											var name10 = _g30;
											var _this8 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
											var result8 = new Array(_this8.length);
											var _g33 = 0;
											var _g34 = _this8.length;
											while(_g33 < _g34) {
												var i8 = _g33++;
												var x8 = _this8[i8];
												result8[i8] = little_tools_TextTools.remove($hxEnums[x8.__enum__].__constructs__[x8._hx_index]._hx_name,"_").toLowerCase();
											}
											var k6 = result8.indexOf($hxEnums[name10.__enum__].__constructs__[name10._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name10)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name10]))[0];
											var v9 = little_interpreter_InterpTokens.TypeCast(value1,little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC));
											paramMap1[0].set(k6,v9);
										} else {
											var type7 = _g31;
											var name11 = _g30;
											var _this9 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
											var result9 = new Array(_this9.length);
											var _g35 = 0;
											var _g36 = _this9.length;
											while(_g35 < _g36) {
												var i9 = _g35++;
												var x9 = _this9[i9];
												result9[i9] = little_tools_TextTools.remove($hxEnums[x9.__enum__].__constructs__[x9._hx_index]._hx_name,"_").toLowerCase();
											}
											var k7 = result9.indexOf($hxEnums[name11.__enum__].__constructs__[name11._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name11)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name11]))[0];
											var v10 = little_interpreter_InterpTokens.TypeCast(value1,type7);
											paramMap1[0].set(k7,v10);
										}
									}
									break;
								default:
								}
							}
							var this4 = statics.properties;
							var v11 = new little_interpreter_memory_ExtTree(this.memory.getTypeInformation(little_Little.keywords.TYPE_FUNCTION).pointer,(function(paramMap,type,field) {
								return function(_,_1) {
									var returnType = little_tools_Extensions.asTokenPath(type[0].typeName);
									return { objectValue : little_interpreter_InterpTokens.FunctionCode(paramMap[0],little_interpreter_InterpTokens.Block([little_interpreter_InterpTokens.FunctionReturn(little_interpreter_InterpTokens.HaxeExtern((function(paramMap,field) {
										return function() {
											var field1 = field[0];
											var _this = little_tools_Extensions.toArray(paramMap[0].keys());
											var result = new Array(_this.length);
											var _g = 0;
											var _g1 = _this.length;
											while(_g < _g1) {
												var i = _g++;
												result[i] = little_interpreter_Interpreter.evaluate(_gthis.memory.read(_this[i]).objectValue);
											}
											var result1 = field1(result);
											return result1;
										};
									})(paramMap,field)),returnType)],returnType)), objectAddress : _gthis.memory.constants.EXTERN};
								};
							})(paramMap1,type5,field));
							this4.h[name7] = v11;
						} else {
							throw haxe_Exception.thrown("Invalid key syntax for `" + key1 + "`. Must start with either `public`/`static` `function`/`var`, and end with a variable name. (Example: `public var myVar`). Each item must be separated by a single whitespace.");
						}
					}
				}
			}
		}
	}
	,registerVariable: function(variableName,variableType,documentation,staticValue,valueGetter) {
		var _gthis = this;
		var varPath = variableName.split(".");
		var object = ($_=this.memory.externs,$_.createPathFor.apply($_,[this.memory.externs.globalProperties].concat(varPath)));
		object.type = this.memory.getTypeInformation(variableName).pointer;
		object.getter = function(_,_1) {
			try {
				var value = staticValue == null ? valueGetter() : staticValue;
				return { objectValue : value, objectAddress : _gthis.memory.store(value)};
			} catch( _g ) {
				var e = haxe_Exception.caught(_g);
				return { objectValue : little_interpreter_InterpTokens.ErrorMessage("External Variable Error: " + e.details()), objectAddress : _gthis.memory.constants.ERROR};
			}
		};
	}
	,registerFunction: function(functionName,documentation,expectedParameters,callback,returnType) {
		var _gthis = this;
		var params = typeof(expectedParameters) == "string" ? little_interpreter_Interpreter.convert.apply(null,little_parser_Parser.parse(little_lexer_Lexer.lex(expectedParameters))) : expectedParameters;
		var functionPath = functionName.split(".");
		var paramMap = new OrderedStringMapImpl();
		var _g = 0;
		while(_g < params.length) {
			var entry = params[_g];
			++_g;
			var _this = [little_tools_InterpTokensSimple.SPLIT_LINE,little_tools_InterpTokensSimple.SET_LINE].slice();
			var result = new Array(_this.length);
			var _g1 = 0;
			var _g2 = _this.length;
			while(_g1 < _g2) {
				var i = _g1++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			if(result.indexOf($hxEnums[entry.__enum__].__constructs__[entry._hx_index]._hx_name.toLowerCase()) != -1) {
				continue;
			}
			switch(entry._hx_index) {
			case 2:
				var _g3 = entry.name;
				var _g4 = entry.type;
				var _g5 = entry.doc;
				if(_g4 == null) {
					var name = _g3;
					var _this1 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
					var result1 = new Array(_this1.length);
					var _g6 = 0;
					var _g7 = _this1.length;
					while(_g6 < _g7) {
						var i1 = _g6++;
						var x1 = _this1[i1];
						result1[i1] = little_tools_TextTools.remove($hxEnums[x1.__enum__].__constructs__[x1._hx_index]._hx_name,"_").toLowerCase();
					}
					var k = result1.indexOf($hxEnums[name.__enum__].__constructs__[name._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name]))[0];
					var v = little_interpreter_InterpTokens.TypeCast(little_interpreter_InterpTokens.NullValue,little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC));
					paramMap.set(k,v);
				} else {
					var type = _g4;
					var name1 = _g3;
					var _this2 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
					var result2 = new Array(_this2.length);
					var _g8 = 0;
					var _g9 = _this2.length;
					while(_g8 < _g9) {
						var i2 = _g8++;
						var x2 = _this2[i2];
						result2[i2] = little_tools_TextTools.remove($hxEnums[x2.__enum__].__constructs__[x2._hx_index]._hx_name,"_").toLowerCase();
					}
					var k1 = result2.indexOf($hxEnums[name1.__enum__].__constructs__[name1._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name1)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name1]))[0];
					var v1 = little_interpreter_InterpTokens.TypeCast(little_interpreter_InterpTokens.NullValue,type);
					paramMap.set(k1,v1);
				}
				break;
			case 9:
				var assignees = entry.assignees;
				var value = entry.value;
				var _g10 = assignees[0];
				if(_g10._hx_index == 2) {
					var _g11 = _g10.name;
					var _g12 = _g10.type;
					var _g13 = _g10.doc;
					if(_g12 == null) {
						var name2 = _g11;
						var _this3 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result3 = new Array(_this3.length);
						var _g14 = 0;
						var _g15 = _this3.length;
						while(_g14 < _g15) {
							var i3 = _g14++;
							var x3 = _this3[i3];
							result3[i3] = little_tools_TextTools.remove($hxEnums[x3.__enum__].__constructs__[x3._hx_index]._hx_name,"_").toLowerCase();
						}
						var k2 = result3.indexOf($hxEnums[name2.__enum__].__constructs__[name2._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name2)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name2]))[0];
						var v2 = little_interpreter_InterpTokens.TypeCast(value,little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC));
						paramMap.set(k2,v2);
					} else {
						var type1 = _g12;
						var name3 = _g11;
						var _this4 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result4 = new Array(_this4.length);
						var _g16 = 0;
						var _g17 = _this4.length;
						while(_g16 < _g17) {
							var i4 = _g16++;
							var x4 = _this4[i4];
							result4[i4] = little_tools_TextTools.remove($hxEnums[x4.__enum__].__constructs__[x4._hx_index]._hx_name,"_").toLowerCase();
						}
						var k3 = result4.indexOf($hxEnums[name3.__enum__].__constructs__[name3._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name3)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name3]))[0];
						var v3 = little_interpreter_InterpTokens.TypeCast(value,type1);
						paramMap.set(k3,v3);
					}
				}
				break;
			default:
			}
		}
		var returnTypeToken = little_interpreter_Interpreter.convert.apply(null,little_parser_Parser.parse(little_lexer_Lexer.lex(returnType)))[0];
		var token = little_interpreter_InterpTokens.Block([little_interpreter_InterpTokens.FunctionReturn(little_interpreter_InterpTokens.HaxeExtern(function() {
			var callback1 = callback;
			var _this = little_tools_Extensions.toArray(paramMap.keys());
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = _gthis.memory.read(_this[i]);
			}
			return callback1(result);
		}),returnTypeToken)],returnTypeToken);
		var token1 = little_interpreter_InterpTokens.FunctionCode(paramMap,token);
		var object = ($_=this.memory.externs,$_.createPathFor.apply($_,[this.memory.externs.globalProperties].concat(functionPath)));
		object.type = this.memory.getTypeInformation(little_Little.keywords.TYPE_FUNCTION).pointer;
		object.getter = function(_,_1) {
			return { objectValue : token1, objectAddress : _gthis.memory.constants.EXTERN};
		};
	}
	,registerCondition: function(conditionName,documentation,callback) {
		var _gthis = this;
		var conditionPath = conditionName.split(".");
		var object = ($_=this.memory.externs,$_.createPathFor.apply($_,[this.memory.externs.globalProperties].concat(conditionPath)));
		object.getter = function(_,_1) {
			var _g = new haxe_ds_ObjectMap();
			_g.set(null,little_interpreter_InterpTokens.Block([little_interpreter_InterpTokens.HaxeExtern(function() {
				return callback(little_interpreter_Interpreter.convert.apply(null,little_parser_Parser.parse(little_lexer_Lexer.lex(Type.enumParameters(_gthis.memory.read(little_Little.keywords.CONDITION_PATTERN_PARAMETER_NAME).objectValue)[0]))),little_interpreter_Interpreter.convert.apply(null,little_parser_Parser.parse(little_lexer_Lexer.lex(Type.enumParameters(_gthis.memory.read(little_Little.keywords.CONDITION_BODY_PARAMETER_NAME).objectValue)[0]))));
			})],null));
			return { objectValue : little_interpreter_InterpTokens.ConditionCode(_g), objectAddress : _gthis.memory.constants.EXTERN};
		};
	}
	,registerInstanceVariable: function(propertyName,propertyType,onType,documentation,staticValue,valueGetter) {
		var _gthis = this;
		var classPath = onType.split(".");
		classPath.push(propertyName);
		var object = ($_=this.memory.externs,$_.createPathFor.apply($_,[this.memory.externs.instanceProperties].concat(classPath)));
		object.type = this.memory.getTypeInformation(propertyType).pointer;
		object.getter = function(v,a) {
			try {
				var value = staticValue == null ? valueGetter(v,a) : staticValue;
				return { objectValue : value, objectAddress : _gthis.memory.store(value)};
			} catch( _g ) {
				var e = haxe_Exception.caught(_g);
				return { objectValue : little_interpreter_InterpTokens.ErrorMessage("External Function Error: " + e.details()), objectAddress : _gthis.memory.constants.ERROR};
			}
		};
	}
	,registerInstanceFunction: function(propertyName,onType,documentation,expectedParameters,callback,returnType) {
		var _gthis = this;
		var params = typeof(expectedParameters) == "string" ? little_interpreter_Interpreter.convert.apply(null,little_parser_Parser.parse(little_lexer_Lexer.lex(expectedParameters))) : expectedParameters;
		var paramMap = new OrderedStringMapImpl();
		var _g = 0;
		while(_g < params.length) {
			var entry = params[_g];
			++_g;
			var _this = [little_tools_InterpTokensSimple.SPLIT_LINE,little_tools_InterpTokensSimple.SET_LINE].slice();
			var result = new Array(_this.length);
			var _g1 = 0;
			var _g2 = _this.length;
			while(_g1 < _g2) {
				var i = _g1++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			if(result.indexOf($hxEnums[entry.__enum__].__constructs__[entry._hx_index]._hx_name.toLowerCase()) != -1) {
				continue;
			}
			switch(entry._hx_index) {
			case 2:
				var _g3 = entry.name;
				var _g4 = entry.type;
				var _g5 = entry.doc;
				if(_g4 == null) {
					var name = _g3;
					var _this1 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
					var result1 = new Array(_this1.length);
					var _g6 = 0;
					var _g7 = _this1.length;
					while(_g6 < _g7) {
						var i1 = _g6++;
						var x1 = _this1[i1];
						result1[i1] = little_tools_TextTools.remove($hxEnums[x1.__enum__].__constructs__[x1._hx_index]._hx_name,"_").toLowerCase();
					}
					var k = result1.indexOf($hxEnums[name.__enum__].__constructs__[name._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name]))[0];
					var v = little_interpreter_InterpTokens.TypeCast(little_interpreter_InterpTokens.NullValue,little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC));
					paramMap.set(k,v);
				} else {
					var type = _g4;
					var name1 = _g3;
					var _this2 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
					var result2 = new Array(_this2.length);
					var _g8 = 0;
					var _g9 = _this2.length;
					while(_g8 < _g9) {
						var i2 = _g8++;
						var x2 = _this2[i2];
						result2[i2] = little_tools_TextTools.remove($hxEnums[x2.__enum__].__constructs__[x2._hx_index]._hx_name,"_").toLowerCase();
					}
					var k1 = result2.indexOf($hxEnums[name1.__enum__].__constructs__[name1._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name1)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name1]))[0];
					var v1 = little_interpreter_InterpTokens.TypeCast(little_interpreter_InterpTokens.NullValue,type);
					paramMap.set(k1,v1);
				}
				break;
			case 9:
				var assignees = entry.assignees;
				var value = entry.value;
				var _g10 = assignees[0];
				if(_g10._hx_index == 2) {
					var _g11 = _g10.name;
					var _g12 = _g10.type;
					var _g13 = _g10.doc;
					if(_g12 == null) {
						var name2 = _g11;
						var _this3 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result3 = new Array(_this3.length);
						var _g14 = 0;
						var _g15 = _this3.length;
						while(_g14 < _g15) {
							var i3 = _g14++;
							var x3 = _this3[i3];
							result3[i3] = little_tools_TextTools.remove($hxEnums[x3.__enum__].__constructs__[x3._hx_index]._hx_name,"_").toLowerCase();
						}
						var k2 = result3.indexOf($hxEnums[name2.__enum__].__constructs__[name2._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name2)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name2]))[0];
						var v2 = little_interpreter_InterpTokens.TypeCast(value,little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC));
						paramMap.set(k2,v2);
					} else {
						var type1 = _g12;
						var name3 = _g11;
						var _this4 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result4 = new Array(_this4.length);
						var _g16 = 0;
						var _g17 = _this4.length;
						while(_g16 < _g17) {
							var i4 = _g16++;
							var x4 = _this4[i4];
							result4[i4] = little_tools_TextTools.remove($hxEnums[x4.__enum__].__constructs__[x4._hx_index]._hx_name,"_").toLowerCase();
						}
						var k3 = result4.indexOf($hxEnums[name3.__enum__].__constructs__[name3._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name3)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name3]))[0];
						var v3 = little_interpreter_InterpTokens.TypeCast(value,type1);
						paramMap.set(k3,v3);
					}
				}
				break;
			default:
			}
		}
		var classPath = onType.split(".");
		classPath.push(propertyName);
		var object = ($_=this.memory.externs,$_.createPathFor.apply($_,[this.memory.externs.instanceProperties].concat(classPath)));
		var returnTypeToken = little_interpreter_Interpreter.convert.apply(null,little_parser_Parser.parse(little_lexer_Lexer.lex(returnType)))[0];
		object.type = this.memory.getTypeInformation(little_Little.keywords.TYPE_FUNCTION).pointer;
		object.getter = function(v,a) {
			try {
				var tmp = little_interpreter_InterpTokens.Block([little_interpreter_InterpTokens.FunctionReturn(little_interpreter_InterpTokens.HaxeExtern(function() {
					var callback1 = callback;
					var v1 = v;
					var a1 = a;
					var _this = little_tools_Extensions.toArray(paramMap.keys());
					var result = new Array(_this.length);
					var _g = 0;
					var _g1 = _this.length;
					while(_g < _g1) {
						var i = _g++;
						result[i] = little_interpreter_Interpreter.evaluate(_gthis.memory.read(_this[i]).objectValue);
					}
					return callback1(v1,a1,result);
				}),returnTypeToken)],returnTypeToken);
				return { objectValue : little_interpreter_InterpTokens.FunctionCode(paramMap,tmp), objectAddress : _gthis.memory.constants.EXTERN};
			} catch( _g ) {
				var e = haxe_Exception.caught(_g);
				return { objectValue : little_interpreter_InterpTokens.ErrorMessage("External Function Error: " + e.details()), objectAddress : _gthis.memory.constants.ERROR};
			}
		};
	}
	,registerOperator: function(symbol,info) {
		if(info.operatorType == null || info.operatorType == little_interpreter_memory_OperatorType.LHS_RHS) {
			if(info.callback == null && info.singleSidedOperatorCallback != null) {
				var tmp = info.operatorType;
				throw new haxe_exceptions_ArgumentException("callback","Incorrect callback given for operator type " + Std.string(tmp != null ? tmp : little_interpreter_memory_OperatorType.LHS_RHS) + " - `singleSidedOperatorCallback` was given, when `callback` was expected",null,{ fileName : "src/little/tools/Plugins.hx", lineNumber : 452, className : "little.tools.Plugins", methodName : "registerOperator"});
			} else if(info.callback == null) {
				var tmp = info.operatorType;
				throw new haxe_exceptions_ArgumentException("callback","No callback given for operator type " + Std.string(tmp != null ? tmp : little_interpreter_memory_OperatorType.LHS_RHS) + " (`callback` is null)",null,{ fileName : "src/little/tools/Plugins.hx", lineNumber : 454, className : "little.tools.Plugins", methodName : "registerOperator"});
			}
			var callbackFunc;
			if(info.lhsAllowedTypes != null && info.rhsAllowedTypes == null && info.allowedTypeCombos == null) {
				callbackFunc = function(lhs,rhs) {
					var lType = little_tools_Extensions.type(little_interpreter_Interpreter.evaluate(lhs));
					var rType = little_tools_Extensions.type(little_interpreter_Interpreter.evaluate(rhs));
					if(info.lhsAllowedTypes.indexOf(lType) == -1) {
						var callbackFunc = little_Little.runtime;
						var callbackFunc1 = "Cannot preform " + lType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						var callbackFunc2 = callbackFunc1 + (result.indexOf($hxEnums[lhs.__enum__].__constructs__[lhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(lhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([lhs]))[0]) + ") " + symbol + " " + rType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						return callbackFunc.throwError(little_interpreter_InterpTokens.ErrorMessage(callbackFunc2 + (result.indexOf($hxEnums[rhs.__enum__].__constructs__[rhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(rhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([rhs]))[0]) + ") - Left operand cannot be of type " + lType + " (accepted types: " + Std.string(info.lhsAllowedTypes) + ")"));
					}
					return info.callback(lhs,rhs);
				};
			} else if(info.lhsAllowedTypes == null && info.rhsAllowedTypes != null && info.allowedTypeCombos == null) {
				callbackFunc = function(lhs,rhs) {
					var lType = little_tools_Extensions.type(little_interpreter_Interpreter.evaluate(lhs));
					var rType = little_tools_Extensions.type(little_interpreter_Interpreter.evaluate(rhs));
					if(info.rhsAllowedTypes.indexOf(rType) == -1) {
						var callbackFunc = little_Little.runtime;
						var callbackFunc1 = "Cannot preform " + lType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						var callbackFunc2 = callbackFunc1 + (result.indexOf($hxEnums[lhs.__enum__].__constructs__[lhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(lhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([lhs]))[0]) + ") " + symbol + " " + rType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						return callbackFunc.throwError(little_interpreter_InterpTokens.ErrorMessage(callbackFunc2 + (result.indexOf($hxEnums[rhs.__enum__].__constructs__[rhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(rhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([rhs]))[0]) + ") - Right operand cannot be of type " + rType + " (accepted types: " + Std.string(info.rhsAllowedTypes) + ")"));
					}
					return info.callback(lhs,rhs);
				};
			} else if(info.lhsAllowedTypes != null && info.rhsAllowedTypes != null && info.allowedTypeCombos == null) {
				callbackFunc = function(lhs,rhs) {
					var lType = little_tools_Extensions.type(little_interpreter_Interpreter.evaluate(lhs));
					var rType = little_tools_Extensions.type(little_interpreter_Interpreter.evaluate(rhs));
					if(info.rhsAllowedTypes.indexOf(rType) == -1) {
						var callbackFunc = little_Little.runtime;
						var callbackFunc1 = "Cannot preform " + lType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						var callbackFunc2 = callbackFunc1 + (result.indexOf($hxEnums[lhs.__enum__].__constructs__[lhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(lhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([lhs]))[0]) + ") " + symbol + " " + rType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						return callbackFunc.throwError(little_interpreter_InterpTokens.ErrorMessage(callbackFunc2 + (result.indexOf($hxEnums[rhs.__enum__].__constructs__[rhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(rhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([rhs]))[0]) + ") - Right operand cannot be of type " + rType + " (accepted types: " + Std.string(info.rhsAllowedTypes) + ")"));
					}
					if(info.rhsAllowedTypes.indexOf(lType) == -1) {
						var callbackFunc = little_Little.runtime;
						var callbackFunc1 = "Cannot preform " + lType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						var callbackFunc2 = callbackFunc1 + (result.indexOf($hxEnums[lhs.__enum__].__constructs__[lhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(lhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([lhs]))[0]) + ") " + symbol + " " + rType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						return callbackFunc.throwError(little_interpreter_InterpTokens.ErrorMessage(callbackFunc2 + (result.indexOf($hxEnums[rhs.__enum__].__constructs__[rhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(rhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([rhs]))[0]) + ") - Left operand cannot be of type " + lType + " (accepted types: " + Std.string(info.lhsAllowedTypes) + ")"));
					}
					return info.callback(lhs,rhs);
				};
			} else if(info.lhsAllowedTypes != null && info.rhsAllowedTypes == null && info.allowedTypeCombos != null) {
				callbackFunc = function(lhs,rhs) {
					var lType = little_tools_Extensions.type(little_interpreter_Interpreter.evaluate(lhs));
					var rType = little_tools_Extensions.type(little_interpreter_Interpreter.evaluate(rhs));
					if(info.lhsAllowedTypes.indexOf(lType) == -1 && !little_tools_Plugins.containsCombo(info.allowedTypeCombos,lType,rType)) {
						var callbackFunc = little_Little.runtime;
						var callbackFunc1 = "Cannot preform " + lType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						var callbackFunc2 = callbackFunc1 + (result.indexOf($hxEnums[lhs.__enum__].__constructs__[lhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(lhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([lhs]))[0]) + ") " + symbol + " " + rType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						var callbackFunc1 = callbackFunc2 + (result.indexOf($hxEnums[rhs.__enum__].__constructs__[rhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(rhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([rhs]))[0]) + ") - Right operand cannot be of type " + rType + " while left operand is of type " + lType + " (accepted types for left operand: " + Std.string(info.lhsAllowedTypes) + ", accepted type combinations: ";
						var _this = info.allowedTypeCombos;
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var object = _this[i];
							result[i] = "" + object.rhs + " " + symbol + " " + object.lhs;
						}
						return callbackFunc.throwError(little_interpreter_InterpTokens.ErrorMessage(callbackFunc1 + Std.string(result) + ")"));
					}
					return info.callback(lhs,rhs);
				};
			} else if(info.lhsAllowedTypes == null && info.rhsAllowedTypes != null && info.allowedTypeCombos != null) {
				callbackFunc = function(lhs,rhs) {
					var lType = little_tools_Extensions.type(little_interpreter_Interpreter.evaluate(lhs));
					var rType = little_tools_Extensions.type(little_interpreter_Interpreter.evaluate(rhs));
					if(info.rhsAllowedTypes.indexOf(rType) == -1 && !little_tools_Plugins.containsCombo(info.allowedTypeCombos,lType,rType)) {
						var callbackFunc = little_Little.runtime;
						var callbackFunc1 = "Cannot preform " + lType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						var callbackFunc2 = callbackFunc1 + (result.indexOf($hxEnums[lhs.__enum__].__constructs__[lhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(lhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([lhs]))[0]) + ") " + symbol + " " + rType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						var callbackFunc1 = callbackFunc2 + (result.indexOf($hxEnums[rhs.__enum__].__constructs__[rhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(rhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([rhs]))[0]) + ") - Right operand cannot be of type " + rType + " while left operand is of type " + lType + " (accepted types for right operand: " + Std.string(info.rhsAllowedTypes) + ", accepted type combinations: ";
						var _this = info.allowedTypeCombos;
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var object = _this[i];
							result[i] = "" + object.rhs + " " + symbol + " " + object.lhs;
						}
						return callbackFunc.throwError(little_interpreter_InterpTokens.ErrorMessage(callbackFunc1 + Std.string(result) + ")"));
					}
					return info.callback(lhs,rhs);
				};
			} else if(info.lhsAllowedTypes != null && info.rhsAllowedTypes != null && info.allowedTypeCombos != null) {
				callbackFunc = function(lhs,rhs) {
					var lType = little_tools_Extensions.type(little_interpreter_Interpreter.evaluate(lhs));
					var rType = little_tools_Extensions.type(little_interpreter_Interpreter.evaluate(rhs));
					if(info.rhsAllowedTypes.indexOf(rType) == -1 && !little_tools_Plugins.containsCombo(info.allowedTypeCombos,lType,rType)) {
						var callbackFunc = little_Little.runtime;
						var callbackFunc1 = "Cannot preform " + lType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						var callbackFunc2 = callbackFunc1 + (result.indexOf($hxEnums[lhs.__enum__].__constructs__[lhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(lhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([lhs]))[0]) + ") " + symbol + " " + rType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						var callbackFunc1 = callbackFunc2 + (result.indexOf($hxEnums[rhs.__enum__].__constructs__[rhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(rhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([rhs]))[0]) + ") - Right operand cannot be of type " + rType + " (accepted types: " + Std.string(info.rhsAllowedTypes) + ", accepted type combinations: ";
						var _this = info.allowedTypeCombos;
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var object = _this[i];
							result[i] = "" + object.rhs + " " + symbol + " " + object.lhs;
						}
						return callbackFunc.throwError(little_interpreter_InterpTokens.ErrorMessage(callbackFunc1 + Std.string(result) + ")"));
					}
					if(info.rhsAllowedTypes.indexOf(lType) == -1 && !little_tools_Plugins.containsCombo(info.allowedTypeCombos,lType,rType)) {
						var callbackFunc = little_Little.runtime;
						var callbackFunc1 = "Cannot preform " + lType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						var callbackFunc2 = callbackFunc1 + (result.indexOf($hxEnums[lhs.__enum__].__constructs__[lhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(lhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([lhs]))[0]) + ") " + symbol + " " + rType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						var callbackFunc1 = callbackFunc2 + (result.indexOf($hxEnums[rhs.__enum__].__constructs__[rhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(rhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([rhs]))[0]) + ") - Left operand cannot be of type " + lType + " (accepted types: " + Std.string(info.lhsAllowedTypes) + ", accepted type combinations: ";
						var _this = info.allowedTypeCombos;
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var object = _this[i];
							result[i] = "" + object.rhs + " " + symbol + " " + object.lhs;
						}
						return callbackFunc.throwError(little_interpreter_InterpTokens.ErrorMessage(callbackFunc1 + Std.string(result) + ")"));
					}
					return info.callback(lhs,rhs);
				};
			} else {
				callbackFunc = info.callback;
			}
			little_Little.operators.add(symbol,little_interpreter_memory_OperatorType.LHS_RHS,info.priority,callbackFunc);
		} else {
			if(info.singleSidedOperatorCallback == null && info.callback != null) {
				throw new haxe_exceptions_ArgumentException("singleSidedOperatorCallback","Incorrect callback given for operator type " + Std.string(info.operatorType) + " - `callback` was given, when `singleSidedOperatorCallback` was expected",null,{ fileName : "src/little/tools/Plugins.hx", lineNumber : 526, className : "little.tools.Plugins", methodName : "registerOperator"});
			} else if(info.singleSidedOperatorCallback == null) {
				var tmp = info.operatorType;
				throw new haxe_exceptions_ArgumentException("singleSidedOperatorCallback","No callback given for operator type " + Std.string(tmp != null ? tmp : little_interpreter_memory_OperatorType.LHS_RHS) + " (`singleSidedOperatorCallback` is null)",null,{ fileName : "src/little/tools/Plugins.hx", lineNumber : 528, className : "little.tools.Plugins", methodName : "registerOperator"});
			}
			var callbackFunc;
			if(info.operatorType == little_interpreter_memory_OperatorType.LHS_ONLY) {
				callbackFunc = function(lhs) {
					var lType = little_tools_Extensions.type(little_interpreter_Interpreter.evaluate(lhs));
					if(info.lhsAllowedTypes.indexOf(lType) == -1) {
						var callbackFunc = little_Little.runtime;
						var callbackFunc1 = "Cannot perform " + lType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						return callbackFunc.throwError(little_interpreter_InterpTokens.ErrorMessage(callbackFunc1 + (result.indexOf($hxEnums[lhs.__enum__].__constructs__[lhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(lhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([lhs]))[0]) + ")" + symbol + " - Operand cannot be of type " + lType + " (accepted types: " + Std.string(info.lhsAllowedTypes) + ")"));
					}
					return info.singleSidedOperatorCallback(lhs);
				};
			} else {
				callbackFunc = function(rhs) {
					var rType = little_tools_Extensions.type(little_interpreter_Interpreter.evaluate(rhs));
					if(info.rhsAllowedTypes.indexOf(rType) == -1) {
						var callbackFunc = little_Little.runtime;
						var callbackFunc1 = "Cannot perform " + symbol + rType + "(";
						var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i = _g++;
							var x = _this[i];
							result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						return callbackFunc.throwError(little_interpreter_InterpTokens.ErrorMessage(callbackFunc1 + (result.indexOf($hxEnums[rhs.__enum__].__constructs__[rhs._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(rhs)[0] : Type.enumParameters(little_interpreter_Interpreter.run([rhs]))[0]) + ") - Operand cannot be of type " + rType + " (accepted types: " + Std.string(info.rhsAllowedTypes) + ")"));
					}
					return info.singleSidedOperatorCallback(rhs);
				};
			}
			little_Little.operators.add(symbol,info.operatorType,info.priority,callbackFunc);
		}
	}
	,__class__: little_tools_Plugins
};
var vision_ds_Queue = function() {
	this.length = 0;
};
$hxClasses["vision.ds.Queue"] = vision_ds_Queue;
vision_ds_Queue.__name__ = "vision.ds.Queue";
vision_ds_Queue.prototype = {
	length: null
	,first: null
	,iterator: function() {
		var l = this.first;
		return { hasNext : function() {
			return l != null;
		}, next : function() {
			var k = l;
			l = k.next;
			return k.value;
		}};
	}
	,dequeue: function() {
		var v = this.get_last().value;
		this.get_last().previous.next = null;
		this.length--;
		return v;
	}
	,enqueue: function(value) {
		if(this.first == null) {
			this.first = new vision_ds_QueueCell(value,null,null);
			this.length++;
			return value;
		}
		this.first.previous = new vision_ds_QueueCell(value,this.first,null);
		this.first = this.first.previous;
		this.length++;
		return value;
	}
	,has: function(value) {
		var processed = this.first;
		while(processed.next != null) {
			if(processed.value == value) {
				return true;
			}
			processed = processed.next;
		}
		return false;
	}
	,toString: function() {
		var s = "[";
		var processed = this.first;
		while(processed.next != null) {
			s += "" + Std.string(processed.value) + " -> ";
			processed = processed.next;
		}
		s += "" + Std.string(processed.value) + "]";
		return s;
	}
	,get_last: function() {
		var processed = this.first;
		while(processed.next != null) processed = processed.next;
		return processed;
	}
	,set_last: function(value) {
		var processed = this.first;
		while(processed.next != null) processed = processed.next;
		processed = value;
		return value;
	}
	,__class__: vision_ds_Queue
	,__properties__: {set_last:"set_last",get_last:"get_last"}
};
var little_interpreter_Runtime = function() {
	this.callStack = [];
	this.stdout = new little_interpreter_StdOut();
	this.onTypeCast = [];
	this.onFieldDeclared = [];
	this.onConditionCalled = [];
	this.onFunctionCalled = [];
	this.onWriteValue = [];
	this.onWarningPrinted = [];
	this.onErrorThrown = [];
	this.onTokenInterpreted = [];
	this.onLineSplit = [];
	this.onLineChanged = [];
	this.errorThrown = false;
	this.exitCode = 0;
	this.currentToken = null;
	this.line = 0;
};
$hxClasses["little.interpreter.Runtime"] = little_interpreter_Runtime;
little_interpreter_Runtime.__name__ = "little.interpreter.Runtime";
little_interpreter_Runtime.prototype = {
	line: null
	,currentToken: null
	,module: null
	,previousToken: null
	,exitCode: null
	,errorThrown: null
	,errorToken: null
	,onLineChanged: null
	,onLineSplit: null
	,onTokenInterpreted: null
	,onErrorThrown: null
	,onWarningPrinted: null
	,onWriteValue: null
	,onFunctionCalled: null
	,onConditionCalled: null
	,onFieldDeclared: null
	,onTypeCast: null
	,stdout: null
	,callStack: null
	,throwError: function(token,layer) {
		if(layer == null) {
			layer = "Interpreter";
		}
		this.callStack.push(token);
		var mod = this.module;
		var reason = little_tools_TextTools.replaceLast(little_tools_TextTools.remove(Std.string(token),$hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name).substring(1),")","");
		var content = "" + (little_Little.debug ? layer.toUpperCase() + ": " : "") + "ERROR: Module " + this.module + ", Line " + this.line + ":  " + reason;
		this.stdout.output += "\n" + content;
		this.stdout.stdoutTokens.push(token);
		this.exitCode = little_tools_Layer.getIndexOf(layer);
		this.errorToken = token;
		this.errorThrown = true;
		var _g = 0;
		var _g1 = this.onErrorThrown;
		while(_g < _g1.length) {
			var func = _g1[_g];
			++_g;
			func(mod,this.line,reason);
		}
		throw haxe_Exception.thrown("Quitting...");
	}
	,warn: function(token,layer) {
		if(layer == null) {
			layer = "Interpreter";
		}
		this.callStack.push(token);
		var reason = little_tools_TextTools.replaceLast(little_tools_TextTools.remove(Std.string(token),$hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name).substring(1),")","");
		var content = "" + (little_Little.debug ? layer.toUpperCase() + ": " : "") + "WARNING: Module " + this.module + ", Line " + this.line + ":  " + reason;
		this.stdout.output += "\n" + content;
		this.stdout.stdoutTokens.push(token);
		var _g = 0;
		var _g1 = this.onWarningPrinted;
		while(_g < _g1.length) {
			var func = _g1[_g];
			++_g;
			func(this.module,this.line,reason);
		}
	}
	,print: function(item) {
		this.stdout.output += "\n" + (little_Little.debug ? "Interpreter".toUpperCase() + ": " : "") + "Module " + this.module + ", Line " + this.line + ":  " + item;
		this.stdout.stdoutTokens.push(little_interpreter_InterpTokens.Characters(item));
	}
	,broadcast: function(item) {
		this.stdout.output += "\n" + (little_Little.debug ? "BROADCAST: " : "") + item;
		this.stdout.stdoutTokens.push(little_interpreter_InterpTokens.Characters(item));
	}
	,__broadcast: function(item) {
		this.stdout.output += "\n" + (little_Little.debug ? "BROADCAST: " : "") + item;
	}
	,__print: function(item,representativeToken) {
		this.stdout.output += "\n" + (little_Little.debug ? "Interpreter".toUpperCase() + ": " : "") + "Module " + this.module + ", Line " + this.line + ":  " + item;
		this.stdout.stdoutTokens.push(representativeToken);
	}
	,__class__: little_interpreter_Runtime
};
var little_Little = function() { };
$hxClasses["little.Little"] = little_Little;
$hx_exports["little"]["Little"] = little_Little;
little_Little.__name__ = "little.Little";
little_Little.loadModule = function(code,name,debug,runRightBeforeMain) {
	if(runRightBeforeMain == null) {
		runRightBeforeMain = false;
	}
	if(debug == null) {
		debug = false;
	}
	little_Little.runtime.errorThrown = false;
	little_Little.runtime.line = 0;
	little_Little.runtime.module = name;
	if(runRightBeforeMain) {
		little_Little.queue.enqueue(code);
	} else {
		var previous = little_Little.debug;
		if(debug != null) {
			little_Little.debug = debug;
		}
		if(!little_tools_PrepareRun.prepared) {
			little_tools_PrepareRun.addTypes();
			little_tools_PrepareRun.addSigns();
			little_tools_PrepareRun.addFunctions();
			little_tools_PrepareRun.addConditions();
			little_tools_PrepareRun.addProps();
		}
		little_interpreter_Interpreter.run(little_interpreter_Interpreter.convert.apply(null,little_parser_Parser.parse(little_lexer_Lexer.lex(code))));
		if(debug != null) {
			little_Little.debug = previous;
		}
	}
};
little_Little.run = function(code,debug) {
	try {
		var previous = little_Little.debug;
		if(debug != null) {
			little_Little.debug = debug;
		}
		if(!little_tools_PrepareRun.prepared) {
			little_tools_PrepareRun.addTypes();
			little_tools_PrepareRun.addSigns();
			little_tools_PrepareRun.addFunctions();
			little_tools_PrepareRun.addConditions();
			little_tools_PrepareRun.addProps();
		}
		little_Little.runtime.module = little_Little.keywords.MAIN_MODULE_NAME;
		little_Little.runtime.errorThrown = false;
		little_Little.runtime.line = 0;
		little_Little.queue.enqueue(code);
		var item = little_Little.queue.iterator();
		while(item.hasNext()) {
			var item1 = item.next();
			little_interpreter_Interpreter.run(little_interpreter_Interpreter.convert.apply(null,little_parser_Parser.parse(little_lexer_Lexer.lex(item1))));
		}
		if(debug != null) {
			little_Little.debug = previous;
		}
	} catch( _g ) {
		var e = haxe_Exception.caught(_g);
		if(e.get_message() == "Quitting...") {
			haxe_Log.trace(e.get_message(),{ fileName : "src/little/Little.hx", lineNumber : 143, className : "little.Little", methodName : "run"});
		} else {
			haxe_Log.trace(e.details(),{ fileName : "src/little/Little.hx", lineNumber : 143, className : "little.Little", methodName : "run"});
		}
	}
};
little_Little.compile = function(code) {
	return little_interpreter_Interpreter.convert.apply(null,little_parser_Parser.parse(little_lexer_Lexer.lex(code)));
};
little_Little.reset = function() {
	little_Little.runtime = new little_interpreter_Runtime();
	little_Little.operators.lhsOnly.h = Object.create(null);
	little_Little.operators.rhsOnly.h = Object.create(null);
	little_Little.operators.standard.h = Object.create(null);
	little_Little.operators.priority.h = { };
	little_Little.memory.reset();
	little_Little.queue = new vision_ds_Queue();
};
var little_interpreter_ByteCode = function() { };
$hxClasses["little.interpreter.ByteCode"] = little_interpreter_ByteCode;
little_interpreter_ByteCode.__name__ = "little.interpreter.ByteCode";
little_interpreter_ByteCode.compile = function() {
	var $l=arguments.length;
	var tokens = new Array($l>0?$l-0:0);
	for(var $i=0;$i<$l;++$i){tokens[$i-0]=arguments[$i];}
	return haxe_Serializer.run(tokens);
};
little_interpreter_ByteCode.decompile = function(bytecode) {
	return haxe_Unserializer.run(bytecode);
};
var little_interpreter_Interpreter = function() { };
$hxClasses["little.interpreter.Interpreter"] = little_interpreter_Interpreter;
little_interpreter_Interpreter.__name__ = "little.interpreter.Interpreter";
little_interpreter_Interpreter.convert = function() {
	var $l=arguments.length;
	var pre = new Array($l>0?$l-0:0);
	for(var $i=0;$i<$l;++$i){pre[$i-0]=arguments[$i];}
	if(pre.length == 1 && pre[0] == null) {
		return [null];
	}
	var post = [];
	var _g_current = 0;
	var _g_args = pre;
	while(_g_current < _g_args.length) {
		var item = _g_args[_g_current++];
		var tmp;
		switch(item._hx_index) {
		case 0:
			var line = item.line;
			tmp = little_interpreter_InterpTokens.SetLine(line);
			break;
		case 1:
			tmp = little_interpreter_InterpTokens.SplitLine;
			break;
		case 2:
			var name = item.name;
			var type = item.type;
			var doc = item.doc;
			tmp = little_interpreter_InterpTokens.VariableDeclaration(little_interpreter_Interpreter.convert(name)[0],type == null ? little_tools_Extensions.asTokenPath(little_Little.keywords.TYPE_UNKNOWN) : little_interpreter_Interpreter.convert(type)[0],doc == null ? little_interpreter_InterpTokens.Characters("") : little_interpreter_Interpreter.convert(doc)[0]);
			break;
		case 3:
			var name1 = item.name;
			var params = item.params;
			var type1 = item.type;
			var doc1 = item.doc;
			tmp = little_interpreter_InterpTokens.FunctionDeclaration(little_interpreter_Interpreter.convert(name1)[0],little_interpreter_Interpreter.convert(params)[0],type1 == null ? little_tools_Extensions.asTokenPath(little_Little.keywords.TYPE_UNKNOWN) : little_interpreter_Interpreter.convert(type1)[0],doc1 == null ? little_interpreter_InterpTokens.Characters("") : little_interpreter_Interpreter.convert(doc1)[0]);
			break;
		case 4:
			var name2 = item.name;
			var exp = item.exp;
			var body = item.body;
			tmp = little_interpreter_InterpTokens.ConditionCall(little_interpreter_Interpreter.convert(name2)[0],little_interpreter_Interpreter.convert(exp)[0],little_interpreter_Interpreter.convert(body)[0]);
			break;
		case 5:
			var name3 = item.name;
			tmp = null;
			break;
		case 6:
			var assignees = item.assignees;
			var value = item.value;
			tmp = little_interpreter_InterpTokens.Write(little_interpreter_Interpreter.convert.apply(null,assignees),little_interpreter_Interpreter.convert(value)[0]);
			break;
		case 7:
			var word = item.word;
			tmp = little_interpreter_InterpTokens.Identifier(word);
			break;
		case 8:
			var value1 = item.value;
			var type2 = item.type;
			tmp = little_interpreter_InterpTokens.TypeCast(little_interpreter_Interpreter.convert(value1)[0],little_interpreter_Interpreter.convert(type2)[0]);
			break;
		case 9:
			var name4 = item.name;
			var params1 = item.params;
			tmp = little_interpreter_InterpTokens.FunctionCall(little_interpreter_Interpreter.convert(name4)[0],little_interpreter_Interpreter.convert(params1)[0]);
			break;
		case 10:
			var value2 = item.value;
			var type3 = item.type;
			tmp = little_interpreter_InterpTokens.FunctionReturn(little_interpreter_Interpreter.convert(value2)[0],type3 == null ? little_tools_Extensions.asTokenPath(little_Little.keywords.TYPE_UNKNOWN) : little_interpreter_Interpreter.convert(type3)[0]);
			break;
		case 11:
			var parts = item.parts;
			var type4 = item.type;
			tmp = little_interpreter_InterpTokens.Expression(little_interpreter_Interpreter.convert.apply(null,parts),type4 == null ? little_tools_Extensions.asTokenPath(little_Little.keywords.TYPE_UNKNOWN) : little_interpreter_Interpreter.convert(type4)[0]);
			break;
		case 12:
			var body1 = item.body;
			var type5 = item.type;
			tmp = little_interpreter_InterpTokens.Block(little_interpreter_Interpreter.convert.apply(null,body1),type5 == null ? little_tools_Extensions.asTokenPath(little_Little.keywords.TYPE_UNKNOWN) : little_interpreter_Interpreter.convert(type5)[0]);
			break;
		case 13:
			var parts1 = item.parts;
			tmp = little_interpreter_InterpTokens.PartArray(little_interpreter_Interpreter.convert.apply(null,parts1));
			break;
		case 14:
			var name5 = item.name;
			var property = item.property;
			tmp = little_interpreter_InterpTokens.PropertyAccess(little_interpreter_Interpreter.convert(name5)[0],little_interpreter_Interpreter.convert(property)[0]);
			break;
		case 15:
			var sign = item.sign;
			tmp = little_interpreter_InterpTokens.Sign(sign);
			break;
		case 16:
			var num = item.num;
			tmp = Math.abs(parseFloat(num)) > 2147483647 ? little_interpreter_InterpTokens.Decimal(parseFloat(num)) : little_interpreter_InterpTokens.Number(Std.parseInt(num));
			break;
		case 17:
			var num1 = item.num;
			tmp = little_interpreter_InterpTokens.Decimal(parseFloat(num1));
			break;
		case 18:
			var string = item.string;
			tmp = little_interpreter_InterpTokens.Characters(string);
			break;
		case 19:
			var doc2 = item.doc;
			tmp = little_interpreter_InterpTokens.Characters("\"\"" + doc2 + "\"\"");
			break;
		case 20:
			var msg = item.msg;
			tmp = little_interpreter_InterpTokens.ErrorMessage(msg);
			break;
		case 21:
			tmp = little_interpreter_InterpTokens.NullValue;
			break;
		case 22:
			tmp = little_interpreter_InterpTokens.TrueValue;
			break;
		case 23:
			tmp = little_interpreter_InterpTokens.FalseValue;
			break;
		case 24:
			var name6 = item.name;
			var params2 = item.params;
			throw haxe_Exception.thrown("Custom tokens cannot remain when transitioning from Parser to Interpreter tokens (found " + Std.string(item) + ")");
		}
		post.push(tmp);
	}
	return post;
};
little_interpreter_Interpreter.error = function(message,layer) {
	if(layer == null) {
		layer = "Interpreter";
	}
	little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage(message),layer);
	throw haxe_Exception.thrown("");
};
little_interpreter_Interpreter.warn = function(message,layer) {
	if(layer == null) {
		layer = "Interpreter";
	}
	little_Little.runtime.warn(little_interpreter_InterpTokens.ErrorMessage(message),layer);
	return little_interpreter_InterpTokens.ErrorMessage(message);
};
little_interpreter_Interpreter.assert = function(token,isType,errorMessage) {
	var tmp;
	if(js_Boot.__instanceof(isType,little_tools_InterpTokensSimple)) {
		var _this = [isType].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		tmp = result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) == -1;
	} else {
		tmp = false;
	}
	if(tmp || ((isType) instanceof Array) && !little_tools_Extensions.containsAny(isType,function(a) {
		var _this = [a].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		return result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1;
	})) {
		little_Little.runtime.throwError(errorMessage != null ? little_interpreter_InterpTokens.ErrorMessage(errorMessage) : little_interpreter_InterpTokens.ErrorMessage("Assertion failed, token " + Std.string(token) + " is not of type " + Std.string(isType)),"Interpreter");
		return little_interpreter_InterpTokens.NullValue;
	}
	return token;
};
little_interpreter_Interpreter.setLine = function(l) {
	var o = little_Little.runtime.line;
	little_Little.runtime.line = l;
	var _g = 0;
	var _g1 = little_Little.runtime.onLineChanged;
	while(_g < _g1.length) {
		var listener = _g1[_g];
		++_g;
		listener(o);
	}
};
little_interpreter_Interpreter.splitLine = function() {
	var _g = 0;
	var _g1 = little_Little.runtime.onLineSplit;
	while(_g < _g1.length) {
		var listener = _g1[_g];
		++_g;
		listener();
	}
};
little_interpreter_Interpreter.declareVariable = function(name,type,doc) {
	var path = little_tools_Extensions.asStringPath(name);
	var tmp = little_Little.memory;
	var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		var x = _this[i];
		result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
	}
	var tmp1 = result.indexOf($hxEnums[type.__enum__].__constructs__[type._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(type)[0] : Type.enumParameters(little_interpreter_Interpreter.run([type]))[0];
	var tmp2;
	if(doc != null) {
		var token = little_interpreter_Interpreter.evaluate(doc);
		var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		tmp2 = result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(token)[0] : Type.enumParameters(little_interpreter_Interpreter.run([token]))[0];
	} else {
		tmp2 = "";
	}
	tmp.write(path,little_interpreter_InterpTokens.NullValue,tmp1,tmp2);
	var _g = 0;
	var _g1 = little_Little.runtime.onFieldDeclared;
	while(_g < _g1.length) {
		var listener = _g1[_g];
		++_g;
		listener(little_tools_Extensions.asJoinedStringPath(name),little_interpreter_FieldDeclarationType.VARIABLE);
	}
};
little_interpreter_Interpreter.declareFunction = function(name,params,doc) {
	var path = little_tools_Extensions.asStringPath(name);
	var paramMap = new OrderedStringMapImpl();
	var array = Type.enumParameters(params)[0];
	var _g = 0;
	while(_g < array.length) {
		var entry = array[_g];
		++_g;
		var _this = [little_tools_InterpTokensSimple.SPLIT_LINE,little_tools_InterpTokensSimple.SET_LINE].slice();
		var result = new Array(_this.length);
		var _g1 = 0;
		var _g2 = _this.length;
		while(_g1 < _g2) {
			var i = _g1++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		if(result.indexOf($hxEnums[entry.__enum__].__constructs__[entry._hx_index]._hx_name.toLowerCase()) != -1) {
			continue;
		}
		switch(entry._hx_index) {
		case 2:
			var _g3 = entry.name;
			var _g4 = entry.type;
			var _g5 = entry.doc;
			if(_g4 == null) {
				var name1 = _g3;
				var _this1 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
				var result1 = new Array(_this1.length);
				var _g6 = 0;
				var _g7 = _this1.length;
				while(_g6 < _g7) {
					var i1 = _g6++;
					var x1 = _this1[i1];
					result1[i1] = little_tools_TextTools.remove($hxEnums[x1.__enum__].__constructs__[x1._hx_index]._hx_name,"_").toLowerCase();
				}
				var k = result1.indexOf($hxEnums[name1.__enum__].__constructs__[name1._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name1)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name1]))[0];
				var v = little_interpreter_InterpTokens.TypeCast(little_interpreter_InterpTokens.NullValue,little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_UNKNOWN));
				paramMap.set(k,v);
			} else {
				var type = _g4;
				var name2 = _g3;
				var _this2 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
				var result2 = new Array(_this2.length);
				var _g8 = 0;
				var _g9 = _this2.length;
				while(_g8 < _g9) {
					var i2 = _g8++;
					var x2 = _this2[i2];
					result2[i2] = little_tools_TextTools.remove($hxEnums[x2.__enum__].__constructs__[x2._hx_index]._hx_name,"_").toLowerCase();
				}
				var v1 = little_interpreter_InterpTokens.TypeCast(little_interpreter_InterpTokens.NullValue,type);
				paramMap.set(result2.indexOf($hxEnums[name2.__enum__].__constructs__[name2._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name2)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name2]))[0],v1);
			}
			break;
		case 9:
			var assignees = entry.assignees;
			var value = entry.value;
			var _g10 = assignees[0];
			if(_g10._hx_index == 2) {
				var _g11 = _g10.name;
				var _g12 = _g10.type;
				var _g13 = _g10.doc;
				if(_g12 == null) {
					var name3 = _g11;
					var _this3 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
					var result3 = new Array(_this3.length);
					var _g14 = 0;
					var _g15 = _this3.length;
					while(_g14 < _g15) {
						var i3 = _g14++;
						var x3 = _this3[i3];
						result3[i3] = little_tools_TextTools.remove($hxEnums[x3.__enum__].__constructs__[x3._hx_index]._hx_name,"_").toLowerCase();
					}
					var k1 = result3.indexOf($hxEnums[name3.__enum__].__constructs__[name3._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name3)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name3]))[0];
					var v2 = little_interpreter_InterpTokens.TypeCast(value,little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_UNKNOWN));
					paramMap.set(k1,v2);
				} else {
					var type1 = _g12;
					var name4 = _g11;
					var _this4 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
					var result4 = new Array(_this4.length);
					var _g16 = 0;
					var _g17 = _this4.length;
					while(_g16 < _g17) {
						var i4 = _g16++;
						var x4 = _this4[i4];
						result4[i4] = little_tools_TextTools.remove($hxEnums[x4.__enum__].__constructs__[x4._hx_index]._hx_name,"_").toLowerCase();
					}
					var v3 = little_interpreter_InterpTokens.TypeCast(value,type1);
					paramMap.set(result4.indexOf($hxEnums[name4.__enum__].__constructs__[name4._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(name4)[0] : Type.enumParameters(little_interpreter_Interpreter.run([name4]))[0],v3);
				}
			}
			break;
		default:
		}
	}
	var tmp = little_Little.memory;
	var tmp1 = little_interpreter_InterpTokens.FunctionCode(paramMap,little_interpreter_InterpTokens.Block([],little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_UNKNOWN)));
	var tmp2 = little_Little.keywords.TYPE_FUNCTION;
	var tmp3;
	if(doc != null) {
		var token = little_interpreter_Interpreter.evaluate(doc);
		var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		tmp3 = result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(token)[0] : Type.enumParameters(little_interpreter_Interpreter.run([token]))[0];
	} else {
		tmp3 = "";
	}
	tmp.write(path,tmp1,tmp2,tmp3);
	var _g = 0;
	var _g1 = little_Little.runtime.onFieldDeclared;
	while(_g < _g1.length) {
		var listener = _g1[_g];
		++_g;
		listener(little_tools_Extensions.asJoinedStringPath(name),little_interpreter_FieldDeclarationType.FUNCTION);
	}
};
little_interpreter_Interpreter.condition = function(name,pattern,body) {
	var conditionToken = ($_=little_Little.memory,$_.read.apply($_,little_tools_Extensions.asStringPath(name)));
	little_interpreter_Interpreter.assert(conditionToken.objectValue,little_tools_InterpTokensSimple.CONDITION_CODE,"" + Std.string(little_tools_Extensions.asStringPath(name)) + " is not a condition.");
	var patterns = Type.enumParameters(conditionToken.objectValue)[0];
	var givenPattern = Type.enumParameters(pattern)[0];
	var fit = null;
	fit = function(given,pattern,currentlyFits) {
		if(currentlyFits == null) {
			currentlyFits = true;
		}
		var _g = 0;
		var _g1 = given.length;
		while(_g < _g1) {
			var i = _g++;
			if(pattern[i] == null) {
				continue;
			}
			if(Type.enumEq(given[i],pattern[i])) {
				continue;
			}
			var e = given[i];
			var e1 = pattern[i];
			if($hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name != $hxEnums[e1.__enum__].__constructs__[e1._hx_index]._hx_name) {
				return false;
			}
			var _g2 = given[i];
			switch(_g2._hx_index) {
			case 0:
				var _g3 = _g2.line;
				if(Type.enumParameters(pattern[i])[0] != null) {
					return false;
				}
				break;
			case 2:
				var _g4 = _g2.name;
				var _g5 = _g2.type;
				var _g6 = _g2.doc;
				currentlyFits = currentlyFits && fit(Type.enumParameters(given[i]),Type.enumParameters(pattern[i]),currentlyFits);
				break;
			case 3:
				var _g7 = _g2.name;
				var _g8 = _g2.params;
				var _g9 = _g2.type;
				var _g10 = _g2.doc;
				currentlyFits = currentlyFits && fit(Type.enumParameters(given[i]),Type.enumParameters(pattern[i]),currentlyFits);
				break;
			case 4:
				var _g11 = _g2.callers;
				return false;
			case 5:
				var _g12 = _g2.name;
				var _g13 = _g2.exp;
				var _g14 = _g2.body;
				currentlyFits = currentlyFits && fit(Type.enumParameters(given[i]),Type.enumParameters(pattern[i]),currentlyFits);
				break;
			case 6:
				var _g15 = _g2.requiredParams;
				var _g16 = _g2.body;
				return false;
			case 7:
				var _g17 = _g2.name;
				var _g18 = _g2.params;
				currentlyFits = currentlyFits && fit(Type.enumParameters(given[i]),Type.enumParameters(pattern[i]),currentlyFits);
				break;
			case 8:
				var _g19 = _g2.value;
				var _g20 = _g2.type;
				currentlyFits = currentlyFits && fit(Type.enumParameters(given[i]),Type.enumParameters(pattern[i]),currentlyFits);
				break;
			case 9:
				var assignees = _g2.assignees;
				var value = _g2.value;
				var patternAssignees = Type.enumParameters(pattern[i])[0];
				if(patternAssignees != null) {
					currentlyFits = currentlyFits && fit(assignees,patternAssignees,currentlyFits);
				}
				if(Type.enumParameters(pattern[i])[1] != null) {
					currentlyFits = currentlyFits && fit(Type.enumParameters(value),Type.enumParameters(pattern[i])[1].getParameters(),currentlyFits);
				}
				break;
			case 10:
				var _g21 = _g2.value;
				var _g22 = _g2.type;
				currentlyFits = currentlyFits && fit(Type.enumParameters(given[i]),Type.enumParameters(pattern[i]),currentlyFits);
				break;
			case 11:
				var parts = _g2.parts;
				var type = _g2.type;
				var patternParts = Type.enumParameters(pattern[i])[0].copy();
				if(patternParts != null) {
					currentlyFits = currentlyFits && fit(parts,patternParts,currentlyFits);
				}
				if(Type.enumParameters(pattern[i])[1] != null) {
					currentlyFits = currentlyFits && fit(Type.enumParameters(type),Type.enumParameters(pattern[i])[1].getParameters(),currentlyFits);
				}
				break;
			case 12:
				var parts1 = _g2.body;
				var type1 = _g2.type;
				var patternParts1 = Type.enumParameters(pattern[i])[0].copy();
				if(patternParts1 != null) {
					currentlyFits = currentlyFits && fit(parts1,patternParts1,currentlyFits);
				}
				if(Type.enumParameters(pattern[i])[1] != null) {
					currentlyFits = currentlyFits && fit(Type.enumParameters(type1),Type.enumParameters(pattern[i])[1].getParameters(),currentlyFits);
				}
				break;
			case 13:
				var parts2 = _g2.parts;
				var patternParts2 = Type.enumParameters(pattern[i])[0];
				if(patternParts2 != null) {
					currentlyFits = currentlyFits && fit(parts2,patternParts2,currentlyFits);
				}
				break;
			case 14:
				var name = _g2.name;
				var property = _g2.property;
				currentlyFits = currentlyFits && fit(Type.enumParameters(given[i]),Type.enumParameters(pattern[i]),currentlyFits);
				break;
			case 15:
				var _g23 = _g2.num;
				if(Type.enumParameters(pattern[i])[0] != null) {
					return false;
				}
				break;
			case 16:
				var _g24 = _g2.num;
				if(Type.enumParameters(pattern[i])[0] != null) {
					return false;
				}
				break;
			case 17:
				var _g25 = _g2.string;
				if(Type.enumParameters(pattern[i])[0] != null) {
					return false;
				}
				break;
			case 18:
				var _g26 = _g2.doc;
				if(Type.enumParameters(pattern[i])[0] != null) {
					return false;
				}
				break;
			case 20:
				var _g27 = _g2.sign;
				if(Type.enumParameters(pattern[i])[0] != null) {
					return false;
				}
				break;
			case 24:
				var _g28 = _g2.word;
				if(Type.enumParameters(pattern[i])[0] != null) {
					return false;
				}
				break;
			case 25:
				var props = _g2.props;
				var typeName = _g2.typeName;
				return false;
			case 26:
				var _g29 = _g2.msg;
				if(Type.enumParameters(pattern[i])[0] != null) {
					return false;
				}
				break;
			default:
				continue;
			}
			if(!currentlyFits) {
				return false;
			}
		}
		return currentlyFits;
	};
	var patternString = little_tools_PrettyPrinter.stringifyInterpreter(null,pattern);
	var bodyString = little_tools_PrettyPrinter.stringifyInterpreter(Type.enumParameters(body)[0]);
	var map = patterns;
	var _g_map = map;
	var _g_keys = map.keys();
	while(_g_keys.hasNext()) {
		var key = _g_keys.next();
		var _g_value = _g_map.get(key);
		var _g_key = key;
		var _pattern = _g_key;
		var caller = _g_value;
		if(_pattern == null || fit(givenPattern,_pattern)) {
			var conditionRunner = Type.enumParameters(caller)[0];
			var params = [little_interpreter_InterpTokens.Write([little_interpreter_InterpTokens.VariableDeclaration(little_interpreter_InterpTokens.Identifier(little_Little.keywords.CONDITION_PATTERN_PARAMETER_NAME),little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_STRING),null)],little_interpreter_InterpTokens.Characters(patternString)),little_interpreter_InterpTokens.Write([little_interpreter_InterpTokens.VariableDeclaration(little_interpreter_InterpTokens.Identifier(little_Little.keywords.CONDITION_BODY_PARAMETER_NAME),little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_STRING),null)],little_interpreter_InterpTokens.Characters(bodyString))];
			var _g = 0;
			var _g1 = little_Little.runtime.onConditionCalled;
			while(_g < _g1.length) {
				var listener = _g1[_g];
				++_g;
				listener(little_tools_Extensions.asJoinedStringPath(name),givenPattern,body);
			}
			return little_interpreter_Interpreter.run(params.concat(conditionRunner),true);
		}
	}
	var tmp = "Pattern " + patternString + " is not supported in condition " + Std.string(little_tools_Extensions.asStringPath(name)) + " (patterns (`*` means any value): \n\t(";
	var _g = [];
	var pattern = patterns.keys();
	while(pattern.hasNext()) {
		var pattern1 = pattern.next();
		_g.push(pattern1);
	}
	var _this = _g;
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = little_tools_TextTools.replace(little_tools_PrettyPrinter.stringifyInterpreter(_this[i]),"null","*");
	}
	return little_interpreter_Interpreter.error(tmp + result.join("),\n\t(") + ")\n)");
};
little_interpreter_Interpreter.write = function(assignees,value) {
	var vars = [];
	var funcs = [];
	var containsFunction = false;
	var containsVariable = false;
	var _g = 0;
	while(_g < assignees.length) {
		var assignee = assignees[_g];
		++_g;
		switch(assignee._hx_index) {
		case 2:
			var name = assignee.name;
			var type = assignee.type;
			var doc = assignee.doc;
			little_interpreter_Interpreter.declareVariable(name,type,doc);
			vars.push(name);
			containsVariable = true;
			break;
		case 3:
			var name1 = assignee.name;
			var params = assignee.params;
			var type1 = assignee.type;
			var doc1 = assignee.doc;
			little_interpreter_Interpreter.declareFunction(name1,params,doc1);
			funcs.push(name1);
			containsFunction = true;
			break;
		default:
			vars.push(assignee);
			containsVariable = true;
		}
	}
	if(containsFunction) {
		var result = new Array(funcs.length);
		var _g = 0;
		var _g1 = funcs.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = little_tools_Extensions.asStringPath(funcs[i]);
		}
		var paths = result;
		var _g = 0;
		while(_g < paths.length) {
			var path = paths[_g];
			++_g;
			var func = ($_=little_Little.memory,$_.read.apply($_,path)).objectValue;
			little_Little.memory.set(path,little_interpreter_InterpTokens.FunctionCode(Type.enumParameters(func)[0],value),little_Little.keywords.TYPE_FUNCTION,"");
		}
	}
	if(containsVariable) {
		var result = new Array(vars.length);
		var _g = 0;
		var _g1 = vars.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = little_tools_Extensions.asStringPath(vars[i]);
		}
		var paths = result;
		var evaluated = little_interpreter_Interpreter.evaluate(value);
		var _g = 0;
		while(_g < paths.length) {
			var path = paths[_g];
			++_g;
			var tmp = little_Little.memory;
			var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.PROPERTY_ACCESS].slice();
			var result = new Array(_this.length);
			var _g1 = 0;
			var _g2 = _this.length;
			while(_g1 < _g2) {
				var i = _g1++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			tmp.set(path,result.indexOf($hxEnums[value.__enum__].__constructs__[value._hx_index]._hx_name.toLowerCase()) != -1 ? value : evaluated,little_tools_Extensions.type(evaluated),"");
		}
	}
	var _g = 0;
	var _g1 = little_Little.runtime.onWriteValue.slice();
	while(_g < _g1.length) {
		var listener = _g1[_g];
		++_g;
		var result = new Array(vars.length);
		var _g2 = 0;
		var _g3 = vars.length;
		while(_g2 < _g3) {
			var i = _g2++;
			var x = vars[i];
			var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
			var result1 = new Array(_this.length);
			var _g4 = 0;
			var _g5 = _this.length;
			while(_g4 < _g5) {
				var i1 = _g4++;
				var x1 = _this[i1];
				result1[i1] = little_tools_TextTools.remove($hxEnums[x1.__enum__].__constructs__[x1._hx_index]._hx_name,"_").toLowerCase();
			}
			result[i] = result1.indexOf($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(x)[0] : Type.enumParameters(little_interpreter_Interpreter.run([x]))[0];
		}
		var tmp = result;
		var result2 = new Array(funcs.length);
		var _g6 = 0;
		var _g7 = funcs.length;
		while(_g6 < _g7) {
			var i2 = _g6++;
			var x2 = funcs[i2];
			var _this1 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
			var result3 = new Array(_this1.length);
			var _g8 = 0;
			var _g9 = _this1.length;
			while(_g8 < _g9) {
				var i3 = _g8++;
				var x3 = _this1[i3];
				result3[i3] = little_tools_TextTools.remove($hxEnums[x3.__enum__].__constructs__[x3._hx_index]._hx_name,"_").toLowerCase();
			}
			result2[i2] = result3.indexOf($hxEnums[x2.__enum__].__constructs__[x2._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(x2)[0] : Type.enumParameters(little_interpreter_Interpreter.run([x2]))[0];
		}
		listener(tmp.concat(result2));
	}
	return value;
};
little_interpreter_Interpreter.call = function(name,params) {
	var functionCode = little_interpreter_Interpreter.evaluate(name);
	var functionName = little_tools_Extensions.asJoinedStringPath(name);
	var processedParams = [];
	var current = [];
	var _g = 0;
	var _g1 = Type.enumParameters(params)[0];
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		switch(p._hx_index) {
		case 0:
			var l = p.line;
			little_interpreter_Interpreter.setLine(l);
			break;
		case 1:
			processedParams.push(little_interpreter_Interpreter.calculate(current));
			current = [];
			break;
		default:
			current.push(p);
		}
	}
	if(current.length > 0) {
		processedParams.push(little_interpreter_Interpreter.calculate(current));
	}
	if(functionCode._hx_index == 6) {
		var requiredParams = functionCode.requiredParams;
		var body = functionCode.body;
		var given = processedParams;
		var resulting = [];
		var attachment = [];
		var _g = requiredParams.keyValueIterator();
		while(_g.hasNext()) {
			var _g1 = _g.next();
			var key = _g1.key;
			var typeCast = _g1.value;
			var name = key;
			var value = little_interpreter_InterpTokens.NullValue;
			var type = little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_DYNAMIC);
			if(typeCast._hx_index == 10) {
				var _g2 = typeCast.value;
				var _g3 = typeCast.type;
				if(_g2._hx_index == 21) {
					var t = _g3;
					type = t;
				} else if(Type.enumParameters(_g3)[0] == little_Little.keywords.TYPE_UNKNOWN == true) {
					var v = _g2;
					value = v;
				} else {
					var v1 = _g2;
					var t1 = _g3;
					type = t1;
					value = v1;
				}
			}
			if(processedParams.length > 0) {
				value = processedParams.shift();
			}
			resulting.push(value);
			attachment.push(little_interpreter_InterpTokens.Write([little_interpreter_InterpTokens.VariableDeclaration(little_interpreter_InterpTokens.Identifier(name),type,null)],value));
		}
		var _g = 0;
		var _g1 = little_Little.runtime.onFunctionCalled;
		while(_g < _g1.length) {
			var listener = _g1[_g];
			++_g;
			listener(functionName,resulting);
		}
		return little_interpreter_Interpreter.run(attachment.concat(Type.enumParameters(body)[0]));
	} else {
		return null;
	}
};
little_interpreter_Interpreter.read = function(name) {
	return ($_=little_Little.memory,$_.read.apply($_,little_tools_Extensions.asStringPath(name))).objectValue;
};
little_interpreter_Interpreter.typeCast = function(value,type) {
	var _this = [little_tools_InterpTokensSimple.NUMBER].slice();
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		var x = _this[i];
		result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
	}
	if(result.indexOf($hxEnums[value.__enum__].__constructs__[value._hx_index]._hx_name.toLowerCase()) != -1 && Type.enumParameters(type)[0] == little_Little.keywords.TYPE_FLOAT) {
		return little_interpreter_InterpTokens.Decimal(Type.enumParameters(value)[0]);
	}
	var _this = [little_tools_InterpTokensSimple.DECIMAL].slice();
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		var x = _this[i];
		result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
	}
	if(result.indexOf($hxEnums[value.__enum__].__constructs__[value._hx_index]._hx_name.toLowerCase()) != -1 && Type.enumParameters(type)[0] == little_Little.keywords.TYPE_INT) {
		return little_interpreter_InterpTokens.Number(Type.enumParameters(value)[0] | 0);
	}
	var _this = [little_tools_InterpTokensSimple.NUMBER,little_tools_InterpTokensSimple.DECIMAL].slice();
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		var x = _this[i];
		result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
	}
	if(result.indexOf($hxEnums[value.__enum__].__constructs__[value._hx_index]._hx_name.toLowerCase()) != -1 && Type.enumParameters(type)[0] == little_Little.keywords.TYPE_STRING) {
		return little_interpreter_InterpTokens.Characters(Std.string(Type.enumParameters(value)[0]));
	}
	var _this = [little_tools_InterpTokensSimple.TRUE_VALUE,little_tools_InterpTokensSimple.FALSE_VALUE,little_tools_InterpTokensSimple.NULL_VALUE].slice();
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		var x = _this[i];
		result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
	}
	if(result.indexOf($hxEnums[value.__enum__].__constructs__[value._hx_index]._hx_name.toLowerCase()) != -1 && Type.enumParameters(type)[0] == little_Little.keywords.TYPE_STRING) {
		var tmp;
		var _this = [little_tools_InterpTokensSimple.TRUE_VALUE].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		if(result.indexOf($hxEnums[value.__enum__].__constructs__[value._hx_index]._hx_name.toLowerCase()) != -1) {
			tmp = little_Little.keywords.TRUE_VALUE;
		} else {
			var _this = [little_tools_InterpTokensSimple.FALSE_VALUE].slice();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			tmp = result.indexOf($hxEnums[value.__enum__].__constructs__[value._hx_index]._hx_name.toLowerCase()) != -1 ? little_Little.keywords.FALSE_VALUE : little_Little.keywords.NULL_VALUE;
		}
		return little_interpreter_InterpTokens.Characters(tmp);
	}
	var _g = 0;
	var _g1 = little_Little.runtime.onTypeCast;
	while(_g < _g1.length) {
		var listener = _g1[_g];
		++_g;
		listener(value,little_tools_Extensions.asJoinedStringPath(type));
	}
	return value;
};
little_interpreter_Interpreter.run = function(body,propagateReturns) {
	if(propagateReturns == null) {
		propagateReturns = false;
	}
	var returnVal = null;
	little_Little.memory.referrer.pushScope();
	var i = 0;
	while(i < body.length) {
		var token = body[i];
		if(token == null) {
			++i;
			continue;
		}
		little_Little.runtime.currentToken = token;
		switch(token._hx_index) {
		case 0:
			var line = token.line;
			little_interpreter_Interpreter.setLine(line);
			break;
		case 1:
			little_interpreter_Interpreter.splitLine();
			break;
		case 2:
			var name = token.name;
			var type = token.type;
			var doc = token.doc;
			var _this = [little_tools_InterpTokensSimple.BLOCK].slice();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i1 = _g++;
				var x = _this[i1];
				result[i1] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			var tmp = result.indexOf($hxEnums[name.__enum__].__constructs__[name._hx_index]._hx_name.toLowerCase()) != -1 ? little_interpreter_Interpreter.evaluate(name) : name;
			var _this1 = [little_tools_InterpTokensSimple.BLOCK].slice();
			var result1 = new Array(_this1.length);
			var _g2 = 0;
			var _g3 = _this1.length;
			while(_g2 < _g3) {
				var i2 = _g2++;
				var x1 = _this1[i2];
				result1[i2] = little_tools_TextTools.remove($hxEnums[x1.__enum__].__constructs__[x1._hx_index]._hx_name,"_").toLowerCase();
			}
			little_interpreter_Interpreter.declareVariable(tmp,result1.indexOf($hxEnums[type.__enum__].__constructs__[type._hx_index]._hx_name.toLowerCase()) != -1 ? little_interpreter_Interpreter.evaluate(type) : type,doc != null ? little_interpreter_Interpreter.evaluate(doc) : little_interpreter_InterpTokens.Characters(""));
			returnVal = little_interpreter_InterpTokens.NullValue;
			break;
		case 3:
			var name1 = token.name;
			var params = token.params;
			var type1 = token.type;
			var doc1 = token.doc;
			var _this2 = [little_tools_InterpTokensSimple.BLOCK].slice();
			var result2 = new Array(_this2.length);
			var _g4 = 0;
			var _g5 = _this2.length;
			while(_g4 < _g5) {
				var i3 = _g4++;
				var x2 = _this2[i3];
				result2[i3] = little_tools_TextTools.remove($hxEnums[x2.__enum__].__constructs__[x2._hx_index]._hx_name,"_").toLowerCase();
			}
			little_interpreter_Interpreter.declareFunction(result2.indexOf($hxEnums[name1.__enum__].__constructs__[name1._hx_index]._hx_name.toLowerCase()) != -1 ? little_interpreter_Interpreter.evaluate(name1) : name1,params,doc1 != null ? little_interpreter_Interpreter.evaluate(doc1) : little_interpreter_InterpTokens.Characters(""));
			returnVal = little_interpreter_InterpTokens.NullValue;
			break;
		case 5:
			var name2 = token.name;
			var exp = token.exp;
			var body1 = token.body;
			returnVal = little_interpreter_Interpreter.condition(name2,exp,body1);
			var tmp1;
			if(returnVal != null) {
				var _this3 = [little_tools_InterpTokensSimple.FUNCTION_RETURN].slice();
				var result3 = new Array(_this3.length);
				var _g6 = 0;
				var _g7 = _this3.length;
				while(_g6 < _g7) {
					var i4 = _g6++;
					var x3 = _this3[i4];
					result3[i4] = little_tools_TextTools.remove($hxEnums[x3.__enum__].__constructs__[x3._hx_index]._hx_name,"_").toLowerCase();
				}
				tmp1 = result3.indexOf($hxEnums[returnVal.__enum__].__constructs__[returnVal._hx_index]._hx_name.toLowerCase()) != -1;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				return little_interpreter_Interpreter.evaluate(returnVal);
			}
			break;
		case 7:
			var name3 = token.name;
			var params1 = token.params;
			returnVal = little_interpreter_Interpreter.call(name3,params1);
			break;
		case 8:
			var value = token.value;
			var type2 = token.type;
			var _this4 = [little_tools_InterpTokensSimple.HAXE_EXTERN].slice();
			var result4 = new Array(_this4.length);
			var _g8 = 0;
			var _g9 = _this4.length;
			while(_g8 < _g9) {
				var i5 = _g8++;
				var x4 = _this4[i5];
				result4[i5] = little_tools_TextTools.remove($hxEnums[x4.__enum__].__constructs__[x4._hx_index]._hx_name,"_").toLowerCase();
			}
			if(result4.indexOf($hxEnums[value.__enum__].__constructs__[value._hx_index]._hx_name.toLowerCase()) != -1) {
				return Type.enumParameters(value)[0]();
			}
			var v = little_interpreter_Interpreter.evaluate(value);
			var t = little_tools_Extensions.asTokenPath(little_tools_Extensions.type(v));
			if(propagateReturns) {
				return little_interpreter_InterpTokens.FunctionReturn(v,t);
			} else {
				return v;
			}
			break;
		case 9:
			var assignees = token.assignees;
			var value1 = token.value;
			returnVal = little_interpreter_Interpreter.write(assignees,value1);
			break;
		case 12:
			var body2 = token.body;
			var type3 = token.type;
			returnVal = little_interpreter_Interpreter.run(body2);
			break;
		case 14:
			var name4 = token.name;
			var property = token.property;
			returnVal = little_interpreter_Interpreter.evaluate(token);
			break;
		case 24:
			var name5 = token.word;
			returnVal = little_interpreter_Interpreter.read(token);
			break;
		case 27:
			var func = token.func;
			returnVal = func();
			break;
		default:
			returnVal = little_interpreter_Interpreter.evaluate(token);
		}
		var _g10 = 0;
		var _g11 = little_Little.runtime.onTokenInterpreted;
		while(_g10 < _g11.length) {
			var listener = _g11[_g10];
			++_g10;
			listener(token);
		}
		little_Little.runtime.previousToken = token;
		++i;
	}
	little_Little.memory.referrer.popScope();
	return returnVal;
};
little_interpreter_Interpreter.evaluate = function(exp,dontThrow) {
	if(dontThrow == null) {
		dontThrow = false;
	}
	switch(exp._hx_index) {
	case 0:
		var line = exp.line;
		little_interpreter_Interpreter.setLine(line);
		return little_interpreter_InterpTokens.NullValue;
	case 1:
		little_interpreter_Interpreter.splitLine();
		return little_interpreter_InterpTokens.NullValue;
	case 2:
		var name = exp.name;
		var type = exp.type;
		var doc = exp.doc;
		var _this = [little_tools_InterpTokensSimple.BLOCK].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		var tmp = result.indexOf($hxEnums[name.__enum__].__constructs__[name._hx_index]._hx_name.toLowerCase()) != -1 ? little_interpreter_Interpreter.evaluate(name) : name;
		var _this = [little_tools_InterpTokensSimple.BLOCK].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		little_interpreter_Interpreter.declareVariable(tmp,result.indexOf($hxEnums[type.__enum__].__constructs__[type._hx_index]._hx_name.toLowerCase()) != -1 ? little_interpreter_Interpreter.evaluate(type) : type,little_interpreter_Interpreter.evaluate(doc));
		return little_interpreter_InterpTokens.NullValue;
	case 3:
		var name = exp.name;
		var params = exp.params;
		var type = exp.type;
		var doc = exp.doc;
		var _this = [little_tools_InterpTokensSimple.BLOCK].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		little_interpreter_Interpreter.declareFunction(result.indexOf($hxEnums[name.__enum__].__constructs__[name._hx_index]._hx_name.toLowerCase()) != -1 ? little_interpreter_Interpreter.evaluate(name) : name,params,little_interpreter_Interpreter.evaluate(doc));
		return little_interpreter_InterpTokens.NullValue;
	case 5:
		var name = exp.name;
		var exp1 = exp.exp;
		var body = exp.body;
		return little_interpreter_Interpreter.condition(name,exp1,body);
	case 6:
		var _g = exp.requiredParams;
		var _g = exp.body;
		return exp;
	case 7:
		var name = exp.name;
		var params = exp.params;
		var currentLine = little_Little.runtime.line;
		return little_interpreter_Interpreter.call(name,params);
	case 8:
		var value = exp.value;
		var t = exp.type;
		return little_interpreter_Interpreter.evaluate(little_interpreter_Interpreter.typeCast(value,t));
	case 9:
		var assignees = exp.assignees;
		var value = exp.value;
		return little_interpreter_Interpreter.write(assignees,value);
	case 10:
		var value = exp.value;
		var t = exp.type;
		return little_interpreter_Interpreter.typeCast(value,t);
	case 11:
		var parts = exp.parts;
		var t = exp.type;
		if(little_tools_Extensions.asJoinedStringPath(t) == little_Little.keywords.TYPE_UNKNOWN) {
			return little_interpreter_Interpreter.calculate(parts);
		}
		return little_interpreter_Interpreter.typeCast(little_interpreter_Interpreter.calculate(parts),t);
	case 12:
		var body = exp.body;
		var t = exp.type;
		var currentLine = little_Little.runtime.line;
		var returnVal = little_interpreter_Interpreter.run(body);
		little_interpreter_Interpreter.setLine(currentLine);
		if(little_tools_Extensions.asJoinedStringPath(t) == little_Little.keywords.TYPE_UNKNOWN) {
			return little_interpreter_Interpreter.evaluate(returnVal,dontThrow);
		}
		return little_interpreter_Interpreter.evaluate(little_interpreter_Interpreter.typeCast(returnVal,t),dontThrow);
	case 13:
		var parts = exp.parts;
		var _g = [];
		var _g1 = 0;
		while(_g1 < parts.length) {
			var p = parts[_g1];
			++_g1;
			_g.push(little_interpreter_Interpreter.evaluate(p,dontThrow));
		}
		return little_interpreter_InterpTokens.PartArray(_g);
	case 14:
		var name = exp.name;
		var property = exp.property;
		var path = little_tools_Extensions.toIdentifierPath(exp);
		var _g = [];
		var _g1 = 0;
		var _g2 = path;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			var _this = [little_tools_InterpTokensSimple.IDENTIFIER].slice();
			var result = new Array(_this.length);
			var _g3 = 0;
			var _g4 = _this.length;
			while(_g3 < _g4) {
				var i = _g3++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			if(result.indexOf($hxEnums[v.__enum__].__constructs__[v._hx_index]._hx_name.toLowerCase()) == -1) {
				_g.push(v);
			}
		}
		if(_g.length == 0) {
			return little_interpreter_Interpreter.read(exp);
		} else {
			var tmp;
			var token = path[0];
			var _this = [little_tools_InterpTokensSimple.IDENTIFIER].slice();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) == -1) {
				var _g = [];
				var _g1 = 0;
				var _g2 = path.slice(1);
				while(_g1 < _g2.length) {
					var v = _g2[_g1];
					++_g1;
					var _this = [little_tools_InterpTokensSimple.IDENTIFIER].slice();
					var result = new Array(_this.length);
					var _g3 = 0;
					var _g4 = _this.length;
					while(_g3 < _g4) {
						var i = _g3++;
						var x = _this[i];
						result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
					}
					if(result.indexOf($hxEnums[v.__enum__].__constructs__[v._hx_index]._hx_name.toLowerCase()) == -1) {
						_g.push(v);
					}
				}
				tmp = _g.length == 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				var value = little_interpreter_Interpreter.evaluate(path[0]);
				var tmp = little_Little.memory;
				var tmp1 = { objectValue : value, objectAddress : little_Little.memory.store(value)};
				var _this = path.slice(1);
				var result = new Array(_this.length);
				var _g = 0;
				var _g1 = _this.length;
				while(_g < _g1) {
					var i = _g++;
					var token = _this[i];
					var _this1 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
					var result1 = new Array(_this1.length);
					var _g2 = 0;
					var _g3 = _this1.length;
					while(_g2 < _g3) {
						var i1 = _g2++;
						var x = _this1[i1];
						result1[i1] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
					}
					result[i] = result1.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(token)[0] : Type.enumParameters(little_interpreter_Interpreter.run([token]))[0];
				}
				return ($_=tmp,$_.readFrom.apply($_,[tmp1].concat(result))).objectValue;
			} else {
				var tmp = "Cannot access " + path.join(little_Little.keywords.PROPERTY_ACCESS_SIGN) + ", path cannot contain a raw value in the middle (for property: ";
				var _g = [];
				var _g1 = 0;
				var _g2 = path.slice(1);
				while(_g1 < _g2.length) {
					var v = _g2[_g1];
					++_g1;
					var _this = [little_tools_InterpTokensSimple.IDENTIFIER].slice();
					var result = new Array(_this.length);
					var _g3 = 0;
					var _g4 = _this.length;
					while(_g3 < _g4) {
						var i = _g3++;
						var x = _this[i];
						result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
					}
					if(result.indexOf($hxEnums[v.__enum__].__constructs__[v._hx_index]._hx_name.toLowerCase()) == -1) {
						_g.push(v);
					}
				}
				return little_interpreter_Interpreter.error(tmp + little_tools_PrettyPrinter.stringifyInterpreter(null,_g[0]));
			}
		}
		break;
	case 15:
		var _g = exp.num;
		return exp;
	case 16:
		var _g = exp.num;
		return exp;
	case 17:
		var _g = exp.string;
		return exp;
	case 19:
		var _g = exp.pointer;
		return exp;
	case 20:
		var _g = exp.sign;
		return exp;
	case 21:case 22:case 23:
		return exp;
	case 24:
		var word = exp.word;
		return little_interpreter_Interpreter.read(exp);
	case 25:
		var _g = exp.props;
		var _g = exp.typeName;
		return exp;
	case 26:
		var msg = exp.msg;
		if(!dontThrow) {
			little_Little.runtime.throwError(exp,"Interpreter, Value Evaluator");
		}
		return exp;
	case 27:
		var func = exp.func;
		return func();
	default:
		return little_interpreter_Interpreter.evaluate(little_interpreter_InterpTokens.ErrorMessage("Unable to evaluate token `" + Std.string(exp) + "`"),dontThrow);
	}
};
little_interpreter_Interpreter.calculate = function(p) {
	while(true) {
		var tmp;
		if(p.length == 1 && ((Type.enumParameters(p[0])[0]) instanceof Array)) {
			var token = p[0];
			var _this = [little_tools_InterpTokensSimple.BLOCK].slice();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			tmp = result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) == -1;
		} else {
			tmp = false;
		}
		if(!tmp) {
			break;
		}
		p = Type.enumParameters(p[0])[0];
	}
	var tokens = little_interpreter_Interpreter.group(p);
	var castType = null;
	if(tokens.length == 1) {
		var token = tokens[0];
		var _this = [little_tools_InterpTokensSimple.PART_ARRAY].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1) {
			tokens = Type.enumParameters(tokens[0])[0];
		} else {
			var token = tokens[0];
			var _this = [little_tools_InterpTokensSimple.EXPRESSION].slice();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1) {
				tokens = Type.enumParameters(tokens[0])[0];
				castType = Type.enumParameters(tokens[0])[1];
			} else {
				var token = tokens[0];
				var _this = [little_tools_InterpTokensSimple.BLOCK].slice();
				var result = new Array(_this.length);
				var _g = 0;
				var _g1 = _this.length;
				while(_g < _g1) {
					var i = _g++;
					var x = _this[i];
					result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
				}
				if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1) {
					tokens = [little_interpreter_Interpreter.run(Type.enumParameters(tokens[0])[0])];
					castType = Type.enumParameters(tokens[0])[1];
				}
			}
		}
	}
	var calculated = null;
	var sign = "";
	var _g = [];
	var _g1 = 0;
	var _g2 = tokens;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null) {
			_g.push(v);
		}
	}
	tokens = _g;
	var _g = 0;
	while(_g < tokens.length) {
		var token = tokens[_g];
		++_g;
		switch(token._hx_index) {
		case 11:
			var parts = token.parts;
			var t = token.type;
			var val = t != null ? little_interpreter_Interpreter.typeCast(little_interpreter_Interpreter.calculate(parts),t) : little_interpreter_Interpreter.calculate(parts);
			if(sign != "" && calculated == null) {
				var _this = little_Little.operators;
				calculated = Object.prototype.hasOwnProperty.call(_this.rhsOnly.h,sign) ? _this.rhsOnly.h[sign](val) : Object.prototype.hasOwnProperty.call(_this.lhsOnly.h,sign) ? little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear before the sign (" + little_tools_PrettyPrinter.stringifyInterpreter(null,val) + sign + " instead of " + sign + little_tools_PrettyPrinter.stringifyInterpreter(null,val) + ")") : Object.prototype.hasOwnProperty.call(_this.standard.h,sign) ? little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear between two values (" + little_tools_PrettyPrinter.stringifyInterpreter(null,val) + " " + sign + " <some value>)") : little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " does not exist. did you make a typo?");
			} else if(calculated == null) {
				calculated = val;
			} else if(sign == "") {
				little_interpreter_Interpreter.error("Two values cannot come one after the other (" + Std.string(calculated) + ", " + Std.string(token) + "). At least one of them should be an operator, or, put an operator in between.");
			} else {
				var _this1 = little_Little.operators;
				calculated = Object.prototype.hasOwnProperty.call(_this1.standard.h,sign) ? _this1.standard.h[sign](calculated,val) : Object.prototype.hasOwnProperty.call(_this1.lhsOnly.h,sign) ? little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should not appear between two values, only to the right of one of them (" + little_tools_PrettyPrinter.stringifyInterpreter(null,val) + sign + " or " + little_tools_PrettyPrinter.stringifyInterpreter(null,calculated) + sign + ")") : Object.prototype.hasOwnProperty.call(_this1.rhsOnly.h,sign) ? little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should not appear between two values, only to the left of one of them (" + sign + little_tools_PrettyPrinter.stringifyInterpreter(null,val) + " or " + sign + little_tools_PrettyPrinter.stringifyInterpreter(null,calculated) + ")") : little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " does not exist. did you make a typo?");
			}
			break;
		case 13:
			var parts1 = token.parts;
			if(sign != "" && calculated == null) {
				var _this2 = little_Little.operators;
				var rhs = little_interpreter_Interpreter.calculate(parts1);
				calculated = Object.prototype.hasOwnProperty.call(_this2.rhsOnly.h,sign) ? _this2.rhsOnly.h[sign](rhs) : Object.prototype.hasOwnProperty.call(_this2.lhsOnly.h,sign) ? little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear before the sign (" + little_tools_PrettyPrinter.stringifyInterpreter(null,rhs) + sign + " instead of " + sign + little_tools_PrettyPrinter.stringifyInterpreter(null,rhs) + ")") : Object.prototype.hasOwnProperty.call(_this2.standard.h,sign) ? little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear between two values (" + little_tools_PrettyPrinter.stringifyInterpreter(null,rhs) + " " + sign + " <some value>)") : little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " does not exist. did you make a typo?");
			} else if(calculated == null) {
				calculated = little_interpreter_Interpreter.calculate(parts1);
			} else if(sign == "") {
				little_interpreter_Interpreter.error("Two values cannot come one after the other (" + Std.string(calculated) + ", " + Std.string(token) + "). At least one of them should be an operator, or, put an operator in between.");
			} else {
				var _this3 = little_Little.operators;
				var rhs1 = little_interpreter_Interpreter.calculate(parts1);
				calculated = Object.prototype.hasOwnProperty.call(_this3.standard.h,sign) ? _this3.standard.h[sign](calculated,rhs1) : Object.prototype.hasOwnProperty.call(_this3.lhsOnly.h,sign) ? little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should not appear between two values, only to the right of one of them (" + little_tools_PrettyPrinter.stringifyInterpreter(null,rhs1) + sign + " or " + little_tools_PrettyPrinter.stringifyInterpreter(null,calculated) + sign + ")") : Object.prototype.hasOwnProperty.call(_this3.rhsOnly.h,sign) ? little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should not appear between two values, only to the left of one of them (" + sign + little_tools_PrettyPrinter.stringifyInterpreter(null,rhs1) + " or " + sign + little_tools_PrettyPrinter.stringifyInterpreter(null,calculated) + ")") : little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " does not exist. did you make a typo?");
			}
			break;
		case 20:
			var s = token.sign;
			sign = s;
			if(tokens.length == 1) {
				return token;
			}
			if(Type.enumEq(tokens[tokens.length - 1],token)) {
				var _this4 = little_Little.operators;
				calculated = _this4.lhsOnly.exists(sign) ? (_this4.lhsOnly.get(sign))(calculated) : _this4.rhsOnly.exists(sign) ? little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear after the sign (" + sign + little_tools_PrettyPrinter.stringifyInterpreter(null,calculated) + " instead of " + little_tools_PrettyPrinter.stringifyInterpreter(null,calculated) + sign + ")") : _this4.standard.exists(sign) ? little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear between two values (" + little_tools_PrettyPrinter.stringifyInterpreter(null,calculated) + " " + sign + " <some value>)") : little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " does not exist. did you make a typo?");
			}
			break;
		default:
			if(sign != "" && calculated == null) {
				var _this5 = little_Little.operators;
				calculated = Object.prototype.hasOwnProperty.call(_this5.rhsOnly.h,sign) ? _this5.rhsOnly.h[sign](token) : Object.prototype.hasOwnProperty.call(_this5.lhsOnly.h,sign) ? little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear before the sign (" + little_tools_PrettyPrinter.stringifyInterpreter(null,token) + sign + " instead of " + sign + little_tools_PrettyPrinter.stringifyInterpreter(null,token) + ")") : Object.prototype.hasOwnProperty.call(_this5.standard.h,sign) ? little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear between two values (" + little_tools_PrettyPrinter.stringifyInterpreter(null,token) + " " + sign + " <some value>)") : little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " does not exist. did you make a typo?");
			} else if(sign == "" && calculated != null) {
				throw haxe_Exception.thrown("Unexpected token: " + Std.string(token) + " After calculating " + Std.string(calculated));
			} else if(calculated == null) {
				calculated = token;
			} else if(sign == "") {
				little_interpreter_Interpreter.error("Two values cannot come one after the other (" + Std.string(calculated) + ", " + Std.string(token) + "). At least one of them should be an operator, or, put an operator in between.");
			} else {
				var _this6 = little_Little.operators;
				calculated = Object.prototype.hasOwnProperty.call(_this6.standard.h,sign) ? _this6.standard.h[sign](calculated,token) : Object.prototype.hasOwnProperty.call(_this6.lhsOnly.h,sign) ? little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should not appear between two values, only to the right of one of them (" + little_tools_PrettyPrinter.stringifyInterpreter(null,token) + sign + " or " + little_tools_PrettyPrinter.stringifyInterpreter(null,calculated) + sign + ")") : Object.prototype.hasOwnProperty.call(_this6.rhsOnly.h,sign) ? little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should not appear between two values, only to the left of one of them (" + sign + little_tools_PrettyPrinter.stringifyInterpreter(null,token) + " or " + sign + little_tools_PrettyPrinter.stringifyInterpreter(null,calculated) + ")") : little_interpreter_InterpTokens.ErrorMessage("Operator " + sign + " does not exist. did you make a typo?");
			}
		}
	}
	if(castType != null) {
		return little_interpreter_Interpreter.typeCast(calculated,castType);
	}
	return calculated;
};
little_interpreter_Interpreter.group = function(tokens) {
	var post = tokens;
	var pre = [];
	var operatorGroup = little_Little.operators.iterateByPriority();
	while(operatorGroup.hasNext()) {
		var operatorGroup1 = operatorGroup.next();
		pre = post.slice();
		post = [];
		var i = 0;
		_hx_loop2: while(i < pre.length) {
			var token = pre[i];
			var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.BLOCK].slice();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i1 = _g++;
				var x = _this[i1];
				result[i1] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			var token1 = result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1 ? little_interpreter_Interpreter.evaluate(pre[i]) : pre[i];
			switch(token1._hx_index) {
			case 11:
				var parts = token1.parts;
				var type = token1.type;
				post.push(little_interpreter_InterpTokens.Expression(little_interpreter_Interpreter.group(parts),type));
				break;
			case 20:
				var _g2 = token1.sign;
				var _g3 = [];
				var _g4 = 0;
				var _g5 = operatorGroup1;
				while(_g4 < _g5.length) {
					var v = _g5[_g4];
					++_g4;
					if(v.sign == _g2) {
						_g3.push(v);
					}
				}
				if(_g3.length > 0 == true) {
					if(i == pre.length - 1) {
						post.push(little_interpreter_InterpTokens.PartArray([post.pop(),token1]));
						break _hx_loop2;
					}
					var lookbehind = post.length > 0 ? post[post.length - 1] : little_interpreter_InterpTokens.Sign("_");
					var token2 = pre[i + 1];
					var _this1 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.BLOCK].slice();
					var result1 = new Array(_this1.length);
					var _g6 = 0;
					var _g7 = _this1.length;
					while(_g6 < _g7) {
						var i2 = _g6++;
						var x1 = _this1[i2];
						result1[i2] = little_tools_TextTools.remove($hxEnums[x1.__enum__].__constructs__[x1._hx_index]._hx_name,"_").toLowerCase();
					}
					var lookahead = result1.indexOf($hxEnums[token2.__enum__].__constructs__[token2._hx_index]._hx_name.toLowerCase()) != -1 ? little_interpreter_Interpreter.evaluate(pre[i + 1]) : pre[i + 1];
					var tmp;
					var _this2 = [little_tools_InterpTokensSimple.SIGN].slice();
					var result2 = new Array(_this2.length);
					var _g8 = 0;
					var _g9 = _this2.length;
					while(_g8 < _g9) {
						var i3 = _g8++;
						var x2 = _this2[i3];
						result2[i3] = little_tools_TextTools.remove($hxEnums[x2.__enum__].__constructs__[x2._hx_index]._hx_name,"_").toLowerCase();
					}
					if(result2.indexOf($hxEnums[lookbehind.__enum__].__constructs__[lookbehind._hx_index]._hx_name.toLowerCase()) != -1) {
						var _g10 = [];
						var _g11 = 0;
						var _g12 = operatorGroup1;
						while(_g11 < _g12.length) {
							var v1 = _g12[_g11];
							++_g11;
							if(v1.sign == Type.enumParameters(lookbehind)[1]) {
								_g10.push(v1);
							}
						}
						tmp = _g10.length > 0;
					} else {
						tmp = false;
					}
					if(tmp) {
						var _this3 = [little_tools_InterpTokensSimple.SIGN].slice();
						var result3 = new Array(_this3.length);
						var _g13 = 0;
						var _g14 = _this3.length;
						while(_g13 < _g14) {
							var i4 = _g13++;
							var x3 = _this3[i4];
							result3[i4] = little_tools_TextTools.remove($hxEnums[x3.__enum__].__constructs__[x3._hx_index]._hx_name,"_").toLowerCase();
						}
						if(result3.indexOf($hxEnums[lookahead.__enum__].__constructs__[lookahead._hx_index]._hx_name.toLowerCase()) != -1) {
							++i;
							if(i + 1 >= pre.length) {
								little_interpreter_Interpreter.error("Expression ended with an operator, when an operand was expected.");
							}
							var token3 = pre[i + 1];
							var _this4 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.BLOCK].slice();
							var result4 = new Array(_this4.length);
							var _g15 = 0;
							var _g16 = _this4.length;
							while(_g15 < _g16) {
								var i5 = _g15++;
								var x4 = _this4[i5];
								result4[i5] = little_tools_TextTools.remove($hxEnums[x4.__enum__].__constructs__[x4._hx_index]._hx_name,"_").toLowerCase();
							}
							var lookahead2 = result4.indexOf($hxEnums[token3.__enum__].__constructs__[token3._hx_index]._hx_name.toLowerCase()) != -1 ? little_interpreter_Interpreter.evaluate(pre[i + 1]) : pre[i + 1];
							var g = [];
							while(true) {
								var tmp1;
								var _this5 = [little_tools_InterpTokensSimple.SIGN].slice();
								var result5 = new Array(_this5.length);
								var _g17 = 0;
								var _g18 = _this5.length;
								while(_g17 < _g18) {
									var i6 = _g17++;
									var x5 = _this5[i6];
									result5[i6] = little_tools_TextTools.remove($hxEnums[x5.__enum__].__constructs__[x5._hx_index]._hx_name,"_").toLowerCase();
								}
								if(result5.indexOf($hxEnums[lookahead2.__enum__].__constructs__[lookahead2._hx_index]._hx_name.toLowerCase()) != -1) {
									var _g19 = [];
									var _g20 = 0;
									var _g21 = operatorGroup1;
									while(_g20 < _g21.length) {
										var v2 = _g21[_g20];
										++_g20;
										if(v2.sign == Type.enumParameters(lookahead2)[1] && v2.side == little_interpreter_memory_OperatorType.RHS_ONLY) {
											_g19.push(v2);
										}
									}
									tmp1 = _g19.length > 0;
								} else {
									tmp1 = false;
								}
								if(!tmp1) {
									break;
								}
								g.push(lookahead2);
								++i;
								if(i + 1 >= pre.length) {
									little_interpreter_Interpreter.error("Expression ended with an operator, when an operand was expected.");
								}
								var token4 = pre[i + 1];
								var _this6 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.BLOCK].slice();
								var result6 = new Array(_this6.length);
								var _g22 = 0;
								var _g23 = _this6.length;
								while(_g22 < _g23) {
									var i7 = _g22++;
									var x6 = _this6[i7];
									result6[i7] = little_tools_TextTools.remove($hxEnums[x6.__enum__].__constructs__[x6._hx_index]._hx_name,"_").toLowerCase();
								}
								lookahead2 = result6.indexOf($hxEnums[token4.__enum__].__constructs__[token4._hx_index]._hx_name.toLowerCase()) != -1 ? little_interpreter_Interpreter.evaluate(pre[i + 1]) : pre[i + 1];
							}
							g.push(lookahead2);
							post.push(little_interpreter_InterpTokens.PartArray([token1,little_interpreter_InterpTokens.PartArray(little_interpreter_Interpreter.group(g))]));
							++i;
						} else {
							var _this7 = [little_tools_InterpTokensSimple.EXPRESSION].slice();
							var result7 = new Array(_this7.length);
							var _g24 = 0;
							var _g25 = _this7.length;
							while(_g24 < _g25) {
								var i8 = _g24++;
								var x7 = _this7[i8];
								result7[i8] = little_tools_TextTools.remove($hxEnums[x7.__enum__].__constructs__[x7._hx_index]._hx_name,"_").toLowerCase();
							}
							if(result7.indexOf($hxEnums[lookahead.__enum__].__constructs__[lookahead._hx_index]._hx_name.toLowerCase()) != -1) {
								post.push(little_interpreter_InterpTokens.PartArray([token1,little_interpreter_InterpTokens.Expression(little_interpreter_Interpreter.group(Type.enumParameters(lookahead)[0]),Type.enumParameters(lookahead)[1])]));
							} else {
								post.push(little_interpreter_InterpTokens.PartArray([token1,lookahead]));
							}
						}
					} else {
						var tmp2;
						var _this8 = [little_tools_InterpTokensSimple.SIGN].slice();
						var result8 = new Array(_this8.length);
						var _g26 = 0;
						var _g27 = _this8.length;
						while(_g26 < _g27) {
							var i9 = _g26++;
							var x8 = _this8[i9];
							result8[i9] = little_tools_TextTools.remove($hxEnums[x8.__enum__].__constructs__[x8._hx_index]._hx_name,"_").toLowerCase();
						}
						if(result8.indexOf($hxEnums[lookahead.__enum__].__constructs__[lookahead._hx_index]._hx_name.toLowerCase()) != -1) {
							var _g28 = [];
							var _g29 = 0;
							var _g30 = operatorGroup1;
							while(_g29 < _g30.length) {
								var v3 = _g30[_g29];
								++_g29;
								if(v3.sign == Type.enumParameters(lookahead)[0]) {
									_g28.push(v3);
								}
							}
							tmp2 = _g28.length > 0;
						} else {
							tmp2 = false;
						}
						if(tmp2) {
							var _g31 = [];
							var _g32 = 0;
							var _g33 = operatorGroup1;
							while(_g32 < _g33.length) {
								var v4 = _g33[_g32];
								++_g32;
								if(v4.sign == Type.enumParameters(token1)[0] && v4.side == little_interpreter_memory_OperatorType.LHS_ONLY) {
									_g31.push(v4);
								}
							}
							if(_g31.length > 0) {
								post.push(little_interpreter_InterpTokens.PartArray([post.pop(),token1]));
							} else {
								var _g34 = [];
								var _g35 = 0;
								var _g36 = operatorGroup1;
								while(_g35 < _g36.length) {
									var v5 = _g36[_g35];
									++_g35;
									if(v5.sign == Type.enumParameters(token1)[0] && v5.side == little_interpreter_memory_OperatorType.LHS_RHS) {
										_g34.push(v5);
									}
								}
								if(_g34.length > 0) {
									var operand1 = post.pop();
									var op = lookahead;
									if(i + 2 >= pre.length) {
										little_interpreter_Interpreter.error("Expression ended with an operator, when an operand was expected.");
									}
									var token5 = pre[i + 2];
									var _this9 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.BLOCK].slice();
									var result9 = new Array(_this9.length);
									var _g37 = 0;
									var _g38 = _this9.length;
									while(_g37 < _g38) {
										var i10 = _g37++;
										var x9 = _this9[i10];
										result9[i10] = little_tools_TextTools.remove($hxEnums[x9.__enum__].__constructs__[x9._hx_index]._hx_name,"_").toLowerCase();
									}
									var lookahead21 = result9.indexOf($hxEnums[token5.__enum__].__constructs__[token5._hx_index]._hx_name.toLowerCase()) != -1 ? little_interpreter_Interpreter.evaluate(pre[i + 2]) : pre[i + 2];
									var _this10 = [little_tools_InterpTokensSimple.SIGN].slice();
									var result10 = new Array(_this10.length);
									var _g39 = 0;
									var _g40 = _this10.length;
									while(_g39 < _g40) {
										var i11 = _g39++;
										var x10 = _this10[i11];
										result10[i11] = little_tools_TextTools.remove($hxEnums[x10.__enum__].__constructs__[x10._hx_index]._hx_name,"_").toLowerCase();
									}
									if(result10.indexOf($hxEnums[lookahead21.__enum__].__constructs__[lookahead21._hx_index]._hx_name.toLowerCase()) == -1) {
										post.push(little_interpreter_InterpTokens.PartArray([operand1,token1,little_interpreter_InterpTokens.PartArray([lookahead,lookahead21])]));
										i += 2;
									} else {
										var g1 = [];
										while(true) {
											var tmp3;
											var _this11 = [little_tools_InterpTokensSimple.SIGN].slice();
											var result11 = new Array(_this11.length);
											var _g41 = 0;
											var _g42 = _this11.length;
											while(_g41 < _g42) {
												var i12 = _g41++;
												var x11 = _this11[i12];
												result11[i12] = little_tools_TextTools.remove($hxEnums[x11.__enum__].__constructs__[x11._hx_index]._hx_name,"_").toLowerCase();
											}
											if(result11.indexOf($hxEnums[lookahead21.__enum__].__constructs__[lookahead21._hx_index]._hx_name.toLowerCase()) != -1) {
												var _g43 = [];
												var _g44 = 0;
												var _g45 = operatorGroup1;
												while(_g44 < _g45.length) {
													var v6 = _g45[_g44];
													++_g44;
													if(v6.sign == Type.enumParameters(lookahead21)[0] && v6.side == little_interpreter_memory_OperatorType.RHS_ONLY) {
														_g43.push(v6);
													}
												}
												tmp3 = _g43.length > 0;
											} else {
												tmp3 = false;
											}
											if(!tmp3) {
												break;
											}
											g1.push(lookahead21);
											++i;
											if(i + 2 >= pre.length) {
												little_interpreter_Interpreter.error("Expression ended with an operator, when an operand was expected.");
											}
											var token6 = pre[i + 2];
											var _this12 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.BLOCK].slice();
											var result12 = new Array(_this12.length);
											var _g46 = 0;
											var _g47 = _this12.length;
											while(_g46 < _g47) {
												var i13 = _g46++;
												var x12 = _this12[i13];
												result12[i13] = little_tools_TextTools.remove($hxEnums[x12.__enum__].__constructs__[x12._hx_index]._hx_name,"_").toLowerCase();
											}
											lookahead21 = result12.indexOf($hxEnums[token6.__enum__].__constructs__[token6._hx_index]._hx_name.toLowerCase()) != -1 ? little_interpreter_Interpreter.evaluate(pre[i + 2]) : pre[i + 2];
										}
										g1.push(lookahead21);
										++i;
										var operand2 = g1.length == 1 ? g1[0] : little_interpreter_InterpTokens.PartArray(little_interpreter_Interpreter.group(g1));
										post.push(little_interpreter_InterpTokens.PartArray([operand1,op,operand2]));
									}
								} else {
									var _g48 = [];
									var _g49 = 0;
									var _g50 = operatorGroup1;
									while(_g49 < _g50.length) {
										var v7 = _g50[_g49];
										++_g49;
										if(v7.sign == Type.enumParameters(token1)[0] && v7.side == little_interpreter_memory_OperatorType.RHS_ONLY) {
											_g48.push(v7);
										}
									}
									if(_g48.length > 0) {
										little_interpreter_Interpreter.error("An operator that expects a right side can't be preceded by an operator that expects a left side.");
									}
								}
							}
						} else {
							var _this13 = [little_tools_InterpTokensSimple.SIGN].slice();
							var result13 = new Array(_this13.length);
							var _g51 = 0;
							var _g52 = _this13.length;
							while(_g51 < _g52) {
								var i14 = _g51++;
								var x13 = _this13[i14];
								result13[i14] = little_tools_TextTools.remove($hxEnums[x13.__enum__].__constructs__[x13._hx_index]._hx_name,"_").toLowerCase();
							}
							if(result13.indexOf($hxEnums[lookahead.__enum__].__constructs__[lookahead._hx_index]._hx_name.toLowerCase()) != -1) {
								post.push(little_interpreter_InterpTokens.PartArray([post.pop(),token1]));
							} else {
								post.push(little_interpreter_InterpTokens.PartArray([post.pop(),token1,lookahead]));
								++i;
							}
						}
					}
				} else {
					post.push(token1);
				}
				break;
			default:
				post.push(token1);
			}
			++i;
		}
	}
	return post;
};
var little_interpreter_FieldDeclarationType = $hxEnums["little.interpreter.FieldDeclarationType"] = { __ename__:"little.interpreter.FieldDeclarationType",__constructs__:null
	,VARIABLE: {_hx_name:"VARIABLE",_hx_index:0,__enum__:"little.interpreter.FieldDeclarationType",toString:$estr}
	,FUNCTION: {_hx_name:"FUNCTION",_hx_index:1,__enum__:"little.interpreter.FieldDeclarationType",toString:$estr}
	,CONDITION: {_hx_name:"CONDITION",_hx_index:2,__enum__:"little.interpreter.FieldDeclarationType",toString:$estr}
	,CLASS: {_hx_name:"CLASS",_hx_index:3,__enum__:"little.interpreter.FieldDeclarationType",toString:$estr}
	,OPERATOR: {_hx_name:"OPERATOR",_hx_index:4,__enum__:"little.interpreter.FieldDeclarationType",toString:$estr}
};
little_interpreter_FieldDeclarationType.__constructs__ = [little_interpreter_FieldDeclarationType.VARIABLE,little_interpreter_FieldDeclarationType.FUNCTION,little_interpreter_FieldDeclarationType.CONDITION,little_interpreter_FieldDeclarationType.CLASS,little_interpreter_FieldDeclarationType.OPERATOR];
var little_interpreter_StdOut = function() {
	this.stdoutTokens = [];
	this.output = "";
};
$hxClasses["little.interpreter.StdOut"] = little_interpreter_StdOut;
little_interpreter_StdOut.__name__ = "little.interpreter.StdOut";
little_interpreter_StdOut.prototype = {
	output: null
	,stdoutTokens: null
	,reset: function() {
		this.output = "";
		this.stdoutTokens = [];
	}
	,__class__: little_interpreter_StdOut
};
var little_interpreter_InterpTokens = $hxEnums["little.interpreter.InterpTokens"] = { __ename__:"little.interpreter.InterpTokens",__constructs__:null
	,SetLine: ($_=function(line) { return {_hx_index:0,line:line,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="SetLine",$_.__params__ = ["line"],$_)
	,SplitLine: {_hx_name:"SplitLine",_hx_index:1,__enum__:"little.interpreter.InterpTokens",toString:$estr}
	,VariableDeclaration: ($_=function(name,type,doc) { return {_hx_index:2,name:name,type:type,doc:doc,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="VariableDeclaration",$_.__params__ = ["name","type","doc"],$_)
	,FunctionDeclaration: ($_=function(name,params,type,doc) { return {_hx_index:3,name:name,params:params,type:type,doc:doc,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="FunctionDeclaration",$_.__params__ = ["name","params","type","doc"],$_)
	,ConditionCode: ($_=function(callers) { return {_hx_index:4,callers:callers,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="ConditionCode",$_.__params__ = ["callers"],$_)
	,ConditionCall: ($_=function(name,exp,body) { return {_hx_index:5,name:name,exp:exp,body:body,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="ConditionCall",$_.__params__ = ["name","exp","body"],$_)
	,FunctionCode: ($_=function(requiredParams,body) { return {_hx_index:6,requiredParams:requiredParams,body:body,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="FunctionCode",$_.__params__ = ["requiredParams","body"],$_)
	,FunctionCall: ($_=function(name,params) { return {_hx_index:7,name:name,params:params,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="FunctionCall",$_.__params__ = ["name","params"],$_)
	,FunctionReturn: ($_=function(value,type) { return {_hx_index:8,value:value,type:type,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="FunctionReturn",$_.__params__ = ["value","type"],$_)
	,Write: ($_=function(assignees,value) { return {_hx_index:9,assignees:assignees,value:value,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="Write",$_.__params__ = ["assignees","value"],$_)
	,TypeCast: ($_=function(value,type) { return {_hx_index:10,value:value,type:type,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="TypeCast",$_.__params__ = ["value","type"],$_)
	,Expression: ($_=function(parts,type) { return {_hx_index:11,parts:parts,type:type,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="Expression",$_.__params__ = ["parts","type"],$_)
	,Block: ($_=function(body,type) { return {_hx_index:12,body:body,type:type,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="Block",$_.__params__ = ["body","type"],$_)
	,PartArray: ($_=function(parts) { return {_hx_index:13,parts:parts,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="PartArray",$_.__params__ = ["parts"],$_)
	,PropertyAccess: ($_=function(name,property) { return {_hx_index:14,name:name,property:property,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="PropertyAccess",$_.__params__ = ["name","property"],$_)
	,Number: ($_=function(num) { return {_hx_index:15,num:num,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="Number",$_.__params__ = ["num"],$_)
	,Decimal: ($_=function(num) { return {_hx_index:16,num:num,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="Decimal",$_.__params__ = ["num"],$_)
	,Characters: ($_=function(string) { return {_hx_index:17,string:string,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="Characters",$_.__params__ = ["string"],$_)
	,Documentation: ($_=function(doc) { return {_hx_index:18,doc:doc,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="Documentation",$_.__params__ = ["doc"],$_)
	,ClassPointer: ($_=function(pointer) { return {_hx_index:19,pointer:pointer,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="ClassPointer",$_.__params__ = ["pointer"],$_)
	,Sign: ($_=function(sign) { return {_hx_index:20,sign:sign,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="Sign",$_.__params__ = ["sign"],$_)
	,NullValue: {_hx_name:"NullValue",_hx_index:21,__enum__:"little.interpreter.InterpTokens",toString:$estr}
	,TrueValue: {_hx_name:"TrueValue",_hx_index:22,__enum__:"little.interpreter.InterpTokens",toString:$estr}
	,FalseValue: {_hx_name:"FalseValue",_hx_index:23,__enum__:"little.interpreter.InterpTokens",toString:$estr}
	,Identifier: ($_=function(word) { return {_hx_index:24,word:word,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="Identifier",$_.__params__ = ["word"],$_)
	,Object: ($_=function(props,typeName) { return {_hx_index:25,props:props,typeName:typeName,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="Object",$_.__params__ = ["props","typeName"],$_)
	,ErrorMessage: ($_=function(msg) { return {_hx_index:26,msg:msg,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="ErrorMessage",$_.__params__ = ["msg"],$_)
	,HaxeExtern: ($_=function(func) { return {_hx_index:27,func:func,__enum__:"little.interpreter.InterpTokens",toString:$estr}; },$_._hx_name="HaxeExtern",$_.__params__ = ["func"],$_)
};
little_interpreter_InterpTokens.__constructs__ = [little_interpreter_InterpTokens.SetLine,little_interpreter_InterpTokens.SplitLine,little_interpreter_InterpTokens.VariableDeclaration,little_interpreter_InterpTokens.FunctionDeclaration,little_interpreter_InterpTokens.ConditionCode,little_interpreter_InterpTokens.ConditionCall,little_interpreter_InterpTokens.FunctionCode,little_interpreter_InterpTokens.FunctionCall,little_interpreter_InterpTokens.FunctionReturn,little_interpreter_InterpTokens.Write,little_interpreter_InterpTokens.TypeCast,little_interpreter_InterpTokens.Expression,little_interpreter_InterpTokens.Block,little_interpreter_InterpTokens.PartArray,little_interpreter_InterpTokens.PropertyAccess,little_interpreter_InterpTokens.Number,little_interpreter_InterpTokens.Decimal,little_interpreter_InterpTokens.Characters,little_interpreter_InterpTokens.Documentation,little_interpreter_InterpTokens.ClassPointer,little_interpreter_InterpTokens.Sign,little_interpreter_InterpTokens.NullValue,little_interpreter_InterpTokens.TrueValue,little_interpreter_InterpTokens.FalseValue,little_interpreter_InterpTokens.Identifier,little_interpreter_InterpTokens.Object,little_interpreter_InterpTokens.ErrorMessage,little_interpreter_InterpTokens.HaxeExtern];
var little_interpreter_memory_ExtTree = function(type,getter,properties,doc) {
	var tmp = getter;
	this.getter = tmp != null ? tmp : function(objectValue,objectAddress) {
		return { objectValue : little_interpreter_InterpTokens.Characters("Externally registered, attached to " + (objectAddress == null ? "null" : little_interpreter_memory_MemoryPointer.toString(objectAddress))), objectAddress : objectAddress};
	};
	var tmp = properties;
	this.properties = tmp != null ? tmp : new haxe_ds_StringMap();
	var tmp = doc;
	this.doc = tmp != null ? tmp : little_Little.memory.constants.EMPTY_STRING;
	var tmp = type;
	this.type = tmp != null ? tmp : little_Little.memory.constants.UNKNOWN;
};
$hxClasses["little.interpreter.memory.ExtTree"] = little_interpreter_memory_ExtTree;
little_interpreter_memory_ExtTree.__name__ = "little.interpreter.memory.ExtTree";
little_interpreter_memory_ExtTree.prototype = {
	getter: null
	,doc: null
	,type: null
	,properties: null
	,__class__: little_interpreter_memory_ExtTree
};
var little_interpreter_memory_HashTables = function() { };
$hxClasses["little.interpreter.memory.HashTables"] = little_interpreter_memory_HashTables;
little_interpreter_memory_HashTables.__name__ = "little.interpreter.memory.HashTables";
little_interpreter_memory_HashTables.generateObjectHashTable = function(pairs) {
	var initialLength = (pairs.length > 1 ? pairs.length : 5) * little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE * 3;
	var this1 = new haxe_io_Bytes(new ArrayBuffer(initialLength));
	this1.fill(0,initialLength,0);
	var array = this1;
	var _g = 0;
	while(_g < pairs.length) {
		var pair = pairs[_g];
		++_g;
		var keyHash = haxe_hash_Murmur1.hash(haxe_io_Bytes.ofString(pair.key));
		var khI64_high = 0;
		var khI64_low = keyHash;
		var x = little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE;
		var b_high = x >> 31;
		var b_low = x;
		var mask = 65535;
		var al = khI64_low & mask;
		var ah = khI64_low >>> 16;
		var bl = b_low & mask;
		var bh = b_low >>> 16;
		var p00 = haxe_Int32._mul(al,bl);
		var p10 = haxe_Int32._mul(ah,bl);
		var p01 = haxe_Int32._mul(al,bh);
		var p11 = haxe_Int32._mul(ah,bh);
		var low = p00;
		var high = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
		p01 <<= 16;
		low = low + p01 | 0;
		if(haxe_Int32.ucompare(low,p01) < 0) {
			var ret = high++;
			high = high | 0;
		}
		p10 <<= 16;
		low = low + p10 | 0;
		if(haxe_Int32.ucompare(low,p10) < 0) {
			var ret1 = high++;
			high = high | 0;
		}
		high = high + (haxe_Int32._mul(khI64_low,b_high) + haxe_Int32._mul(khI64_high,b_low) | 0) | 0;
		var this1 = new haxe__$Int64__$_$_$Int64(high,low);
		var x1 = array.length;
		var keyIndex = haxe_Int64.divMod(this1,new haxe__$Int64__$_$_$Int64(x1 >> 31,x1)).modulus.low;
		if(array.getInt32(keyIndex) == 0) {
			array.setInt32(keyIndex,pair.keyPointer);
			array.setInt32(keyIndex + 4 | 0,pair.value);
			array.setInt32(keyIndex + 8 | 0,pair.type);
			array.setInt32(keyIndex + 12 | 0,pair.doc);
		} else {
			var incrementation = 0;
			var i = keyIndex;
			while(array.getInt32(i) != 0) {
				i = i + little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE | 0;
				incrementation += little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE;
				if(i >= array.length) {
					i = 0;
				}
				if(incrementation >= array.length) {
					throw haxe_Exception.thrown("Object hash table did not generate. This should never happen. Initial length may be incorrect.");
				}
			}
			array.setInt32(i,pair.keyPointer);
			array.setInt32(i + 4 | 0,pair.value);
			array.setInt32(i + 8 | 0,pair.type);
			array.setInt32(i + 12 | 0,pair.doc);
		}
	}
	return array;
};
little_interpreter_memory_HashTables.readObjectHashTable = function(bytes,storage) {
	var arr = [];
	var i = 0;
	while(i < bytes.length) {
		var keyPointer = little_interpreter_memory_MemoryPointer.fromInt(bytes.getInt32(i));
		var value = little_interpreter_memory_MemoryPointer.fromInt(bytes.getInt32(i + 4));
		var type = little_interpreter_memory_MemoryPointer.fromInt(bytes.getInt32(i + 8));
		var doc = little_interpreter_memory_MemoryPointer.fromInt(bytes.getInt32(i + 12));
		var key = null;
		if(keyPointer == 0) {
			i += little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE;
			continue;
		}
		if(storage != null) {
			key = storage.readString(keyPointer);
		}
		arr.push({ key : key, keyPointer : keyPointer, value : value, type : type, doc : doc});
		i += little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE;
	}
	return arr;
};
little_interpreter_memory_HashTables.hashTableHasKey = function(hashTable,key,storage) {
	var keyHash = haxe_hash_Murmur1.hash(haxe_io_Bytes.ofString(key));
	var khI64_high = 0;
	var khI64_low = keyHash;
	var x = little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE;
	var b_high = x >> 31;
	var b_low = x;
	var mask = 65535;
	var al = khI64_low & mask;
	var ah = khI64_low >>> 16;
	var bl = b_low & mask;
	var bh = b_low >>> 16;
	var p00 = haxe_Int32._mul(al,bl);
	var p10 = haxe_Int32._mul(ah,bl);
	var p01 = haxe_Int32._mul(al,bh);
	var p11 = haxe_Int32._mul(ah,bh);
	var low = p00;
	var high = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
	p01 <<= 16;
	low = low + p01 | 0;
	if(haxe_Int32.ucompare(low,p01) < 0) {
		var ret = high++;
		high = high | 0;
	}
	p10 <<= 16;
	low = low + p10 | 0;
	if(haxe_Int32.ucompare(low,p10) < 0) {
		var ret = high++;
		high = high | 0;
	}
	high = high + (haxe_Int32._mul(khI64_low,b_high) + haxe_Int32._mul(khI64_high,b_low) | 0) | 0;
	var this1 = new haxe__$Int64__$_$_$Int64(high,low);
	var x = hashTable.length;
	var keyIndex = haxe_Int64.divMod(this1,new haxe__$Int64__$_$_$Int64(x >> 31,x)).modulus.low;
	var incrementation = 0;
	while(true) {
		var currentKey = storage.readString(little_interpreter_memory_MemoryPointer.fromInt(hashTable.getInt32(keyIndex)));
		if(currentKey == key) {
			return true;
		}
		keyIndex = keyIndex + little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE | 0;
		++incrementation;
		if(keyIndex >= hashTable.length) {
			keyIndex = 0;
		}
		if(incrementation >= hashTable.length) {
			return false;
		}
	}
};
little_interpreter_memory_HashTables.hashTableGetKey = function(hashTable,key,storage) {
	var keyHash = haxe_hash_Murmur1.hash(haxe_io_Bytes.ofString(key));
	var khI64_high = 0;
	var khI64_low = keyHash;
	var x = little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE;
	var b_high = x >> 31;
	var b_low = x;
	var mask = 65535;
	var al = khI64_low & mask;
	var ah = khI64_low >>> 16;
	var bl = b_low & mask;
	var bh = b_low >>> 16;
	var p00 = haxe_Int32._mul(al,bl);
	var p10 = haxe_Int32._mul(ah,bl);
	var p01 = haxe_Int32._mul(al,bh);
	var p11 = haxe_Int32._mul(ah,bh);
	var low = p00;
	var high = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
	p01 <<= 16;
	low = low + p01 | 0;
	if(haxe_Int32.ucompare(low,p01) < 0) {
		var ret = high++;
		high = high | 0;
	}
	p10 <<= 16;
	low = low + p10 | 0;
	if(haxe_Int32.ucompare(low,p10) < 0) {
		var ret = high++;
		high = high | 0;
	}
	high = high + (haxe_Int32._mul(khI64_low,b_high) + haxe_Int32._mul(khI64_high,b_low) | 0) | 0;
	var this1 = new haxe__$Int64__$_$_$Int64(high,low);
	var x = hashTable.length;
	var keyIndex = haxe_Int64.divMod(this1,new haxe__$Int64__$_$_$Int64(x >> 31,x)).modulus.low;
	var incrementation = 0;
	while(true) {
		var currentKey = storage.readString(little_interpreter_memory_MemoryPointer.fromInt(hashTable.getInt32(keyIndex)));
		if(currentKey == key) {
			return { key : key, keyPointer : little_interpreter_memory_MemoryPointer.fromInt(hashTable.getInt32(keyIndex)), value : little_interpreter_memory_MemoryPointer.fromInt(hashTable.getInt32(keyIndex + 4 | 0)), type : little_interpreter_memory_MemoryPointer.fromInt(hashTable.getInt32(keyIndex + 8 | 0)), doc : little_interpreter_memory_MemoryPointer.fromInt(hashTable.getInt32(keyIndex + 12 | 0))};
		}
		keyIndex = keyIndex + little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE | 0;
		incrementation += little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE;
		if(keyIndex >= hashTable.length) {
			keyIndex = 0;
		}
		if(incrementation >= hashTable.length) {
			throw haxe_Exception.thrown("Key " + key + " not found in hash table");
		}
	}
};
little_interpreter_memory_HashTables.objectAddKey = function(object,key,value,type,doc,storage) {
	var hashTableBytes = storage.readBytes(storage.readPointer(little_interpreter_memory_MemoryPointer.fromInt(object + 4)),storage.readInt32(little_interpreter_memory_MemoryPointer.fromInt(object)));
	var table = little_interpreter_memory_HashTables.readObjectHashTable(hashTableBytes,storage);
	var tableSize = hashTableBytes.length;
	var occupied = table.length * little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE;
	if(occupied / tableSize >= 0.7) {
		table.push({ key : key, keyPointer : storage.storeString(key), value : value, type : type, doc : doc});
		haxe_Log.trace("Rehashing object: " + object,{ fileName : "src/little/interpreter/memory/HashTables.hx", lineNumber : 212, className : "little.interpreter.memory.HashTables", methodName : "objectAddKey"});
		var newHashTable = little_interpreter_memory_HashTables.generateObjectHashTable(table);
		storage.freeBytes(storage.readPointer(little_interpreter_memory_MemoryPointer.fromInt(object + 4)),hashTableBytes.length);
		var tablePointer = storage.storeBytes(newHashTable.length,newHashTable);
		haxe_Log.trace(tablePointer == null ? "null" : little_interpreter_memory_MemoryPointer.toString(tablePointer),{ fileName : "src/little/interpreter/memory/HashTables.hx", lineNumber : 219, className : "little.interpreter.memory.HashTables", methodName : "objectAddKey", customParams : [newHashTable.length]});
		storage.setPointer(little_interpreter_memory_MemoryPointer.fromInt(object + 4),tablePointer);
		storage.setInt32(little_interpreter_memory_MemoryPointer.fromInt(object),newHashTable.length);
		return;
	}
	var hashTablePosition = storage.readPointer(little_interpreter_memory_MemoryPointer.fromInt(object + 4));
	var keyHash = haxe_hash_Murmur1.hash(haxe_io_Bytes.ofString(key));
	var khI64_high = 0;
	var khI64_low = keyHash;
	var x = little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE;
	var b_high = x >> 31;
	var b_low = x;
	var mask = 65535;
	var al = khI64_low & mask;
	var ah = khI64_low >>> 16;
	var bl = b_low & mask;
	var bh = b_low >>> 16;
	var p00 = haxe_Int32._mul(al,bl);
	var p10 = haxe_Int32._mul(ah,bl);
	var p01 = haxe_Int32._mul(al,bh);
	var p11 = haxe_Int32._mul(ah,bh);
	var low = p00;
	var high = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
	p01 <<= 16;
	low = low + p01 | 0;
	if(haxe_Int32.ucompare(low,p01) < 0) {
		var ret = high++;
		high = high | 0;
	}
	p10 <<= 16;
	low = low + p10 | 0;
	if(haxe_Int32.ucompare(low,p10) < 0) {
		var ret = high++;
		high = high | 0;
	}
	high = high + (haxe_Int32._mul(khI64_low,b_high) + haxe_Int32._mul(khI64_high,b_low) | 0) | 0;
	var this1 = new haxe__$Int64__$_$_$Int64(high,low);
	var x = hashTableBytes.length;
	var keyIndex = haxe_Int64.divMod(this1,new haxe__$Int64__$_$_$Int64(x >> 31,x)).modulus.low;
	var incrementation = 0;
	while(true) {
		if(hashTableBytes.getInt32(keyIndex) == 0) {
			storage.setPointer(little_interpreter_memory_MemoryPointer.fromInt(hashTablePosition + keyIndex | 0),little_interpreter_memory_MemoryPointer.fromInt(storage.storeString(key)));
			storage.setPointer(little_interpreter_memory_MemoryPointer.fromInt((hashTablePosition + keyIndex | 0) + 4 | 0),little_interpreter_memory_MemoryPointer.fromInt(value));
			storage.setPointer(little_interpreter_memory_MemoryPointer.fromInt((hashTablePosition + keyIndex | 0) + 8 | 0),little_interpreter_memory_MemoryPointer.fromInt(type));
			storage.setPointer(little_interpreter_memory_MemoryPointer.fromInt((hashTablePosition + keyIndex | 0) + 12 | 0),little_interpreter_memory_MemoryPointer.fromInt(doc));
			return;
		}
		keyIndex = keyIndex + little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE | 0;
		incrementation += little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE;
		if(keyIndex >= tableSize) {
			keyIndex = 0;
		}
		if(incrementation >= tableSize) {
			throw haxe_Exception.thrown("How did you get here? 6");
		}
	}
};
little_interpreter_memory_HashTables.objectSetKey = function(object,key,pair,storage) {
	var hashTableBytesLength = storage.readInt32(little_interpreter_memory_MemoryPointer.fromInt(object));
	var hashTablePosition = storage.readPointer(little_interpreter_memory_MemoryPointer.fromInt(object + 4));
	var keyHash = haxe_hash_Murmur1.hash(haxe_io_Bytes.ofString(key));
	var khI64_high = 0;
	var khI64_low = keyHash;
	var x = little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE;
	var b_high = x >> 31;
	var b_low = x;
	var mask = 65535;
	var al = khI64_low & mask;
	var ah = khI64_low >>> 16;
	var bl = b_low & mask;
	var bh = b_low >>> 16;
	var p00 = haxe_Int32._mul(al,bl);
	var p10 = haxe_Int32._mul(ah,bl);
	var p01 = haxe_Int32._mul(al,bh);
	var p11 = haxe_Int32._mul(ah,bh);
	var low = p00;
	var high = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
	p01 <<= 16;
	low = low + p01 | 0;
	if(haxe_Int32.ucompare(low,p01) < 0) {
		var ret = high++;
		high = high | 0;
	}
	p10 <<= 16;
	low = low + p10 | 0;
	if(haxe_Int32.ucompare(low,p10) < 0) {
		var ret = high++;
		high = high | 0;
	}
	high = high + (haxe_Int32._mul(khI64_low,b_high) + haxe_Int32._mul(khI64_high,b_low) | 0) | 0;
	var keyIndex = haxe_Int64.divMod(new haxe__$Int64__$_$_$Int64(high,low),new haxe__$Int64__$_$_$Int64(hashTableBytesLength >> 31,hashTableBytesLength)).modulus.low;
	var incrementation = 0;
	while(true) {
		var currentKey = storage.readString(storage.readPointer(little_interpreter_memory_MemoryPointer.fromInt(hashTablePosition + keyIndex | 0)));
		if(currentKey == key) {
			if(pair.value != null) {
				storage.setInt32(little_interpreter_memory_MemoryPointer.fromInt((hashTablePosition + keyIndex | 0) + 4 | 0),pair.value);
			}
			if(pair.type != null) {
				storage.setInt32(little_interpreter_memory_MemoryPointer.fromInt((hashTablePosition + keyIndex | 0) + 8 | 0),pair.type);
			}
			if(pair.doc != null) {
				storage.setInt32(little_interpreter_memory_MemoryPointer.fromInt((hashTablePosition + keyIndex | 0) + 12 | 0),pair.doc);
			}
			return;
		}
		keyIndex = keyIndex + little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE | 0;
		incrementation += little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE;
		if(keyIndex >= hashTableBytesLength) {
			keyIndex = 0;
		}
		if(incrementation >= hashTableBytesLength) {
			throw haxe_Exception.thrown("Cannot set a non-existing key in the object's hash table.");
		}
	}
};
little_interpreter_memory_HashTables.objectGetKey = function(object,key,storage) {
	var hashTableBytes = storage.readBytes(storage.readPointer(little_interpreter_memory_MemoryPointer.fromInt(object + 4)),storage.readInt32(little_interpreter_memory_MemoryPointer.fromInt(object)));
	return little_interpreter_memory_HashTables.hashTableGetKey(hashTableBytes,key,storage);
};
little_interpreter_memory_HashTables.getHashTableOf = function(objectPointer,storage) {
	var bytesLength = storage.readInt32(little_interpreter_memory_MemoryPointer.fromInt(objectPointer));
	var bytesPointer = storage.readPointer(little_interpreter_memory_MemoryPointer.fromInt(objectPointer + 4));
	return storage.readBytes(bytesPointer,bytesLength);
};
var little_interpreter_memory_MemoryPointer = {};
little_interpreter_memory_MemoryPointer.__properties__ = {set_rawLocation:"set_rawLocation",get_rawLocation:"get_rawLocation"};
little_interpreter_memory_MemoryPointer.get_rawLocation = function(this1) {
	return this1;
};
little_interpreter_memory_MemoryPointer.set_rawLocation = function(this1,v) {
	this1 = v;
	return this1;
};
little_interpreter_memory_MemoryPointer._new = function(address) {
	return address;
};
little_interpreter_memory_MemoryPointer.fromInt = function(i) {
	return little_interpreter_memory_MemoryPointer._new(i);
};
little_interpreter_memory_MemoryPointer.fromInt64 = function(i) {
	return little_interpreter_memory_MemoryPointer._new(i.low);
};
little_interpreter_memory_MemoryPointer.toString = function(this1) {
	return this1 + "";
};
little_interpreter_memory_MemoryPointer.toArray = function(this1) {
	var bytes = [];
	var i = this1;
	bytes.unshift(i & 255);
	i >>= 8;
	bytes.unshift(i & 255);
	i >>= 8;
	bytes.unshift(i & 255);
	i >>= 8;
	bytes.unshift(i & 255);
	i >>= 8;
	bytes.unshift(0);
	bytes.unshift(0);
	bytes.unshift(0);
	bytes.unshift(0);
	return bytes;
};
little_interpreter_memory_MemoryPointer.toBytes = function(this1) {
	var bytes = new haxe_io_Bytes(new ArrayBuffer(4));
	bytes.b[0] = this1 & 255;
	bytes.b[1] = this1 >> 8 & 255;
	bytes.b[2] = this1 >> 16 & 255;
	return bytes;
};
var little_interpreter_memory_OperatorType = $hxEnums["little.interpreter.memory.OperatorType"] = { __ename__:"little.interpreter.memory.OperatorType",__constructs__:null
	,LHS_RHS: {_hx_name:"LHS_RHS",_hx_index:0,__enum__:"little.interpreter.memory.OperatorType",toString:$estr}
	,LHS_ONLY: {_hx_name:"LHS_ONLY",_hx_index:1,__enum__:"little.interpreter.memory.OperatorType",toString:$estr}
	,RHS_ONLY: {_hx_name:"RHS_ONLY",_hx_index:2,__enum__:"little.interpreter.memory.OperatorType",toString:$estr}
};
little_interpreter_memory_OperatorType.__constructs__ = [little_interpreter_memory_OperatorType.LHS_RHS,little_interpreter_memory_OperatorType.LHS_ONLY,little_interpreter_memory_OperatorType.RHS_ONLY];
var little_lexer_Lexer = function() { };
$hxClasses["little.lexer.Lexer"] = little_lexer_Lexer;
little_lexer_Lexer.__name__ = "little.lexer.Lexer";
little_lexer_Lexer.lex = function(code) {
	var tokens = [];
	var i = 0;
	while(i < code.length) {
		var char = code.charAt(i);
		if(i < code.length - 2 && little_tools_TextTools.replace(HxOverrides.substr(code,i,3),"\"","").length == 0) {
			var string = "";
			var queuedNewlines = 0;
			i += 3;
			while(i < code.length - 2 && little_tools_TextTools.replace(HxOverrides.substr(code,i,3),"\"","").length != 0) {
				string += code.charAt(i);
				if(code.charAt(i) == "\n") {
					++queuedNewlines;
				}
				++i;
			}
			i += 2;
			var _g = 0;
			var _g1 = queuedNewlines;
			while(_g < _g1) {
				var j = _g++;
				tokens.push(little_lexer_LexerTokens.Newline);
			}
			tokens.push(little_lexer_LexerTokens.Documentation(StringTools.trim(little_tools_TextTools.replace(little_tools_TextTools.replace(string,"<br>","\n"),"</br>","\n"))));
		} else if(char == "\"") {
			var string1 = "";
			++i;
			while(i < code.length && code.charAt(i) != "\"") {
				string1 += code.charAt(i);
				++i;
			}
			tokens.push(little_lexer_LexerTokens.Characters(string1));
		} else if(little_tools_TextTools.contains("1234567890.",char)) {
			var num = char;
			++i;
			while(i < code.length && little_tools_TextTools.contains("1234567890.",code.charAt(i))) {
				num += code.charAt(i);
				++i;
			}
			--i;
			if(num == ".") {
				tokens.push(little_lexer_LexerTokens.Sign("."));
			} else if(StringTools.endsWith(num,".")) {
				tokens.push(little_lexer_LexerTokens.Number(little_tools_TextTools.replaceLast(num,".","")));
				tokens.push(little_lexer_LexerTokens.Sign("."));
			} else {
				tokens.push(little_lexer_LexerTokens.Number(num));
			}
		} else if(char == "\n") {
			tokens.push(little_lexer_LexerTokens.Newline);
		} else if(char == ";" || char == ",") {
			tokens.push(little_lexer_LexerTokens.SplitLine);
		} else if(little_KeywordConfig.recognizedOperators.indexOf(char) != -1) {
			var sign = char;
			++i;
			while(i < code.length && little_KeywordConfig.recognizedOperators.indexOf(code.charAt(i)) != -1) {
				sign += code.charAt(i);
				++i;
			}
			--i;
			tokens.push(little_lexer_LexerTokens.Sign(sign));
		} else if(new EReg("[^+-.!@#$%%^&*0-9 \t\n\r;,\\(\\)\\[\\]\\{\\}]","").match(char)) {
			var name = char;
			++i;
			while(i < code.length && new EReg("[^+-.!@#$%%^&* \t\n\r;,\\(\\)\\[\\]\\{\\}]","").match(code.charAt(i))) {
				name += code.charAt(i);
				++i;
			}
			--i;
			tokens.push(little_lexer_LexerTokens.Identifier(name));
		}
		++i;
	}
	tokens = little_lexer_Lexer.separateBooleanIdentifiers(tokens);
	tokens = little_lexer_Lexer.mergeOrSplitKnownSigns(tokens);
	return tokens;
};
little_lexer_Lexer.separateBooleanIdentifiers = function(tokens) {
	var result = new Array(tokens.length);
	var _g = 0;
	var _g1 = tokens.length;
	while(_g < _g1) {
		var i = _g++;
		var token = tokens[i];
		result[i] = Type.enumEq(token,little_lexer_LexerTokens.Identifier(little_Little.keywords.TRUE_VALUE)) || Type.enumEq(token,little_lexer_LexerTokens.Identifier(little_Little.keywords.FALSE_VALUE)) ? little_lexer_LexerTokens.Boolean(Type.enumParameters(token)[0]) : Type.enumEq(token,little_lexer_LexerTokens.Identifier(little_Little.keywords.NULL_VALUE)) ? little_lexer_LexerTokens.NullValue : token;
	}
	return result;
};
little_lexer_Lexer.mergeOrSplitKnownSigns = function(tokens) {
	var post = [];
	var i = 0;
	while(i < tokens.length) {
		var token = tokens[i];
		if(token._hx_index == 1) {
			var char = token.char;
			var recognizedSigns = little_tools_TextTools.sortByLength(little_Little.keywords.RECOGNIZED_SIGNS.concat([little_Little.keywords.PROPERTY_ACCESS_SIGN]));
			recognizedSigns.reverse();
			var shouldContinue = false;
			while(char.length > 0) {
				shouldContinue = false;
				var _g = 0;
				while(_g < recognizedSigns.length) {
					var sign = recognizedSigns[_g];
					++_g;
					if(StringTools.startsWith(char,sign)) {
						char = char.substring(sign.length);
						post.push(little_lexer_LexerTokens.Sign(sign));
						shouldContinue = true;
						break;
					}
				}
				if(shouldContinue) {
					continue;
				}
				post.push(little_lexer_LexerTokens.Sign(char.charAt(0)));
				char = char.substring(1);
			}
		} else {
			post.push(token);
		}
		++i;
	}
	return post;
};
var little_lexer_LexerTokens = $hxEnums["little.lexer.LexerTokens"] = { __ename__:"little.lexer.LexerTokens",__constructs__:null
	,Identifier: ($_=function(name) { return {_hx_index:0,name:name,__enum__:"little.lexer.LexerTokens",toString:$estr}; },$_._hx_name="Identifier",$_.__params__ = ["name"],$_)
	,Sign: ($_=function(char) { return {_hx_index:1,char:char,__enum__:"little.lexer.LexerTokens",toString:$estr}; },$_._hx_name="Sign",$_.__params__ = ["char"],$_)
	,Number: ($_=function(num) { return {_hx_index:2,num:num,__enum__:"little.lexer.LexerTokens",toString:$estr}; },$_._hx_name="Number",$_.__params__ = ["num"],$_)
	,Boolean: ($_=function(value) { return {_hx_index:3,value:value,__enum__:"little.lexer.LexerTokens",toString:$estr}; },$_._hx_name="Boolean",$_.__params__ = ["value"],$_)
	,Characters: ($_=function(string) { return {_hx_index:4,string:string,__enum__:"little.lexer.LexerTokens",toString:$estr}; },$_._hx_name="Characters",$_.__params__ = ["string"],$_)
	,NullValue: {_hx_name:"NullValue",_hx_index:5,__enum__:"little.lexer.LexerTokens",toString:$estr}
	,Newline: {_hx_name:"Newline",_hx_index:6,__enum__:"little.lexer.LexerTokens",toString:$estr}
	,SplitLine: {_hx_name:"SplitLine",_hx_index:7,__enum__:"little.lexer.LexerTokens",toString:$estr}
	,Documentation: ($_=function(content) { return {_hx_index:8,content:content,__enum__:"little.lexer.LexerTokens",toString:$estr}; },$_._hx_name="Documentation",$_.__params__ = ["content"],$_)
};
little_lexer_LexerTokens.__constructs__ = [little_lexer_LexerTokens.Identifier,little_lexer_LexerTokens.Sign,little_lexer_LexerTokens.Number,little_lexer_LexerTokens.Boolean,little_lexer_LexerTokens.Characters,little_lexer_LexerTokens.NullValue,little_lexer_LexerTokens.Newline,little_lexer_LexerTokens.SplitLine,little_lexer_LexerTokens.Documentation];
var little_parser_ParserTokens = $hxEnums["little.parser.ParserTokens"] = { __ename__:"little.parser.ParserTokens",__constructs__:null
	,SetLine: ($_=function(line) { return {_hx_index:0,line:line,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="SetLine",$_.__params__ = ["line"],$_)
	,SplitLine: {_hx_name:"SplitLine",_hx_index:1,__enum__:"little.parser.ParserTokens",toString:$estr}
	,Variable: ($_=function(name,type,doc) { return {_hx_index:2,name:name,type:type,doc:doc,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="Variable",$_.__params__ = ["name","type","doc"],$_)
	,Function: ($_=function(name,params,type,doc) { return {_hx_index:3,name:name,params:params,type:type,doc:doc,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="Function",$_.__params__ = ["name","params","type","doc"],$_)
	,ConditionCall: ($_=function(name,exp,body) { return {_hx_index:4,name:name,exp:exp,body:body,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="ConditionCall",$_.__params__ = ["name","exp","body"],$_)
	,Read: ($_=function(name) { return {_hx_index:5,name:name,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="Read",$_.__params__ = ["name"],$_)
	,Write: ($_=function(assignees,value) { return {_hx_index:6,assignees:assignees,value:value,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="Write",$_.__params__ = ["assignees","value"],$_)
	,Identifier: ($_=function(word) { return {_hx_index:7,word:word,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="Identifier",$_.__params__ = ["word"],$_)
	,TypeDeclaration: ($_=function(value,type) { return {_hx_index:8,value:value,type:type,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="TypeDeclaration",$_.__params__ = ["value","type"],$_)
	,FunctionCall: ($_=function(name,params) { return {_hx_index:9,name:name,params:params,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="FunctionCall",$_.__params__ = ["name","params"],$_)
	,Return: ($_=function(value,type) { return {_hx_index:10,value:value,type:type,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="Return",$_.__params__ = ["value","type"],$_)
	,Expression: ($_=function(parts,type) { return {_hx_index:11,parts:parts,type:type,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="Expression",$_.__params__ = ["parts","type"],$_)
	,Block: ($_=function(body,type) { return {_hx_index:12,body:body,type:type,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="Block",$_.__params__ = ["body","type"],$_)
	,PartArray: ($_=function(parts) { return {_hx_index:13,parts:parts,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="PartArray",$_.__params__ = ["parts"],$_)
	,PropertyAccess: ($_=function(name,property) { return {_hx_index:14,name:name,property:property,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="PropertyAccess",$_.__params__ = ["name","property"],$_)
	,Sign: ($_=function(sign) { return {_hx_index:15,sign:sign,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="Sign",$_.__params__ = ["sign"],$_)
	,Number: ($_=function(num) { return {_hx_index:16,num:num,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="Number",$_.__params__ = ["num"],$_)
	,Decimal: ($_=function(num) { return {_hx_index:17,num:num,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="Decimal",$_.__params__ = ["num"],$_)
	,Characters: ($_=function(string) { return {_hx_index:18,string:string,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="Characters",$_.__params__ = ["string"],$_)
	,Documentation: ($_=function(doc) { return {_hx_index:19,doc:doc,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="Documentation",$_.__params__ = ["doc"],$_)
	,ErrorMessage: ($_=function(msg) { return {_hx_index:20,msg:msg,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="ErrorMessage",$_.__params__ = ["msg"],$_)
	,NullValue: {_hx_name:"NullValue",_hx_index:21,__enum__:"little.parser.ParserTokens",toString:$estr}
	,TrueValue: {_hx_name:"TrueValue",_hx_index:22,__enum__:"little.parser.ParserTokens",toString:$estr}
	,FalseValue: {_hx_name:"FalseValue",_hx_index:23,__enum__:"little.parser.ParserTokens",toString:$estr}
	,Custom: ($_=function(name,params) { return {_hx_index:24,name:name,params:params,__enum__:"little.parser.ParserTokens",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["name","params"],$_)
};
little_parser_ParserTokens.__constructs__ = [little_parser_ParserTokens.SetLine,little_parser_ParserTokens.SplitLine,little_parser_ParserTokens.Variable,little_parser_ParserTokens.Function,little_parser_ParserTokens.ConditionCall,little_parser_ParserTokens.Read,little_parser_ParserTokens.Write,little_parser_ParserTokens.Identifier,little_parser_ParserTokens.TypeDeclaration,little_parser_ParserTokens.FunctionCall,little_parser_ParserTokens.Return,little_parser_ParserTokens.Expression,little_parser_ParserTokens.Block,little_parser_ParserTokens.PartArray,little_parser_ParserTokens.PropertyAccess,little_parser_ParserTokens.Sign,little_parser_ParserTokens.Number,little_parser_ParserTokens.Decimal,little_parser_ParserTokens.Characters,little_parser_ParserTokens.Documentation,little_parser_ParserTokens.ErrorMessage,little_parser_ParserTokens.NullValue,little_parser_ParserTokens.TrueValue,little_parser_ParserTokens.FalseValue,little_parser_ParserTokens.Custom];
var little_tools_ParserTokensSimple = $hxEnums["little.tools.ParserTokensSimple"] = { __ename__:"little.tools.ParserTokensSimple",__constructs__:null
	,SET_LINE: {_hx_name:"SET_LINE",_hx_index:0,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,SPLIT_LINE: {_hx_name:"SPLIT_LINE",_hx_index:1,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,VARIABLE: {_hx_name:"VARIABLE",_hx_index:2,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,FUNCTION: {_hx_name:"FUNCTION",_hx_index:3,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,CONDITION_CALL: {_hx_name:"CONDITION_CALL",_hx_index:4,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,READ: {_hx_name:"READ",_hx_index:5,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,WRITE: {_hx_name:"WRITE",_hx_index:6,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,IDENTIFIER: {_hx_name:"IDENTIFIER",_hx_index:7,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,TYPE_DECLARATION: {_hx_name:"TYPE_DECLARATION",_hx_index:8,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,FUNCTION_CALL: {_hx_name:"FUNCTION_CALL",_hx_index:9,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,RETURN: {_hx_name:"RETURN",_hx_index:10,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,EXPRESSION: {_hx_name:"EXPRESSION",_hx_index:11,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,BLOCK: {_hx_name:"BLOCK",_hx_index:12,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,PART_ARRAY: {_hx_name:"PART_ARRAY",_hx_index:13,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,PROPERTY_ACCESS: {_hx_name:"PROPERTY_ACCESS",_hx_index:14,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,SIGN: {_hx_name:"SIGN",_hx_index:15,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,NUMBER: {_hx_name:"NUMBER",_hx_index:16,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,DECIMAL: {_hx_name:"DECIMAL",_hx_index:17,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,CHARACTERS: {_hx_name:"CHARACTERS",_hx_index:18,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,DOCUMENTATION: {_hx_name:"DOCUMENTATION",_hx_index:19,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,MODULE: {_hx_name:"MODULE",_hx_index:20,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,EXTERNAL: {_hx_name:"EXTERNAL",_hx_index:21,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,EXTERNAL_CONDITION: {_hx_name:"EXTERNAL_CONDITION",_hx_index:22,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,ERROR_MESSAGE: {_hx_name:"ERROR_MESSAGE",_hx_index:23,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,NULL_VALUE: {_hx_name:"NULL_VALUE",_hx_index:24,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,TRUE_VALUE: {_hx_name:"TRUE_VALUE",_hx_index:25,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,FALSE_VALUE: {_hx_name:"FALSE_VALUE",_hx_index:26,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
	,NOBODY: {_hx_name:"NOBODY",_hx_index:27,__enum__:"little.tools.ParserTokensSimple",toString:$estr}
};
little_tools_ParserTokensSimple.__constructs__ = [little_tools_ParserTokensSimple.SET_LINE,little_tools_ParserTokensSimple.SPLIT_LINE,little_tools_ParserTokensSimple.VARIABLE,little_tools_ParserTokensSimple.FUNCTION,little_tools_ParserTokensSimple.CONDITION_CALL,little_tools_ParserTokensSimple.READ,little_tools_ParserTokensSimple.WRITE,little_tools_ParserTokensSimple.IDENTIFIER,little_tools_ParserTokensSimple.TYPE_DECLARATION,little_tools_ParserTokensSimple.FUNCTION_CALL,little_tools_ParserTokensSimple.RETURN,little_tools_ParserTokensSimple.EXPRESSION,little_tools_ParserTokensSimple.BLOCK,little_tools_ParserTokensSimple.PART_ARRAY,little_tools_ParserTokensSimple.PROPERTY_ACCESS,little_tools_ParserTokensSimple.SIGN,little_tools_ParserTokensSimple.NUMBER,little_tools_ParserTokensSimple.DECIMAL,little_tools_ParserTokensSimple.CHARACTERS,little_tools_ParserTokensSimple.DOCUMENTATION,little_tools_ParserTokensSimple.MODULE,little_tools_ParserTokensSimple.EXTERNAL,little_tools_ParserTokensSimple.EXTERNAL_CONDITION,little_tools_ParserTokensSimple.ERROR_MESSAGE,little_tools_ParserTokensSimple.NULL_VALUE,little_tools_ParserTokensSimple.TRUE_VALUE,little_tools_ParserTokensSimple.FALSE_VALUE,little_tools_ParserTokensSimple.NOBODY];
var little_parser_Parser = function() { };
$hxClasses["little.parser.Parser"] = little_parser_Parser;
little_parser_Parser.__name__ = "little.parser.Parser";
little_parser_Parser.__properties__ = {set_line:"set_line",get_line:"get_line"};
little_parser_Parser.parse = function(lexerTokens) {
	var tokens = little_parser_Parser.convert(lexerTokens);
	tokens = little_parser_Parser.mergeBlocks(tokens);
	tokens = little_parser_Parser.mergeExpressions(tokens);
	tokens = little_parser_Parser.mergePropertyOperations(tokens);
	tokens = little_parser_Parser.mergeTypeDecls(tokens);
	tokens = little_parser_Parser.mergeComplexStructures(tokens);
	tokens = little_parser_Parser.mergeCalls(tokens);
	tokens = little_parser_Parser.mergeWrites(tokens);
	tokens = little_parser_Parser.mergeValuesWithTypeDeclarations(tokens);
	tokens = little_parser_Parser.mergeNonBlockBodies(tokens);
	var _g = 0;
	var _g1 = little_parser_Parser.additionalParsingLevels;
	while(_g < _g1.length) {
		var level = _g1[_g];
		++_g;
		tokens = level(tokens);
	}
	return tokens;
};
little_parser_Parser.convert = function(lexerTokens) {
	var tokens = [];
	var line = 1;
	var i = 0;
	while(i < lexerTokens.length) {
		var token = lexerTokens[i];
		switch(token._hx_index) {
		case 0:
			var name = token.name;
			tokens.push(little_parser_ParserTokens.Identifier(name));
			break;
		case 1:
			var char = token.char;
			tokens.push(little_parser_ParserTokens.Sign(char));
			break;
		case 2:
			var num = token.num;
			if(little_tools_TextTools.countOccurrencesOf(num,".") == 0) {
				tokens.push(little_parser_ParserTokens.Number(num));
			} else if(little_tools_TextTools.countOccurrencesOf(num,".") == 1) {
				tokens.push(little_parser_ParserTokens.Decimal(num));
			}
			break;
		case 3:
			var value = token.value;
			if(value == little_Little.keywords.FALSE_VALUE) {
				tokens.push(little_parser_ParserTokens.FalseValue);
			} else if(value == little_Little.keywords.TRUE_VALUE) {
				tokens.push(little_parser_ParserTokens.TrueValue);
			}
			break;
		case 4:
			var string = token.string;
			tokens.push(little_parser_ParserTokens.Characters(string));
			break;
		case 5:
			tokens.push(little_parser_ParserTokens.NullValue);
			break;
		case 6:
			tokens.push(little_parser_ParserTokens.SetLine(line));
			++line;
			break;
		case 7:
			tokens.push(little_parser_ParserTokens.SplitLine);
			break;
		case 8:
			var content = token.content;
			tokens.push(little_parser_ParserTokens.Documentation(content));
			break;
		}
		++i;
	}
	return tokens;
};
little_parser_Parser.mergeBlocks = function(pre) {
	if(pre == null) {
		return null;
	}
	if(pre.length == 1 && pre[0] == null) {
		return [null];
	}
	var post = [];
	var i = 0;
	while(i < pre.length) {
		var token = pre[i];
		switch(token._hx_index) {
		case 0:
			var line = token.line;
			little_parser_Parser.setLine(line);
			post.push(token);
			break;
		case 1:
			little_parser_Parser.nextPart();
			post.push(token);
			break;
		case 11:
			var parts = token.parts;
			var type = token.type;
			post.push(little_parser_ParserTokens.Expression(little_parser_Parser.mergeBlocks(parts),little_parser_Parser.mergeBlocks([type])[0]));
			break;
		case 12:
			var body = token.body;
			var type1 = token.type;
			post.push(little_parser_ParserTokens.Block(little_parser_Parser.mergeBlocks(body),little_parser_Parser.mergeBlocks([type1])[0]));
			break;
		case 15:
			if(token.sign == "{") {
				var blockStartLine = little_parser_Parser.get_line();
				var blockBody = [];
				var blockStack = 1;
				while(i + 1 < pre.length) {
					var lookahead = pre[i + 1];
					if(Type.enumEq(lookahead,little_parser_ParserTokens.Sign("{"))) {
						++blockStack;
						blockBody.push(lookahead);
					} else if(Type.enumEq(lookahead,little_parser_ParserTokens.Sign("}"))) {
						--blockStack;
						if(blockStack == 0) {
							break;
						}
						blockBody.push(lookahead);
					} else {
						blockBody.push(lookahead);
					}
					++i;
				}
				if(i + 1 == pre.length) {
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Unclosed code block, starting at line " + blockStartLine));
					return null;
				}
				post.push(little_parser_ParserTokens.Block(little_parser_Parser.mergeBlocks(blockBody),null));
				++i;
			} else {
				post.push(token);
			}
			break;
		case 24:
			var name = token.name;
			var params = token.params;
			var result = new Array(params.length);
			var _g = 0;
			var _g1 = params.length;
			while(_g < _g1) {
				var i1 = _g++;
				result[i1] = little_parser_Parser.mergeBlocks([params[i1]])[0];
			}
			post.push(little_parser_ParserTokens.Custom(name,result));
			break;
		default:
			post.push(token);
		}
		++i;
	}
	little_parser_Parser.resetLines();
	return post;
};
little_parser_Parser.mergeExpressions = function(pre) {
	if(pre == null) {
		return null;
	}
	if(pre.length == 1 && pre[0] == null) {
		return [null];
	}
	var post = [];
	var i = 0;
	while(i < pre.length) {
		var token = pre[i];
		switch(token._hx_index) {
		case 0:
			var line = token.line;
			little_parser_Parser.setLine(line);
			post.push(token);
			break;
		case 1:
			little_parser_Parser.nextPart();
			post.push(token);
			break;
		case 11:
			var parts = token.parts;
			var type = token.type;
			post.push(little_parser_ParserTokens.Expression(little_parser_Parser.mergeExpressions(parts),little_parser_Parser.mergeExpressions([type])[0]));
			break;
		case 12:
			var body = token.body;
			var type1 = token.type;
			post.push(little_parser_ParserTokens.Block(little_parser_Parser.mergeExpressions(body),little_parser_Parser.mergeExpressions([type1])[0]));
			break;
		case 15:
			if(token.sign == "(") {
				var expressionStartLine = little_parser_Parser.get_line();
				var expressionBody = [];
				var expressionStack = 1;
				while(i + 1 < pre.length) {
					var lookahead = pre[i + 1];
					if(Type.enumEq(lookahead,little_parser_ParserTokens.Sign("("))) {
						++expressionStack;
						expressionBody.push(lookahead);
					} else if(Type.enumEq(lookahead,little_parser_ParserTokens.Sign(")"))) {
						--expressionStack;
						if(expressionStack == 0) {
							break;
						}
						expressionBody.push(lookahead);
					} else {
						expressionBody.push(lookahead);
					}
					++i;
				}
				if(i + 1 == pre.length) {
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Unclosed expression, starting at line " + expressionStartLine));
					return null;
				}
				post.push(little_parser_ParserTokens.Expression(little_parser_Parser.mergeExpressions(expressionBody),null));
				++i;
			} else {
				post.push(token);
			}
			break;
		case 24:
			var name = token.name;
			var params = token.params;
			var result = new Array(params.length);
			var _g = 0;
			var _g1 = params.length;
			while(_g < _g1) {
				var i1 = _g++;
				result[i1] = little_parser_Parser.mergeExpressions([params[i1]])[0];
			}
			post.push(little_parser_ParserTokens.Custom(name,result));
			break;
		default:
			post.push(token);
		}
		++i;
	}
	little_parser_Parser.resetLines();
	return post;
};
little_parser_Parser.mergePropertyOperations = function(pre) {
	if(pre == null) {
		return null;
	}
	if(pre.length == 1 && pre[0] == null) {
		return [null];
	}
	var post = [];
	var i = 0;
	while(i < pre.length) {
		var token = pre[i];
		switch(token._hx_index) {
		case 0:
			var line = token.line;
			little_parser_Parser.setLine(line);
			post.push(token);
			break;
		case 1:
			little_parser_Parser.nextPart();
			post.push(token);
			break;
		case 11:
			var parts = token.parts;
			var type = token.type;
			post.push(little_parser_ParserTokens.Expression(little_parser_Parser.mergePropertyOperations(parts),little_parser_Parser.mergePropertyOperations([type])[0]));
			break;
		case 12:
			var body = token.body;
			var type1 = token.type;
			post.push(little_parser_ParserTokens.Block(little_parser_Parser.mergePropertyOperations(body),little_parser_Parser.mergePropertyOperations([type1])[0]));
			break;
		case 15:
			if(token.sign == little_Little.keywords.PROPERTY_ACCESS_SIGN == true) {
				if(i + 1 >= pre.length) {
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Property access cut off by the end of file, block or expression."),"Parser");
					return null;
				}
				if(post.length == 0) {
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Property access cut off by the start of file, block or expression."),"Parser");
					return null;
				}
				var lookbehind = post.pop();
				if(lookbehind == null) {
					var field = pre[++i];
					var tmp;
					if(i + 1 < pre.length) {
						var token1 = pre[i + 1];
						var _this = [little_tools_ParserTokensSimple.EXPRESSION].slice();
						var result = new Array(_this.length);
						var _g = 0;
						var _g1 = _this.length;
						while(_g < _g1) {
							var i1 = _g++;
							var x = _this[i1];
							result[i1] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
						}
						tmp = result.indexOf($hxEnums[token1.__enum__].__constructs__[token1._hx_index]._hx_name.toLowerCase()) != -1;
					} else {
						tmp = false;
					}
					if(tmp) {
						var expression = pre[++i];
						post.push(little_parser_ParserTokens.FunctionCall(little_parser_ParserTokens.PropertyAccess(lookbehind,field),expression));
					} else {
						post.push(little_parser_ParserTokens.PropertyAccess(lookbehind,field));
					}
				} else {
					switch(lookbehind._hx_index) {
					case 0:
						var _g2 = lookbehind.line;
						little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Property access cut off by the start of a line, or by a line split (; or ,)."),"Parser");
						return null;
					case 1:
						little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Property access cut off by the start of a line, or by a line split (; or ,)."),"Parser");
						return null;
					default:
						var field1 = pre[++i];
						var tmp1;
						if(i + 1 < pre.length) {
							var token2 = pre[i + 1];
							var _this1 = [little_tools_ParserTokensSimple.EXPRESSION].slice();
							var result1 = new Array(_this1.length);
							var _g3 = 0;
							var _g4 = _this1.length;
							while(_g3 < _g4) {
								var i2 = _g3++;
								var x1 = _this1[i2];
								result1[i2] = little_tools_TextTools.remove($hxEnums[x1.__enum__].__constructs__[x1._hx_index]._hx_name,"_").toLowerCase();
							}
							tmp1 = result1.indexOf($hxEnums[token2.__enum__].__constructs__[token2._hx_index]._hx_name.toLowerCase()) != -1;
						} else {
							tmp1 = false;
						}
						if(tmp1) {
							var expression1 = pre[++i];
							post.push(little_parser_ParserTokens.FunctionCall(little_parser_ParserTokens.PropertyAccess(lookbehind,field1),expression1));
						} else {
							post.push(little_parser_ParserTokens.PropertyAccess(lookbehind,field1));
						}
					}
				}
			} else {
				post.push(token);
			}
			break;
		case 24:
			var name = token.name;
			var params = token.params;
			var result2 = new Array(params.length);
			var _g5 = 0;
			var _g6 = params.length;
			while(_g5 < _g6) {
				var i3 = _g5++;
				result2[i3] = little_parser_Parser.mergePropertyOperations([params[i3]])[0];
			}
			post.push(little_parser_ParserTokens.Custom(name,result2));
			break;
		default:
			post.push(token);
		}
		++i;
	}
	little_parser_Parser.resetLines();
	return post;
};
little_parser_Parser.mergeTypeDecls = function(pre) {
	if(pre == null) {
		return null;
	}
	if(pre.length == 1 && pre[0] == null) {
		return [null];
	}
	var post = [];
	var i = 0;
	while(i < pre.length) {
		var token = pre[i];
		switch(token._hx_index) {
		case 0:
			var line = token.line;
			little_parser_Parser.setLine(line);
			post.push(token);
			break;
		case 1:
			little_parser_Parser.nextPart();
			post.push(token);
			break;
		case 7:
			var word = token.word;
			if(word == little_Little.keywords.TYPE_DECL_OR_CAST && i + 1 < pre.length) {
				var lookahead = pre[i + 1];
				post.push(little_parser_ParserTokens.TypeDeclaration(null,little_parser_Parser.mergeTypeDecls([lookahead])[0]));
				++i;
			} else if(word == little_Little.keywords.TYPE_DECL_OR_CAST) {
				if(i + 1 == pre.length) {
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Incomplete type declaration, make sure to input a type after the `" + little_Little.keywords.TYPE_DECL_OR_CAST + "`."));
					return null;
				}
			} else {
				post.push(token);
			}
			break;
		case 11:
			var parts = token.parts;
			var type = token.type;
			post.push(little_parser_ParserTokens.Expression(little_parser_Parser.mergeTypeDecls(parts),little_parser_Parser.mergeTypeDecls([type])[0]));
			break;
		case 12:
			var body = token.body;
			var type1 = token.type;
			post.push(little_parser_ParserTokens.Block(little_parser_Parser.mergeTypeDecls(body),little_parser_Parser.mergeTypeDecls([type1])[0]));
			break;
		case 14:
			var name = token.name;
			var property = token.property;
			post.push(little_parser_ParserTokens.PropertyAccess(little_parser_Parser.mergeTypeDecls([name])[0],little_parser_Parser.mergeTypeDecls([property])[0]));
			break;
		case 24:
			var name1 = token.name;
			var params = token.params;
			var result = new Array(params.length);
			var _g = 0;
			var _g1 = params.length;
			while(_g < _g1) {
				var i1 = _g++;
				result[i1] = little_parser_Parser.mergeTypeDecls([params[i1]])[0];
			}
			post.push(little_parser_ParserTokens.Custom(name1,result));
			break;
		default:
			post.push(token);
		}
		++i;
	}
	little_parser_Parser.resetLines();
	return post;
};
little_parser_Parser.mergeComplexStructures = function(pre) {
	if(pre == null) {
		return null;
	}
	if(pre.length == 1 && pre[0] == null) {
		return [null];
	}
	var post = [];
	var currentDoc = null;
	var i = 0;
	while(i < pre.length) {
		var token = pre[i];
		switch(token._hx_index) {
		case 0:
			var line = token.line;
			little_parser_Parser.setLine(line);
			post.push(token);
			break;
		case 1:
			little_parser_Parser.nextPart();
			post.push(token);
			break;
		case 7:
			var _g = token.word;
			var _hx_tmp;
			var _hx_tmp1;
			if(_g == little_Little.keywords.VARIABLE_DECLARATION == true) {
				++i;
				if(i >= pre.length) {
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Missing variable name, variable is cut off by the end of the file, block or expression."),"Parser");
					return null;
				}
				var name = null;
				var type = null;
				_hx_loop2: while(i < pre.length) {
					var lookahead = pre[i];
					switch(lookahead._hx_index) {
					case 0:
						var _g1 = lookahead.line;
						--i;
						break _hx_loop2;
					case 1:
						--i;
						break _hx_loop2;
					case 8:
						var _g2 = lookahead.value;
						var typeToken = lookahead.type;
						if(name == null) {
							little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Missing variable name before type declaration."),"Parser");
							return null;
						}
						type = typeToken;
						break _hx_loop2;
					case 11:
						var body = lookahead.parts;
						var type1 = lookahead.type;
						if(name == null) {
							name = little_parser_ParserTokens.Expression(little_parser_Parser.mergeComplexStructures(body),little_parser_Parser.mergeComplexStructures([type1])[0]);
						} else if(type1 == null) {
							type1 = little_parser_ParserTokens.Expression(little_parser_Parser.mergeComplexStructures(body),little_parser_Parser.mergeComplexStructures([type1])[0]);
						} else {
							--i;
							break _hx_loop2;
						}
						break;
					case 12:
						var body1 = lookahead.body;
						var type2 = lookahead.type;
						if(name == null) {
							name = little_parser_ParserTokens.Block(little_parser_Parser.mergeComplexStructures(body1),little_parser_Parser.mergeComplexStructures([type2])[0]);
						} else if(type2 == null) {
							type2 = little_parser_ParserTokens.Block(little_parser_Parser.mergeComplexStructures(body1),little_parser_Parser.mergeComplexStructures([type2])[0]);
						} else {
							--i;
							break _hx_loop2;
						}
						break;
					case 15:
						if(lookahead.sign == "=") {
							--i;
							break _hx_loop2;
						} else if(name == null) {
							name = lookahead;
						} else {
							var tmp;
							if(type == null) {
								var _this = [little_tools_ParserTokensSimple.TYPE_DECLARATION].slice();
								var result = new Array(_this.length);
								var _g3 = 0;
								var _g4 = _this.length;
								while(_g3 < _g4) {
									var i1 = _g3++;
									var x = _this[i1];
									result[i1] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
								}
								tmp = result.indexOf($hxEnums[lookahead.__enum__].__constructs__[lookahead._hx_index]._hx_name.toLowerCase()) != -1;
							} else {
								tmp = false;
							}
							if(tmp) {
								type = lookahead;
							} else {
								--i;
								break _hx_loop2;
							}
						}
						break;
					default:
						if(name == null) {
							name = lookahead;
						} else {
							var tmp1;
							if(type == null) {
								var _this1 = [little_tools_ParserTokensSimple.TYPE_DECLARATION].slice();
								var result1 = new Array(_this1.length);
								var _g5 = 0;
								var _g6 = _this1.length;
								while(_g5 < _g6) {
									var i2 = _g5++;
									var x1 = _this1[i2];
									result1[i2] = little_tools_TextTools.remove($hxEnums[x1.__enum__].__constructs__[x1._hx_index]._hx_name,"_").toLowerCase();
								}
								tmp1 = result1.indexOf($hxEnums[lookahead.__enum__].__constructs__[lookahead._hx_index]._hx_name.toLowerCase()) != -1;
							} else {
								tmp1 = false;
							}
							if(tmp1) {
								type = lookahead;
							} else {
								--i;
								break _hx_loop2;
							}
						}
					}
					++i;
				}
				if(name == null) {
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Missing variable name, variable is cut off by the end of the file, block or expression."),"Parser");
				}
				post.push(little_parser_ParserTokens.Variable(name,type,currentDoc));
				currentDoc = null;
			} else {
				_hx_tmp1 = _g == little_Little.keywords.FUNCTION_DECLARATION;
				if(_hx_tmp1 == true) {
					++i;
					if(i >= pre.length) {
						little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Missing function name, function is cut off by the end of the file, block or expression."),"Parser");
						return null;
					}
					if(i + 1 >= pre.length) {
						little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Missing function parameter body, function is cut off by the end of the file, block or expression."),"Parser");
						return null;
					}
					var name1 = null;
					var params = null;
					var type3 = null;
					_hx_loop5: while(i < pre.length) {
						var lookahead1 = pre[i];
						switch(lookahead1._hx_index) {
						case 8:
							var _g7 = lookahead1.value;
							var typeToken1 = lookahead1.type;
							if(name1 == null) {
								little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Missing function name and parameters before type declaration."),"Parser");
								return null;
							} else if(params == null) {
								little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Missing function parameters before type declaration."),"Parser");
								return null;
							}
							type3 = little_parser_Parser.mergeComplexStructures([typeToken1])[0];
							break _hx_loop5;
						case 11:
							var body2 = lookahead1.parts;
							var type4 = lookahead1.type;
							if(name1 == null) {
								name1 = little_parser_ParserTokens.Expression(little_parser_Parser.mergeComplexStructures(body2),little_parser_Parser.mergeComplexStructures([type4])[0]);
							} else if(params == null) {
								params = little_parser_ParserTokens.Expression(little_parser_Parser.mergeComplexStructures(body2),little_parser_Parser.mergeComplexStructures([type4])[0]);
							} else if(type4 == null) {
								type4 = little_parser_ParserTokens.Expression(little_parser_Parser.mergeComplexStructures(body2),little_parser_Parser.mergeComplexStructures([type4])[0]);
							} else {
								break _hx_loop5;
							}
							break;
						case 12:
							var body3 = lookahead1.body;
							var type5 = lookahead1.type;
							if(name1 == null) {
								name1 = little_parser_ParserTokens.Block(little_parser_Parser.mergeComplexStructures(body3),little_parser_Parser.mergeComplexStructures([type5])[0]);
							} else if(params == null) {
								params = little_parser_ParserTokens.Block(little_parser_Parser.mergeComplexStructures(body3),little_parser_Parser.mergeComplexStructures([type5])[0]);
							} else if(type5 == null) {
								type5 = little_parser_ParserTokens.Block(little_parser_Parser.mergeComplexStructures(body3),little_parser_Parser.mergeComplexStructures([type5])[0]);
							} else {
								break _hx_loop5;
							}
							break;
						case 15:
							if(lookahead1.sign == "=") {
								--i;
								break _hx_loop5;
							} else if(name1 == null) {
								name1 = lookahead1;
							} else if(params == null) {
								params = lookahead1;
							} else if(type3 == null && $hxEnums[lookahead1.__enum__].__constructs__[lookahead1._hx_index]._hx_name == "TypeDeclaration") {
								type3 = little_parser_Parser.mergeComplexStructures([Type.enumParameters(lookahead1)[1]])[0];
							} else {
								break _hx_loop5;
							}
							break;
						default:
							if(name1 == null) {
								name1 = lookahead1;
							} else if(params == null) {
								params = lookahead1;
							} else if(type3 == null && $hxEnums[lookahead1.__enum__].__constructs__[lookahead1._hx_index]._hx_name == "TypeDeclaration") {
								type3 = little_parser_Parser.mergeComplexStructures([Type.enumParameters(lookahead1)[1]])[0];
							} else {
								break _hx_loop5;
							}
						}
						++i;
					}
					if(name1 == null) {
						little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Missing function name and parameters, function is cut off by the end of the file, block or expression."),"Parser");
					} else if(params == null) {
						little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Missing function parameters, function is cut off by the end of the file, block or expression."),"Parser");
					}
					post.push(little_parser_ParserTokens.Function(name1,params,type3,currentDoc));
					currentDoc = null;
				} else {
					_hx_tmp = _g == little_Little.keywords.FUNCTION_RETURN;
					if(_hx_tmp == true) {
						++i;
						if(i >= pre.length) {
							little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Missing return value, value is cut off by the end of the file, block or expression."),"Parser");
							return null;
						}
						var valueToReturn = [];
						_hx_loop6: while(i < pre.length) {
							var lookahead2 = pre[i];
							switch(lookahead2._hx_index) {
							case 0:
								var _g8 = lookahead2.line;
								--i;
								break _hx_loop6;
							case 1:
								--i;
								break _hx_loop6;
							case 11:
								var body4 = lookahead2.parts;
								var type6 = lookahead2.type;
								valueToReturn.push(little_parser_ParserTokens.Expression(little_parser_Parser.mergeComplexStructures(body4),little_parser_Parser.mergeComplexStructures([type6])[0]));
								break;
							case 12:
								var body5 = lookahead2.body;
								var type7 = lookahead2.type;
								valueToReturn.push(little_parser_ParserTokens.Block(little_parser_Parser.mergeComplexStructures(body5),little_parser_Parser.mergeComplexStructures([type7])[0]));
								break;
							default:
								valueToReturn.push(lookahead2);
							}
							++i;
						}
						post.push(little_parser_ParserTokens.Return(valueToReturn.length == 1 ? valueToReturn[0] : little_parser_ParserTokens.Expression(valueToReturn.slice(),null),null));
					} else {
						++i;
						if(i + 1 >= pre.length) {
							post.push(token);
							continue;
						}
						var name2 = little_parser_ParserTokens.Identifier(Type.enumParameters(token)[0]);
						var exp = null;
						var body6 = null;
						var fallback = i - 1;
						_hx_loop7: while(true) {
							if(i >= pre.length) {
								i = fallback;
								break;
							}
							var lookahead3 = pre[i];
							switch(lookahead3._hx_index) {
							case 0:
								var _g9 = lookahead3.line;
								break;
							case 1:
								if(exp != null && body6 != null) {
									break _hx_loop7;
								}
								i = fallback;
								break _hx_loop7;
							case 11:
								var parts = lookahead3.parts;
								var type8 = lookahead3.type;
								if(exp == null) {
									exp = little_parser_ParserTokens.Expression(little_parser_Parser.mergeComplexStructures(parts),little_parser_Parser.mergeComplexStructures([type8])[0]);
								} else if(body6 == null) {
									i = fallback;
								} else {
									break _hx_loop7;
								}
								break;
							case 12:
								var b = lookahead3.body;
								var type9 = lookahead3.type;
								if(exp == null) {
									i = fallback;
									break _hx_loop7;
								} else if(body6 == null) {
									body6 = little_parser_ParserTokens.Block(little_parser_Parser.mergeComplexStructures(b),little_parser_Parser.mergeComplexStructures([type9])[0]);
								} else {
									break _hx_loop7;
								}
								break;
							default:
								if(exp == null || body6 == null) {
									i = fallback;
									break _hx_loop7;
								} else {
									break _hx_loop7;
								}
							}
							++i;
						}
						if(i == fallback) {
							post.push(token);
						} else {
							--i;
							post.push(little_parser_ParserTokens.ConditionCall(name2,exp,body6));
							currentDoc = null;
						}
					}
				}
			}
			break;
		case 11:
			var parts1 = token.parts;
			var type10 = token.type;
			post.push(little_parser_ParserTokens.Expression(little_parser_Parser.mergeComplexStructures(parts1),little_parser_Parser.mergeComplexStructures([type10])[0]));
			break;
		case 12:
			var body7 = token.body;
			var type11 = token.type;
			post.push(little_parser_ParserTokens.Block(little_parser_Parser.mergeComplexStructures(body7),little_parser_Parser.mergeComplexStructures([type11])[0]));
			break;
		case 14:
			var name3 = token.name;
			var property = token.property;
			post.push(little_parser_ParserTokens.PropertyAccess(little_parser_Parser.mergeComplexStructures([name3])[0],little_parser_Parser.mergeComplexStructures([property])[0]));
			break;
		case 19:
			var doc = token.doc;
			currentDoc = token;
			break;
		case 24:
			var name4 = token.name;
			var params1 = token.params;
			var result2 = new Array(params1.length);
			var _g10 = 0;
			var _g11 = params1.length;
			while(_g10 < _g11) {
				var i3 = _g10++;
				result2[i3] = little_parser_Parser.mergeComplexStructures([params1[i3]])[0];
			}
			post.push(little_parser_ParserTokens.Custom(name4,result2));
			break;
		default:
			post.push(token);
		}
		++i;
	}
	little_parser_Parser.resetLines();
	return post;
};
little_parser_Parser.mergeCalls = function(pre) {
	if(pre == null) {
		return null;
	}
	if(pre.length == 1 && pre[0] == null) {
		return [null];
	}
	var post = [];
	var i = 0;
	while(i < pre.length) {
		var token = pre[i];
		switch(token._hx_index) {
		case 0:
			var line = token.line;
			little_parser_Parser.setLine(line);
			post.push(token);
			break;
		case 1:
			little_parser_Parser.nextPart();
			post.push(token);
			break;
		case 2:
			var name = token.name;
			var type = token.type;
			var doc = token.doc;
			post.push(little_parser_ParserTokens.Variable(little_parser_Parser.mergeCalls([name])[0],little_parser_Parser.mergeCalls([type])[0],little_parser_Parser.mergeCalls([doc])[0]));
			break;
		case 3:
			var name1 = token.name;
			var params = token.params;
			var type1 = token.type;
			var doc1 = token.doc;
			post.push(little_parser_ParserTokens.Function(little_parser_Parser.mergeCalls([name1])[0],little_parser_Parser.mergeCalls([params])[0],little_parser_Parser.mergeCalls([type1])[0],little_parser_Parser.mergeCalls([doc1])[0]));
			break;
		case 4:
			var name2 = token.name;
			var exp = token.exp;
			var body = token.body;
			post.push(little_parser_ParserTokens.ConditionCall(little_parser_Parser.mergeCalls([name2])[0],little_parser_Parser.mergeCalls([exp])[0],little_parser_Parser.mergeCalls([body])[0]));
			break;
		case 10:
			var value = token.value;
			var type2 = token.type;
			post.push(little_parser_ParserTokens.Return(little_parser_Parser.mergeCalls([value])[0],little_parser_Parser.mergeCalls([type2])[0]));
			break;
		case 11:
			var parts = token.parts;
			var type3 = token.type;
			parts = little_parser_Parser.mergeCalls(parts);
			if(i == 0) {
				post.push(little_parser_ParserTokens.Expression(parts,type3));
			} else {
				var lookbehind = pre[i - 1];
				switch(lookbehind._hx_index) {
				case 0:
					var _g = lookbehind.line;
					post.push(little_parser_ParserTokens.Expression(parts,type3));
					break;
				case 1:
					post.push(little_parser_ParserTokens.Expression(parts,type3));
					break;
				case 15:
					var _g1 = lookbehind.sign;
					post.push(little_parser_ParserTokens.Expression(parts,type3));
					break;
				default:
					var previous = post.pop();
					token = little_parser_ParserTokens.PartArray(parts);
					post.push(little_parser_ParserTokens.FunctionCall(previous,token));
				}
			}
			break;
		case 12:
			var body1 = token.body;
			var type4 = token.type;
			post.push(little_parser_ParserTokens.Block(little_parser_Parser.mergeCalls(body1),little_parser_Parser.mergeCalls([type4])[0]));
			break;
		case 13:
			var parts1 = token.parts;
			post.push(little_parser_ParserTokens.PartArray(little_parser_Parser.mergeCalls(parts1)));
			break;
		case 14:
			var name3 = token.name;
			var property = token.property;
			post.push(little_parser_ParserTokens.PropertyAccess(little_parser_Parser.mergeCalls([name3])[0],little_parser_Parser.mergeCalls([property])[0]));
			break;
		case 24:
			var name4 = token.name;
			var params1 = token.params;
			var result = new Array(params1.length);
			var _g2 = 0;
			var _g3 = params1.length;
			while(_g2 < _g3) {
				var i1 = _g2++;
				result[i1] = little_parser_Parser.mergeCalls([params1[i1]])[0];
			}
			post.push(little_parser_ParserTokens.Custom(name4,result));
			break;
		default:
			post.push(token);
		}
		++i;
	}
	little_parser_Parser.resetLines();
	return post;
};
little_parser_Parser.mergeWrites = function(pre) {
	if(pre == null) {
		return null;
	}
	if(pre.length == 1 && pre[0] == null) {
		return [null];
	}
	var post = [];
	var potentialAssignee = little_parser_ParserTokens.NullValue;
	var i = 0;
	while(i < pre.length) {
		var token = pre[i];
		switch(token._hx_index) {
		case 0:
			var line = token.line;
			little_parser_Parser.setLine(line);
			if(potentialAssignee != null) {
				post.push(potentialAssignee);
			}
			potentialAssignee = token;
			break;
		case 1:
			little_parser_Parser.nextPart();
			if(potentialAssignee != null) {
				post.push(potentialAssignee);
			}
			potentialAssignee = token;
			break;
		case 2:
			var name = token.name;
			var type = token.type;
			var doc = token.doc;
			if(potentialAssignee != null) {
				post.push(potentialAssignee);
			}
			potentialAssignee = little_parser_ParserTokens.Variable(little_parser_Parser.mergeWrites([name])[0],little_parser_Parser.mergeWrites([type])[0],little_parser_Parser.mergeWrites([doc])[0]);
			break;
		case 3:
			var name1 = token.name;
			var params = token.params;
			var type1 = token.type;
			var doc1 = token.doc;
			if(potentialAssignee != null) {
				post.push(potentialAssignee);
			}
			potentialAssignee = little_parser_ParserTokens.Function(little_parser_Parser.mergeWrites([name1])[0],little_parser_Parser.mergeWrites([params])[0],little_parser_Parser.mergeWrites([type1])[0],little_parser_Parser.mergeWrites([doc1])[0]);
			break;
		case 4:
			var name2 = token.name;
			var exp = token.exp;
			var body = token.body;
			if(potentialAssignee != null) {
				post.push(potentialAssignee);
			}
			potentialAssignee = little_parser_ParserTokens.ConditionCall(little_parser_Parser.mergeWrites([name2])[0],little_parser_Parser.mergeWrites([exp])[0],little_parser_Parser.mergeWrites([body])[0]);
			break;
		case 9:
			var name3 = token.name;
			var params1 = token.params;
			if(potentialAssignee != null) {
				post.push(potentialAssignee);
			}
			potentialAssignee = little_parser_ParserTokens.FunctionCall(little_parser_Parser.mergeWrites([name3])[0],little_parser_Parser.mergeWrites([params1])[0]);
			break;
		case 10:
			var value = token.value;
			var type2 = token.type;
			if(potentialAssignee != null) {
				post.push(potentialAssignee);
			}
			potentialAssignee = little_parser_ParserTokens.Return(little_parser_Parser.mergeWrites([value])[0],little_parser_Parser.mergeWrites([type2])[0]);
			break;
		case 11:
			var parts = token.parts;
			var type3 = token.type;
			if(potentialAssignee != null) {
				post.push(potentialAssignee);
			}
			potentialAssignee = little_parser_ParserTokens.Expression(little_parser_Parser.mergeWrites(parts),little_parser_Parser.mergeWrites([type3])[0]);
			break;
		case 12:
			var body1 = token.body;
			var type4 = token.type;
			if(potentialAssignee != null) {
				post.push(potentialAssignee);
			}
			potentialAssignee = little_parser_ParserTokens.Block(little_parser_Parser.mergeWrites(body1),little_parser_Parser.mergeWrites([type4])[0]);
			break;
		case 13:
			var parts1 = token.parts;
			if(potentialAssignee != null) {
				post.push(potentialAssignee);
			}
			potentialAssignee = little_parser_ParserTokens.PartArray(little_parser_Parser.mergeWrites(parts1));
			break;
		case 14:
			var name4 = token.name;
			var property = token.property;
			if(potentialAssignee != null) {
				post.push(potentialAssignee);
			}
			potentialAssignee = little_parser_ParserTokens.PropertyAccess(little_parser_Parser.mergeWrites([name4])[0],little_parser_Parser.mergeWrites([property])[0]);
			break;
		case 15:
			if(token.sign == "=") {
				if(i + 1 >= pre.length) {
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Missing value after the `=`"),"Parser");
					return null;
				}
				var currentAssignee = [potentialAssignee];
				var assignees = [currentAssignee.length == 1 ? currentAssignee[0] : little_parser_ParserTokens.Expression(currentAssignee.slice(),null)];
				currentAssignee = [];
				_hx_loop2: while(i + 1 < pre.length) {
					var lookahead = pre[i + 1];
					switch(lookahead._hx_index) {
					case 0:
						var _g = lookahead.line;
						break _hx_loop2;
					case 1:
						break _hx_loop2;
					case 15:
						if(lookahead.sign == "=") {
							var assignee = currentAssignee.length == 1 ? currentAssignee[0] : little_parser_ParserTokens.Expression(currentAssignee.slice(),null);
							assignees.push(assignee);
							currentAssignee = [];
						} else {
							currentAssignee.push(lookahead);
						}
						break;
					default:
						currentAssignee.push(lookahead);
					}
					++i;
				}
				if(currentAssignee.length == 0) {
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Missing value after the last `=`"),"Parser");
					return null;
				}
				var value1 = currentAssignee.length == 1 ? currentAssignee[0] : little_parser_ParserTokens.Expression(currentAssignee,null);
				var fValue = little_parser_Parser.mergeWrites([value1]);
				var v = fValue.length == 1 ? fValue[0] : little_parser_ParserTokens.Expression(fValue,null);
				post.push(little_parser_ParserTokens.Write(assignees,v));
				potentialAssignee = null;
			} else {
				if(potentialAssignee != null) {
					post.push(potentialAssignee);
				}
				potentialAssignee = token;
			}
			break;
		case 24:
			var name5 = token.name;
			var params2 = token.params;
			if(potentialAssignee != null) {
				post.push(potentialAssignee);
			}
			var result = new Array(params2.length);
			var _g1 = 0;
			var _g2 = params2.length;
			while(_g1 < _g2) {
				var i1 = _g1++;
				result[i1] = little_parser_Parser.mergeWrites([params2[i1]])[0];
			}
			potentialAssignee = little_parser_ParserTokens.Custom(name5,result);
			break;
		default:
			if(potentialAssignee != null) {
				post.push(potentialAssignee);
			}
			potentialAssignee = token;
		}
		++i;
	}
	if(potentialAssignee != null) {
		post.push(potentialAssignee);
	}
	post.shift();
	little_parser_Parser.resetLines();
	return post;
};
little_parser_Parser.mergeValuesWithTypeDeclarations = function(pre) {
	if(pre == null) {
		return null;
	}
	if(pre.length == 1 && pre[0] == null) {
		return [null];
	}
	var post = [];
	var i = pre.length - 1;
	while(i >= 0) {
		var token = pre[i];
		switch(token._hx_index) {
		case 0:
			var line = token.line;
			little_parser_Parser.setLine(line);
			post.unshift(token);
			break;
		case 1:
			little_parser_Parser.nextPart();
			post.unshift(token);
			break;
		case 2:
			var name = token.name;
			var type = token.type;
			var doc = token.doc;
			post.unshift(little_parser_ParserTokens.Variable(little_parser_Parser.mergeValuesWithTypeDeclarations([name])[0],little_parser_Parser.mergeValuesWithTypeDeclarations([type])[0],little_parser_Parser.mergeValuesWithTypeDeclarations([doc])[0]));
			break;
		case 3:
			var name1 = token.name;
			var params = token.params;
			var type1 = token.type;
			var doc1 = token.doc;
			post.unshift(little_parser_ParserTokens.Function(little_parser_Parser.mergeValuesWithTypeDeclarations([name1])[0],little_parser_Parser.mergeValuesWithTypeDeclarations([params])[0],little_parser_Parser.mergeValuesWithTypeDeclarations([type1])[0],little_parser_Parser.mergeValuesWithTypeDeclarations([doc1])[0]));
			break;
		case 4:
			var name2 = token.name;
			var exp = token.exp;
			var body = token.body;
			post.unshift(little_parser_ParserTokens.ConditionCall(little_parser_Parser.mergeValuesWithTypeDeclarations([name2])[0],little_parser_Parser.mergeValuesWithTypeDeclarations([exp])[0],little_parser_Parser.mergeValuesWithTypeDeclarations([body])[0]));
			break;
		case 6:
			var assignees = token.assignees;
			var value = token.value;
			post.unshift(little_parser_ParserTokens.Write(little_parser_Parser.mergeValuesWithTypeDeclarations(assignees),little_parser_Parser.mergeValuesWithTypeDeclarations([value])[0]));
			break;
		case 8:
			if(token.value == null) {
				var type2 = token.type;
				if(i-- <= 0) {
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Value's type declaration cut off by the start of file, block or expression."),"Parser");
					return null;
				}
				var lookbehind = pre[i];
				switch(lookbehind._hx_index) {
				case 0:
					var _g = lookbehind.line;
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Value's type declaration access cut off by the start of a line, or by a line split (; or ,)."),"Parser");
					return null;
				case 1:
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Value's type declaration access cut off by the start of a line, or by a line split (; or ,)."),"Parser");
					return null;
				default:
					post.unshift(little_parser_ParserTokens.TypeDeclaration(lookbehind,type2));
				}
			} else {
				post.unshift(token);
			}
			break;
		case 9:
			var name3 = token.name;
			var params1 = token.params;
			post.unshift(little_parser_ParserTokens.FunctionCall(little_parser_Parser.mergeValuesWithTypeDeclarations([name3])[0],little_parser_Parser.mergeValuesWithTypeDeclarations([params1])[0]));
			break;
		case 10:
			var value1 = token.value;
			var type3 = token.type;
			post.unshift(little_parser_ParserTokens.Return(little_parser_Parser.mergeValuesWithTypeDeclarations([value1])[0],little_parser_Parser.mergeValuesWithTypeDeclarations([type3])[0]));
			break;
		case 11:
			var parts = token.parts;
			var type4 = token.type;
			post.unshift(little_parser_ParserTokens.Expression(little_parser_Parser.mergeValuesWithTypeDeclarations(parts),little_parser_Parser.mergeValuesWithTypeDeclarations([type4])[0]));
			break;
		case 12:
			var body1 = token.body;
			var type5 = token.type;
			post.unshift(little_parser_ParserTokens.Block(little_parser_Parser.mergeValuesWithTypeDeclarations(body1),little_parser_Parser.mergeValuesWithTypeDeclarations([type5])[0]));
			break;
		case 13:
			var parts1 = token.parts;
			post.unshift(little_parser_ParserTokens.PartArray(little_parser_Parser.mergeValuesWithTypeDeclarations(parts1)));
			break;
		case 14:
			var name4 = token.name;
			var property = token.property;
			post.unshift(little_parser_ParserTokens.PropertyAccess(little_parser_Parser.mergeValuesWithTypeDeclarations([name4])[0],little_parser_Parser.mergeValuesWithTypeDeclarations([property])[0]));
			break;
		case 24:
			var name5 = token.name;
			var params2 = token.params;
			var result = new Array(params2.length);
			var _g1 = 0;
			var _g2 = params2.length;
			while(_g1 < _g2) {
				var i1 = _g1++;
				result[i1] = little_parser_Parser.mergeValuesWithTypeDeclarations([params2[i1]])[0];
			}
			post.unshift(little_parser_ParserTokens.Custom(name5,result));
			break;
		default:
			post.unshift(token);
		}
		--i;
	}
	little_parser_Parser.resetLines();
	return post;
};
little_parser_Parser.mergeNonBlockBodies = function(pre) {
	if(pre == null) {
		return null;
	}
	if(pre.length == 1 && pre[0] == null) {
		return [null];
	}
	var post = [];
	var i = 0;
	while(i < pre.length) {
		var token = pre[i];
		switch(token._hx_index) {
		case 0:
			var line = token.line;
			little_parser_Parser.setLine(line);
			post.push(token);
			break;
		case 1:
			little_parser_Parser.nextPart();
			post.push(token);
			break;
		case 2:
			var name = token.name;
			var type = token.type;
			var doc = token.doc;
			post.push(little_parser_ParserTokens.Variable(little_parser_Parser.mergeNonBlockBodies([name])[0],little_parser_Parser.mergeNonBlockBodies([type])[0],little_parser_Parser.mergeNonBlockBodies([doc])[0]));
			break;
		case 3:
			var name1 = token.name;
			var params = token.params;
			var type1 = token.type;
			var doc1 = token.doc;
			post.push(little_parser_ParserTokens.Function(little_parser_Parser.mergeNonBlockBodies([name1])[0],little_parser_Parser.mergeNonBlockBodies([params])[0],little_parser_Parser.mergeNonBlockBodies([type1])[0],little_parser_Parser.mergeNonBlockBodies([doc1])[0]));
			break;
		case 4:
			var name2 = token.name;
			var exp = token.exp;
			var body = token.body;
			post.push(little_parser_ParserTokens.ConditionCall(little_parser_Parser.mergeNonBlockBodies([name2])[0],little_parser_Parser.mergeNonBlockBodies([exp])[0],little_parser_Parser.mergeNonBlockBodies([body])[0]));
			break;
		case 6:
			var assignees = token.assignees;
			var value = token.value;
			post.push(little_parser_ParserTokens.Write(little_parser_Parser.mergeNonBlockBodies(assignees),little_parser_Parser.mergeNonBlockBodies([value])[0]));
			break;
		case 9:
			var name3 = token.name;
			var params1 = token.params;
			if(i + 1 >= pre.length) {
				post.push(little_parser_ParserTokens.FunctionCall(little_parser_Parser.mergeNonBlockBodies([name3])[0],little_parser_Parser.mergeNonBlockBodies([params1])[0]));
				++i;
				continue;
			}
			var lookahead = pre[i + 1];
			switch(lookahead._hx_index) {
			case 0:
				var _g = lookahead.line;
				post.push(little_parser_ParserTokens.FunctionCall(little_parser_Parser.mergeNonBlockBodies([name3])[0],little_parser_Parser.mergeNonBlockBodies([params1])[0]));
				break;
			case 1:
				post.push(little_parser_ParserTokens.FunctionCall(little_parser_Parser.mergeNonBlockBodies([name3])[0],little_parser_Parser.mergeNonBlockBodies([params1])[0]));
				break;
			default:
				post.push(little_parser_ParserTokens.ConditionCall(little_parser_Parser.mergeNonBlockBodies([name3])[0],little_parser_Parser.mergeNonBlockBodies([params1])[0],little_parser_ParserTokens.Block(little_parser_Parser.mergeNonBlockBodies([lookahead]),null)));
				++i;
			}
			break;
		case 10:
			var value1 = token.value;
			var type2 = token.type;
			post.push(little_parser_ParserTokens.Return(little_parser_Parser.mergeNonBlockBodies([value1])[0],little_parser_Parser.mergeNonBlockBodies([type2])[0]));
			break;
		case 11:
			var parts = token.parts;
			var type3 = token.type;
			post.push(little_parser_ParserTokens.Expression(little_parser_Parser.mergeNonBlockBodies(parts),little_parser_Parser.mergeNonBlockBodies([type3])[0]));
			break;
		case 12:
			var body1 = token.body;
			var type4 = token.type;
			post.push(little_parser_ParserTokens.Block(little_parser_Parser.mergeNonBlockBodies(body1),little_parser_Parser.mergeNonBlockBodies([type4])[0]));
			break;
		case 13:
			var parts1 = token.parts;
			post.push(little_parser_ParserTokens.PartArray(little_parser_Parser.mergeNonBlockBodies(parts1)));
			break;
		case 14:
			var name4 = token.name;
			var property = token.property;
			post.push(little_parser_ParserTokens.PropertyAccess(little_parser_Parser.mergeNonBlockBodies([name4])[0],little_parser_Parser.mergeNonBlockBodies([property])[0]));
			break;
		case 24:
			var name5 = token.name;
			var params2 = token.params;
			var result = new Array(params2.length);
			var _g1 = 0;
			var _g2 = params2.length;
			while(_g1 < _g2) {
				var i1 = _g1++;
				result[i1] = little_parser_Parser.mergeNonBlockBodies([params2[i1]])[0];
			}
			post.push(little_parser_ParserTokens.Custom(name5,result));
			break;
		default:
			post.push(token);
		}
		++i;
	}
	little_parser_Parser.resetLines();
	return post;
};
little_parser_Parser.mergeElses = function(pre) {
	if(pre == null) {
		return null;
	}
	if(pre.length == 1 && pre[0] == null) {
		return [null];
	}
	var post = [];
	var i = 0;
	while(i < pre.length) {
		var token = pre[i];
		switch(token._hx_index) {
		case 0:
			var line = token.line;
			little_parser_Parser.setLine(line);
			post.push(token);
			break;
		case 1:
			little_parser_Parser.nextPart();
			post.push(token);
			break;
		case 2:
			var name = token.name;
			var type = token.type;
			var doc = token.doc;
			post.push(little_parser_ParserTokens.Variable(little_parser_Parser.mergeElses([name])[0],little_parser_Parser.mergeElses([type])[0],little_parser_Parser.mergeElses([doc])[0]));
			break;
		case 3:
			var name1 = token.name;
			var params = token.params;
			var type1 = token.type;
			var doc1 = token.doc;
			post.push(little_parser_ParserTokens.Function(little_parser_Parser.mergeElses([name1])[0],little_parser_Parser.mergeElses([params])[0],little_parser_Parser.mergeElses([type1])[0],little_parser_Parser.mergeElses([doc1])[0]));
			break;
		case 4:
			var name2 = token.name;
			var exp = token.exp;
			var body = token.body;
			post.push(little_parser_ParserTokens.ConditionCall(little_parser_Parser.mergeElses([name2])[0],little_parser_Parser.mergeElses([exp])[0],little_parser_Parser.mergeElses([body])[0]));
			break;
		case 6:
			var assignees = token.assignees;
			var value = token.value;
			post.push(little_parser_ParserTokens.Write(little_parser_Parser.mergeElses(assignees),little_parser_Parser.mergeElses([value])[0]));
			break;
		case 7:
			if(token.word == little_Little.keywords.ELSE == true) {
				var tmp;
				if(post.length != 0) {
					var token1 = post[post.length - 1];
					var _this = [little_tools_ParserTokensSimple.CONDITION_CALL].slice();
					var result = new Array(_this.length);
					var _g = 0;
					var _g1 = _this.length;
					while(_g < _g1) {
						var i1 = _g++;
						var x = _this[i1];
						result[i1] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
					}
					tmp = result.indexOf($hxEnums[token1.__enum__].__constructs__[token1._hx_index]._hx_name.toLowerCase()) == -1;
				} else {
					tmp = true;
				}
				if(tmp) {
					post.push(token);
					++i;
					continue;
				}
				if(i + 1 >= pre.length) {
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Condition has no body, body may be cut off by the end of file, block or expression."),"Parser");
					return null;
				}
				var exp1 = Type.enumParameters(post[post.length - 1])[1];
				exp1 = little_parser_ParserTokens.Expression([exp1,little_parser_ParserTokens.Sign("!="),little_parser_ParserTokens.TrueValue],null);
				++i;
				var body1 = pre[i];
				switch(body1._hx_index) {
				case 0:
					var _g2 = body1.line;
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("`" + little_Little.keywords.ELSE + "` condition has no body, body cut off by a new line, or does not exist"),"Parser");
					return null;
				case 1:
					little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("`" + little_Little.keywords.ELSE + "` condition has no body, body cut off by a line split, or does not exist"),"Parser");
					return null;
				case 4:
					var _g3 = body1.name;
					if(_g3._hx_index == 7) {
						if(_g3.word == "if") {
							var exp2 = body1.exp;
							var body2 = body1.body;
							var tmp1 = little_parser_ParserTokens.Identifier("if");
							var tmp2 = little_parser_ParserTokens.Expression([exp1,little_parser_ParserTokens.Sign("&&"),exp2],null);
							var _this1 = [little_tools_ParserTokensSimple.BLOCK].slice();
							var result1 = new Array(_this1.length);
							var _g4 = 0;
							var _g5 = _this1.length;
							while(_g4 < _g5) {
								var i2 = _g4++;
								var x1 = _this1[i2];
								result1[i2] = little_tools_TextTools.remove($hxEnums[x1.__enum__].__constructs__[x1._hx_index]._hx_name,"_").toLowerCase();
							}
							post.push(little_parser_ParserTokens.ConditionCall(tmp1,tmp2,result1.indexOf($hxEnums[body2.__enum__].__constructs__[body2._hx_index]._hx_name.toLowerCase()) == -1 ? little_parser_ParserTokens.Block([body2],null) : body2));
						} else {
							var tmp3 = little_parser_ParserTokens.Identifier("if");
							var _this2 = [little_tools_ParserTokensSimple.BLOCK].slice();
							var result2 = new Array(_this2.length);
							var _g6 = 0;
							var _g7 = _this2.length;
							while(_g6 < _g7) {
								var i3 = _g6++;
								var x2 = _this2[i3];
								result2[i3] = little_tools_TextTools.remove($hxEnums[x2.__enum__].__constructs__[x2._hx_index]._hx_name,"_").toLowerCase();
							}
							post.push(little_parser_ParserTokens.ConditionCall(tmp3,exp1,result2.indexOf($hxEnums[body1.__enum__].__constructs__[body1._hx_index]._hx_name.toLowerCase()) == -1 ? little_parser_ParserTokens.Block([body1],null) : body1));
						}
					} else {
						var tmp4 = little_parser_ParserTokens.Identifier("if");
						var _this3 = [little_tools_ParserTokensSimple.BLOCK].slice();
						var result3 = new Array(_this3.length);
						var _g8 = 0;
						var _g9 = _this3.length;
						while(_g8 < _g9) {
							var i4 = _g8++;
							var x3 = _this3[i4];
							result3[i4] = little_tools_TextTools.remove($hxEnums[x3.__enum__].__constructs__[x3._hx_index]._hx_name,"_").toLowerCase();
						}
						post.push(little_parser_ParserTokens.ConditionCall(tmp4,exp1,result3.indexOf($hxEnums[body1.__enum__].__constructs__[body1._hx_index]._hx_name.toLowerCase()) == -1 ? little_parser_ParserTokens.Block([body1],null) : body1));
					}
					break;
				default:
					var tmp5 = little_parser_ParserTokens.Identifier("if");
					var _this4 = [little_tools_ParserTokensSimple.BLOCK].slice();
					var result4 = new Array(_this4.length);
					var _g10 = 0;
					var _g11 = _this4.length;
					while(_g10 < _g11) {
						var i5 = _g10++;
						var x4 = _this4[i5];
						result4[i5] = little_tools_TextTools.remove($hxEnums[x4.__enum__].__constructs__[x4._hx_index]._hx_name,"_").toLowerCase();
					}
					post.push(little_parser_ParserTokens.ConditionCall(tmp5,exp1,result4.indexOf($hxEnums[body1.__enum__].__constructs__[body1._hx_index]._hx_name.toLowerCase()) == -1 ? little_parser_ParserTokens.Block([body1],null) : body1));
				}
			} else {
				post.push(token);
			}
			break;
		case 9:
			var name3 = token.name;
			var params1 = token.params;
			post.push(little_parser_ParserTokens.FunctionCall(little_parser_Parser.mergeElses([name3])[0],little_parser_Parser.mergeElses([params1])[0]));
			break;
		case 10:
			var value1 = token.value;
			var type2 = token.type;
			post.push(little_parser_ParserTokens.Return(little_parser_Parser.mergeElses([value1])[0],little_parser_Parser.mergeElses([type2])[0]));
			break;
		case 11:
			var parts = token.parts;
			var type3 = token.type;
			post.push(little_parser_ParserTokens.Expression(little_parser_Parser.mergeElses(parts),little_parser_Parser.mergeElses([type3])[0]));
			break;
		case 12:
			var body3 = token.body;
			var type4 = token.type;
			post.push(little_parser_ParserTokens.Block(little_parser_Parser.mergeElses(body3),little_parser_Parser.mergeElses([type4])[0]));
			break;
		case 13:
			var parts1 = token.parts;
			post.push(little_parser_ParserTokens.PartArray(little_parser_Parser.mergeElses(parts1)));
			break;
		case 14:
			var name4 = token.name;
			var property = token.property;
			post.push(little_parser_ParserTokens.PropertyAccess(little_parser_Parser.mergeElses([name4])[0],little_parser_Parser.mergeElses([property])[0]));
			break;
		case 24:
			var name5 = token.name;
			var params2 = token.params;
			var result5 = new Array(params2.length);
			var _g12 = 0;
			var _g13 = params2.length;
			while(_g12 < _g13) {
				var i6 = _g12++;
				result5[i6] = little_parser_Parser.mergeElses([params2[i6]])[0];
			}
			post.push(little_parser_ParserTokens.Custom(name5,result5));
			break;
		default:
			post.push(token);
		}
		++i;
	}
	little_parser_Parser.resetLines();
	return post;
};
little_parser_Parser.get_line = function() {
	return little_Little.runtime.line;
};
little_parser_Parser.set_line = function(l) {
	return little_Little.runtime.line = l;
};
little_parser_Parser.setLine = function(l) {
	little_parser_Parser.set_line(l);
	little_parser_Parser.linePart = 0;
};
little_parser_Parser.nextPart = function() {
	little_parser_Parser.linePart++;
};
little_parser_Parser.resetLines = function() {
	little_parser_Parser.set_line(0);
	little_parser_Parser.linePart = 0;
};
var little_tools_Conversion = function() { };
$hxClasses["little.tools.Conversion"] = little_tools_Conversion;
little_tools_Conversion.__name__ = "little.tools.Conversion";
little_tools_Conversion.extractHaxeType = function(type) {
	switch(type._hx_index) {
	case 0:
		return "Dynamic";
	case 1:
		return "Int";
	case 2:
		return "Float";
	case 3:
		return "Bool";
	case 4:
		return "Dynamic";
	case 5:
		return "Dynamic";
	case 6:
		var c = type.c;
		return c.__name__.split(".").pop();
	case 7:
		var e = type.e;
		return e.__ename__.split(".").pop();
	case 8:
		return "Dynamic";
	}
};
little_tools_Conversion.toLittleValue = function(val) {
	if(val == null) {
		return little_interpreter_InterpTokens.NullValue;
	}
	if(typeof(val) == "string") {
		return little_interpreter_InterpTokens.Characters(val);
	}
	var type = Type.typeof(val);
	switch(type._hx_index) {
	case 0:
		return little_interpreter_InterpTokens.NullValue;
	case 1:
		return little_interpreter_InterpTokens.Number(val);
	case 2:
		return little_interpreter_InterpTokens.Decimal(val);
	case 3:
		if(val) {
			return little_interpreter_InterpTokens.TrueValue;
		} else {
			return little_interpreter_InterpTokens.FalseValue;
		}
		break;
	case 4:
		if(js_Boot.getClass(val) != null) {
			var map = new haxe_ds_StringMap();
			var _g = 0;
			var _g1 = Type.getInstanceFields(js_Boot.getClass(val));
			while(_g < _g1.length) {
				var field = _g1[_g];
				++_g;
				var v = { value : little_tools_Conversion.toLittleValue(Reflect.getProperty(val,field)), documentation : ""};
				map.h[field] = v;
			}
			var v = { value : little_interpreter_InterpTokens.Block([little_interpreter_InterpTokens.FunctionReturn(little_interpreter_InterpTokens.Characters(Std.string(val)),little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_STRING))],little_interpreter_InterpTokens.Identifier(little_Little.keywords.TYPE_STRING)), documentation : "The function that will be used to convert this object to a string."};
			map.h[little_Little.keywords.TO_STRING_PROPERTY_NAME] = v;
			var k = little_Little.keywords.OBJECT_TYPE_PROPERTY_NAME;
			var v = { value : little_interpreter_InterpTokens.Characters(little_tools_Conversion.toLittleType(val.__name__)), documentation : "The type of this object, as a " + little_Little.keywords.TYPE_STRING + "."};
			map.h[k] = v;
			return little_interpreter_InterpTokens.Object(map,Type.enumParameters(map.h[little_Little.keywords.OBJECT_TYPE_PROPERTY_NAME].value)[0]);
		} else {
			var objType = little_Little.keywords.TYPE_DYNAMIC;
			var map = new haxe_ds_StringMap();
			var _g = 0;
			var _g1 = Type.getInstanceFields(js_Boot.getClass(val));
			while(_g < _g1.length) {
				var field = _g1[_g];
				++_g;
				var v = { value : little_tools_Conversion.toLittleValue(Reflect.getProperty(val,field)), documentation : ""};
				map.h[field] = v;
			}
			return little_interpreter_InterpTokens.Object(map,objType);
		}
		break;
	case 5:
		return little_interpreter_InterpTokens.NullValue;
	case 6:
		var c = type.c;
		return little_interpreter_InterpTokens.NullValue;
	case 7:
		var e = type.e;
		return little_interpreter_InterpTokens.NullValue;
	case 8:
		return little_interpreter_InterpTokens.NullValue;
	}
};
little_tools_Conversion.toHaxeValue = function(val) {
	val = little_interpreter_Interpreter.evaluate(val);
	switch(val._hx_index) {
	case 6:
		var _g = val.requiredParams;
		var _g = val.body;
		return null;
	case 15:
		var num = val.num;
		return num;
	case 16:
		var num = val.num;
		return num;
	case 17:
		var string = val.string;
		return string;
	case 21:
		return null;
	case 22:
		return true;
	case 23:
		return false;
	case 25:
		var props = val.props;
		var typeName = val.typeName;
		var obj = { };
		var h = props.h;
		var _g_h = h;
		var _g_keys = Object.keys(h);
		var _g_length = _g_keys.length;
		var _g_current = 0;
		while(_g_current < _g_length) {
			var key = _g_keys[_g_current++];
			var _g_key = key;
			var _g_value = _g_h[key];
			var key1 = _g_key;
			var value = _g_value;
			if(key1 == little_Little.keywords.TO_STRING_PROPERTY_NAME) {
				continue;
			}
			obj.key = little_tools_Conversion.toHaxeValue(value.value);
		}
		return obj;
	case 26:
		var msg = val.msg;
		haxe_Log.trace("WARNING: " + msg + ". Returning null",{ fileName : "src/little/tools/Conversion.hx", lineNumber : 99, className : "little.tools.Conversion", methodName : "toHaxeValue"});
		return null;
	default:
		return null;
	}
};
little_tools_Conversion.toLittleType = function(type) {
	switch(type) {
	case "Bool":
		return little_Little.keywords.TYPE_BOOLEAN;
	case "Dynamic":
		return little_Little.keywords.TYPE_DYNAMIC;
	case "Float":
		return little_Little.keywords.TYPE_FLOAT;
	case "Int":
		return little_Little.keywords.TYPE_INT;
	case "String":
		return little_Little.keywords.TYPE_STRING;
	default:
		return type;
	}
};
var little_tools_Extensions = function() { };
$hxClasses["little.tools.Extensions"] = little_tools_Extensions;
little_tools_Extensions.__name__ = "little.tools.Extensions";
little_tools_Extensions.tokenize = function(code) {
	return little_interpreter_Interpreter.convert.apply(null,little_parser_Parser.parse(little_lexer_Lexer.lex(code)));
};
little_tools_Extensions.eval = function(code) {
	return little_interpreter_Interpreter.run(little_interpreter_Interpreter.convert.apply(null,little_parser_Parser.parse(little_lexer_Lexer.lex(code))));
};
little_tools_Extensions.passedByValue = function(token) {
	var _this = [little_tools_InterpTokensSimple.TRUE_VALUE,little_tools_InterpTokensSimple.FALSE_VALUE,little_tools_InterpTokensSimple.NULL_VALUE,little_tools_InterpTokensSimple.NUMBER,little_tools_InterpTokensSimple.DECIMAL,little_tools_InterpTokensSimple.SIGN,little_tools_InterpTokensSimple.CHARACTERS].slice();
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		var x = _this[i];
		result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
	}
	return result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1;
};
little_tools_Extensions.passedByReference = function(token) {
	var _this = [little_tools_InterpTokensSimple.TRUE_VALUE,little_tools_InterpTokensSimple.FALSE_VALUE,little_tools_InterpTokensSimple.NULL_VALUE,little_tools_InterpTokensSimple.NUMBER,little_tools_InterpTokensSimple.DECIMAL,little_tools_InterpTokensSimple.SIGN,little_tools_InterpTokensSimple.CHARACTERS].slice();
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		var x = _this[i];
		result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
	}
	return result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) == -1;
};
little_tools_Extensions.staticallyStorable = function(token) {
	var _this = [little_tools_InterpTokensSimple.TRUE_VALUE,little_tools_InterpTokensSimple.FALSE_VALUE,little_tools_InterpTokensSimple.NULL_VALUE,little_tools_InterpTokensSimple.NUMBER,little_tools_InterpTokensSimple.DECIMAL,little_tools_InterpTokensSimple.SIGN,little_tools_InterpTokensSimple.CHARACTERS].slice();
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		var x = _this[i];
		result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
	}
	if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) == -1) {
		var _this = [little_tools_InterpTokensSimple.CHARACTERS].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		return result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1;
	} else {
		return true;
	}
};
little_tools_Extensions.extractIdentifier = function(token) {
	var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		var x = _this[i];
		result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
	}
	if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1) {
		return Type.enumParameters(token)[0];
	} else {
		return Type.enumParameters(little_interpreter_Interpreter.run([token]))[0];
	}
};
little_tools_Extensions.asStringPath = function(token) {
	var path = [];
	var current = token;
	while(current != null) switch(current._hx_index) {
	case 14:
		var source = current.name;
		var property = current.property;
		var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		path.unshift(result.indexOf($hxEnums[property.__enum__].__constructs__[property._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(property)[0] : Type.enumParameters(little_interpreter_Interpreter.run([property]))[0]);
		current = source;
		break;
	case 17:
		var word = current.string;
		path.unshift(word);
		current = null;
		break;
	case 24:
		var word1 = current.word;
		path.unshift(word1);
		current = null;
		break;
	default:
		var _this1 = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
		var result1 = new Array(_this1.length);
		var _g2 = 0;
		var _g3 = _this1.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			var x1 = _this1[i1];
			result1[i1] = little_tools_TextTools.remove($hxEnums[x1.__enum__].__constructs__[x1._hx_index]._hx_name,"_").toLowerCase();
		}
		path.unshift(result1.indexOf($hxEnums[current.__enum__].__constructs__[current._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(current)[0] : Type.enumParameters(little_interpreter_Interpreter.run([current]))[0]);
		current = null;
	}
	return path;
};
little_tools_Extensions.asJoinedStringPath = function(token) {
	return little_tools_Extensions.asStringPath(token).join(little_Little.keywords.PROPERTY_ACCESS_SIGN);
};
little_tools_Extensions.type = function(token) {
	switch(token._hx_index) {
	case 6:
		var requiredParams = token.requiredParams;
		var body = token.body;
		return little_Little.keywords.TYPE_FUNCTION;
	case 15:
		var number = token.num;
		return little_Little.keywords.TYPE_INT;
	case 16:
		var number = token.num;
		return little_Little.keywords.TYPE_FLOAT;
	case 17:
		var string = token.string;
		return little_Little.keywords.TYPE_STRING;
	case 19:
		var pointer = token.pointer;
		return little_Little.keywords.TYPE_MODULE;
	case 20:
		var sign = token.sign;
		return little_Little.keywords.TYPE_SIGN;
	case 21:
		return little_Little.keywords.TYPE_DYNAMIC;
	case 22:case 23:
		return little_Little.keywords.TYPE_BOOLEAN;
	case 25:
		var _g = token.props;
		var typeName = token.typeName;
		return typeName;
	default:
		throw haxe_Exception.thrown("" + Std.string(token) + " is not a simple token (given " + Std.string(token) + ")");
	}
};
little_tools_Extensions.asTokenPath = function(string) {
	var path = string.split(little_Little.keywords.PROPERTY_ACCESS_SIGN);
	if(path.length == 1) {
		return little_interpreter_InterpTokens.Identifier(path[0]);
	} else {
		return little_interpreter_InterpTokens.PropertyAccess(little_tools_Extensions.asTokenPath(path.slice(0,path.length - 1).join(little_Little.keywords.PROPERTY_ACCESS_SIGN)),little_interpreter_InterpTokens.Identifier(path.pop()));
	}
};
little_tools_Extensions.toIdentifierPath = function(propertyAccess) {
	var arr = [];
	var current = propertyAccess;
	while(current != null) if(current._hx_index == 14) {
		var source = current.name;
		var property = current.property;
		arr.unshift(property);
		current = source;
	} else {
		arr.unshift(current);
		current = null;
	}
	return arr;
};
little_tools_Extensions.containsAny = function(array,func) {
	var _g = [];
	var _g1 = 0;
	var _g2 = array;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(func(v)) {
			_g.push(v);
		}
	}
	return _g.length > 0;
};
little_tools_Extensions.toArray = function(iter) {
	var _g = [];
	var i = iter;
	while(i.hasNext()) {
		var i1 = i.next();
		_g.push(i1);
	}
	return _g;
};
var little_tools_InterpTokensSimple = $hxEnums["little.tools.InterpTokensSimple"] = { __ename__:"little.tools.InterpTokensSimple",__constructs__:null
	,SET_LINE: {_hx_name:"SET_LINE",_hx_index:0,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,SPLIT_LINE: {_hx_name:"SPLIT_LINE",_hx_index:1,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,VARIABLE_DECLARATION: {_hx_name:"VARIABLE_DECLARATION",_hx_index:2,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,FUNCTION_DECLARATION: {_hx_name:"FUNCTION_DECLARATION",_hx_index:3,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,CONDITION_DECLARATION: {_hx_name:"CONDITION_DECLARATION",_hx_index:4,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,CLASS_DECLARATION: {_hx_name:"CLASS_DECLARATION",_hx_index:5,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,CONDITION_CALL: {_hx_name:"CONDITION_CALL",_hx_index:6,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,CONDITION_CODE: {_hx_name:"CONDITION_CODE",_hx_index:7,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,FUNCTION_CALL: {_hx_name:"FUNCTION_CALL",_hx_index:8,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,FUNCTION_CODE: {_hx_name:"FUNCTION_CODE",_hx_index:9,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,FUNCTION_RETURN: {_hx_name:"FUNCTION_RETURN",_hx_index:10,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,WRITE: {_hx_name:"WRITE",_hx_index:11,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,TYPE_CAST: {_hx_name:"TYPE_CAST",_hx_index:12,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,EXPRESSION: {_hx_name:"EXPRESSION",_hx_index:13,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,BLOCK: {_hx_name:"BLOCK",_hx_index:14,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,PART_ARRAY: {_hx_name:"PART_ARRAY",_hx_index:15,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,PROPERTY_ACCESS: {_hx_name:"PROPERTY_ACCESS",_hx_index:16,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,NUMBER: {_hx_name:"NUMBER",_hx_index:17,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,DECIMAL: {_hx_name:"DECIMAL",_hx_index:18,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,CHARACTERS: {_hx_name:"CHARACTERS",_hx_index:19,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,DOCUMENTATION: {_hx_name:"DOCUMENTATION",_hx_index:20,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,CLASS_POINTER: {_hx_name:"CLASS_POINTER",_hx_index:21,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,SIGN: {_hx_name:"SIGN",_hx_index:22,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,NULL_VALUE: {_hx_name:"NULL_VALUE",_hx_index:23,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,TRUE_VALUE: {_hx_name:"TRUE_VALUE",_hx_index:24,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,FALSE_VALUE: {_hx_name:"FALSE_VALUE",_hx_index:25,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,IDENTIFIER: {_hx_name:"IDENTIFIER",_hx_index:26,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,TYPE_REFERENCE: {_hx_name:"TYPE_REFERENCE",_hx_index:27,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,OBJECT: {_hx_name:"OBJECT",_hx_index:28,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,CLASS: {_hx_name:"CLASS",_hx_index:29,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,ERROR_MESSAGE: {_hx_name:"ERROR_MESSAGE",_hx_index:30,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
	,HAXE_EXTERN: {_hx_name:"HAXE_EXTERN",_hx_index:31,__enum__:"little.tools.InterpTokensSimple",toString:$estr}
};
little_tools_InterpTokensSimple.__constructs__ = [little_tools_InterpTokensSimple.SET_LINE,little_tools_InterpTokensSimple.SPLIT_LINE,little_tools_InterpTokensSimple.VARIABLE_DECLARATION,little_tools_InterpTokensSimple.FUNCTION_DECLARATION,little_tools_InterpTokensSimple.CONDITION_DECLARATION,little_tools_InterpTokensSimple.CLASS_DECLARATION,little_tools_InterpTokensSimple.CONDITION_CALL,little_tools_InterpTokensSimple.CONDITION_CODE,little_tools_InterpTokensSimple.FUNCTION_CALL,little_tools_InterpTokensSimple.FUNCTION_CODE,little_tools_InterpTokensSimple.FUNCTION_RETURN,little_tools_InterpTokensSimple.WRITE,little_tools_InterpTokensSimple.TYPE_CAST,little_tools_InterpTokensSimple.EXPRESSION,little_tools_InterpTokensSimple.BLOCK,little_tools_InterpTokensSimple.PART_ARRAY,little_tools_InterpTokensSimple.PROPERTY_ACCESS,little_tools_InterpTokensSimple.NUMBER,little_tools_InterpTokensSimple.DECIMAL,little_tools_InterpTokensSimple.CHARACTERS,little_tools_InterpTokensSimple.DOCUMENTATION,little_tools_InterpTokensSimple.CLASS_POINTER,little_tools_InterpTokensSimple.SIGN,little_tools_InterpTokensSimple.NULL_VALUE,little_tools_InterpTokensSimple.TRUE_VALUE,little_tools_InterpTokensSimple.FALSE_VALUE,little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.TYPE_REFERENCE,little_tools_InterpTokensSimple.OBJECT,little_tools_InterpTokensSimple.CLASS,little_tools_InterpTokensSimple.ERROR_MESSAGE,little_tools_InterpTokensSimple.HAXE_EXTERN];
var little_tools_Layer = {};
little_tools_Layer.getIndexOf = function(layer) {
	switch(layer) {
	case "Interpreter":
		return 4;
	case "Interpreter, Expression Evaluator":
		return 6;
	case "Interpreter, Token Identifier Stringifier":
		return 8;
	case "Interpreter, Token Value Stringifier":
		return 7;
	case "Interpreter, Value Evaluator":
		return 5;
	case "Lexer":
		return 1;
	case "Memory":
		return 9;
	case "Memory, External Interfacing":
		return 12;
	case "Memory, Garbage Collector":
		return 14;
	case "Memory, Referrer":
		return 10;
	case "Memory, Size Evaluator":
		return 13;
	case "Memory, Storage":
		return 11;
	case "Parser":
		return 2;
	case "Parser, Macro":
		return 3;
	default:
		return 999999999;
	}
};
var little_tools_PrepareRun = function() { };
$hxClasses["little.tools.PrepareRun"] = little_tools_PrepareRun;
little_tools_PrepareRun.__name__ = "little.tools.PrepareRun";
little_tools_PrepareRun.addTypes = function() {
	little_Little.plugin.registerType(little_Little.keywords.TYPE_FUNCTION,new haxe_ds_StringMap());
	little_Little.plugin.registerType(little_Little.keywords.TYPE_CONDITION,new haxe_ds_StringMap());
	little_Little.plugin.registerType(little_Little.keywords.TYPE_INT,new haxe_ds_StringMap());
	little_Little.plugin.registerType(little_Little.keywords.TYPE_FLOAT,new haxe_ds_StringMap());
	little_Little.plugin.registerType(little_Little.keywords.TYPE_STRING,new haxe_ds_StringMap());
	little_Little.plugin.registerType(little_Little.keywords.TYPE_SIGN,new haxe_ds_StringMap());
	var tmp = little_Little.plugin;
	var tmp1 = little_Little.keywords.TYPE_MODULE;
	var _g = new haxe_ds_StringMap();
	_g.h["public " + little_Little.keywords.TYPE_STRING + " toString ()"] = function(address,_,_1) {
		return little_tools_Conversion.toLittleValue(little_Little.memory.getTypeName(address));
	};
	tmp.registerType(tmp1,_g);
	var tmp = little_Little.plugin;
	var _g = new haxe_ds_StringMap();
	_g.h["static " + little_Little.keywords.TYPE_STRING + " now ()"] = function(_) {
		return little_tools_Conversion.toLittleValue(HxOverrides.dateStr(new Date()));
	};
	tmp.registerType("Date",_g);
	var tmp = little_Little.plugin;
	var tmp1 = little_Little.keywords.TYPE_INT;
	var _g = new haxe_ds_StringMap();
	_g.h["public " + little_Little.keywords.TYPE_STRING + " toString ()"] = function(_,value,_1) {
		return little_tools_Conversion.toLittleValue(Std.string(Type.enumParameters(value)[0]));
	};
	tmp.registerType(tmp1,_g);
	var tmp = little_Little.plugin;
	var tmp1 = little_Little.keywords.TYPE_FLOAT;
	var _g = new haxe_ds_StringMap();
	_g.h["public " + little_Little.keywords.TYPE_STRING + " toString ()"] = function(_,value,_1) {
		return little_tools_Conversion.toLittleValue(Std.string(Type.enumParameters(value)[0]));
	};
	_g.h["public " + little_Little.keywords.TYPE_BOOLEAN + " isWhole ()"] = function(_,value,_1) {
		return little_tools_Conversion.toLittleValue(Type.enumParameters(value)[0] % 1 == 0);
	};
	tmp.registerType(tmp1,_g);
	var tmp = little_Little.plugin;
	var tmp1 = little_Little.keywords.TYPE_STRING;
	var _g = new haxe_ds_StringMap();
	_g.h["public " + little_Little.keywords.TYPE_INT + " length"] = function(_,value) {
		return little_tools_Conversion.toLittleValue(Type.enumParameters(value)[0].length);
	};
	_g.h["public " + little_Little.keywords.TYPE_STRING + " charAt (define index as " + little_Little.keywords.TYPE_INT + ")"] = function(_,value,params) {
		return little_tools_Conversion.toLittleValue(Type.enumParameters(value)[0].charAt(little_tools_Conversion.toHaxeValue(params[0])));
	};
	_g.h["public " + little_Little.keywords.TYPE_STRING + " substring (define start as " + little_Little.keywords.TYPE_INT + ", define end as " + little_Little.keywords.TYPE_INT + " = -1)"] = function(_,value,params) {
		return little_interpreter_InterpTokens.Characters(Type.enumParameters(value)[0].substring(little_tools_Conversion.toHaxeValue(params[0]),little_tools_Conversion.toHaxeValue(params[1])));
	};
	_g.h["public " + little_Little.keywords.TYPE_STRING + " toLowerCase ()"] = function(_,value,_1) {
		return little_interpreter_InterpTokens.Characters(Type.enumParameters(value)[0].toLowerCase());
	};
	_g.h["public " + little_Little.keywords.TYPE_STRING + " toUpperCase ()"] = function(_,value,_1) {
		return little_interpreter_InterpTokens.Characters(Type.enumParameters(value)[0].toUpperCase());
	};
	_g.h["public " + little_Little.keywords.TYPE_STRING + " replace (define search as " + little_Little.keywords.TYPE_STRING + ", define replace as " + little_Little.keywords.TYPE_STRING + ")"] = function(_,value,params) {
		return little_interpreter_InterpTokens.Characters(Type.enumParameters(value)[0].replace(little_tools_Conversion.toHaxeValue(params[0]),little_tools_Conversion.toHaxeValue(params[1])));
	};
	_g.h["public " + little_Little.keywords.TYPE_STRING + " trim ()"] = function(_,value,_1) {
		return little_interpreter_InterpTokens.Characters(Type.enumParameters(value)[0].trim());
	};
	_g.h["public " + little_Little.keywords.TYPE_STRING + " remove (define search as " + little_Little.keywords.TYPE_STRING + ")"] = function(_,value,params) {
		return little_interpreter_InterpTokens.Characters(Type.enumParameters(value)[0].replace(little_tools_Conversion.toHaxeValue(params[0]),""));
	};
	_g.h["public " + little_Little.keywords.TYPE_BOOLEAN + " contains (define search as " + little_Little.keywords.TYPE_STRING + ")"] = function(_,value,params) {
		return little_tools_Conversion.toLittleValue(Type.enumParameters(value)[0].contains(little_tools_Conversion.toHaxeValue(params[0])));
	};
	_g.h["public " + little_Little.keywords.TYPE_INT + " indexOf (define search as " + little_Little.keywords.TYPE_STRING + ")"] = function(_,value,params) {
		return little_tools_Conversion.toLittleValue(Type.enumParameters(value)[0].indexOf(little_tools_Conversion.toHaxeValue(params[0])));
	};
	_g.h["public " + little_Little.keywords.TYPE_INT + " lastIndexOf (define search as " + little_Little.keywords.TYPE_STRING + ")"] = function(_,value,params) {
		return little_tools_Conversion.toLittleValue(Type.enumParameters(value)[0].lastIndexOf(little_tools_Conversion.toHaxeValue(params[0])));
	};
	_g.h["public " + little_Little.keywords.TYPE_BOOLEAN + " startsWith (define prefix as " + little_Little.keywords.TYPE_STRING + ")"] = function(_,value,params) {
		return little_tools_Conversion.toLittleValue(Type.enumParameters(value)[0].indexOf(little_tools_Conversion.toHaxeValue(params[0]) == 0));
	};
	_g.h["public " + little_Little.keywords.TYPE_BOOLEAN + " endsWith (define postfix as " + little_Little.keywords.TYPE_STRING + ")"] = function(_,value,params) {
		return little_tools_Conversion.toLittleValue(Type.enumParameters(value)[0].indexOf(little_tools_Conversion.toHaxeValue(params[0])) == Type.enumParameters(value)[0].length - little_tools_Conversion.toHaxeValue(params[0]).length);
	};
	_g.h["static " + little_Little.keywords.TYPE_STRING + " fromCharCode (define code as " + little_Little.keywords.TYPE_INT + ")"] = function(_,value,params) {
		var code = little_tools_Conversion.toHaxeValue(params[0]);
		return little_tools_Conversion.toLittleValue(String.fromCodePoint(code));
	};
	tmp.registerType(tmp1,_g);
	var tmp = little_Little.plugin;
	var _g = new haxe_ds_StringMap();
	_g.h["static Object create (define fieldEstimate as " + little_Little.keywords.TYPE_INT + " = 20)"] = function(params) {
		return little_interpreter_InterpTokens.Object(new haxe_ds_StringMap(),"Object");
	};
	tmp.registerType("Object",_g);
};
little_tools_PrepareRun.addFunctions = function() {
	little_Little.plugin.registerFunction(little_Little.keywords.PRINT_FUNCTION_NAME,null,[little_interpreter_InterpTokens.VariableDeclaration(little_interpreter_InterpTokens.Identifier("item"),null)],function(params) {
		var $eval = params[0].objectValue;
		var tmp = little_Little.runtime;
		var tmp1;
		var _this = [little_tools_InterpTokensSimple.OBJECT].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		if(result.indexOf($hxEnums[$eval.__enum__].__constructs__[$eval._hx_index]._hx_name.toLowerCase()) != -1) {
			var _this = little_tools_PrettyPrinter.printInterpreterAst([$eval]).split("\n").slice(1);
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = _this[i].substring(6);
			}
			tmp1 = result.join("\n");
		} else {
			tmp1 = little_tools_PrettyPrinter.stringifyInterpreter(null,$eval);
		}
		tmp.__print(tmp1,$eval);
		return little_interpreter_InterpTokens.NullValue;
	},little_Little.keywords.TYPE_DYNAMIC);
	little_Little.plugin.registerFunction(little_Little.keywords.RAISE_ERROR_FUNCTION_NAME,null,[little_interpreter_InterpTokens.VariableDeclaration(little_interpreter_InterpTokens.Identifier("message"),null)],function(params) {
		little_Little.runtime.throwError(params[0].objectValue);
		return little_interpreter_InterpTokens.NullValue;
	},little_Little.keywords.TYPE_DYNAMIC);
	little_Little.plugin.registerFunction(little_Little.keywords.READ_FUNCTION_NAME,null,[little_interpreter_InterpTokens.VariableDeclaration(little_interpreter_InterpTokens.Identifier("identifier"),little_tools_Extensions.asTokenPath(little_Little.keywords.TYPE_STRING))],function(params) {
		return little_tools_Extensions.asTokenPath(little_tools_Conversion.toHaxeValue(params[0].objectValue));
	},little_Little.keywords.TYPE_DYNAMIC);
	little_Little.plugin.registerFunction(little_Little.keywords.RUN_CODE_FUNCTION_NAME,null,[little_interpreter_InterpTokens.VariableDeclaration(little_interpreter_InterpTokens.Identifier("code"),little_tools_Extensions.asTokenPath(little_Little.keywords.TYPE_STRING))],function(params) {
		return little_interpreter_Interpreter.run(little_interpreter_Interpreter.convert.apply(null,little_parser_Parser.parse(little_lexer_Lexer.lex(little_tools_Conversion.toHaxeValue(params[0].objectValue)))));
	},little_Little.keywords.TYPE_DYNAMIC);
};
little_tools_PrepareRun.addProps = function() {
	little_Little.plugin.registerInstanceVariable(little_Little.keywords.OBJECT_TYPE_PROPERTY_NAME,little_Little.keywords.TYPE_STRING,little_Little.keywords.TYPE_DYNAMIC,"The name of this value's type, as a " + little_Little.keywords.TYPE_STRING,null,function(value,address) {
		return little_interpreter_InterpTokens.Characters(little_tools_Extensions.type(value));
	});
	little_Little.plugin.registerInstanceVariable(little_Little.keywords.OBJECT_ADDRESS_PROPERTY_NAME,little_Little.keywords.TYPE_INT,little_Little.keywords.TYPE_DYNAMIC,"The address of this value",null,function(value,address) {
		return little_interpreter_InterpTokens.Number(address);
	});
};
little_tools_PrepareRun.addSigns = function() {
	little_Little.plugin.registerOperator("+",{ rhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], operatorType : little_interpreter_memory_OperatorType.RHS_ONLY, priority : "last", singleSidedOperatorCallback : function(rhs) {
		var r = little_tools_Conversion.toHaxeValue(rhs);
		if(typeof(r) == "number" && ((r | 0) === r)) {
			return little_interpreter_InterpTokens.Number(r);
		}
		return little_interpreter_InterpTokens.Decimal(r);
	}});
	little_Little.plugin.registerOperator("-",{ rhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], operatorType : little_interpreter_memory_OperatorType.RHS_ONLY, priority : "with +_", singleSidedOperatorCallback : function(rhs) {
		var r = little_tools_Conversion.toHaxeValue(rhs);
		if(typeof(r) == "number" && ((r | 0) === r)) {
			return little_interpreter_InterpTokens.Number(-r);
		}
		return little_interpreter_InterpTokens.Decimal(-r);
	}});
	little_Little.plugin.registerOperator("",{ rhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], operatorType : little_interpreter_memory_OperatorType.RHS_ONLY, priority : "first", singleSidedOperatorCallback : function(rhs) {
		var r = little_tools_Conversion.toHaxeValue(rhs);
		return little_interpreter_InterpTokens.Decimal(Math.sqrt(r));
	}});
	little_Little.plugin.registerOperator("!",{ rhsAllowedTypes : [little_Little.keywords.TYPE_BOOLEAN], operatorType : little_interpreter_memory_OperatorType.RHS_ONLY, priority : "with +_", singleSidedOperatorCallback : function(rhs) {
		var r = little_tools_Conversion.toHaxeValue(rhs);
		if(r) {
			return little_interpreter_InterpTokens.FalseValue;
		} else {
			return little_interpreter_InterpTokens.TrueValue;
		}
	}});
	little_Little.plugin.registerOperator("!",{ lhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], operatorType : little_interpreter_memory_OperatorType.LHS_ONLY, priority : "with _", singleSidedOperatorCallback : function(lhs) {
		var l = little_tools_Conversion.toHaxeValue(lhs);
		var shifted = Math.pow(10,10) * l;
		if(shifted != Math.floor(shifted)) {
			return little_interpreter_InterpTokens.Number(Math.round(vision_tools_MathTools.factorial(l)));
		}
		return little_interpreter_InterpTokens.Decimal(vision_tools_MathTools.factorial(l));
	}});
	little_Little.plugin.registerOperator("+",{ rhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT,little_Little.keywords.TYPE_STRING], lhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT,little_Little.keywords.TYPE_STRING], allowedTypeCombos : [{ lhs : little_Little.keywords.TYPE_STRING, rhs : little_Little.keywords.TYPE_DYNAMIC},{ lhs : little_Little.keywords.TYPE_DYNAMIC, rhs : little_Little.keywords.TYPE_STRING}], priority : "with +_", callback : function(lhs,rhs) {
		lhs = little_interpreter_Interpreter.evaluate(lhs);
		rhs = little_interpreter_Interpreter.evaluate(rhs);
		var l = little_tools_Conversion.toHaxeValue(lhs);
		var r = little_tools_Conversion.toHaxeValue(rhs);
		if(typeof(l) == "string" || typeof(r) == "string") {
			if(l == null) {
				l = little_Little.keywords.NULL_VALUE;
			}
			if(r == null) {
				r = little_Little.keywords.NULL_VALUE;
			}
			return little_interpreter_InterpTokens.Characters("" + l + r);
		}
		if(little_tools_Extensions.type(lhs) == little_Little.keywords.TYPE_INT && little_tools_Extensions.type(rhs) == little_Little.keywords.TYPE_INT) {
			return little_interpreter_InterpTokens.Number(l + r);
		}
		return little_interpreter_InterpTokens.Decimal(l + r);
	}});
	little_Little.plugin.registerOperator("-",{ rhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], lhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], allowedTypeCombos : [{ lhs : little_Little.keywords.TYPE_STRING, rhs : little_Little.keywords.TYPE_STRING}], priority : "with +", callback : function(lhs,rhs) {
		lhs = little_interpreter_Interpreter.evaluate(lhs);
		rhs = little_interpreter_Interpreter.evaluate(rhs);
		var l = little_tools_Conversion.toHaxeValue(lhs);
		var r = little_tools_Conversion.toHaxeValue(rhs);
		if(typeof(l) == "string") {
			if(l == null) {
				l = little_Little.keywords.NULL_VALUE;
			}
			if(r == null) {
				r = little_Little.keywords.NULL_VALUE;
			}
			return little_interpreter_InterpTokens.Characters(little_tools_TextTools.replaceLast(l,r,""));
		}
		if(little_tools_Extensions.type(lhs) == little_Little.keywords.TYPE_INT && little_tools_Extensions.type(rhs) == little_Little.keywords.TYPE_INT) {
			return little_interpreter_InterpTokens.Number(l - r);
		}
		return little_interpreter_InterpTokens.Decimal(l - r);
	}});
	little_Little.plugin.registerOperator("*",{ rhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], lhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], allowedTypeCombos : [{ lhs : little_Little.keywords.TYPE_STRING, rhs : little_Little.keywords.TYPE_INT}], priority : "between + _", callback : function(lhs,rhs) {
		lhs = little_interpreter_Interpreter.evaluate(lhs);
		rhs = little_interpreter_Interpreter.evaluate(rhs);
		var l = little_tools_Conversion.toHaxeValue(lhs);
		var r = little_tools_Conversion.toHaxeValue(rhs);
		if(typeof(l) == "string") {
			if(l == null) {
				l = little_Little.keywords.NULL_VALUE;
			}
			return little_interpreter_InterpTokens.Characters(little_tools_TextTools.multiply(l,r));
		}
		if(little_tools_Extensions.type(lhs) == little_Little.keywords.TYPE_INT && little_tools_Extensions.type(rhs) == little_Little.keywords.TYPE_INT) {
			return little_interpreter_InterpTokens.Number(l * r);
		}
		return little_interpreter_InterpTokens.Decimal(l * r);
	}});
	little_Little.plugin.registerOperator("/",{ rhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], lhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], priority : "with *", callback : function(lhs,rhs) {
		var l = little_tools_Conversion.toHaxeValue(lhs);
		var r = little_tools_Conversion.toHaxeValue(rhs);
		if(r == 0) {
			little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot divide by 0"));
		}
		return little_interpreter_InterpTokens.Decimal(l / r);
	}});
	little_Little.plugin.registerOperator("^",{ rhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], lhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], priority : "before *", callback : function(lhs,rhs) {
		lhs = little_interpreter_Interpreter.evaluate(lhs);
		rhs = little_interpreter_Interpreter.evaluate(rhs);
		var l = little_tools_Conversion.toHaxeValue(lhs);
		var r = little_tools_Conversion.toHaxeValue(rhs);
		if(little_tools_Extensions.type(lhs) == little_Little.keywords.TYPE_INT && little_tools_Extensions.type(rhs) == little_Little.keywords.TYPE_INT) {
			return little_interpreter_InterpTokens.Number(Math.pow(l,r) | 0);
		}
		return little_interpreter_InterpTokens.Decimal(Math.pow(l,r));
	}});
	little_Little.plugin.registerOperator("",{ rhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], lhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], priority : "with ^", callback : function(lhs,rhs) {
		var l = little_tools_Conversion.toHaxeValue(lhs);
		var r = little_tools_Conversion.toHaxeValue(rhs);
		var lPositive = l >= 0;
		var oddN = r % 2 == 1;
		if(!lPositive) {
			l = -l;
		}
		return little_interpreter_InterpTokens.Decimal(Math.pow(l * (!lPositive && oddN ? -1 : 1),1 / r));
	}});
	little_Little.plugin.registerOperator("&&",{ rhsAllowedTypes : [little_Little.keywords.TYPE_BOOLEAN], lhsAllowedTypes : [little_Little.keywords.TYPE_BOOLEAN], priority : "last", callback : function(lhs,rhs) {
		if(little_tools_Conversion.toHaxeValue(lhs) && little_tools_Conversion.toHaxeValue(rhs)) {
			return little_interpreter_InterpTokens.TrueValue;
		} else {
			return little_interpreter_InterpTokens.FalseValue;
		}
	}});
	little_Little.plugin.registerOperator("||",{ rhsAllowedTypes : [little_Little.keywords.TYPE_BOOLEAN], lhsAllowedTypes : [little_Little.keywords.TYPE_BOOLEAN], priority : "with &&", callback : function(lhs,rhs) {
		if(little_tools_Conversion.toHaxeValue(lhs) || little_tools_Conversion.toHaxeValue(rhs)) {
			return little_interpreter_InterpTokens.TrueValue;
		} else {
			return little_interpreter_InterpTokens.FalseValue;
		}
	}});
	little_Little.plugin.registerOperator("==",{ priority : "last", callback : function(lhs,rhs) {
		if(little_tools_Conversion.toHaxeValue(lhs) == little_tools_Conversion.toHaxeValue(rhs)) {
			return little_interpreter_InterpTokens.TrueValue;
		} else {
			return little_interpreter_InterpTokens.FalseValue;
		}
	}});
	little_Little.plugin.registerOperator("!=",{ priority : "with ==", callback : function(lhs,rhs) {
		if(little_tools_Conversion.toHaxeValue(lhs) != little_tools_Conversion.toHaxeValue(rhs)) {
			return little_interpreter_InterpTokens.TrueValue;
		} else {
			return little_interpreter_InterpTokens.FalseValue;
		}
	}});
	little_Little.plugin.registerOperator("^^",{ rhsAllowedTypes : [little_Little.keywords.TYPE_BOOLEAN], lhsAllowedTypes : [little_Little.keywords.TYPE_BOOLEAN], priority : "with &&", callback : function(lhs,rhs) {
		if(little_tools_Conversion.toHaxeValue(lhs) != little_tools_Conversion.toHaxeValue(rhs)) {
			return little_interpreter_InterpTokens.TrueValue;
		} else {
			return little_interpreter_InterpTokens.FalseValue;
		}
	}});
	little_Little.plugin.registerOperator(">",{ rhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], lhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], allowedTypeCombos : [{ lhs : little_Little.keywords.TYPE_STRING, rhs : little_Little.keywords.TYPE_STRING}], priority : "with ==", callback : function(lhs,rhs) {
		var l = little_tools_Conversion.toHaxeValue(lhs);
		var r = little_tools_Conversion.toHaxeValue(rhs);
		if(typeof(l) == "string") {
			if(l.length > r.length) {
				return little_interpreter_InterpTokens.TrueValue;
			} else {
				return little_interpreter_InterpTokens.FalseValue;
			}
		}
		if(l > r) {
			return little_interpreter_InterpTokens.TrueValue;
		} else {
			return little_interpreter_InterpTokens.FalseValue;
		}
	}});
	little_Little.plugin.registerOperator(">=",{ rhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], lhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], allowedTypeCombos : [{ lhs : little_Little.keywords.TYPE_STRING, rhs : little_Little.keywords.TYPE_STRING}], priority : "with ==", callback : function(lhs,rhs) {
		var l = little_tools_Conversion.toHaxeValue(lhs);
		var r = little_tools_Conversion.toHaxeValue(rhs);
		if(typeof(l) == "string") {
			if(l.length >= r.length) {
				return little_interpreter_InterpTokens.TrueValue;
			} else {
				return little_interpreter_InterpTokens.FalseValue;
			}
		}
		if(l >= r) {
			return little_interpreter_InterpTokens.TrueValue;
		} else {
			return little_interpreter_InterpTokens.FalseValue;
		}
	}});
	little_Little.plugin.registerOperator("<",{ rhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], lhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], allowedTypeCombos : [{ lhs : little_Little.keywords.TYPE_STRING, rhs : little_Little.keywords.TYPE_STRING}], priority : "with ==", callback : function(lhs,rhs) {
		var l = little_tools_Conversion.toHaxeValue(lhs);
		var r = little_tools_Conversion.toHaxeValue(rhs);
		if(typeof(l) == "string") {
			if(l.length < r.length) {
				return little_interpreter_InterpTokens.TrueValue;
			} else {
				return little_interpreter_InterpTokens.FalseValue;
			}
		}
		if(l < r) {
			return little_interpreter_InterpTokens.TrueValue;
		} else {
			return little_interpreter_InterpTokens.FalseValue;
		}
	}});
	little_Little.plugin.registerOperator("<=",{ rhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], lhsAllowedTypes : [little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_INT], allowedTypeCombos : [{ lhs : little_Little.keywords.TYPE_STRING, rhs : little_Little.keywords.TYPE_STRING}], priority : "with ==", callback : function(lhs,rhs) {
		var l = little_tools_Conversion.toHaxeValue(lhs);
		var r = little_tools_Conversion.toHaxeValue(rhs);
		if(typeof(l) == "string") {
			if(l.length <= r.length) {
				return little_interpreter_InterpTokens.TrueValue;
			} else {
				return little_interpreter_InterpTokens.FalseValue;
			}
		}
		if(l <= r) {
			return little_interpreter_InterpTokens.TrueValue;
		} else {
			return little_interpreter_InterpTokens.FalseValue;
		}
	}});
};
little_tools_PrepareRun.addConditions = function() {
	little_Little.plugin.registerCondition("while","A loop that executes code until the condition is not met",function(params,body) {
		var val = little_interpreter_InterpTokens.NullValue;
		var safetyNet = 0;
		while(safetyNet < 500000) {
			var condition = little_tools_Conversion.toHaxeValue(little_interpreter_Interpreter.calculate(params));
			if(typeof(condition) == "boolean" && condition) {
				val = little_interpreter_Interpreter.run(body);
				++safetyNet;
			} else if(typeof(condition) == "boolean" && !condition) {
				return val;
			} else {
				little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("While condition must be a " + little_Little.keywords.TYPE_BOOLEAN + " or " + little_Little.keywords.FALSE_VALUE),"Interpreter");
				return val;
			}
		}
		if(safetyNet >= 500000) {
			little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Too much iteration (is `" + little_tools_PrettyPrinter.stringifyInterpreter(params) + "` forever `" + little_Little.keywords.TRUE_VALUE + "`?)"),"Interpreter");
		}
		return val;
	});
	little_Little.plugin.registerCondition("if","Executes the following block of code if the given condition is true.",function(params,body) {
		var val = little_interpreter_InterpTokens.NullValue;
		var cond = little_tools_Conversion.toHaxeValue(little_interpreter_Interpreter.calculate(params));
		if(typeof(cond) == "boolean" && cond) {
			val = little_interpreter_Interpreter.run(body);
		} else if(typeof(cond) != "boolean") {
			little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("If condition must be a " + little_Little.keywords.TYPE_BOOLEAN),"Interpreter");
		}
		return val;
	});
	little_Little.plugin.registerCondition("for","A loop that executes code while changing a variable, until it meets a condition",function(params,body) {
		var val = little_interpreter_InterpTokens.NullValue;
		var fp = [];
		var _g = 0;
		while(_g < params.length) {
			var p = params[_g];
			++_g;
			if(p._hx_index == 7) {
				var _g1 = p.name;
				var _g2 = p.params;
				var _hx_tmp;
				var _hx_tmp1;
				var _hx_tmp2;
				if(Type.enumParameters(_g1)[0] == little_Little.keywords.FOR_LOOP_FROM == true) {
					var params1 = _g2;
					fp.push(little_interpreter_InterpTokens.Identifier(little_Little.keywords.FOR_LOOP_FROM));
					fp.push(little_interpreter_InterpTokens.Expression(Type.enumParameters(params1)[0],null));
				} else {
					_hx_tmp2 = Type.enumParameters(_g1)[0] == little_Little.keywords.FOR_LOOP_TO;
					if(_hx_tmp2 == true) {
						var params2 = _g2;
						fp.push(little_interpreter_InterpTokens.Identifier(little_Little.keywords.FOR_LOOP_TO));
						fp.push(little_interpreter_InterpTokens.Expression(Type.enumParameters(params2)[0],null));
					} else {
						_hx_tmp1 = Type.enumParameters(_g1)[0] == little_Little.keywords.FOR_LOOP_JUMP;
						if(_hx_tmp1 == true) {
							var params3 = _g2;
							fp.push(little_interpreter_InterpTokens.Identifier(little_Little.keywords.FOR_LOOP_JUMP));
							fp.push(little_interpreter_InterpTokens.Expression(Type.enumParameters(params3)[0],null));
						} else {
							var _this = [little_tools_InterpTokensSimple.BLOCK].slice();
							var result = new Array(_this.length);
							var _g3 = 0;
							var _g4 = _this.length;
							while(_g3 < _g4) {
								var i = _g3++;
								var x = _this[i];
								result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
							}
							_hx_tmp = result.indexOf($hxEnums[_g1.__enum__].__constructs__[_g1._hx_index]._hx_name.toLowerCase()) != -1 && [little_Little.keywords.FOR_LOOP_FROM,little_Little.keywords.FOR_LOOP_TO,little_Little.keywords.FOR_LOOP_JUMP].indexOf(Type.enumParameters(little_interpreter_Interpreter.evaluate(_g1))[0]) != -1;
							if(_hx_tmp == true) {
								var params4 = _g2;
								fp.push(little_interpreter_InterpTokens.Identifier(Type.enumParameters(little_interpreter_Interpreter.evaluate(Type.enumParameters(p)[0]))[0]));
								fp.push(little_interpreter_InterpTokens.Expression(Type.enumParameters(params4)[0],null));
							} else {
								fp.push(p);
							}
						}
					}
				}
			} else {
				fp.push(p);
			}
		}
		params = fp;
		var token = params[0];
		var _this = [little_tools_InterpTokensSimple.VARIABLE_DECLARATION].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) == -1) {
			little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("`for` loop must start with a variable to count on (expected definition/block, found: `" + little_tools_PrettyPrinter.stringifyInterpreter(null,params[0]) + "`)"));
			return val;
		}
		var typeName = little_tools_Extensions.asJoinedStringPath(Type.enumParameters(params[0])[1]);
		if([little_Little.keywords.TYPE_INT,little_Little.keywords.TYPE_FLOAT,little_Little.keywords.TYPE_DYNAMIC,little_Little.keywords.TYPE_UNKNOWN].indexOf(typeName) == -1) {
			little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("`for` loop's variable must be of type " + little_Little.keywords.TYPE_INT + ", " + little_Little.keywords.TYPE_FLOAT + " or " + little_Little.keywords.TYPE_DYNAMIC + " (given: " + typeName + ")"));
		}
		var from = null;
		var to = null;
		var jump = 1;
		var currentExpression = [];
		var currentlySet = -1;
		var _g = 1;
		var _g1 = params.length;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = params[i];
			if(_g2._hx_index == 24) {
				var _g3 = _g2.word;
				var _hx_tmp;
				var _hx_tmp1;
				if(_g3 == little_Little.keywords.FOR_LOOP_FROM == true) {
					if(currentExpression.length > 0) {
						switch(currentlySet) {
						case -1:
							little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Invalid `for` loop syntax: expected a `" + little_Little.keywords.FOR_LOOP_TO + "`, `" + little_Little.keywords.FOR_LOOP_FROM + "` or `" + little_Little.keywords.FOR_LOOP_JUMP + "` after the variable"));
							break;
						case 0:
							little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot repeat `" + little_Little.keywords.FOR_LOOP_FROM + "` tag twice in `for` loop."));
							break;
						case 1:
							to = little_tools_Conversion.toHaxeValue(little_interpreter_Interpreter.calculate(currentExpression));
							break;
						case 2:
							jump = little_tools_Conversion.toHaxeValue(little_interpreter_Interpreter.calculate(currentExpression));
							break;
						}
					}
					currentExpression = [];
					currentlySet = 0;
				} else {
					_hx_tmp1 = _g3 == little_Little.keywords.FOR_LOOP_TO;
					if(_hx_tmp1 == true) {
						if(currentExpression.length > 0) {
							switch(currentlySet) {
							case -1:
								little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Invalid `for` loop syntax: expected a `" + little_Little.keywords.FOR_LOOP_TO + "`, `" + little_Little.keywords.FOR_LOOP_FROM + "` or `" + little_Little.keywords.FOR_LOOP_JUMP + "` after the variable"));
								break;
							case 0:
								from = little_tools_Conversion.toHaxeValue(little_interpreter_Interpreter.calculate(currentExpression));
								break;
							case 1:
								little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot repeat `" + little_Little.keywords.FOR_LOOP_TO + "` tag twice in `for` loop."));
								break;
							case 2:
								jump = little_tools_Conversion.toHaxeValue(little_interpreter_Interpreter.calculate(currentExpression));
								break;
							}
						}
						currentExpression = [];
						currentlySet = 1;
					} else {
						_hx_tmp = _g3 == little_Little.keywords.FOR_LOOP_JUMP;
						if(_hx_tmp == true) {
							if(currentExpression.length > 0) {
								switch(currentlySet) {
								case -1:
									little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Invalid `for` loop syntax: expected a `" + little_Little.keywords.FOR_LOOP_TO + "`, `" + little_Little.keywords.FOR_LOOP_FROM + "` or `" + little_Little.keywords.FOR_LOOP_JUMP + "` after the variable"));
									break;
								case 0:
									from = little_tools_Conversion.toHaxeValue(little_interpreter_Interpreter.calculate(currentExpression));
									break;
								case 1:
									to = little_tools_Conversion.toHaxeValue(little_interpreter_Interpreter.calculate(currentExpression));
									break;
								case 2:
									little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot repeat `" + little_Little.keywords.FOR_LOOP_JUMP + "` tag twice in `for` loop."));
									break;
								}
							}
							currentExpression = [];
							currentlySet = 2;
						} else {
							currentExpression.push(params[i]);
						}
					}
				}
			} else {
				currentExpression.push(params[i]);
			}
		}
		switch(currentlySet) {
		case -1:
			little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Invalid `for` loop syntax: expected a `" + little_Little.keywords.FOR_LOOP_TO + "`, `" + little_Little.keywords.FOR_LOOP_FROM + "` or `" + little_Little.keywords.FOR_LOOP_JUMP + "` after the variable"));
			break;
		case 0:
			little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("Cannot repeat `" + little_Little.keywords.FOR_LOOP_FROM + "` tag twice in `for` loop."));
			break;
		case 1:
			to = little_tools_Conversion.toHaxeValue(little_interpreter_Interpreter.calculate(currentExpression));
			break;
		case 2:
			jump = little_tools_Conversion.toHaxeValue(little_interpreter_Interpreter.calculate(currentExpression));
			break;
		}
		if(jump == null) {
			jump = 1;
		}
		if(from < to) {
			while(from < to) {
				val = little_interpreter_Interpreter.run([little_interpreter_InterpTokens.Write([params[0]],little_tools_Conversion.toLittleValue(from))].concat(body));
				from += jump;
			}
		} else {
			while(from > to) {
				val = little_interpreter_Interpreter.run([little_interpreter_InterpTokens.Write([params[0]],little_tools_Conversion.toLittleValue(from))].concat(body));
				from -= jump;
			}
		}
		return val;
	});
	little_Little.plugin.registerCondition("after",null,function(params,body) {
		var val = little_interpreter_InterpTokens.NullValue;
		var ident = "";
		var token = params[0];
		var _this = [little_tools_InterpTokensSimple.BLOCK].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1) {
			var output = little_interpreter_Interpreter.run(Type.enumParameters(params[0])[0]);
			little_interpreter_Interpreter.assert(output,[little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.PROPERTY_ACCESS],"`after` condition that starts with a code block must have it's code block return an identifier using the `" + little_Little.keywords.READ_FUNCTION_NAME + "` function (returned: " + little_tools_PrettyPrinter.stringifyInterpreter(null,output) + ")");
			ident = little_tools_Extensions.asJoinedStringPath(output);
			params[0] = output;
		} else {
			var token = params[0];
			var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.PROPERTY_ACCESS].slice();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1) {
				var token = params[0];
				var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
				var result = new Array(_this.length);
				var _g = 0;
				var _g1 = _this.length;
				while(_g < _g1) {
					var i = _g++;
					var x = _this[i];
					result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
				}
				ident = result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(token)[0] : Type.enumParameters(little_interpreter_Interpreter.run([token]))[0];
			} else {
				little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("`after` condition must start with a variable to watch (expected definition, found: `" + little_tools_PrettyPrinter.stringifyInterpreter(null,params[0]) + "`)"));
				return val;
			}
		}
		var listener = null;
		listener = function(setIdentifiers) {
			var cond = little_tools_Conversion.toHaxeValue(little_interpreter_Interpreter.calculate(params));
			if(setIdentifiers.indexOf(ident) != -1 && cond) {
				little_interpreter_Interpreter.run(body);
				HxOverrides.remove(little_Little.runtime.onWriteValue,listener);
			}
		};
		little_Little.runtime.onWriteValue.push(listener);
		return val;
	});
	little_Little.plugin.registerCondition("whenever",null,function(params,body) {
		var val = little_interpreter_InterpTokens.NullValue;
		var ident = "";
		var token = params[0];
		var _this = [little_tools_InterpTokensSimple.BLOCK].slice();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
		}
		if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1) {
			var output = little_interpreter_Interpreter.evaluate(params[0]);
			little_interpreter_Interpreter.assert(output,[little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.PROPERTY_ACCESS],"`whenever` condition that starts with a code block must have it's code block return a `" + little_Little.keywords.TYPE_STRING + "` (returned: " + little_tools_PrettyPrinter.stringifyInterpreter(null,output) + ")");
			ident = little_tools_Conversion.toHaxeValue(output);
		} else {
			var token = params[0];
			var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.PROPERTY_ACCESS].slice();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				var x = _this[i];
				result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
			}
			if(result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1) {
				var token = params[0];
				var _this = [little_tools_InterpTokensSimple.IDENTIFIER,little_tools_InterpTokensSimple.CHARACTERS].slice();
				var result = new Array(_this.length);
				var _g = 0;
				var _g1 = _this.length;
				while(_g < _g1) {
					var i = _g++;
					var x = _this[i];
					result[i] = little_tools_TextTools.remove($hxEnums[x.__enum__].__constructs__[x._hx_index]._hx_name,"_").toLowerCase();
				}
				ident = result.indexOf($hxEnums[token.__enum__].__constructs__[token._hx_index]._hx_name.toLowerCase()) != -1 ? Type.enumParameters(token)[0] : Type.enumParameters(little_interpreter_Interpreter.run([token]))[0];
			} else {
				little_Little.runtime.throwError(little_interpreter_InterpTokens.ErrorMessage("`whenever` condition must start with a variable to watch (expected definition, found: `" + little_tools_PrettyPrinter.stringifyInterpreter(null,params[0]) + "`)"));
				return val;
			}
		}
		var listener = function(setIdentifiers) {
			var cond = little_tools_Conversion.toHaxeValue(little_interpreter_Interpreter.calculate(params));
			if(setIdentifiers.indexOf(ident) != -1 && cond) {
				little_interpreter_Interpreter.run(body);
			}
		};
		little_Little.runtime.onWriteValue.push(listener);
		return val;
	});
};
var little_tools_PrettyOutput = function() { };
$hxClasses["little.tools.PrettyOutput"] = little_tools_PrettyOutput;
little_tools_PrettyOutput.__name__ = "little.tools.PrettyOutput";
little_tools_PrettyOutput.generateAstHtml = function(code) {
	var htmlFile = "<table><tr><th>Stage</th><th>AST</th></tr>";
	var lexical = little_parser_Parser.convert(little_lexer_Lexer.lex(code));
	var map = new OrderedStringMapImpl();
	var this_h = Object.create(null);
	this_h["Merge Blocks"] = little_parser_Parser.mergeBlocks;
	this_h["Merge Expressions"] = little_parser_Parser.mergeExpressions;
	this_h["Merge Property Operations"] = little_parser_Parser.mergePropertyOperations;
	this_h["Merge Type Declarations"] = little_parser_Parser.mergeTypeDecls;
	this_h["Merge Complex Structures"] = little_parser_Parser.mergeComplexStructures;
	this_h["Merge Calls"] = little_parser_Parser.mergeCalls;
	this_h["Merge Writes"] = little_parser_Parser.mergeWrites;
	this_h["Marge Values With Type Decl"] = little_parser_Parser.mergeValuesWithTypeDeclarations;
	this_h["Merge Non-Block Bodies"] = little_parser_Parser.mergeNonBlockBodies;
	this_h["Merge Elses"] = little_parser_Parser.mergeElses;
	var h = this_h;
	var _g_h = h;
	var _g_keys = Object.keys(h);
	var _g_length = _g_keys.length;
	var _g_current = 0;
	while(_g_current < _g_length) {
		var key = _g_keys[_g_current++];
		var _g_key = key;
		var _g_value = _g_h[key];
		var k = _g_key;
		var v = _g_value;
		map.set(k,v);
	}
	var _g = map.keyValueIterator();
	while(_g.hasNext()) {
		var _g1 = _g.next();
		var key = _g1.key;
		var func = _g1.value;
		htmlFile += "<tr><th>" + key + "</th>";
		var pretty = little_tools_PrettyPrinter.printParserAst(func(lexical));
		pretty = StringTools.replace(StringTools.replace(pretty,"\n","<br>"),"\t","&nbsp;&nbsp;&nbsp;&nbsp;");
		htmlFile += "<td>" + pretty + "</td></tr>";
	}
	htmlFile += "</table>";
	return htmlFile;
};
var little_tools_PrettyPrinter = function() { };
$hxClasses["little.tools.PrettyPrinter"] = little_tools_PrettyPrinter;
little_tools_PrettyPrinter.__name__ = "little.tools.PrettyPrinter";
little_tools_PrettyPrinter.printParserAst = function(ast,spacingBetweenNodes) {
	if(spacingBetweenNodes == null) {
		spacingBetweenNodes = 6;
	}
	if(ast == null) {
		return "null (look for errors in input)";
	}
	little_tools_PrettyPrinter.s = little_tools_TextTools.multiply(" ",spacingBetweenNodes);
	var unfilteredResult = little_tools_PrettyPrinter.getTree_PARSER(little_parser_ParserTokens.Expression(ast,null),[],0,true);
	var filtered = "";
	var _g = 0;
	var _g1 = unfilteredResult.split("\n");
	while(_g < _g1.length) {
		var line = _g1[_g];
		++_g;
		if(line == " Expression") {
			continue;
		}
		filtered += line.substring(spacingBetweenNodes - 1) + "\n";
	}
	return "\nAst\n" + filtered;
};
little_tools_PrettyPrinter.printInterpreterAst = function(ast,spacingBetweenNodes) {
	if(spacingBetweenNodes == null) {
		spacingBetweenNodes = 6;
	}
	if(ast == null) {
		return "null (look for errors in input)";
	}
	little_tools_PrettyPrinter.s = little_tools_TextTools.multiply(" ",spacingBetweenNodes);
	var unfilteredResult = little_tools_PrettyPrinter.getTree_INTERP(little_interpreter_InterpTokens.Expression(ast,null),[],0,true);
	var filtered = "";
	var _g = 0;
	var _g1 = unfilteredResult.split("\n");
	while(_g < _g1.length) {
		var line = _g1[_g];
		++_g;
		if(line == " Expression") {
			continue;
		}
		filtered += line.substring(spacingBetweenNodes - 1) + "\n";
	}
	return "\nAst\n" + filtered;
};
little_tools_PrettyPrinter.prefixFA = function(pArray) {
	var prefix = "";
	var _g = 0;
	var _g1 = little_tools_PrettyPrinter.l;
	while(_g < _g1) {
		var i = _g++;
		if(pArray[i] == 1) {
			prefix += "" + little_tools_PrettyPrinter.s.substring(1);
		} else {
			prefix += little_tools_PrettyPrinter.s;
		}
	}
	return prefix;
};
little_tools_PrettyPrinter.pushIndex = function(pArray,i) {
	var arr = pArray.slice();
	arr[i + 1] = 1;
	return arr;
};
little_tools_PrettyPrinter.getTree_PARSER = function(root,prefix,level,last) {
	little_tools_PrettyPrinter.l = level;
	var t = last ? "" : "";
	var c = "";
	var d = "";
	if(root == null) {
		return "";
	}
	switch(root._hx_index) {
	case 0:
		var line = root.line;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " SetLine(" + line + ")\n";
	case 1:
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " SplitLine\n";
	case 2:
		var name = root.name;
		var type = root.type;
		var doc = root.doc;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Variable Creation\n";
		if(doc != null) {
			title += little_tools_PrettyPrinter.getTree_PARSER(doc,prefix.slice(),level + 1,false);
		}
		title += little_tools_PrettyPrinter.getTree_PARSER(name,prefix.slice(),level + 1,type == null);
		if(type != null) {
			title += little_tools_PrettyPrinter.getTree_PARSER(type,prefix.slice(),level + 1,true);
		}
		return title;
	case 3:
		var name = root.name;
		var params = root.params;
		var type = root.type;
		var doc = root.doc;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Function Creation\n";
		if(doc != null) {
			title += little_tools_PrettyPrinter.getTree_PARSER(doc,prefix.slice(),level + 1,false);
		}
		title += little_tools_PrettyPrinter.getTree_PARSER(name,prefix.slice(),level + 1,false);
		title += little_tools_PrettyPrinter.getTree_PARSER(params,prefix.slice(),level + 1,type == null);
		if(type != null) {
			title += little_tools_PrettyPrinter.getTree_PARSER(type,prefix.slice(),level + 1,true);
		}
		return title;
	case 4:
		var name = root.name;
		var exp = root.exp;
		var body = root.body;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Condition\n";
		title += little_tools_PrettyPrinter.getTree_PARSER(name,prefix.slice(),level + 1,false);
		title += little_tools_PrettyPrinter.getTree_PARSER(exp,little_tools_PrettyPrinter.pushIndex(prefix,level),level + 1,false);
		title += little_tools_PrettyPrinter.getTree_PARSER(body,prefix.slice(),level + 1,true);
		return title;
	case 5:
		var name = root.name;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Read: " + Std.string(name) + "\n";
	case 6:
		var assignees = root.assignees;
		var value = root.value;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Variable Write\n" + little_tools_PrettyPrinter.getTree_PARSER(little_parser_ParserTokens.PartArray(assignees),little_tools_PrettyPrinter.pushIndex(prefix,level),level + 1,false) + little_tools_PrettyPrinter.getTree_PARSER(value,prefix.slice(),level + 1,true);
	case 7:
		var value = root.word;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + value + "\n";
	case 8:
		var value = root.value;
		var type = root.type;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Type Declaration\n" + little_tools_PrettyPrinter.getTree_PARSER(value,type == null ? prefix.slice() : little_tools_PrettyPrinter.pushIndex(prefix,level),level + 1,type == null) + little_tools_PrettyPrinter.getTree_PARSER(type,prefix.slice(),level + 1,true);
	case 9:
		var name = root.name;
		var params = root.params;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Function Call\n";
		title += little_tools_PrettyPrinter.getTree_PARSER(name,little_tools_PrettyPrinter.pushIndex(prefix,level),level + 1,false);
		title += little_tools_PrettyPrinter.getTree_PARSER(params,prefix.slice(),level + 1,true);
		return title;
	case 10:
		var value = root.value;
		var type = root.type;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Return\n" + little_tools_PrettyPrinter.getTree_PARSER(value,prefix.slice(),level + 1,type == null) + little_tools_PrettyPrinter.getTree_PARSER(type,prefix.slice(),level + 1,true);
	case 11:
		var parts = root.parts;
		var type = root.type;
		if(parts.length == 0) {
			return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " <empty expression>\n";
		}
		var strParts = ["" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Expression\n" + little_tools_PrettyPrinter.getTree_PARSER(type,prefix.slice(),level + 1,false)];
		var _g = [];
		var _g1 = 0;
		var _g2 = parts.length - 1;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(little_tools_PrettyPrinter.getTree_PARSER(parts[i],little_tools_PrettyPrinter.pushIndex(prefix,level),level + 1,false));
		}
		var strParts1 = strParts.concat(_g);
		strParts1.push(little_tools_PrettyPrinter.getTree_PARSER(parts[parts.length - 1],prefix.slice(),level + 1,true));
		return strParts1.join("");
	case 12:
		var body = root.body;
		var type = root.type;
		if(body.length == 0) {
			return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " <empty block>\n";
		}
		var strParts = ["" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Block\n" + little_tools_PrettyPrinter.getTree_PARSER(type,prefix.slice(),level + 1,false)];
		var _g = [];
		var _g1 = 0;
		var _g2 = body.length - 1;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(little_tools_PrettyPrinter.getTree_PARSER(body[i],little_tools_PrettyPrinter.pushIndex(prefix,level),level + 1,false));
		}
		var strParts1 = strParts.concat(_g);
		strParts1.push(little_tools_PrettyPrinter.getTree_PARSER(body[body.length - 1],prefix.slice(),level + 1,true));
		return strParts1.join("");
	case 13:
		var body = root.parts;
		if(body.length == 0) {
			return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " <empty array>\n";
		}
		var strParts = ["" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Part Array\n"];
		var _g = [];
		var _g1 = 0;
		var _g2 = body.length - 1;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(little_tools_PrettyPrinter.getTree_PARSER(body[i],little_tools_PrettyPrinter.pushIndex(prefix,level),level + 1,false));
		}
		var strParts1 = strParts.concat(_g);
		strParts1.push(little_tools_PrettyPrinter.getTree_PARSER(body[body.length - 1],prefix.slice(),level + 1,true));
		return strParts1.join("");
	case 14:
		var name = root.name;
		var property = root.property;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Property Access\n" + little_tools_PrettyPrinter.getTree_PARSER(name,little_tools_PrettyPrinter.pushIndex(prefix,level),level + 1,false) + little_tools_PrettyPrinter.getTree_PARSER(property,prefix.slice(),level + 1,true);
	case 15:
		var value = root.sign;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + value + "\n";
	case 16:
		var num = root.num;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + num + "\n";
	case 17:
		var num = root.num;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + num + "\n";
	case 18:
		var string = root.string;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " \"" + string + "\"\n";
	case 19:
		var doc = root.doc;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Documentation: " + little_tools_TextTools.replace(doc,"\n","\n" + little_tools_PrettyPrinter.prefixFA(prefix) + "                  ") + "\n";
	case 20:
		var name = root.msg;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Error: " + name + "\n";
	case 21:
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + little_Little.keywords.NULL_VALUE + "\n";
	case 22:
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + little_Little.keywords.TRUE_VALUE + "\n";
	case 23:
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + little_Little.keywords.FALSE_VALUE + "\n";
	case 24:
		var name = root.name;
		var parts = root.params;
		if(parts.length == 0) {
			return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + name + "\n";
		}
		var strParts = ["" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + name + "\n"];
		var _g = [];
		var _g1 = 0;
		var _g2 = parts.length - 1;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(little_tools_PrettyPrinter.getTree_PARSER(parts[i],little_tools_PrettyPrinter.pushIndex(prefix,level),level + 1,false));
		}
		var strParts1 = strParts.concat(_g);
		strParts1.push(little_tools_PrettyPrinter.getTree_PARSER(parts[parts.length - 1],prefix.slice(),level + 1,true));
		return strParts1.join("");
	}
};
little_tools_PrettyPrinter.getTree_INTERP = function(root,prefix,level,last) {
	little_tools_PrettyPrinter.l = level;
	var t = last ? "" : "";
	var c = "";
	var d = "";
	if(root == null) {
		return "";
	}
	switch(root._hx_index) {
	case 0:
		var line = root.line;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " SetLine(" + line + ")\n";
	case 1:
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " SplitLine\n";
	case 2:
		var name = root.name;
		var type = root.type;
		var doc = root.doc;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Variable Declaration\n";
		if(doc != null) {
			title += little_tools_PrettyPrinter.getTree_INTERP(doc,prefix.slice(),level + 1,false);
		}
		title += little_tools_PrettyPrinter.getTree_INTERP(name,prefix.slice(),level + 1,type == null);
		if(type != null) {
			title += little_tools_PrettyPrinter.getTree_INTERP(type,prefix.slice(),level + 1,true);
		}
		return title;
	case 3:
		var name = root.name;
		var params = root.params;
		var type = root.type;
		var doc = root.doc;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Function Declaration\n";
		if(doc != null) {
			title += little_tools_PrettyPrinter.getTree_INTERP(doc,prefix.slice(),level + 1,false);
		}
		title += little_tools_PrettyPrinter.getTree_INTERP(name,prefix.slice(),level + 1,false);
		title += little_tools_PrettyPrinter.getTree_INTERP(params,prefix.slice(),level + 1,type == null);
		if(type != null) {
			title += little_tools_PrettyPrinter.getTree_INTERP(type,prefix.slice(),level + 1,true);
		}
		return title;
	case 4:
		var callers = root.callers;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Condition Code\n";
		title += little_tools_PrettyPrinter.getTree_INTERP(little_interpreter_InterpTokens.Characters(callers.toString()),prefix.slice(),level + 1,true);
		return title;
	case 5:
		var name = root.name;
		var exp = root.exp;
		var body = root.body;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Condition Call\n";
		title += little_tools_PrettyPrinter.getTree_INTERP(name,prefix.slice(),level + 1,false);
		title += little_tools_PrettyPrinter.getTree_INTERP(exp,little_tools_PrettyPrinter.pushIndex(prefix,level),level + 1,false);
		title += little_tools_PrettyPrinter.getTree_INTERP(body,prefix.slice(),level + 1,true);
		return title;
	case 6:
		var requiredParams = root.requiredParams;
		var body = root.body;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Function Code\n";
		title += little_tools_PrettyPrinter.getTree_INTERP(little_interpreter_InterpTokens.Identifier(requiredParams.toString()),prefix.slice(),level + 1,false);
		title += little_tools_PrettyPrinter.getTree_INTERP(body,prefix.slice(),level + 1,true);
		return title;
	case 7:
		var name = root.name;
		var params = root.params;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Function Call\n";
		title += little_tools_PrettyPrinter.getTree_INTERP(name,little_tools_PrettyPrinter.pushIndex(prefix,level),level + 1,false);
		title += little_tools_PrettyPrinter.getTree_INTERP(params,prefix.slice(),level + 1,true);
		return title;
	case 8:
		var value = root.value;
		var type = root.type;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Function Return\n";
		title += little_tools_PrettyPrinter.getTree_INTERP(value,prefix.slice(),level + 1,type == null);
		if(type != null) {
			title += little_tools_PrettyPrinter.getTree_INTERP(type,prefix.slice(),level + 1,true);
		}
		return title;
	case 9:
		var assignees = root.assignees;
		var value = root.value;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Write\n";
		title += little_tools_PrettyPrinter.getTree_INTERP(little_interpreter_InterpTokens.PartArray(assignees),little_tools_PrettyPrinter.pushIndex(prefix,level),level + 1,false);
		title += little_tools_PrettyPrinter.getTree_INTERP(value,prefix.slice(),level + 1,true);
		return title;
	case 10:
		var value = root.value;
		var type = root.type;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Type Cast\n";
		title += little_tools_PrettyPrinter.getTree_INTERP(value,prefix.slice(),level + 1,false);
		title += little_tools_PrettyPrinter.getTree_INTERP(type,prefix.slice(),level + 1,true);
		return title;
	case 11:
		var parts = root.parts;
		var type = root.type;
		if(parts.length == 0) {
			return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " <empty expression>\n";
		}
		var strParts = ["" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Expression\n" + little_tools_PrettyPrinter.getTree_INTERP(type,prefix.slice(),level + 1,false)];
		var _g = [];
		var _g1 = 0;
		var _g2 = parts.length - 1;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(little_tools_PrettyPrinter.getTree_INTERP(parts[i],little_tools_PrettyPrinter.pushIndex(prefix,level),level + 1,false));
		}
		var strParts1 = strParts.concat(_g);
		strParts1.push(little_tools_PrettyPrinter.getTree_INTERP(parts[parts.length - 1],prefix.slice(),level + 1,true));
		return strParts1.join("");
	case 12:
		var body = root.body;
		var type = root.type;
		if(body.length == 0) {
			return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " <empty block>\n";
		}
		var strParts = ["" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Block\n" + little_tools_PrettyPrinter.getTree_INTERP(type,prefix.slice(),level + 1,false)];
		var _g = [];
		var _g1 = 0;
		var _g2 = body.length - 1;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(little_tools_PrettyPrinter.getTree_INTERP(body[i],little_tools_PrettyPrinter.pushIndex(prefix,level),level + 1,false));
		}
		var strParts1 = strParts.concat(_g);
		strParts1.push(little_tools_PrettyPrinter.getTree_INTERP(body[body.length - 1],prefix.slice(),level + 1,true));
		return strParts1.join("");
	case 13:
		var parts = root.parts;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Part Array\n";
		var _g = 0;
		while(_g < parts.length) {
			var part = parts[_g];
			++_g;
			title += little_tools_PrettyPrinter.getTree_INTERP(part,prefix.slice(),level + 1,part == parts[parts.length - 1]);
		}
		return title;
	case 14:
		var name = root.name;
		var property = root.property;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Property Access\n";
		title += little_tools_PrettyPrinter.getTree_INTERP(name,prefix.slice(),level + 1,false);
		title += little_tools_PrettyPrinter.getTree_INTERP(property,prefix.slice(),level + 1,true);
		return title;
	case 15:
		var num = root.num;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + num + "\n";
	case 16:
		var num = root.num;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + num + "\n";
	case 17:
		var string = root.string;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " \"" + string + "\"\n";
	case 18:
		var doc = root.doc;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " \"\"\"" + doc + "\"\"\"\n";
	case 19:
		var pointer = root.pointer;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " ClassPointer: " + (pointer == null ? "null" : little_interpreter_memory_MemoryPointer.toString(pointer)) + "\n";
	case 20:
		var sign = root.sign;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + sign + "\n";
	case 21:
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + Std.string(little_parser_ParserTokens.NullValue) + "\n";
	case 22:
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + Std.string(little_parser_ParserTokens.TrueValue) + "\n";
	case 23:
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + Std.string(little_parser_ParserTokens.FalseValue) + "\n";
	case 24:
		var word = root.word;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + word + "\n";
	case 25:
		var _g = root.typeName;
		var props = root.props;
		var title = "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " Object\n";
		var i = 0;
		var h = props.h;
		var _g_h = h;
		var _g_keys = Object.keys(h);
		var _g_length = _g_keys.length;
		var _g_current = 0;
		while(_g_current < _g_length) {
			var key = _g_keys[_g_current++];
			var _g_key = key;
			var _g_value = _g_h[key];
			var key1 = _g_key;
			var value = _g_value;
			++i;
			var title1 = little_interpreter_InterpTokens.Identifier(key1);
			var title2 = prefix.slice();
			var title3 = level + 1;
			var _g = [];
			var h = props.h;
			var x_h = h;
			var x_keys = Object.keys(h);
			var x_length = x_keys.length;
			var x_current = 0;
			while(x_current < x_length) {
				var x = x_keys[x_current++];
				_g.push(x);
			}
			title += little_tools_PrettyPrinter.getTree_INTERP(title1,title2,title3,i == _g.length);
			var title4 = little_interpreter_InterpTokens.Characters(value.documentation);
			var _g1 = [];
			var h1 = props.h;
			var x_h1 = h1;
			var x_keys1 = Object.keys(h1);
			var x_length1 = x_keys1.length;
			var x_current1 = 0;
			while(x_current1 < x_length1) {
				var x1 = x_keys1[x_current1++];
				_g1.push(x1);
			}
			title += little_tools_PrettyPrinter.getTree_INTERP(title4,i == _g1.length ? prefix.slice() : little_tools_PrettyPrinter.pushIndex(prefix,level),level + 2,false);
			var value1 = value.value;
			var _g2 = [];
			var h2 = props.h;
			var x_h2 = h2;
			var x_keys2 = Object.keys(h2);
			var x_length2 = x_keys2.length;
			var x_current2 = 0;
			while(x_current2 < x_length2) {
				var x2 = x_keys2[x_current2++];
				_g2.push(x2);
			}
			title += little_tools_PrettyPrinter.getTree_INTERP(value1,i == _g2.length ? prefix.slice() : little_tools_PrettyPrinter.pushIndex(prefix,level),level + 2,true);
		}
		return title;
	case 26:
		var msg = root.msg;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " " + Std.string(root) + "\n";
	case 27:
		var func = root.func;
		return "" + little_tools_PrettyPrinter.prefixFA(prefix) + t + d + " <Haxe Extern>\n";
	}
};
little_tools_PrettyPrinter.stringifyParser = function(code,token) {
	if(token != null) {
		code = [token];
	}
	var s = "";
	var _g = 0;
	while(_g < code.length) {
		var token = code[_g];
		++_g;
		switch(token._hx_index) {
		case 0:
			var line = token.line;
			s += "\n" + little_tools_PrettyPrinter.indent;
			break;
		case 1:
			s += ", ";
			break;
		case 2:
			var _g1 = token.doc;
			var name = token.name;
			var type = token.type;
			s += "" + little_Little.keywords.VARIABLE_DECLARATION + " " + Std.string(name) + " " + (type != null ? "" + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_tools_PrettyPrinter.stringifyParser(null,type) : "");
			break;
		case 3:
			var _g2 = token.doc;
			var name1 = token.name;
			var params = token.params;
			var type1 = token.type;
			s += "" + little_Little.keywords.FUNCTION_DECLARATION + " " + little_tools_PrettyPrinter.stringifyParser(null,name1) + "(" + little_tools_PrettyPrinter.stringifyParser(null,params) + ") " + (type1 != null ? "" + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_tools_PrettyPrinter.stringifyParser(null,type1) : "");
			break;
		case 4:
			var name2 = token.name;
			var exp = token.exp;
			var body = token.body;
			little_tools_PrettyPrinter.indent += "\t";
			s += "" + little_tools_PrettyPrinter.stringifyParser(null,name2) + " (" + little_tools_PrettyPrinter.stringifyParser(null,exp) + ") \n" + little_tools_PrettyPrinter.stringifyParser(null,body);
			little_tools_PrettyPrinter.indent = little_tools_TextTools.replaceLast(little_tools_PrettyPrinter.indent,"\t","");
			break;
		case 5:
			var name3 = token.name;
			s += little_tools_PrettyPrinter.stringifyParser(null,name3);
			break;
		case 6:
			var assignees = token.assignees;
			var value = token.value;
			var _this = assignees.concat([value]);
			var result = new Array(_this.length);
			var _g3 = 0;
			var _g4 = _this.length;
			while(_g3 < _g4) {
				var i = _g3++;
				result[i] = little_tools_PrettyPrinter.stringifyParser(null,_this[i]);
			}
			s += Std.string([result.join(" = ")]);
			break;
		case 7:
			var word = token.word;
			s += word;
			break;
		case 8:
			var value1 = token.value;
			var type2 = token.type;
			s += "" + little_tools_PrettyPrinter.stringifyParser(null,value1) + " " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_tools_PrettyPrinter.stringifyParser(null,type2);
			break;
		case 9:
			var name4 = token.name;
			var params1 = token.params;
			s += "" + little_tools_PrettyPrinter.stringifyParser(null,name4) + "(" + little_tools_PrettyPrinter.stringifyParser(null,params1) + ")";
			break;
		case 10:
			var value2 = token.value;
			var type3 = token.type;
			s += "" + little_Little.keywords.FUNCTION_RETURN + " " + little_tools_PrettyPrinter.stringifyParser(null,value2);
			break;
		case 11:
			var parts = token.parts;
			var type4 = token.type;
			s += little_tools_PrettyPrinter.stringifyParser(parts);
			break;
		case 12:
			var body1 = token.body;
			var type5 = token.type;
			little_tools_PrettyPrinter.indent += "\t";
			s += "{" + little_tools_PrettyPrinter.stringifyParser(body1) + "} " + (type5 != null ? "" + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_tools_PrettyPrinter.stringifyParser(null,type5) : "");
			little_tools_PrettyPrinter.indent = little_tools_TextTools.replaceLast(little_tools_PrettyPrinter.indent,"\t","");
			break;
		case 13:
			var parts1 = token.parts;
			s += little_tools_PrettyPrinter.stringifyParser(parts1);
			break;
		case 14:
			var name5 = token.name;
			var property = token.property;
			s += "" + little_tools_PrettyPrinter.stringifyParser(null,name5) + little_Little.keywords.PROPERTY_ACCESS_SIGN + little_tools_PrettyPrinter.stringifyParser(null,property);
			break;
		case 15:
			var sign = token.sign;
			s += " " + sign + " ";
			break;
		case 16:
			var num = token.num;
			s += num;
			break;
		case 17:
			var num1 = token.num;
			s += num1;
			break;
		case 18:
			var string = token.string;
			s += "\"" + string + "\"";
			break;
		case 19:
			var doc = token.doc;
			s += "\"\"\"" + doc + "\"\"\"";
			break;
		case 20:
			var msg = token.msg;
			break;
		case 21:
			s += little_Little.keywords.NULL_VALUE;
			break;
		case 22:
			s += little_Little.keywords.TRUE_VALUE;
			break;
		case 23:
			s += little_Little.keywords.FALSE_VALUE;
			break;
		case 24:
			var _g5 = token.name;
			var _g6 = token.params;
			throw haxe_Exception.thrown("Custom tokens cannot be stringified, as they dont represent any output syntax (found " + Std.string(token) + ")");
		}
	}
	return s;
};
little_tools_PrettyPrinter.stringifyInterpreter = function(code,token) {
	if(token != null) {
		code = [token];
	}
	var s = "";
	var _g = 0;
	while(_g < code.length) {
		var token = code[_g];
		++_g;
		switch(token._hx_index) {
		case 0:
			var line = token.line;
			s += "\n" + little_tools_PrettyPrinter.indent;
			break;
		case 1:
			s += ", ";
			break;
		case 2:
			var name = token.name;
			var type = token.type;
			var doc = token.doc;
			s += "" + little_Little.keywords.VARIABLE_DECLARATION + " " + little_tools_PrettyPrinter.stringifyInterpreter(null,name) + " " + (type != null && little_tools_Extensions.asJoinedStringPath(type) != little_Little.keywords.TYPE_UNKNOWN ? "" + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_tools_PrettyPrinter.stringifyInterpreter(null,type) : "");
			break;
		case 3:
			var name1 = token.name;
			var params = token.params;
			var type1 = token.type;
			var doc1 = token.doc;
			s += "" + little_Little.keywords.FUNCTION_DECLARATION + " " + little_tools_PrettyPrinter.stringifyInterpreter(null,name1) + "(" + little_tools_PrettyPrinter.stringifyInterpreter(null,params) + ") " + (type1 != null && little_tools_Extensions.asJoinedStringPath(type1) != little_Little.keywords.TYPE_UNKNOWN ? "" + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_tools_PrettyPrinter.stringifyInterpreter(null,type1) : "");
			break;
		case 5:
			var name2 = token.name;
			var exp = token.exp;
			var body = token.body;
			s += "" + little_tools_PrettyPrinter.stringifyInterpreter(null,name2) + " (" + little_tools_PrettyPrinter.stringifyInterpreter(null,exp) + ") \n" + little_tools_PrettyPrinter.stringifyInterpreter(null,body);
			break;
		case 7:
			var name3 = token.name;
			var params1 = token.params;
			s += "" + little_tools_PrettyPrinter.stringifyInterpreter(null,name3) + "(" + little_tools_PrettyPrinter.stringifyInterpreter(null,params1) + ")";
			break;
		case 8:
			var value = token.value;
			var type2 = token.type;
			s += "" + little_Little.keywords.FUNCTION_RETURN + " " + little_tools_PrettyPrinter.stringifyInterpreter(null,value);
			break;
		case 9:
			var assignees = token.assignees;
			var value1 = token.value;
			var _this = assignees.concat([value1]);
			var result = new Array(_this.length);
			var _g1 = 0;
			var _g2 = _this.length;
			while(_g1 < _g2) {
				var i = _g1++;
				result[i] = little_tools_PrettyPrinter.stringifyInterpreter(null,_this[i]);
			}
			s += result.join(" = ");
			break;
		case 10:
			var value2 = token.value;
			var type3 = token.type;
			s += "" + little_tools_PrettyPrinter.stringifyInterpreter(null,value2) + " " + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_tools_PrettyPrinter.stringifyInterpreter(null,type3);
			break;
		case 11:
			var parts = token.parts;
			var type4 = token.type;
			s += little_tools_PrettyPrinter.stringifyInterpreter(parts);
			break;
		case 12:
			var body1 = token.body;
			var type5 = token.type;
			little_tools_PrettyPrinter.indent += "\t";
			s += "{" + little_tools_PrettyPrinter.stringifyInterpreter(body1) + "} " + (type5 != null && little_tools_Extensions.asJoinedStringPath(type5) != little_Little.keywords.TYPE_UNKNOWN ? "" + little_Little.keywords.TYPE_DECL_OR_CAST + " " + little_tools_PrettyPrinter.stringifyInterpreter(null,type5) : "");
			little_tools_PrettyPrinter.indent = little_tools_TextTools.replaceLast(little_tools_PrettyPrinter.indent,"\t","");
			break;
		case 13:
			var parts1 = token.parts;
			s += little_tools_PrettyPrinter.stringifyInterpreter(parts1);
			break;
		case 14:
			var name4 = token.name;
			var property = token.property;
			s += "" + little_tools_PrettyPrinter.stringifyInterpreter(null,name4) + little_Little.keywords.PROPERTY_ACCESS_SIGN + little_tools_PrettyPrinter.stringifyInterpreter(null,property);
			break;
		case 15:
			var num = token.num;
			s += num;
			break;
		case 16:
			var num1 = token.num;
			s += num1;
			break;
		case 17:
			var string = token.string;
			s += "\"" + string + "\"";
			break;
		case 18:
			var doc2 = token.doc;
			s += "\"\"\"" + doc2 + "\"\"\"";
			break;
		case 19:
			var pointer = token.pointer;
			var s1;
			if(little_Little.memory != null) {
				s1 = little_Little.memory.getTypeName(pointer);
			} else {
				throw haxe_Exception.thrown("No memory for ClassPointer token " + (pointer == null ? "null" : little_interpreter_memory_MemoryPointer.toString(pointer)));
			}
			s += s1;
			break;
		case 20:
			var sign = token.sign;
			s += sign;
			break;
		case 21:
			s += little_Little.keywords.NULL_VALUE;
			break;
		case 22:
			s += little_Little.keywords.TRUE_VALUE;
			break;
		case 23:
			s += little_Little.keywords.FALSE_VALUE;
			break;
		case 24:
			var word = token.word;
			s += word;
			break;
		case 26:
			var msg = token.msg;
			break;
		default:
			throw haxe_Exception.thrown("Stringifying token " + Std.string(token) + " does not make sense, as it is represented by other tokens on parse time, and thus cannot appear in a non-manipulated InterpTokens AST");
		}
		s += " ";
	}
	return little_tools_TextTools.replaceLast(s," ","");
};
little_tools_PrettyPrinter.prettyPrintOperatorPriority = function(priority) {
	var _g = [];
	var x = priority.keys();
	while(x.hasNext()) {
		var x1 = x.next();
		_g.push(x1);
	}
	var sortedKeys = _g;
	haxe_ds_ArraySort.sort(sortedKeys,function(x,y) {
		return x - y;
	});
	var string = "";
	var _g = 0;
	while(_g < sortedKeys.length) {
		var key = sortedKeys[_g];
		++_g;
		string += "" + key + ": (";
		var _g1 = 0;
		var _g2 = priority.h[key];
		while(_g1 < _g2.length) {
			var obj = _g2[_g1];
			++_g1;
			if(obj.side == little_interpreter_memory_OperatorType.LHS_RHS) {
				string += "_" + obj.sign + "_";
			} else if(obj.side == little_interpreter_memory_OperatorType.LHS_ONLY) {
				string += "_" + obj.sign;
			} else if(obj.side == little_interpreter_memory_OperatorType.RHS_ONLY) {
				string += "" + obj.sign + "_";
			}
			string += ", ";
		}
		string = little_tools_TextTools.replaceLast(string,", ",")") + "\n";
	}
	return string;
};
var little_tools_TextDirection = $hxEnums["little.tools.TextDirection"] = { __ename__:"little.tools.TextDirection",__constructs__:null
	,RTL: {_hx_name:"RTL",_hx_index:0,__enum__:"little.tools.TextDirection",toString:$estr}
	,LTR: {_hx_name:"LTR",_hx_index:1,__enum__:"little.tools.TextDirection",toString:$estr}
	,UNDETERMINED: {_hx_name:"UNDETERMINED",_hx_index:2,__enum__:"little.tools.TextDirection",toString:$estr}
};
little_tools_TextDirection.__constructs__ = [little_tools_TextDirection.RTL,little_tools_TextDirection.LTR,little_tools_TextDirection.UNDETERMINED];
var vision_algorithms_BilinearInterpolation = function() { };
$hxClasses["vision.algorithms.BilinearInterpolation"] = vision_algorithms_BilinearInterpolation;
vision_algorithms_BilinearInterpolation.__name__ = "vision.algorithms.BilinearInterpolation";
vision_algorithms_BilinearInterpolation.interpolate = function(image,width,height) {
	var length = width * height * 4 + vision_ds_Image.OFFSET;
	var this1 = new haxe_io_Bytes(new ArrayBuffer(length));
	this1.fill(0,length,0);
	var this2 = this1;
	this2.setUInt16(0,width);
	this2.setUInt16(vision_ds_Image.WIDTH_BYTES,0);
	this2.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP,0);
	this2.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES,0);
	this2.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP,0);
	this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] = 0;
	var i = vision_ds_Image.OFFSET;
	while(i < this2.length) {
		this2.b[i] = 0;
		this2.b[i + 1] = 0;
		this2.b[i + 2] = 0;
		this2.b[i + 3] = 0;
		i += 4;
	}
	var resized = this2;
	var xMultiplier = image.getUInt16(0) / width - 1 / width;
	var yMultiplier = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) / height - 1 / height;
	var _g = 0;
	var _g1 = resized.getUInt16(0);
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = Math.ceil((resized.length - vision_ds_Image.OFFSET) / (resized.getUInt16(0) * 4));
		while(_g2 < _g3) {
			var y = _g2++;
			var position = (y * resized.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			var value = resized.b[position] << 24 | resized.b[position + 1] << 16 | resized.b[position + 2] << 8 | resized.b[position + 3];
			if(value == null) {
				value = 0;
			}
			var c = value;
			var x1 = x * xMultiplier;
			var y1 = y * yMultiplier;
			var tmp;
			var x2 = Math.ceil(x1);
			var y2 = Math.ceil(y1);
			if(x2 >= 0 && y2 >= 0 && x2 < image.getUInt16(0) && y2 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4))) {
				var x3 = Math.floor(x1);
				var y3 = Math.floor(y1);
				tmp = !(x3 >= 0 && y3 >= 0 && x3 < image.getUInt16(0) && y3 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)));
			} else {
				tmp = true;
			}
			if(tmp) {
				x1 = vision_tools_MathTools.boundFloat(x1,0,image.getUInt16(0) - 1);
				y1 = vision_tools_MathTools.boundFloat(y1,0,Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) - 1);
			}
			var yFraction = y1 - (y1 | 0);
			var xFraction = x1 - (x1 | 0);
			var x4 = 1 - yFraction;
			var x5 = x1 | 0;
			var y4 = y1 | 0;
			if(!(x5 >= 0 && y4 >= 0 && x5 < image.getUInt16(0) && y4 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x = x5;
				var this_y = y4;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x,this_y)));
			}
			var position1 = (y4 * image.getUInt16(0) + x5) * 4;
			position1 += vision_ds_Image.OFFSET;
			var value1 = image.b[position1] << 24 | image.b[position1 + 1] << 16 | image.b[position1 + 2] << 8 | image.b[position1 + 3];
			if(value1 == null) {
				value1 = 0;
			}
			var x6 = (1 - xFraction) * (value1 >> 16 & 255);
			var ma = image.getUInt16(0) - 1;
			var values = [(x1 | 0) + 1,0];
			var max = values[0];
			var _g4 = 0;
			var _g5 = values.length;
			while(_g4 < _g5) {
				var i = _g4++;
				if(values[i] > max) {
					max = values[i];
				}
			}
			var values1 = [max,ma];
			var min = values1[0];
			var _g6 = 0;
			var _g7 = values1.length;
			while(_g6 < _g7) {
				var i1 = _g6++;
				if(values1[i1] < min) {
					min = values1[i1];
				}
			}
			var x7 = min;
			var ma1 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) - 1;
			var values2 = [y1 | 0,0];
			var max1 = values2[0];
			var _g8 = 0;
			var _g9 = values2.length;
			while(_g8 < _g9) {
				var i2 = _g8++;
				if(values2[i2] > max1) {
					max1 = values2[i2];
				}
			}
			var values3 = [max1,ma1];
			var min1 = values3[0];
			var _g10 = 0;
			var _g11 = values3.length;
			while(_g10 < _g11) {
				var i3 = _g10++;
				if(values3[i3] < min1) {
					min1 = values3[i3];
				}
			}
			var y5 = min1;
			if(!(x7 >= 0 && y5 >= 0 && x7 < image.getUInt16(0) && y5 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x1 = x7;
				var this_y1 = y5;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x1,this_y1)));
			}
			var position2 = (y5 * image.getUInt16(0) + x7) * 4;
			position2 += vision_ds_Image.OFFSET;
			var value2 = image.b[position2] << 24 | image.b[position2 + 1] << 16 | image.b[position2 + 2] << 8 | image.b[position2 + 3];
			if(value2 == null) {
				value2 = 0;
			}
			var x8 = x4 * (x6 + xFraction * (value2 >> 16 & 255));
			var x9 = 1 - xFraction;
			var ma2 = image.getUInt16(0) - 1;
			var values4 = [x1 | 0,0];
			var max2 = values4[0];
			var _g12 = 0;
			var _g13 = values4.length;
			while(_g12 < _g13) {
				var i4 = _g12++;
				if(values4[i4] > max2) {
					max2 = values4[i4];
				}
			}
			var values5 = [max2,ma2];
			var min2 = values5[0];
			var _g14 = 0;
			var _g15 = values5.length;
			while(_g14 < _g15) {
				var i5 = _g14++;
				if(values5[i5] < min2) {
					min2 = values5[i5];
				}
			}
			var x10 = min2;
			var ma3 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) - 1;
			var values6 = [(y1 | 0) + 1,0];
			var max3 = values6[0];
			var _g16 = 0;
			var _g17 = values6.length;
			while(_g16 < _g17) {
				var i6 = _g16++;
				if(values6[i6] > max3) {
					max3 = values6[i6];
				}
			}
			var values7 = [max3,ma3];
			var min3 = values7[0];
			var _g18 = 0;
			var _g19 = values7.length;
			while(_g18 < _g19) {
				var i7 = _g18++;
				if(values7[i7] < min3) {
					min3 = values7[i7];
				}
			}
			var y6 = min3;
			if(!(x10 >= 0 && y6 >= 0 && x10 < image.getUInt16(0) && y6 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x2 = x10;
				var this_y2 = y6;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x2,this_y2)));
			}
			var position3 = (y6 * image.getUInt16(0) + x10) * 4;
			position3 += vision_ds_Image.OFFSET;
			var value3 = image.b[position3] << 24 | image.b[position3 + 1] << 16 | image.b[position3 + 2] << 8 | image.b[position3 + 3];
			if(value3 == null) {
				value3 = 0;
			}
			var x11 = x9 * (value3 >> 16 & 255);
			var ma4 = image.getUInt16(0) - 1;
			var values8 = [(x1 | 0) + 1,0];
			var max4 = values8[0];
			var _g20 = 0;
			var _g21 = values8.length;
			while(_g20 < _g21) {
				var i8 = _g20++;
				if(values8[i8] > max4) {
					max4 = values8[i8];
				}
			}
			var values9 = [max4,ma4];
			var min4 = values9[0];
			var _g22 = 0;
			var _g23 = values9.length;
			while(_g22 < _g23) {
				var i9 = _g22++;
				if(values9[i9] < min4) {
					min4 = values9[i9];
				}
			}
			var x12 = min4;
			var ma5 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) - 1;
			var values10 = [(y1 | 0) + 1,0];
			var max5 = values10[0];
			var _g24 = 0;
			var _g25 = values10.length;
			while(_g24 < _g25) {
				var i10 = _g24++;
				if(values10[i10] > max5) {
					max5 = values10[i10];
				}
			}
			var values11 = [max5,ma5];
			var min5 = values11[0];
			var _g26 = 0;
			var _g27 = values11.length;
			while(_g26 < _g27) {
				var i11 = _g26++;
				if(values11[i11] < min5) {
					min5 = values11[i11];
				}
			}
			var y7 = min5;
			if(!(x12 >= 0 && y7 >= 0 && x12 < image.getUInt16(0) && y7 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x3 = x12;
				var this_y3 = y7;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x3,this_y3)));
			}
			var position4 = (y7 * image.getUInt16(0) + x12) * 4;
			position4 += vision_ds_Image.OFFSET;
			var value4 = image.b[position4] << 24 | image.b[position4 + 1] << 16 | image.b[position4 + 2] << 8 | image.b[position4 + 3];
			if(value4 == null) {
				value4 = 0;
			}
			var red = x8 + yFraction * (x11 + xFraction * (value4 >> 16 & 255)) | 0;
			var x13 = 1 - yFraction;
			var x14 = x1 | 0;
			var y8 = y1 | 0;
			if(!(x14 >= 0 && y8 >= 0 && x14 < image.getUInt16(0) && y8 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x4 = x14;
				var this_y4 = y8;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x4,this_y4)));
			}
			var position5 = (y8 * image.getUInt16(0) + x14) * 4;
			position5 += vision_ds_Image.OFFSET;
			var value5 = image.b[position5] << 24 | image.b[position5 + 1] << 16 | image.b[position5 + 2] << 8 | image.b[position5 + 3];
			if(value5 == null) {
				value5 = 0;
			}
			var x15 = (1 - xFraction) * (value5 >> 8 & 255);
			var ma6 = image.getUInt16(0) - 1;
			var values12 = [(x1 | 0) + 1,0];
			var max6 = values12[0];
			var _g28 = 0;
			var _g29 = values12.length;
			while(_g28 < _g29) {
				var i12 = _g28++;
				if(values12[i12] > max6) {
					max6 = values12[i12];
				}
			}
			var values13 = [max6,ma6];
			var min6 = values13[0];
			var _g30 = 0;
			var _g31 = values13.length;
			while(_g30 < _g31) {
				var i13 = _g30++;
				if(values13[i13] < min6) {
					min6 = values13[i13];
				}
			}
			var x16 = min6;
			var ma7 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) - 1;
			var values14 = [y1 | 0,0];
			var max7 = values14[0];
			var _g32 = 0;
			var _g33 = values14.length;
			while(_g32 < _g33) {
				var i14 = _g32++;
				if(values14[i14] > max7) {
					max7 = values14[i14];
				}
			}
			var values15 = [max7,ma7];
			var min7 = values15[0];
			var _g34 = 0;
			var _g35 = values15.length;
			while(_g34 < _g35) {
				var i15 = _g34++;
				if(values15[i15] < min7) {
					min7 = values15[i15];
				}
			}
			var y9 = min7;
			if(!(x16 >= 0 && y9 >= 0 && x16 < image.getUInt16(0) && y9 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x5 = x16;
				var this_y5 = y9;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x5,this_y5)));
			}
			var position6 = (y9 * image.getUInt16(0) + x16) * 4;
			position6 += vision_ds_Image.OFFSET;
			var value6 = image.b[position6] << 24 | image.b[position6 + 1] << 16 | image.b[position6 + 2] << 8 | image.b[position6 + 3];
			if(value6 == null) {
				value6 = 0;
			}
			var x17 = x13 * (x15 + xFraction * (value6 >> 8 & 255));
			var x18 = 1 - xFraction;
			var ma8 = image.getUInt16(0) - 1;
			var values16 = [x1 | 0,0];
			var max8 = values16[0];
			var _g36 = 0;
			var _g37 = values16.length;
			while(_g36 < _g37) {
				var i16 = _g36++;
				if(values16[i16] > max8) {
					max8 = values16[i16];
				}
			}
			var values17 = [max8,ma8];
			var min8 = values17[0];
			var _g38 = 0;
			var _g39 = values17.length;
			while(_g38 < _g39) {
				var i17 = _g38++;
				if(values17[i17] < min8) {
					min8 = values17[i17];
				}
			}
			var x19 = min8;
			var ma9 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) - 1;
			var values18 = [(y1 | 0) + 1,0];
			var max9 = values18[0];
			var _g40 = 0;
			var _g41 = values18.length;
			while(_g40 < _g41) {
				var i18 = _g40++;
				if(values18[i18] > max9) {
					max9 = values18[i18];
				}
			}
			var values19 = [max9,ma9];
			var min9 = values19[0];
			var _g42 = 0;
			var _g43 = values19.length;
			while(_g42 < _g43) {
				var i19 = _g42++;
				if(values19[i19] < min9) {
					min9 = values19[i19];
				}
			}
			var y10 = min9;
			if(!(x19 >= 0 && y10 >= 0 && x19 < image.getUInt16(0) && y10 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x6 = x19;
				var this_y6 = y10;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x6,this_y6)));
			}
			var position7 = (y10 * image.getUInt16(0) + x19) * 4;
			position7 += vision_ds_Image.OFFSET;
			var value7 = image.b[position7] << 24 | image.b[position7 + 1] << 16 | image.b[position7 + 2] << 8 | image.b[position7 + 3];
			if(value7 == null) {
				value7 = 0;
			}
			var x20 = x18 * (value7 >> 8 & 255);
			var ma10 = image.getUInt16(0) - 1;
			var values20 = [(x1 | 0) + 1,0];
			var max10 = values20[0];
			var _g44 = 0;
			var _g45 = values20.length;
			while(_g44 < _g45) {
				var i20 = _g44++;
				if(values20[i20] > max10) {
					max10 = values20[i20];
				}
			}
			var values21 = [max10,ma10];
			var min10 = values21[0];
			var _g46 = 0;
			var _g47 = values21.length;
			while(_g46 < _g47) {
				var i21 = _g46++;
				if(values21[i21] < min10) {
					min10 = values21[i21];
				}
			}
			var x21 = min10;
			var ma11 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) - 1;
			var values22 = [(y1 | 0) + 1,0];
			var max11 = values22[0];
			var _g48 = 0;
			var _g49 = values22.length;
			while(_g48 < _g49) {
				var i22 = _g48++;
				if(values22[i22] > max11) {
					max11 = values22[i22];
				}
			}
			var values23 = [max11,ma11];
			var min11 = values23[0];
			var _g50 = 0;
			var _g51 = values23.length;
			while(_g50 < _g51) {
				var i23 = _g50++;
				if(values23[i23] < min11) {
					min11 = values23[i23];
				}
			}
			var y11 = min11;
			if(!(x21 >= 0 && y11 >= 0 && x21 < image.getUInt16(0) && y11 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x7 = x21;
				var this_y7 = y11;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x7,this_y7)));
			}
			var position8 = (y11 * image.getUInt16(0) + x21) * 4;
			position8 += vision_ds_Image.OFFSET;
			var value8 = image.b[position8] << 24 | image.b[position8 + 1] << 16 | image.b[position8 + 2] << 8 | image.b[position8 + 3];
			if(value8 == null) {
				value8 = 0;
			}
			var green = x17 + yFraction * (x20 + xFraction * (value8 >> 8 & 255)) | 0;
			var x22 = 1 - yFraction;
			var x23 = x1 | 0;
			var y12 = y1 | 0;
			if(!(x23 >= 0 && y12 >= 0 && x23 < image.getUInt16(0) && y12 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x8 = x23;
				var this_y8 = y12;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x8,this_y8)));
			}
			var position9 = (y12 * image.getUInt16(0) + x23) * 4;
			position9 += vision_ds_Image.OFFSET;
			var value9 = image.b[position9] << 24 | image.b[position9 + 1] << 16 | image.b[position9 + 2] << 8 | image.b[position9 + 3];
			if(value9 == null) {
				value9 = 0;
			}
			var x24 = (1 - xFraction) * (value9 & 255);
			var ma12 = image.getUInt16(0) - 1;
			var values24 = [(x1 | 0) + 1,0];
			var max12 = values24[0];
			var _g52 = 0;
			var _g53 = values24.length;
			while(_g52 < _g53) {
				var i24 = _g52++;
				if(values24[i24] > max12) {
					max12 = values24[i24];
				}
			}
			var values25 = [max12,ma12];
			var min12 = values25[0];
			var _g54 = 0;
			var _g55 = values25.length;
			while(_g54 < _g55) {
				var i25 = _g54++;
				if(values25[i25] < min12) {
					min12 = values25[i25];
				}
			}
			var x25 = min12;
			var ma13 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) - 1;
			var values26 = [y1 | 0,0];
			var max13 = values26[0];
			var _g56 = 0;
			var _g57 = values26.length;
			while(_g56 < _g57) {
				var i26 = _g56++;
				if(values26[i26] > max13) {
					max13 = values26[i26];
				}
			}
			var values27 = [max13,ma13];
			var min13 = values27[0];
			var _g58 = 0;
			var _g59 = values27.length;
			while(_g58 < _g59) {
				var i27 = _g58++;
				if(values27[i27] < min13) {
					min13 = values27[i27];
				}
			}
			var y13 = min13;
			if(!(x25 >= 0 && y13 >= 0 && x25 < image.getUInt16(0) && y13 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x9 = x25;
				var this_y9 = y13;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x9,this_y9)));
			}
			var position10 = (y13 * image.getUInt16(0) + x25) * 4;
			position10 += vision_ds_Image.OFFSET;
			var value10 = image.b[position10] << 24 | image.b[position10 + 1] << 16 | image.b[position10 + 2] << 8 | image.b[position10 + 3];
			if(value10 == null) {
				value10 = 0;
			}
			var x26 = x22 * (x24 + xFraction * (value10 & 255));
			var x27 = 1 - xFraction;
			var ma14 = image.getUInt16(0) - 1;
			var values28 = [x1 | 0,0];
			var max14 = values28[0];
			var _g60 = 0;
			var _g61 = values28.length;
			while(_g60 < _g61) {
				var i28 = _g60++;
				if(values28[i28] > max14) {
					max14 = values28[i28];
				}
			}
			var values29 = [max14,ma14];
			var min14 = values29[0];
			var _g62 = 0;
			var _g63 = values29.length;
			while(_g62 < _g63) {
				var i29 = _g62++;
				if(values29[i29] < min14) {
					min14 = values29[i29];
				}
			}
			var x28 = min14;
			var ma15 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) - 1;
			var values30 = [(y1 | 0) + 1,0];
			var max15 = values30[0];
			var _g64 = 0;
			var _g65 = values30.length;
			while(_g64 < _g65) {
				var i30 = _g64++;
				if(values30[i30] > max15) {
					max15 = values30[i30];
				}
			}
			var values31 = [max15,ma15];
			var min15 = values31[0];
			var _g66 = 0;
			var _g67 = values31.length;
			while(_g66 < _g67) {
				var i31 = _g66++;
				if(values31[i31] < min15) {
					min15 = values31[i31];
				}
			}
			var y14 = min15;
			if(!(x28 >= 0 && y14 >= 0 && x28 < image.getUInt16(0) && y14 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x10 = x28;
				var this_y10 = y14;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x10,this_y10)));
			}
			var position11 = (y14 * image.getUInt16(0) + x28) * 4;
			position11 += vision_ds_Image.OFFSET;
			var value11 = image.b[position11] << 24 | image.b[position11 + 1] << 16 | image.b[position11 + 2] << 8 | image.b[position11 + 3];
			if(value11 == null) {
				value11 = 0;
			}
			var x29 = x27 * (value11 & 255);
			var ma16 = image.getUInt16(0) - 1;
			var values32 = [(x1 | 0) + 1,0];
			var max16 = values32[0];
			var _g68 = 0;
			var _g69 = values32.length;
			while(_g68 < _g69) {
				var i32 = _g68++;
				if(values32[i32] > max16) {
					max16 = values32[i32];
				}
			}
			var values33 = [max16,ma16];
			var min16 = values33[0];
			var _g70 = 0;
			var _g71 = values33.length;
			while(_g70 < _g71) {
				var i33 = _g70++;
				if(values33[i33] < min16) {
					min16 = values33[i33];
				}
			}
			var x30 = min16;
			var ma17 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) - 1;
			var values34 = [(y1 | 0) + 1,0];
			var max17 = values34[0];
			var _g72 = 0;
			var _g73 = values34.length;
			while(_g72 < _g73) {
				var i34 = _g72++;
				if(values34[i34] > max17) {
					max17 = values34[i34];
				}
			}
			var values35 = [max17,ma17];
			var min17 = values35[0];
			var _g74 = 0;
			var _g75 = values35.length;
			while(_g74 < _g75) {
				var i35 = _g74++;
				if(values35[i35] < min17) {
					min17 = values35[i35];
				}
			}
			var y15 = min17;
			if(!(x30 >= 0 && y15 >= 0 && x30 < image.getUInt16(0) && y15 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x11 = x30;
				var this_y11 = y15;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x11,this_y11)));
			}
			var position12 = (y15 * image.getUInt16(0) + x30) * 4;
			position12 += vision_ds_Image.OFFSET;
			var value12 = image.b[position12] << 24 | image.b[position12 + 1] << 16 | image.b[position12 + 2] << 8 | image.b[position12 + 3];
			if(value12 == null) {
				value12 = 0;
			}
			var blue = x26 + yFraction * (x29 + xFraction * (value12 & 255)) | 0;
			var x31 = 1 - yFraction;
			var x32 = x1 | 0;
			var y16 = y1 | 0;
			if(!(x32 >= 0 && y16 >= 0 && x32 < image.getUInt16(0) && y16 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x12 = x32;
				var this_y12 = y16;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x12,this_y12)));
			}
			var position13 = (y16 * image.getUInt16(0) + x32) * 4;
			position13 += vision_ds_Image.OFFSET;
			var value13 = image.b[position13] << 24 | image.b[position13 + 1] << 16 | image.b[position13 + 2] << 8 | image.b[position13 + 3];
			if(value13 == null) {
				value13 = 0;
			}
			var x33 = (1 - xFraction) * (value13 >> 24 & 255);
			var ma18 = image.getUInt16(0) - 1;
			var values36 = [(x1 | 0) + 1,0];
			var max18 = values36[0];
			var _g76 = 0;
			var _g77 = values36.length;
			while(_g76 < _g77) {
				var i36 = _g76++;
				if(values36[i36] > max18) {
					max18 = values36[i36];
				}
			}
			var values37 = [max18,ma18];
			var min18 = values37[0];
			var _g78 = 0;
			var _g79 = values37.length;
			while(_g78 < _g79) {
				var i37 = _g78++;
				if(values37[i37] < min18) {
					min18 = values37[i37];
				}
			}
			var x34 = min18;
			var ma19 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) - 1;
			var values38 = [y1 | 0,0];
			var max19 = values38[0];
			var _g80 = 0;
			var _g81 = values38.length;
			while(_g80 < _g81) {
				var i38 = _g80++;
				if(values38[i38] > max19) {
					max19 = values38[i38];
				}
			}
			var values39 = [max19,ma19];
			var min19 = values39[0];
			var _g82 = 0;
			var _g83 = values39.length;
			while(_g82 < _g83) {
				var i39 = _g82++;
				if(values39[i39] < min19) {
					min19 = values39[i39];
				}
			}
			var y17 = min19;
			if(!(x34 >= 0 && y17 >= 0 && x34 < image.getUInt16(0) && y17 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x13 = x34;
				var this_y13 = y17;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x13,this_y13)));
			}
			var position14 = (y17 * image.getUInt16(0) + x34) * 4;
			position14 += vision_ds_Image.OFFSET;
			var value14 = image.b[position14] << 24 | image.b[position14 + 1] << 16 | image.b[position14 + 2] << 8 | image.b[position14 + 3];
			if(value14 == null) {
				value14 = 0;
			}
			var x35 = x31 * (x33 + xFraction * (value14 >> 24 & 255));
			var x36 = 1 - xFraction;
			var ma20 = image.getUInt16(0) - 1;
			var values40 = [x1 | 0,0];
			var max20 = values40[0];
			var _g84 = 0;
			var _g85 = values40.length;
			while(_g84 < _g85) {
				var i40 = _g84++;
				if(values40[i40] > max20) {
					max20 = values40[i40];
				}
			}
			var values41 = [max20,ma20];
			var min20 = values41[0];
			var _g86 = 0;
			var _g87 = values41.length;
			while(_g86 < _g87) {
				var i41 = _g86++;
				if(values41[i41] < min20) {
					min20 = values41[i41];
				}
			}
			var x37 = min20;
			var ma21 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) - 1;
			var values42 = [(y1 | 0) + 1,0];
			var max21 = values42[0];
			var _g88 = 0;
			var _g89 = values42.length;
			while(_g88 < _g89) {
				var i42 = _g88++;
				if(values42[i42] > max21) {
					max21 = values42[i42];
				}
			}
			var values43 = [max21,ma21];
			var min21 = values43[0];
			var _g90 = 0;
			var _g91 = values43.length;
			while(_g90 < _g91) {
				var i43 = _g90++;
				if(values43[i43] < min21) {
					min21 = values43[i43];
				}
			}
			var y18 = min21;
			if(!(x37 >= 0 && y18 >= 0 && x37 < image.getUInt16(0) && y18 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x14 = x37;
				var this_y14 = y18;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x14,this_y14)));
			}
			var position15 = (y18 * image.getUInt16(0) + x37) * 4;
			position15 += vision_ds_Image.OFFSET;
			var value15 = image.b[position15] << 24 | image.b[position15 + 1] << 16 | image.b[position15 + 2] << 8 | image.b[position15 + 3];
			if(value15 == null) {
				value15 = 0;
			}
			var x38 = x36 * (value15 >> 24 & 255);
			var ma22 = image.getUInt16(0) - 1;
			var values44 = [(x1 | 0) + 1,0];
			var max22 = values44[0];
			var _g92 = 0;
			var _g93 = values44.length;
			while(_g92 < _g93) {
				var i44 = _g92++;
				if(values44[i44] > max22) {
					max22 = values44[i44];
				}
			}
			var values45 = [max22,ma22];
			var min22 = values45[0];
			var _g94 = 0;
			var _g95 = values45.length;
			while(_g94 < _g95) {
				var i45 = _g94++;
				if(values45[i45] < min22) {
					min22 = values45[i45];
				}
			}
			var x39 = min22;
			var ma23 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) - 1;
			var values46 = [(y1 | 0) + 1,0];
			var max23 = values46[0];
			var _g96 = 0;
			var _g97 = values46.length;
			while(_g96 < _g97) {
				var i46 = _g96++;
				if(values46[i46] > max23) {
					max23 = values46[i46];
				}
			}
			var values47 = [max23,ma23];
			var min23 = values47[0];
			var _g98 = 0;
			var _g99 = values47.length;
			while(_g98 < _g99) {
				var i47 = _g98++;
				if(values47[i47] < min23) {
					min23 = values47[i47];
				}
			}
			var y19 = min23;
			if(!(x39 >= 0 && y19 >= 0 && x39 < image.getUInt16(0) && y19 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x15 = x39;
				var this_y15 = y19;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x15,this_y15)));
			}
			var position16 = (y19 * image.getUInt16(0) + x39) * 4;
			position16 += vision_ds_Image.OFFSET;
			var value16 = image.b[position16] << 24 | image.b[position16 + 1] << 16 | image.b[position16 + 2] << 8 | image.b[position16 + 3];
			if(value16 == null) {
				value16 = 0;
			}
			var alpha = x35 + yFraction * (x38 + xFraction * (value16 >> 24 & 255)) | 0;
			var Alpha = alpha;
			if(Alpha == null) {
				Alpha = 255;
			}
			var color = 0;
			var Alpha1 = Alpha;
			if(Alpha1 == null) {
				Alpha1 = 255;
			}
			color &= -16711681;
			color |= (red > 255 ? 255 : red < 0 ? 0 : red) << 16;
			color &= -65281;
			color |= (green > 255 ? 255 : green < 0 ? 0 : green) << 8;
			color &= -256;
			color |= blue > 255 ? 255 : blue < 0 ? 0 : blue;
			color &= 16777215;
			color |= (Alpha1 > 255 ? 255 : Alpha1 < 0 ? 0 : Alpha1) << 24;
			var color1 = color;
			if(!(x >= 0 && y >= 0 && x < resized.getUInt16(0) && y < Math.ceil((resized.length - vision_ds_Image.OFFSET) / (resized.getUInt16(0) * 4)))) {
				var this_x16 = x;
				var this_y16 = y;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(resized,new vision_ds_Point2D(this_x16,this_y16)));
			} else if(resized.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || resized.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || resized.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || resized.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || resized.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp1;
				if(!(resized.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || resized.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || resized.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || resized.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || resized.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp1 = x >= 0 && y >= 0 && x < resized.getUInt16(0) && y < Math.ceil((resized.length - vision_ds_Image.OFFSET) / (resized.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g100 = resized.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g101 = resized.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g102 = resized.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var resized1 = resized.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g100,_g101,_g102,resized.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),resized1[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
						break;
					case 1:
						has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c1 = Math.sqrt(a * a - b * b);
							var x40 = view.x + view.width / 2 - c1;
							var y20 = view.y + view.height / 2;
							if(y20 == null) {
								y20 = 0;
							}
							if(x40 == null) {
								x40 = 0;
							}
							var f1_x = x40;
							var f1_y = y20;
							var x41 = view.x + view.width / 2 + c1;
							var y21 = view.y + view.height / 2;
							if(y21 == null) {
								y21 = 0;
							}
							if(x41 == null) {
								x41 = 0;
							}
							var f2_x = x41;
							var f2_y = y21;
							var p_x = x;
							var p_y = y;
							var x42 = p_x - f1_x;
							var y22 = p_y - f1_y;
							var x43 = p_x - f2_x;
							var y23 = p_y - f2_y;
							has = Math.sqrt(x42 * x42 + y22 * y22) + Math.sqrt(x43 * x43 + y23 * y23) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a1 = view.height / 2;
							var b1 = view.width / 2;
							var c2 = Math.sqrt(a1 * a1 - b1 * b1);
							var x44 = view.x + view.width / 2;
							var y24 = view.y + view.height / 2 - c2;
							if(y24 == null) {
								y24 = 0;
							}
							if(x44 == null) {
								x44 = 0;
							}
							var f1_x1 = x44;
							var f1_y1 = y24;
							var x45 = view.x + view.width / 2;
							var y25 = view.y + view.height / 2 + c2;
							if(y25 == null) {
								y25 = 0;
							}
							if(x45 == null) {
								x45 = 0;
							}
							var f2_x1 = x45;
							var f2_y1 = y25;
							var p_x1 = x;
							var p_y1 = y;
							var x46 = p_x1 - f1_x1;
							var y26 = p_y1 - f1_y1;
							var x47 = p_x1 - f2_x1;
							var y27 = p_y1 - f2_y1;
							has = Math.sqrt(x46 * x46 + y26 * y26) + Math.sqrt(x47 * x47 + y27 * y27) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x48 = x;
							var y28 = y;
							if(y28 == null) {
								y28 = 0;
							}
							if(x48 == null) {
								x48 = 0;
							}
							var point1_x = x48;
							var point1_y = y28;
							var x49 = view.x + view.width / 2;
							var y29 = view.y + view.height / 2;
							if(y29 == null) {
								y29 = 0;
							}
							if(x49 == null) {
								x49 = 0;
							}
							var point2_x = x49;
							var point2_y = y29;
							var x50 = point2_x - point1_x;
							var y30 = point2_y - point1_y;
							has = Math.sqrt(x50 * x50 + y30 * y30) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp1 = has;
				}
				if(tmp1) {
					var position17 = (y * resized.getUInt16(0) + x) * 4;
					position17 += vision_ds_Image.OFFSET;
					resized.b[position17] = color1 >> 24 & 255;
					resized.b[position17 + 1] = color1 >> 16 & 255;
					resized.b[position17 + 2] = color1 >> 8 & 255;
					resized.b[position17 + 3] = color1 & 255;
				}
			} else {
				var position18 = (y * resized.getUInt16(0) + x) * 4;
				position18 += vision_ds_Image.OFFSET;
				resized.b[position18] = color1 >> 24 & 255;
				resized.b[position18 + 1] = color1 >> 16 & 255;
				resized.b[position18 + 2] = color1 >> 8 & 255;
				resized.b[position18 + 3] = color1 & 255;
			}
		}
	}
	return resized;
};
vision_algorithms_BilinearInterpolation.interpolateMissingPixels = function(image,kernelRadiusX,kernelRadiusY,minX,minY) {
	if(kernelRadiusX == 0 && kernelRadiusY == 0) {
		return image;
	}
	var interpolated = vision_ds_Image.clone(image);
	var _g = minX;
	var _g1 = image.getUInt16(0);
	while(_g < _g1) {
		var x = _g++;
		var _g2 = minY;
		var _g3 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4));
		while(_g2 < _g3) {
			var y = _g2++;
			if(!(x >= 0 && y >= 0 && x < image.getUInt16(0) && y < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x = x;
				var this_y = y;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x,this_y)));
			}
			var position = (y * image.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			var value = image.b[position] << 24 | image.b[position + 1] << 16 | image.b[position + 2] << 8 | image.b[position + 3];
			if(value == null) {
				value = 0;
			}
			if(value != 0) {
				continue;
			}
			var neighborArray = [];
			var _g4 = -kernelRadiusX;
			var _g5 = kernelRadiusX + 1;
			while(_g4 < _g5) {
				var offX = _g4++;
				var _g6 = -kernelRadiusY;
				var _g7 = kernelRadiusY + 1;
				while(_g6 < _g7) {
					var offY = _g6++;
					var ma = image.getUInt16(0) - 1;
					var values = [x + offX,0];
					var max = values[0];
					var _g8 = 0;
					var _g9 = values.length;
					while(_g8 < _g9) {
						var i = _g8++;
						if(values[i] > max) {
							max = values[i];
						}
					}
					var values1 = [max,ma];
					var min = values1[0];
					var _g10 = 0;
					var _g11 = values1.length;
					while(_g10 < _g11) {
						var i1 = _g10++;
						if(values1[i1] < min) {
							min = values1[i1];
						}
					}
					var x1 = min;
					var ma1 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) - 1;
					var values2 = [y + offY,0];
					var max1 = values2[0];
					var _g12 = 0;
					var _g13 = values2.length;
					while(_g12 < _g13) {
						var i2 = _g12++;
						if(values2[i2] > max1) {
							max1 = values2[i2];
						}
					}
					var values3 = [max1,ma1];
					var min1 = values3[0];
					var _g14 = 0;
					var _g15 = values3.length;
					while(_g14 < _g15) {
						var i3 = _g14++;
						if(values3[i3] < min1) {
							min1 = values3[i3];
						}
					}
					var y1 = min1;
					if(!(x1 >= 0 && y1 >= 0 && x1 < image.getUInt16(0) && y1 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
						var this_x1 = x1;
						var this_y1 = y1;
						throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x1,this_y1)));
					}
					var position1 = (y1 * image.getUInt16(0) + x1) * 4;
					position1 += vision_ds_Image.OFFSET;
					var value1 = image.b[position1] << 24 | image.b[position1 + 1] << 16 | image.b[position1 + 2] << 8 | image.b[position1 + 3];
					if(value1 == null) {
						value1 = 0;
					}
					neighborArray.push(value1);
				}
			}
			var _g16 = [];
			var _g17 = 0;
			var _g18 = neighborArray;
			while(_g17 < _g18.length) {
				var v = _g18[_g17];
				++_g17;
				if(vision_ds_Color.toInt(v) != 0) {
					_g16.push(v);
				}
			}
			neighborArray = _g16;
			var sumR = 0;
			var sumG = 0;
			var sumB = 0;
			var sumA = 0;
			var _g19 = 0;
			while(_g19 < neighborArray.length) {
				var color = neighborArray[_g19];
				++_g19;
				sumR += color >> 16 & 255;
				sumG += color >> 8 & 255;
				sumB += color & 255;
				sumA += color >> 24 & 255;
			}
			var Red = Math.round(sumR / neighborArray.length);
			var Green = Math.round(sumG / neighborArray.length);
			var Blue = Math.round(sumB / neighborArray.length);
			var Alpha = Math.round(sumA / neighborArray.length);
			if(Alpha == null) {
				Alpha = 255;
			}
			var color1 = 0;
			var Alpha1 = Alpha;
			if(Alpha1 == null) {
				Alpha1 = 255;
			}
			color1 &= -16711681;
			color1 |= (Red > 255 ? 255 : Red < 0 ? 0 : Red) << 16;
			color1 &= -65281;
			color1 |= (Green > 255 ? 255 : Green < 0 ? 0 : Green) << 8;
			color1 &= -256;
			color1 |= Blue > 255 ? 255 : Blue < 0 ? 0 : Blue;
			color1 &= 16777215;
			color1 |= (Alpha1 > 255 ? 255 : Alpha1 < 0 ? 0 : Alpha1) << 24;
			var color2 = color1;
			if(!(x >= 0 && y >= 0 && x < interpolated.getUInt16(0) && y < Math.ceil((interpolated.length - vision_ds_Image.OFFSET) / (interpolated.getUInt16(0) * 4)))) {
				var this_x2 = x;
				var this_y2 = y;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(interpolated,new vision_ds_Point2D(this_x2,this_y2)));
			} else if(interpolated.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || interpolated.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || interpolated.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || interpolated.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || interpolated.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v1 = null;
				var tmp;
				if(!(interpolated.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || interpolated.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || interpolated.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || interpolated.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || interpolated.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v1 == null) {
					tmp = x >= 0 && y >= 0 && x < interpolated.getUInt16(0) && y < Math.ceil((interpolated.length - vision_ds_Image.OFFSET) / (interpolated.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v1 != null) {
						view = v1;
					} else {
						var _g20 = interpolated.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g21 = interpolated.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g22 = interpolated.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var interpolated1 = interpolated.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g20,_g21,_g22,interpolated.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),interpolated1[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
						break;
					case 1:
						has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x2 = view.x + view.width / 2 - c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f1_x = x2;
							var f1_y = y2;
							var x3 = view.x + view.width / 2 + c;
							var y3 = view.y + view.height / 2;
							if(y3 == null) {
								y3 = 0;
							}
							if(x3 == null) {
								x3 = 0;
							}
							var f2_x = x3;
							var f2_y = y3;
							var p_x = x;
							var p_y = y;
							var x4 = p_x - f1_x;
							var y4 = p_y - f1_y;
							var x5 = p_x - f2_x;
							var y5 = p_y - f2_y;
							has = Math.sqrt(x4 * x4 + y4 * y4) + Math.sqrt(x5 * x5 + y5 * y5) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a1 = view.height / 2;
							var b1 = view.width / 2;
							var c1 = Math.sqrt(a1 * a1 - b1 * b1);
							var x6 = view.x + view.width / 2;
							var y6 = view.y + view.height / 2 - c1;
							if(y6 == null) {
								y6 = 0;
							}
							if(x6 == null) {
								x6 = 0;
							}
							var f1_x1 = x6;
							var f1_y1 = y6;
							var x7 = view.x + view.width / 2;
							var y7 = view.y + view.height / 2 + c1;
							if(y7 == null) {
								y7 = 0;
							}
							if(x7 == null) {
								x7 = 0;
							}
							var f2_x1 = x7;
							var f2_y1 = y7;
							var p_x1 = x;
							var p_y1 = y;
							var x8 = p_x1 - f1_x1;
							var y8 = p_y1 - f1_y1;
							var x9 = p_x1 - f2_x1;
							var y9 = p_y1 - f2_y1;
							has = Math.sqrt(x8 * x8 + y8 * y8) + Math.sqrt(x9 * x9 + y9 * y9) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x10 = x;
							var y10 = y;
							if(y10 == null) {
								y10 = 0;
							}
							if(x10 == null) {
								x10 = 0;
							}
							var point1_x = x10;
							var point1_y = y10;
							var x11 = view.x + view.width / 2;
							var y11 = view.y + view.height / 2;
							if(y11 == null) {
								y11 = 0;
							}
							if(x11 == null) {
								x11 = 0;
							}
							var point2_x = x11;
							var point2_y = y11;
							var x12 = point2_x - point1_x;
							var y12 = point2_y - point1_y;
							has = Math.sqrt(x12 * x12 + y12 * y12) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position2 = (y * interpolated.getUInt16(0) + x) * 4;
					position2 += vision_ds_Image.OFFSET;
					interpolated.b[position2] = color2 >> 24 & 255;
					interpolated.b[position2 + 1] = color2 >> 16 & 255;
					interpolated.b[position2 + 2] = color2 >> 8 & 255;
					interpolated.b[position2 + 3] = color2 & 255;
				}
			} else {
				var position3 = (y * interpolated.getUInt16(0) + x) * 4;
				position3 += vision_ds_Image.OFFSET;
				interpolated.b[position3] = color2 >> 24 & 255;
				interpolated.b[position3 + 1] = color2 >> 16 & 255;
				interpolated.b[position3 + 2] = color2 >> 8 & 255;
				interpolated.b[position3 + 3] = color2 & 255;
			}
		}
	}
	return interpolated;
};
var vision_algorithms_Cramer = function() { };
$hxClasses["vision.algorithms.Cramer"] = vision_algorithms_Cramer;
vision_algorithms_Cramer.__name__ = "vision.algorithms.Cramer";
vision_algorithms_Cramer.solveVariablesFor = function(coefficients,solutions) {
	if(coefficients.width != solutions.length) {
		throw haxe_Exception.thrown("");
	}
	if(coefficients.height != solutions.length) {
		throw haxe_Exception.thrown("");
	}
	var arr = new vision_ds_Array2D(coefficients.width,coefficients.height);
	arr.inner = coefficients.inner.slice();
	var A = arr;
	var arr = new vision_ds_Array2D(A.width,A.height);
	arr.inner = A.inner.slice();
	var replacedA = arr;
	var variables = [];
	var _g = 0;
	var _g1 = solutions.length;
	while(_g < _g1) {
		var i = _g++;
		var arr = new vision_ds_Array2D(A.width,A.height);
		arr.inner = A.inner.slice();
		replacedA = arr;
		if(solutions.length < replacedA.height) {
			throw haxe_Exception.thrown("");
		}
		var _g2 = 0;
		var _g3 = replacedA.height;
		while(_g2 < _g3) {
			var y = _g2++;
			replacedA.inner[i + y * replacedA.width] = solutions[y];
		}
		var len = replacedA.width;
		var tmp;
		switch(len) {
		case 0:
			tmp = 1;
			break;
		case 1:
			tmp = replacedA.inner[0 * replacedA.width];
			break;
		case 2:
			tmp = replacedA.inner[0 * replacedA.width] * replacedA.inner[replacedA.width + 1] - replacedA.inner[replacedA.width] * replacedA.inner[0 * replacedA.width + 1];
			break;
		default:
			var determinantSum = 0.;
			var sign = 1;
			var _g4 = 0;
			var _g5 = replacedA.width;
			while(_g4 < _g5) {
				var i1 = _g4++;
				var current = replacedA.inner[0 * replacedA.width + i1];
				var fromX = 0;
				var fromY = 1;
				var toX = null;
				var toY = null;
				if(fromY == null) {
					fromY = 0;
				}
				if(fromX == null) {
					fromX = 0;
				}
				var copy = replacedA.to2DArray();
				if(toX == null) {
					toX = replacedA.width;
				}
				if(toY == null) {
					toY = replacedA.height;
				}
				var _g6 = 0;
				var _g7 = fromY;
				while(_g6 < _g7) {
					var _ = _g6++;
					copy.shift();
				}
				var _g8 = toX;
				var _g9 = copy.length;
				while(_g8 < _g9) {
					var _1 = _g8++;
					copy.pop();
				}
				var _g10 = 0;
				while(_g10 < copy.length) {
					var row = copy[_g10];
					++_g10;
					var _g11 = 0;
					var _g12 = fromX;
					while(_g11 < _g12) {
						var _2 = _g11++;
						row.shift();
					}
					var _g13 = toY;
					var _g14 = row.length;
					while(_g13 < _g14) {
						var _3 = _g13++;
						row.pop();
					}
				}
				var childMatrix;
				if(copy.length == 0) {
					childMatrix = new vision_ds_Array2D(0,0);
				} else {
					var arr2d = new vision_ds_Array2D(copy[0].length,copy.length);
					var flat = [];
					var _g15 = 0;
					while(_g15 < copy.length) {
						var item = copy[_g15];
						++_g15;
						flat = flat.concat(item);
					}
					arr2d.inner = flat;
					childMatrix = arr2d;
				}
				var underlyingArray = childMatrix.inner.slice();
				var _g16 = 0;
				var _g17 = childMatrix.height;
				while(_g16 < _g17) {
					var i2 = _g16++;
					underlyingArray[i1 + i2 * childMatrix.width] = null;
				}
				var _g18 = [];
				var _g19 = 0;
				var _g20 = underlyingArray;
				while(_g19 < _g20.length) {
					var v = _g20[_g19];
					++_g19;
					if(v != null) {
						_g18.push(v);
					}
				}
				underlyingArray = _g18;
				var value = childMatrix.width - 1;
				childMatrix.inner.length = value * childMatrix.height;
				childMatrix.width = value;
				childMatrix.inner = underlyingArray;
				var determinantSum1 = sign * current;
				var len1 = childMatrix.width;
				var determinantSum2;
				switch(len1) {
				case 0:
					determinantSum2 = 1;
					break;
				case 1:
					determinantSum2 = childMatrix.inner[0 * childMatrix.width];
					break;
				case 2:
					determinantSum2 = childMatrix.inner[0 * childMatrix.width] * childMatrix.inner[childMatrix.width + 1] - childMatrix.inner[childMatrix.width] * childMatrix.inner[0 * childMatrix.width + 1];
					break;
				default:
					var determinantSum3 = 0.;
					var sign1 = 1;
					var _g21 = 0;
					var _g22 = childMatrix.width;
					while(_g21 < _g22) {
						var i3 = _g21++;
						var current1 = childMatrix.inner[0 * childMatrix.width + i3];
						var fromX1 = 0;
						var fromY1 = 1;
						var toX1 = null;
						var toY1 = null;
						if(fromY1 == null) {
							fromY1 = 0;
						}
						if(fromX1 == null) {
							fromX1 = 0;
						}
						var copy1 = childMatrix.to2DArray();
						if(toX1 == null) {
							toX1 = childMatrix.width;
						}
						if(toY1 == null) {
							toY1 = childMatrix.height;
						}
						var _g23 = 0;
						var _g24 = fromY1;
						while(_g23 < _g24) {
							var _4 = _g23++;
							copy1.shift();
						}
						var _g25 = toX1;
						var _g26 = copy1.length;
						while(_g25 < _g26) {
							var _5 = _g25++;
							copy1.pop();
						}
						var _g27 = 0;
						while(_g27 < copy1.length) {
							var row1 = copy1[_g27];
							++_g27;
							var _g28 = 0;
							var _g29 = fromX1;
							while(_g28 < _g29) {
								var _6 = _g28++;
								row1.shift();
							}
							var _g30 = toY1;
							var _g31 = row1.length;
							while(_g30 < _g31) {
								var _7 = _g30++;
								row1.pop();
							}
						}
						var childMatrix1;
						if(copy1.length == 0) {
							childMatrix1 = new vision_ds_Array2D(0,0);
						} else {
							var arr2d1 = new vision_ds_Array2D(copy1[0].length,copy1.length);
							var flat1 = [];
							var _g32 = 0;
							while(_g32 < copy1.length) {
								var item1 = copy1[_g32];
								++_g32;
								flat1 = flat1.concat(item1);
							}
							arr2d1.inner = flat1;
							childMatrix1 = arr2d1;
						}
						var underlyingArray1 = childMatrix1.inner.slice();
						var _g33 = 0;
						var _g34 = childMatrix1.height;
						while(_g33 < _g34) {
							var i4 = _g33++;
							underlyingArray1[i3 + i4 * childMatrix1.width] = null;
						}
						var _g35 = [];
						var _g36 = 0;
						var _g37 = underlyingArray1;
						while(_g36 < _g37.length) {
							var v1 = _g37[_g36];
							++_g36;
							if(v1 != null) {
								_g35.push(v1);
							}
						}
						underlyingArray1 = _g35;
						var value1 = childMatrix1.width - 1;
						childMatrix1.inner.length = value1 * childMatrix1.height;
						childMatrix1.width = value1;
						childMatrix1.inner = underlyingArray1;
						determinantSum3 += sign1 * current1 * vision_ds_Matrix2D.getDeterminant(childMatrix1);
						sign1 *= -1;
					}
					determinantSum2 = determinantSum3;
				}
				determinantSum += determinantSum1 * determinantSum2;
				sign *= -1;
			}
			tmp = determinantSum;
		}
		var len2 = A.width;
		var tmp1;
		switch(len2) {
		case 0:
			tmp1 = 1;
			break;
		case 1:
			tmp1 = A.inner[0 * A.width];
			break;
		case 2:
			tmp1 = A.inner[0 * A.width] * A.inner[A.width + 1] - A.inner[A.width] * A.inner[0 * A.width + 1];
			break;
		default:
			var determinantSum4 = 0.;
			var sign2 = 1;
			var _g38 = 0;
			var _g39 = A.width;
			while(_g38 < _g39) {
				var i5 = _g38++;
				var current2 = A.inner[0 * A.width + i5];
				var fromX2 = 0;
				var fromY2 = 1;
				var toX2 = null;
				var toY2 = null;
				if(fromY2 == null) {
					fromY2 = 0;
				}
				if(fromX2 == null) {
					fromX2 = 0;
				}
				var copy2 = A.to2DArray();
				if(toX2 == null) {
					toX2 = A.width;
				}
				if(toY2 == null) {
					toY2 = A.height;
				}
				var _g40 = 0;
				var _g41 = fromY2;
				while(_g40 < _g41) {
					var _8 = _g40++;
					copy2.shift();
				}
				var _g42 = toX2;
				var _g43 = copy2.length;
				while(_g42 < _g43) {
					var _9 = _g42++;
					copy2.pop();
				}
				var _g44 = 0;
				while(_g44 < copy2.length) {
					var row2 = copy2[_g44];
					++_g44;
					var _g45 = 0;
					var _g46 = fromX2;
					while(_g45 < _g46) {
						var _10 = _g45++;
						row2.shift();
					}
					var _g47 = toY2;
					var _g48 = row2.length;
					while(_g47 < _g48) {
						var _11 = _g47++;
						row2.pop();
					}
				}
				var childMatrix2;
				if(copy2.length == 0) {
					childMatrix2 = new vision_ds_Array2D(0,0);
				} else {
					var arr2d2 = new vision_ds_Array2D(copy2[0].length,copy2.length);
					var flat2 = [];
					var _g49 = 0;
					while(_g49 < copy2.length) {
						var item2 = copy2[_g49];
						++_g49;
						flat2 = flat2.concat(item2);
					}
					arr2d2.inner = flat2;
					childMatrix2 = arr2d2;
				}
				var underlyingArray2 = childMatrix2.inner.slice();
				var _g50 = 0;
				var _g51 = childMatrix2.height;
				while(_g50 < _g51) {
					var i6 = _g50++;
					underlyingArray2[i5 + i6 * childMatrix2.width] = null;
				}
				var _g52 = [];
				var _g53 = 0;
				var _g54 = underlyingArray2;
				while(_g53 < _g54.length) {
					var v2 = _g54[_g53];
					++_g53;
					if(v2 != null) {
						_g52.push(v2);
					}
				}
				underlyingArray2 = _g52;
				var value2 = childMatrix2.width - 1;
				childMatrix2.inner.length = value2 * childMatrix2.height;
				childMatrix2.width = value2;
				childMatrix2.inner = underlyingArray2;
				var determinantSum5 = sign2 * current2;
				var len3 = childMatrix2.width;
				var determinantSum6;
				switch(len3) {
				case 0:
					determinantSum6 = 1;
					break;
				case 1:
					determinantSum6 = childMatrix2.inner[0 * childMatrix2.width];
					break;
				case 2:
					determinantSum6 = childMatrix2.inner[0 * childMatrix2.width] * childMatrix2.inner[childMatrix2.width + 1] - childMatrix2.inner[childMatrix2.width] * childMatrix2.inner[0 * childMatrix2.width + 1];
					break;
				default:
					var determinantSum7 = 0.;
					var sign3 = 1;
					var _g55 = 0;
					var _g56 = childMatrix2.width;
					while(_g55 < _g56) {
						var i7 = _g55++;
						var current3 = childMatrix2.inner[0 * childMatrix2.width + i7];
						var fromX3 = 0;
						var fromY3 = 1;
						var toX3 = null;
						var toY3 = null;
						if(fromY3 == null) {
							fromY3 = 0;
						}
						if(fromX3 == null) {
							fromX3 = 0;
						}
						var copy3 = childMatrix2.to2DArray();
						if(toX3 == null) {
							toX3 = childMatrix2.width;
						}
						if(toY3 == null) {
							toY3 = childMatrix2.height;
						}
						var _g57 = 0;
						var _g58 = fromY3;
						while(_g57 < _g58) {
							var _12 = _g57++;
							copy3.shift();
						}
						var _g59 = toX3;
						var _g60 = copy3.length;
						while(_g59 < _g60) {
							var _13 = _g59++;
							copy3.pop();
						}
						var _g61 = 0;
						while(_g61 < copy3.length) {
							var row3 = copy3[_g61];
							++_g61;
							var _g62 = 0;
							var _g63 = fromX3;
							while(_g62 < _g63) {
								var _14 = _g62++;
								row3.shift();
							}
							var _g64 = toY3;
							var _g65 = row3.length;
							while(_g64 < _g65) {
								var _15 = _g64++;
								row3.pop();
							}
						}
						var childMatrix3;
						if(copy3.length == 0) {
							childMatrix3 = new vision_ds_Array2D(0,0);
						} else {
							var arr2d3 = new vision_ds_Array2D(copy3[0].length,copy3.length);
							var flat3 = [];
							var _g66 = 0;
							while(_g66 < copy3.length) {
								var item3 = copy3[_g66];
								++_g66;
								flat3 = flat3.concat(item3);
							}
							arr2d3.inner = flat3;
							childMatrix3 = arr2d3;
						}
						var underlyingArray3 = childMatrix3.inner.slice();
						var _g67 = 0;
						var _g68 = childMatrix3.height;
						while(_g67 < _g68) {
							var i8 = _g67++;
							underlyingArray3[i7 + i8 * childMatrix3.width] = null;
						}
						var _g69 = [];
						var _g70 = 0;
						var _g71 = underlyingArray3;
						while(_g70 < _g71.length) {
							var v3 = _g71[_g70];
							++_g70;
							if(v3 != null) {
								_g69.push(v3);
							}
						}
						underlyingArray3 = _g69;
						var value3 = childMatrix3.width - 1;
						childMatrix3.inner.length = value3 * childMatrix3.height;
						childMatrix3.width = value3;
						childMatrix3.inner = underlyingArray3;
						determinantSum7 += sign3 * current3 * vision_ds_Matrix2D.getDeterminant(childMatrix3);
						sign3 *= -1;
					}
					determinantSum6 = determinantSum7;
				}
				determinantSum4 += determinantSum5 * determinantSum6;
				sign2 *= -1;
			}
			tmp1 = determinantSum4;
		}
		variables.push(tmp / tmp1);
	}
	return variables;
};
var vision_algorithms_GaussJordan = function() { };
$hxClasses["vision.algorithms.GaussJordan"] = vision_algorithms_GaussJordan;
vision_algorithms_GaussJordan.__name__ = "vision.algorithms.GaussJordan";
vision_algorithms_GaussJordan.invert = function(matrix) {
	var n = matrix.height;
	var identity = vision_algorithms_GaussJordan.createIdentityMatrix(n);
	var augmentedMatrix = vision_algorithms_GaussJordan.augmentMatrix(vision_ds_Matrix2D.to_array_array_float(matrix),vision_ds_Matrix2D.to_array_array_float(identity));
	var _g = 0;
	var _g1 = n;
	while(_g < _g1) {
		var i = _g++;
		var pivotRow = i;
		var _g2 = i + 1;
		var _g3 = n;
		while(_g2 < _g3) {
			var j = _g2++;
			if(Math.abs(augmentedMatrix.inner[i * augmentedMatrix.width + j]) > Math.abs(augmentedMatrix.inner[i * augmentedMatrix.width + pivotRow])) {
				pivotRow = j;
			}
		}
		if(Math.abs(augmentedMatrix.inner[i * augmentedMatrix.width + pivotRow]) < 1e-12) {
			throw haxe_Exception.thrown("Matrix is not invertible");
		}
		if(pivotRow != i) {
			vision_algorithms_GaussJordan.swapRows(vision_ds_Matrix2D.to_array_array_float(augmentedMatrix),i,pivotRow);
		}
		var pivot = augmentedMatrix.inner[i * augmentedMatrix.width + i];
		var _g4 = 0;
		var _g5 = 2 * n;
		while(_g4 < _g5) {
			var j1 = _g4++;
			augmentedMatrix.inner[i + j1 * augmentedMatrix.width] = pivot;
		}
		var _g6 = 0;
		var _g7 = n;
		while(_g6 < _g7) {
			var j2 = _g6++;
			if(j2 != i) {
				var factor = augmentedMatrix.inner[i * augmentedMatrix.width + j2];
				var _g8 = 0;
				var _g9 = 2 * n;
				while(_g8 < _g9) {
					var k = _g8++;
					augmentedMatrix.inner[j2 + k * augmentedMatrix.width] = factor * augmentedMatrix.inner[k * augmentedMatrix.width + i];
				}
			}
		}
	}
	var _g = [];
	var _g1 = n + 1;
	var _g2 = 2 * n;
	while(_g1 < _g2) {
		var l = _g1++;
		_g.push(l);
	}
	var invertedMatrix = vision_algorithms_GaussJordan.extractMatrix(augmentedMatrix,n,_g);
	return invertedMatrix;
};
vision_algorithms_GaussJordan.createIdentityMatrix = function(size) {
	var matrix = [];
	var _g = 0;
	var _g1 = size;
	while(_g < _g1) {
		var i = _g++;
		matrix.push([]);
		var _g2 = 0;
		var _g3 = size;
		while(_g2 < _g3) {
			var j = _g2++;
			if(i == j) {
				matrix[i].push(1.0);
			} else {
				matrix[i].push(0.0);
			}
		}
	}
	return vision_ds_Matrix2D.from_array_array_float(matrix);
};
vision_algorithms_GaussJordan.augmentMatrix = function(matrix,augmentation) {
	var augmentedMatrix = [];
	var _g = 0;
	var _g1 = matrix.length;
	while(_g < _g1) {
		var i = _g++;
		augmentedMatrix.push(matrix[i].concat(augmentation[i]));
	}
	return vision_ds_Matrix2D.from_array_array_float(augmentedMatrix);
};
vision_algorithms_GaussJordan.swapRows = function(matrix,row1,row2) {
	var temp = matrix[row1];
	matrix[row1] = matrix[row2];
	matrix[row2] = temp;
};
vision_algorithms_GaussJordan.extractMatrix = function(matrix,rows,columns) {
	var extractedMatrix = [];
	var _g = 0;
	var _g1 = rows;
	while(_g < _g1) {
		var i = _g++;
		extractedMatrix.push([]);
		var _g2 = 0;
		while(_g2 < columns.length) {
			var j = columns[_g2];
			++_g2;
			extractedMatrix[i].push(matrix.inner[j * matrix.width + i]);
		}
	}
	return vision_ds_Matrix2D.from_array_array_float(extractedMatrix);
};
var vision_algorithms_PerspectiveWarp = function() { };
$hxClasses["vision.algorithms.PerspectiveWarp"] = vision_algorithms_PerspectiveWarp;
vision_algorithms_PerspectiveWarp.__name__ = "vision.algorithms.PerspectiveWarp";
vision_algorithms_PerspectiveWarp.generateMatrix = function(destinationPoints,sourcePoints) {
	if(sourcePoints.length != 4 || sourcePoints.length != 4) {
		throw haxe_Exception.thrown("");
	}
	var M = new vision_ds_Array2D(3,3);
	var _g = [];
	var _g1 = [];
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g.push(_g1);
	var _g1 = [];
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g.push(_g1);
	var _g1 = [];
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g.push(_g1);
	var _g1 = [];
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g.push(_g1);
	var _g1 = [];
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g.push(_g1);
	var _g1 = [];
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g.push(_g1);
	var _g1 = [];
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g.push(_g1);
	var _g1 = [];
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g1.push(0.);
	_g.push(_g1);
	var a = _g;
	var _g = [];
	_g.push(0.);
	_g.push(0.);
	_g.push(0.);
	_g.push(0.);
	_g.push(0.);
	_g.push(0.);
	_g.push(0.);
	_g.push(0.);
	var b = _g;
	var _g = 0;
	while(_g < 4) {
		var i = _g++;
		a[i][0] = a[i + 4][3] = destinationPoints[i].x;
		a[i][1] = a[i + 4][4] = destinationPoints[i].y;
		a[i][2] = a[i + 4][5] = 1;
		a[i][3] = a[i][4] = a[i][5] = a[i + 4][0] = a[i + 4][1] = a[i + 4][2] = 0;
		a[i][6] = -destinationPoints[i].x * sourcePoints[i].x;
		a[i][7] = -destinationPoints[i].y * sourcePoints[i].x;
		a[i + 4][6] = -destinationPoints[i].x * sourcePoints[i].y;
		a[i + 4][7] = -destinationPoints[i].y * sourcePoints[i].y;
		b[i] = sourcePoints[i].x;
		b[i + 4] = sourcePoints[i].y;
	}
	var x = vision_algorithms_Cramer.solveVariablesFor(vision_ds_Matrix2D.from_array_array_float(a),b);
	x[8] = 1.;
	M.inner[0 * M.width] = x[0];
	M.inner[1 + 0 * M.width] = x[1];
	M.inner[2 + 0 * M.width] = x[2];
	M.inner[M.width] = x[3];
	M.inner[1 + M.width] = x[4];
	M.inner[2 + M.width] = x[5];
	M.inner[2 * M.width] = x[6];
	M.inner[1 + 2 * M.width] = x[7];
	M.inner[2 + 2 * M.width] = x[8];
	return M;
};
var vision_algorithms_Radix = function() { };
$hxClasses["vision.algorithms.Radix"] = vision_algorithms_Radix;
vision_algorithms_Radix.__name__ = "vision.algorithms.Radix";
vision_algorithms_Radix.getMax = function(array,endIndex) {
	if(endIndex == null) {
		endIndex = array.length;
	}
	var potential = array[0];
	var _g = 1;
	var _g1 = endIndex;
	while(_g < _g1) {
		var i = _g++;
		if(array[i] > potential) {
			potential = array[i];
		}
	}
	return potential;
};
vision_algorithms_Radix.countingSort = function(array,exp,endIndex) {
	if(endIndex == null) {
		endIndex = array.length;
	}
	var output = [];
	var i = -1;
	var _g = [];
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	var count = _g;
	while(++i < endIndex) {
		var tmp = (array[i] / exp | 0) % 10;
		count[tmp]++;
	}
	i = 0;
	while(++i < 10) count[i] += count[i - 1];
	i = endIndex;
	while(--i >= 0) {
		output[count[(array[i] / exp | 0) % 10] - 1] = array[i];
		var tmp = (array[i] / exp | 0) % 10;
		count[tmp]--;
	}
	i = -1;
	while(++i < endIndex) array[i] = output[i];
	return output;
};
vision_algorithms_Radix.sort = function(main) {
	var negatives = [];
	var positives = [];
	var _g = 0;
	var _g1 = main.length;
	while(_g < _g1) {
		var i = _g++;
		if(main[i] < 0) {
			negatives.push(-main[i]);
		} else {
			positives.push(main[i]);
		}
	}
	var array = negatives;
	var max = vision_algorithms_Radix.getMax(array,array.length);
	var exp = 1;
	while(max / exp > 0) {
		array = vision_algorithms_Radix.countingSort(array,exp,array.length);
		exp *= 10;
	}
	var array = positives;
	var max = vision_algorithms_Radix.getMax(array,array.length);
	var exp = 1;
	while(max / exp > 0) {
		array = vision_algorithms_Radix.countingSort(array,exp,array.length);
		exp *= 10;
	}
	negatives.reverse();
	var result = new Array(negatives.length);
	var _g = 0;
	var _g1 = negatives.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = -negatives[i];
	}
	negatives = result;
	main = negatives.concat(positives);
	return main;
};
var vision_ds_Array2D = function(width,height,fillWith) {
	this.width = width;
	this.height = height;
	this.inner = [];
	this.inner.length = width * height;
	if(fillWith != null) {
		var _g = 0;
		var _g1 = this.inner.length;
		while(_g < _g1) {
			var i = _g++;
			this.inner[i] = fillWith;
		}
	}
};
$hxClasses["vision.ds.Array2D"] = vision_ds_Array2D;
vision_ds_Array2D.__name__ = "vision.ds.Array2D";
vision_ds_Array2D.prototype = {
	inner: null
	,width: null
	,height: null
	,get: function(x,y) {
		return this.inner[y * this.width + x];
	}
	,set: function(x,y,val) {
		return this.inner[x + y * this.width] = val;
	}
	,setMultiple: function(points,val) {
		var _g = 0;
		while(_g < points.length) {
			var p = points[_g];
			++_g;
			this.inner[p.x + p.y * this.width] = val;
		}
	}
	,row: function(y) {
		var _g = [];
		var _g1 = y * this.width;
		var _g2 = y * this.width + this.width;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(this.inner[i]);
		}
		return _g;
	}
	,column: function(x) {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.height;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(this.inner[i * this.width + x]);
		}
		return _g;
	}
	,iterator: function() {
		return new haxe_iterators_ArrayIterator(this.inner);
	}
	,fill: function(value) {
		var _g = 0;
		var _g1 = this.inner.length;
		while(_g < _g1) {
			var i = _g++;
			this.inner[i] = value;
		}
		return this;
	}
	,clone: function() {
		var arr = new vision_ds_Array2D(this.width,this.height);
		arr.inner = this.inner.slice();
		return arr;
	}
	,toString: function() {
		var str = "\n[[";
		var counter = 0;
		var _g = 0;
		var _g1 = this.inner;
		while(_g < _g1.length) {
			var item = _g1[_g];
			++_g;
			if(counter < this.width) {
				var add = ", " + Std.string(item);
				if(counter == 0) {
					add = HxOverrides.substr(add,2,null);
				}
				str += add;
				++counter;
			} else {
				counter = 0;
				str += "],\n [";
				var add1 = "" + Std.string(item);
				str += add1;
				++counter;
			}
		}
		return str.substring(0,str.length) + "]]";
	}
	,get_length: function() {
		return this.inner.length;
	}
	,set_length: function(value) {
		this.inner.length = value;
		return value;
	}
	,set_width: function(value) {
		this.inner.length = value * this.height;
		return this.width = value;
	}
	,set_height: function(value) {
		this.inner.length = this.width * value;
		return this.height = value;
	}
	,get_item: function(index) {
		return this.inner[index[0] + index[1] * this.height];
	}
	,set_item: function(index,value) {
		return this.inner[index[0] + index[1] * this.height] = value;
	}
	,to2DArray: function() {
		var arr = [];
		var _g = 0;
		var _g1 = this.height;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = [];
			var _g3 = y * this.width;
			var _g4 = y * this.width + this.width;
			while(_g3 < _g4) {
				var i = _g3++;
				_g2.push(this.inner[i]);
			}
			arr.push(_g2);
		}
		return arr;
	}
	,__class__: vision_ds_Array2D
	,__properties__: {set_length:"set_length",get_length:"get_length",set_height:"set_height",set_width:"set_width"}
};
var vision_ds_ByteArray = {};
vision_ds_ByteArray.read = function(this1,index) {
	return this1.b[index];
};
vision_ds_ByteArray.write = function(this1,index,value) {
	this1.b[index] = value;
};
vision_ds_ByteArray.setUInt8 = function(this1,pos,v) {
	this1.b[pos] = v;
};
vision_ds_ByteArray.getUInt8 = function(this1,pos) {
	return this1.b[pos];
};
vision_ds_ByteArray.setUInt32 = function(this1,pos,value) {
	this1.setInt32(pos,value);
};
vision_ds_ByteArray.getUInt32 = function(this1,pos) {
	return this1.getInt32(pos);
};
vision_ds_ByteArray.setInt8 = function(this1,pos,v) {
	this1.b[pos] = v;
};
vision_ds_ByteArray.getInt8 = function(this1,pos) {
	var v = this1.b[pos];
	return v * -(v >> 7);
};
vision_ds_ByteArray.setBytes = function(this1,pos,array) {
	this1.blit(pos,array,0,array.length);
};
vision_ds_ByteArray.getBytes = function(this1,pos,length) {
	var this2 = new haxe_io_Bytes(new ArrayBuffer(length));
	this2.fill(0,length,0);
	var array = this2;
	array.blit(0,this1,pos,length);
	return array;
};
vision_ds_ByteArray._new = function(length,fillWith) {
	if(fillWith == null) {
		fillWith = 0;
	}
	var this1 = new haxe_io_Bytes(new ArrayBuffer(length));
	this1.fill(0,length,fillWith);
	return this1;
};
vision_ds_ByteArray.resize = function(this1,length) {
	var newBytes = new haxe_io_Bytes(new ArrayBuffer(length));
	var values = [newBytes.length,this1.length];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	newBytes.blit(0,this1,0,min);
	this1 = newBytes;
};
vision_ds_ByteArray.concat = function(this1,array) {
	var newBytes = new haxe_io_Bytes(new ArrayBuffer(this1.length + array.length));
	newBytes.blit(0,this1,0,this1.length);
	newBytes.blit(this1.length,array,0,array.length);
	return newBytes;
};
vision_ds_ByteArray.isEmpty = function(this1) {
	var _g = 0;
	var _g1 = this1.length;
	while(_g < _g1) {
		var i = _g++;
		if(this1.b[i] != 0) {
			return false;
		}
	}
	return true;
};
vision_ds_ByteArray.toArray = function(this1) {
	var _g = [];
	var _g1 = 0;
	var _g2 = this1.length;
	while(_g1 < _g2) {
		var i = _g1++;
		_g.push(this1.b[i]);
	}
	return _g;
};
var vision_ds_Color = {};
vision_ds_Color.__properties__ = {set_lightness:"set_lightness",get_lightness:"get_lightness",set_brightness:"set_brightness",get_brightness:"get_brightness",set_saturation:"set_saturation",get_saturation:"get_saturation",set_hue:"set_hue",get_hue:"get_hue",set_rgb:"set_rgb",get_rgb:"get_rgb",set_black:"set_black",get_black:"get_black",set_yellow:"set_yellow",get_yellow:"get_yellow",set_magenta:"set_magenta",get_magenta:"get_magenta",set_cyan:"set_cyan",get_cyan:"get_cyan",set_alphaFloat:"set_alphaFloat",get_alphaFloat:"get_alphaFloat",set_greenFloat:"set_greenFloat",get_greenFloat:"get_greenFloat",set_blueFloat:"set_blueFloat",get_blueFloat:"get_blueFloat",set_redFloat:"set_redFloat",get_redFloat:"get_redFloat",set_alpha:"set_alpha",get_alpha:"get_alpha",set_green:"set_green",get_green:"get_green",set_blue:"set_blue",get_blue:"get_blue",set_red:"set_red",get_red:"get_red"};
vision_ds_Color.fromInt = function(value) {
	var value1 = value;
	if(value1 == null) {
		value1 = 0;
	}
	return value1;
};
vision_ds_Color.fromRGBA = function(Red,Green,Blue,Alpha) {
	if(Alpha == null) {
		Alpha = 255;
	}
	var color = 0;
	var Alpha1 = Alpha;
	if(Alpha1 == null) {
		Alpha1 = 255;
	}
	color &= -16711681;
	color |= (Red > 255 ? 255 : Red < 0 ? 0 : Red) << 16;
	color &= -65281;
	color |= (Green > 255 ? 255 : Green < 0 ? 0 : Green) << 8;
	color &= -256;
	color |= Blue > 255 ? 255 : Blue < 0 ? 0 : Blue;
	color &= 16777215;
	color |= (Alpha1 > 255 ? 255 : Alpha1 < 0 ? 0 : Alpha1) << 24;
	return color;
};
vision_ds_Color.from8Bit = function(Value) {
	var color = 0;
	var Alpha = 1;
	if(Alpha == null) {
		Alpha = 255;
	}
	color &= -16711681;
	color |= (Value > 255 ? 255 : Value < 0 ? 0 : Value) << 16;
	color &= -65281;
	color |= (Value > 255 ? 255 : Value < 0 ? 0 : Value) << 8;
	color &= -256;
	color |= Value > 255 ? 255 : Value < 0 ? 0 : Value;
	color &= 16777215;
	color |= (Alpha > 255 ? 255 : Alpha < 0 ? 0 : Alpha) << 24;
	return color;
};
vision_ds_Color.fromRGBAFloat = function(Red,Green,Blue,Alpha) {
	if(Alpha == null) {
		Alpha = 1;
	}
	var color = 0;
	var Alpha1 = Alpha;
	if(Alpha1 == null) {
		Alpha1 = 1;
	}
	var value = Math.round(Red * 255);
	color &= -16711681;
	color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
	var value = Math.round(Green * 255);
	color &= -65281;
	color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
	var value = Math.round(Blue * 255);
	color &= -256;
	color |= value > 255 ? 255 : value < 0 ? 0 : value;
	var value = Math.round(Alpha1 * 255);
	color &= 16777215;
	color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
	return color;
};
vision_ds_Color.fromCMYK = function(Cyan,Magenta,Yellow,Black,Alpha) {
	if(Alpha == null) {
		Alpha = 1;
	}
	var color = 0;
	var Alpha1 = Alpha;
	if(Alpha1 == null) {
		Alpha1 = 1;
	}
	var value = (1 - Cyan) * (1 - Black);
	var value1 = Math.round(value * 255);
	color &= -16711681;
	color |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
	var value = (1 - Magenta) * (1 - Black);
	var value1 = Math.round(value * 255);
	color &= -65281;
	color |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
	var value = (1 - Yellow) * (1 - Black);
	var value1 = Math.round(value * 255);
	color &= -256;
	color |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
	var value = Math.round(Alpha1 * 255);
	color &= 16777215;
	color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
	return color;
};
vision_ds_Color.fromHSB = function(Hue,Saturation,Brightness,Alpha) {
	if(Alpha == null) {
		Alpha = 1;
	}
	var color = 0;
	var chroma = Brightness * Saturation;
	var match = Brightness - chroma;
	var Hue1 = Hue;
	var Chroma = chroma;
	Hue1 %= 360;
	var hueD = Hue1 / 60;
	var mid = Chroma * (1 - Math.abs(hueD % 2 - 1)) + match;
	Chroma += match;
	switch(hueD | 0) {
	case 0:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Chroma * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(mid * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(match * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 1:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(mid * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Chroma * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(match * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 2:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(match * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Chroma * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(mid * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 3:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(match * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(mid * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Chroma * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 4:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(mid * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(match * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Chroma * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 5:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Chroma * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(match * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(mid * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	}
	return color;
};
vision_ds_Color.fromHSL = function(Hue,Saturation,Lightness,Alpha) {
	if(Alpha == null) {
		Alpha = 1;
	}
	var color = 0;
	var chroma = (1 - Math.abs(2 * Lightness - 1)) * Saturation;
	var match = Lightness - chroma / 2;
	var Hue1 = Hue;
	var Chroma = chroma;
	Hue1 %= 360;
	var hueD = Hue1 / 60;
	var mid = Chroma * (1 - Math.abs(hueD % 2 - 1)) + match;
	Chroma += match;
	switch(hueD | 0) {
	case 0:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Chroma * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(mid * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(match * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 1:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(mid * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Chroma * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(match * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 2:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(match * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Chroma * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(mid * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 3:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(match * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(mid * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Chroma * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 4:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(mid * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(match * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Chroma * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 5:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Chroma * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(match * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(mid * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	}
	return color;
};
vision_ds_Color.fromString = function(str) {
	var result = null;
	str = StringTools.trim(str);
	if(vision_ds_Color.COLOR_REGEX.match(str)) {
		var hexColor = "0x" + vision_ds_Color.COLOR_REGEX.matched(2);
		var value = Std.parseInt(hexColor);
		if(value == null) {
			value = 0;
		}
		result = value;
		if(hexColor.length == 8) {
			var value = Math.round(255);
			result &= 16777215;
			result |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		}
	}
	return result;
};
vision_ds_Color.getHSBColorWheel = function(Alpha) {
	if(Alpha == null) {
		Alpha = 255;
	}
	var _g = [];
	var _g1 = 0;
	while(_g1 < 360) {
		var c = _g1++;
		_g.push(vision_ds_Color.fromHSB(c,1.0,1.0,Alpha));
	}
	return _g;
};
vision_ds_Color.interpolate = function(Color1,Color2,Factor) {
	if(Factor == null) {
		Factor = 0.5;
	}
	var r = ((Color2 >> 16 & 255) - (Color1 >> 16 & 255)) * Factor + (Color1 >> 16 & 255) | 0;
	var g = ((Color2 >> 8 & 255) - (Color1 >> 8 & 255)) * Factor + (Color1 >> 8 & 255) | 0;
	var b = ((Color2 & 255) - (Color1 & 255)) * Factor + (Color1 & 255) | 0;
	var a = ((Color2 >> 24 & 255) - (Color1 >> 24 & 255)) * Factor + (Color1 >> 24 & 255) | 0;
	var Alpha = a;
	if(Alpha == null) {
		Alpha = 255;
	}
	var color = 0;
	var Alpha1 = Alpha;
	if(Alpha1 == null) {
		Alpha1 = 255;
	}
	color &= -16711681;
	color |= (r > 255 ? 255 : r < 0 ? 0 : r) << 16;
	color &= -65281;
	color |= (g > 255 ? 255 : g < 0 ? 0 : g) << 8;
	color &= -256;
	color |= b > 255 ? 255 : b < 0 ? 0 : b;
	color &= 16777215;
	color |= (Alpha1 > 255 ? 255 : Alpha1 < 0 ? 0 : Alpha1) << 24;
	return color;
};
vision_ds_Color.gradient = function(Color1,Color2,Steps,Ease) {
	var output = [];
	if(Ease == null) {
		Ease = function(t) {
			return t;
		};
	}
	var _g = 0;
	var _g1 = Steps;
	while(_g < _g1) {
		var step = _g++;
		var Factor = Ease(step / (Steps - 1));
		if(Factor == null) {
			Factor = 0.5;
		}
		var r = ((Color2 >> 16 & 255) - (Color1 >> 16 & 255)) * Factor + (Color1 >> 16 & 255) | 0;
		var g = ((Color2 >> 8 & 255) - (Color1 >> 8 & 255)) * Factor + (Color1 >> 8 & 255) | 0;
		var b = ((Color2 & 255) - (Color1 & 255)) * Factor + (Color1 & 255) | 0;
		var a = ((Color2 >> 24 & 255) - (Color1 >> 24 & 255)) * Factor + (Color1 >> 24 & 255) | 0;
		var Alpha = a;
		if(Alpha == null) {
			Alpha = 255;
		}
		var color = 0;
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 255;
		}
		color &= -16711681;
		color |= (r > 255 ? 255 : r < 0 ? 0 : r) << 16;
		color &= -65281;
		color |= (g > 255 ? 255 : g < 0 ? 0 : g) << 8;
		color &= -256;
		color |= b > 255 ? 255 : b < 0 ? 0 : b;
		color &= 16777215;
		color |= (Alpha1 > 255 ? 255 : Alpha1 < 0 ? 0 : Alpha1) << 24;
		output[step] = color;
	}
	return output;
};
vision_ds_Color.makeRandom = function(alphaLock,alphaValue) {
	if(alphaValue == null) {
		alphaValue = 255;
	}
	if(alphaLock == null) {
		alphaLock = true;
	}
	var Red = Math.random();
	var Green = Math.random();
	var Blue = Math.random();
	var Alpha = alphaLock ? alphaValue : Math.random();
	if(Alpha == null) {
		Alpha = 1;
	}
	var color = 0;
	var Alpha1 = Alpha;
	if(Alpha1 == null) {
		Alpha1 = 1;
	}
	var value = Math.round(Red * 255);
	color &= -16711681;
	color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
	var value = Math.round(Green * 255);
	color &= -65281;
	color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
	var value = Math.round(Blue * 255);
	color &= -256;
	color |= value > 255 ? 255 : value < 0 ? 0 : value;
	var value = Math.round(Alpha1 * 255);
	color &= 16777215;
	color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
	return color;
};
vision_ds_Color.multiply = function(lhs,rhs) {
	var Red = (lhs >> 16 & 255) / 255 * ((rhs >> 16 & 255) / 255);
	var Green = (lhs >> 8 & 255) / 255 * ((rhs >> 8 & 255) / 255);
	var Blue = (lhs & 255) / 255 * ((rhs & 255) / 255);
	var Alpha = (lhs >> 24 & 255) / 255 * ((rhs >> 24 & 255) / 255);
	if(Alpha == null) {
		Alpha = 1;
	}
	var color = 0;
	var Alpha1 = Alpha;
	if(Alpha1 == null) {
		Alpha1 = 1;
	}
	var value = Math.round(Red * 255);
	color &= -16711681;
	color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
	var value = Math.round(Green * 255);
	color &= -65281;
	color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
	var value = Math.round(Blue * 255);
	color &= -256;
	color |= value > 255 ? 255 : value < 0 ? 0 : value;
	var value = Math.round(Alpha1 * 255);
	color &= 16777215;
	color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
	return color;
};
vision_ds_Color.add = function(lhs,rhs) {
	var Red = (lhs >> 16 & 255) + (rhs >> 16 & 255);
	var Green = (lhs >> 8 & 255) + (rhs >> 8 & 255);
	var Blue = (lhs & 255) + (rhs & 255);
	var Alpha = (lhs >> 24 & 255) + (rhs >> 24 & 255);
	if(Alpha == null) {
		Alpha = 255;
	}
	var color = 0;
	var Alpha1 = Alpha;
	if(Alpha1 == null) {
		Alpha1 = 255;
	}
	color &= -16711681;
	color |= (Red > 255 ? 255 : Red < 0 ? 0 : Red) << 16;
	color &= -65281;
	color |= (Green > 255 ? 255 : Green < 0 ? 0 : Green) << 8;
	color &= -256;
	color |= Blue > 255 ? 255 : Blue < 0 ? 0 : Blue;
	color &= 16777215;
	color |= (Alpha1 > 255 ? 255 : Alpha1 < 0 ? 0 : Alpha1) << 24;
	return color;
};
vision_ds_Color.subtract = function(lhs,rhs) {
	var Red = (lhs >> 16 & 255) - (rhs >> 16 & 255);
	var Green = (lhs >> 8 & 255) - (rhs >> 8 & 255);
	var Blue = (lhs & 255) - (rhs & 255);
	var Alpha = (lhs >> 24 & 255) - (rhs >> 24 & 255);
	if(Alpha == null) {
		Alpha = 255;
	}
	var color = 0;
	var Alpha1 = Alpha;
	if(Alpha1 == null) {
		Alpha1 = 255;
	}
	color &= -16711681;
	color |= (Red > 255 ? 255 : Red < 0 ? 0 : Red) << 16;
	color &= -65281;
	color |= (Green > 255 ? 255 : Green < 0 ? 0 : Green) << 8;
	color &= -256;
	color |= Blue > 255 ? 255 : Blue < 0 ? 0 : Blue;
	color &= 16777215;
	color |= (Alpha1 > 255 ? 255 : Alpha1 < 0 ? 0 : Alpha1) << 24;
	return color;
};
vision_ds_Color.divide = function(lhs,rhs) {
	var Red = ((lhs >> 16 & 255) / (rhs >> 16 & 255) == 0 ? 1 : rhs >> 16 & 255) | 0;
	var Green = ((lhs >> 8 & 255) / (rhs >> 8 & 255) == 0 ? 1 : rhs >> 8 & 255) | 0;
	var Blue = ((lhs & 255) / (rhs & 255) == 0 ? 1 : rhs & 255) | 0;
	var Alpha = ((lhs >> 24 & 255) / (rhs >> 24 & 255) == 0 ? 1 : rhs >> 24 & 255) | 0;
	if(Alpha == null) {
		Alpha = 255;
	}
	var color = 0;
	var Alpha1 = Alpha;
	if(Alpha1 == null) {
		Alpha1 = 255;
	}
	color &= -16711681;
	color |= (Red > 255 ? 255 : Red < 0 ? 0 : Red) << 16;
	color &= -65281;
	color |= (Green > 255 ? 255 : Green < 0 ? 0 : Green) << 8;
	color &= -256;
	color |= Blue > 255 ? 255 : Blue < 0 ? 0 : Blue;
	color &= 16777215;
	color |= (Alpha1 > 255 ? 255 : Alpha1 < 0 ? 0 : Alpha1) << 24;
	return color;
};
vision_ds_Color.getComplementHarmony = function(this1) {
	var value = (vision_ds_Color.get_hue(this1) | 0) + 180;
	var range = 351;
	if(value < 0) {
		value += range * ((0 - value) / range + 1 | 0);
	}
	return vision_ds_Color.fromHSB(value % range,Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)),(Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)) - Math.min((this1 >> 16 & 255) / 255,Math.min((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)),(this1 >> 24 & 255) / 255);
};
vision_ds_Color.getAnalogousHarmony = function(this1,Threshold) {
	if(Threshold == null) {
		Threshold = 30;
	}
	var value = (vision_ds_Color.get_hue(this1) | 0) - Threshold;
	var range = 351;
	if(value < 0) {
		value += range * ((0 - value) / range + 1 | 0);
	}
	var warmer = vision_ds_Color.fromHSB(value % range,(Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)) - Math.min((this1 >> 16 & 255) / 255,Math.min((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)),Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)),(this1 >> 24 & 255) / 255);
	var value = (vision_ds_Color.get_hue(this1) | 0) + Threshold;
	var range = 351;
	if(value < 0) {
		value += range * ((0 - value) / range + 1 | 0);
	}
	var colder = vision_ds_Color.fromHSB(value % range,(Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)) - Math.min((this1 >> 16 & 255) / 255,Math.min((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)),Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)),(this1 >> 24 & 255) / 255);
	return { original : this1, warmer : warmer, colder : colder};
};
vision_ds_Color.getSplitComplementHarmony = function(this1,Threshold) {
	if(Threshold == null) {
		Threshold = 30;
	}
	var value = (vision_ds_Color.get_hue(this1) | 0) + 180;
	var range = 351;
	if(value < 0) {
		value += range * ((0 - value) / range + 1 | 0);
	}
	var oppositeHue = value % range;
	var value = oppositeHue - Threshold;
	var range = 351;
	if(value < 0) {
		value += range * ((0 - value) / range + 1 | 0);
	}
	var warmer = vision_ds_Color.fromHSB(value % range,(Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)) - Math.min((this1 >> 16 & 255) / 255,Math.min((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)),Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)),(this1 >> 24 & 255) / 255);
	var value = oppositeHue + Threshold;
	var range = 351;
	if(value < 0) {
		value += range * ((0 - value) / range + 1 | 0);
	}
	var colder = vision_ds_Color.fromHSB(value % range,(Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)) - Math.min((this1 >> 16 & 255) / 255,Math.min((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)),Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)),(this1 >> 24 & 255) / 255);
	return { original : this1, warmer : warmer, colder : colder};
};
vision_ds_Color.getTriadicHarmony = function(this1) {
	var value = (vision_ds_Color.get_hue(this1) | 0) + 120;
	var range = 360;
	if(value < 0) {
		value += range * ((0 - value) / range + 1 | 0);
	}
	var triadic1 = vision_ds_Color.fromHSB(value % range,(Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)) - Math.min((this1 >> 16 & 255) / 255,Math.min((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)),Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)),(this1 >> 24 & 255) / 255);
	var value = (vision_ds_Color.get_hue(triadic1) | 0) + 120;
	var range = 360;
	if(value < 0) {
		value += range * ((0 - value) / range + 1 | 0);
	}
	var triadic2 = vision_ds_Color.fromHSB(value % range,(Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)) - Math.min((this1 >> 16 & 255) / 255,Math.min((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)),Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)),(this1 >> 24 & 255) / 255);
	return { color1 : this1, color2 : triadic1, color3 : triadic2};
};
vision_ds_Color.to24Bit = function(this1) {
	return this1 & 16777215;
};
vision_ds_Color.toHexString = function(this1,Alpha,Prefix) {
	if(Prefix == null) {
		Prefix = true;
	}
	if(Alpha == null) {
		Alpha = true;
	}
	var tmp = Alpha ? StringTools.hex(this1 >> 24 & 255,2) : "";
	return (Prefix ? "0x" : "") + tmp + StringTools.hex(this1 >> 16 & 255,2) + StringTools.hex(this1 >> 8 & 255,2) + StringTools.hex(this1 & 255,2);
};
vision_ds_Color.toWebString = function(this1) {
	var Alpha = false;
	var Prefix = false;
	if(Prefix == null) {
		Prefix = true;
	}
	if(Alpha == null) {
		Alpha = true;
	}
	var tmp = Alpha ? StringTools.hex(this1 >> 24 & 255,2) : "";
	return "#" + ((Prefix ? "0x" : "") + tmp + StringTools.hex(this1 >> 16 & 255,2) + StringTools.hex(this1 >> 8 & 255,2) + StringTools.hex(this1 & 255,2));
};
vision_ds_Color.darken = function(this1,Factor) {
	if(Factor == null) {
		Factor = 0.2;
	}
	Factor = vision_tools_MathTools.boundFloat(Factor,0,1);
	var output = this1;
	var value = (Math.max((output >> 16 & 255) / 255,Math.max((output >> 8 & 255) / 255,(output & 255) / 255)) + Math.min((output >> 16 & 255) / 255,Math.min((output >> 8 & 255) / 255,(output & 255) / 255))) / 2 * (1 - Factor);
	var Hue = vision_ds_Color.get_hue(output);
	var Alpha = (output >> 24 & 255) / 255;
	var chroma = (1 - Math.abs(2 * value - 1)) * ((Math.max((output >> 16 & 255) / 255,Math.max((output >> 8 & 255) / 255,(output & 255) / 255)) - Math.min((output >> 16 & 255) / 255,Math.min((output >> 8 & 255) / 255,(output & 255) / 255))) / Math.max((output >> 16 & 255) / 255,Math.max((output >> 8 & 255) / 255,(output & 255) / 255)));
	var match = value - chroma / 2;
	var Hue1 = Hue;
	var Chroma = chroma;
	Hue1 %= 360;
	var hueD = Hue1 / 60;
	var mid = Chroma * (1 - Math.abs(hueD % 2 - 1)) + match;
	Chroma += match;
	switch(hueD | 0) {
	case 0:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Chroma * 255);
		output &= -16711681;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(mid * 255);
		output &= -65281;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(match * 255);
		output &= -256;
		output |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		output &= 16777215;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 1:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(mid * 255);
		output &= -16711681;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Chroma * 255);
		output &= -65281;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(match * 255);
		output &= -256;
		output |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		output &= 16777215;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 2:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(match * 255);
		output &= -16711681;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Chroma * 255);
		output &= -65281;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(mid * 255);
		output &= -256;
		output |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		output &= 16777215;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 3:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(match * 255);
		output &= -16711681;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(mid * 255);
		output &= -65281;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Chroma * 255);
		output &= -256;
		output |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		output &= 16777215;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 4:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(mid * 255);
		output &= -16711681;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(match * 255);
		output &= -65281;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Chroma * 255);
		output &= -256;
		output |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		output &= 16777215;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 5:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Chroma * 255);
		output &= -16711681;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(match * 255);
		output &= -65281;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(mid * 255);
		output &= -256;
		output |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		output &= 16777215;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	}
	return output;
};
vision_ds_Color.lighten = function(this1,Factor) {
	if(Factor == null) {
		Factor = 0.2;
	}
	Factor = vision_tools_MathTools.boundFloat(Factor,0,1);
	var output = this1;
	var value = (Math.max((output >> 16 & 255) / 255,Math.max((output >> 8 & 255) / 255,(output & 255) / 255)) + Math.min((output >> 16 & 255) / 255,Math.min((output >> 8 & 255) / 255,(output & 255) / 255))) / 2 + (1 - (Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)) + Math.min((this1 >> 16 & 255) / 255,Math.min((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) / 2) * Factor;
	var Hue = vision_ds_Color.get_hue(output);
	var Alpha = (output >> 24 & 255) / 255;
	var chroma = (1 - Math.abs(2 * value - 1)) * ((Math.max((output >> 16 & 255) / 255,Math.max((output >> 8 & 255) / 255,(output & 255) / 255)) - Math.min((output >> 16 & 255) / 255,Math.min((output >> 8 & 255) / 255,(output & 255) / 255))) / Math.max((output >> 16 & 255) / 255,Math.max((output >> 8 & 255) / 255,(output & 255) / 255)));
	var match = value - chroma / 2;
	var Hue1 = Hue;
	var Chroma = chroma;
	Hue1 %= 360;
	var hueD = Hue1 / 60;
	var mid = Chroma * (1 - Math.abs(hueD % 2 - 1)) + match;
	Chroma += match;
	switch(hueD | 0) {
	case 0:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Chroma * 255);
		output &= -16711681;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(mid * 255);
		output &= -65281;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(match * 255);
		output &= -256;
		output |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		output &= 16777215;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 1:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(mid * 255);
		output &= -16711681;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Chroma * 255);
		output &= -65281;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(match * 255);
		output &= -256;
		output |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		output &= 16777215;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 2:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(match * 255);
		output &= -16711681;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Chroma * 255);
		output &= -65281;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(mid * 255);
		output &= -256;
		output |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		output &= 16777215;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 3:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(match * 255);
		output &= -16711681;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(mid * 255);
		output &= -65281;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Chroma * 255);
		output &= -256;
		output |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		output &= 16777215;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 4:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(mid * 255);
		output &= -16711681;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(match * 255);
		output &= -65281;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Chroma * 255);
		output &= -256;
		output |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		output &= 16777215;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 5:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Chroma * 255);
		output &= -16711681;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(match * 255);
		output &= -65281;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(mid * 255);
		output &= -256;
		output |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		output &= 16777215;
		output |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	}
	return output;
};
vision_ds_Color.invert = function(this1) {
	var oldAlpha = this1 >> 24 & 255;
	var lhs = -1;
	var Red = (lhs >> 16 & 255) - (this1 >> 16 & 255);
	var Green = (lhs >> 8 & 255) - (this1 >> 8 & 255);
	var Blue = (lhs & 255) - (this1 & 255);
	var Alpha = (lhs >> 24 & 255) - (this1 >> 24 & 255);
	if(Alpha == null) {
		Alpha = 255;
	}
	var color = 0;
	var Alpha1 = Alpha;
	if(Alpha1 == null) {
		Alpha1 = 255;
	}
	color &= -16711681;
	color |= (Red > 255 ? 255 : Red < 0 ? 0 : Red) << 16;
	color &= -65281;
	color |= (Green > 255 ? 255 : Green < 0 ? 0 : Green) << 8;
	color &= -256;
	color |= Blue > 255 ? 255 : Blue < 0 ? 0 : Blue;
	color &= 16777215;
	color |= (Alpha1 > 255 ? 255 : Alpha1 < 0 ? 0 : Alpha1) << 24;
	var output = color;
	output &= 16777215;
	output |= (oldAlpha > 255 ? 255 : oldAlpha < 0 ? 0 : oldAlpha) << 24;
	return output;
};
vision_ds_Color.setRGBA = function(this1,Red,Green,Blue,Alpha) {
	if(Alpha == null) {
		Alpha = 255;
	}
	this1 &= -16711681;
	this1 |= (Red > 255 ? 255 : Red < 0 ? 0 : Red) << 16;
	this1 &= -65281;
	this1 |= (Green > 255 ? 255 : Green < 0 ? 0 : Green) << 8;
	this1 &= -256;
	this1 |= Blue > 255 ? 255 : Blue < 0 ? 0 : Blue;
	this1 &= 16777215;
	this1 |= (Alpha > 255 ? 255 : Alpha < 0 ? 0 : Alpha) << 24;
	return this1;
};
vision_ds_Color.setRGBAFloat = function(this1,Red,Green,Blue,Alpha) {
	if(Alpha == null) {
		Alpha = 1;
	}
	var value = Math.round(Red * 255);
	this1 &= -16711681;
	this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
	var value = Math.round(Green * 255);
	this1 &= -65281;
	this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
	var value = Math.round(Blue * 255);
	this1 &= -256;
	this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
	var value = Math.round(Alpha * 255);
	this1 &= 16777215;
	this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
	return this1;
};
vision_ds_Color.setCMYK = function(this1,Cyan,Magenta,Yellow,Black,Alpha) {
	if(Alpha == null) {
		Alpha = 1;
	}
	var value = (1 - Cyan) * (1 - Black);
	var value1 = Math.round(value * 255);
	this1 &= -16711681;
	this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
	var value = (1 - Magenta) * (1 - Black);
	var value1 = Math.round(value * 255);
	this1 &= -65281;
	this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
	var value = (1 - Yellow) * (1 - Black);
	var value1 = Math.round(value * 255);
	this1 &= -256;
	this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
	var value = Math.round(Alpha * 255);
	this1 &= 16777215;
	this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
	return this1;
};
vision_ds_Color.setHSB = function(this1,Hue,Saturation,Brightness,Alpha) {
	var chroma = Brightness * Saturation;
	var match = Brightness - chroma;
	var Hue1 = Hue;
	var Chroma = chroma;
	Hue1 %= 360;
	var hueD = Hue1 / 60;
	var mid = Chroma * (1 - Math.abs(hueD % 2 - 1)) + match;
	Chroma += match;
	switch(hueD | 0) {
	case 0:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Chroma * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(mid * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(match * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 1:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(mid * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Chroma * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(match * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 2:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(match * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Chroma * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(mid * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 3:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(match * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(mid * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Chroma * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 4:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(mid * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(match * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Chroma * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 5:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Chroma * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(match * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(mid * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	}
	return this1;
};
vision_ds_Color.setHSL = function(this1,Hue,Saturation,Lightness,Alpha) {
	var chroma = (1 - Math.abs(2 * Lightness - 1)) * Saturation;
	var match = Lightness - chroma / 2;
	var Hue1 = Hue;
	var Chroma = chroma;
	Hue1 %= 360;
	var hueD = Hue1 / 60;
	var mid = Chroma * (1 - Math.abs(hueD % 2 - 1)) + match;
	Chroma += match;
	switch(hueD | 0) {
	case 0:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Chroma * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(mid * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(match * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 1:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(mid * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Chroma * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(match * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 2:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(match * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Chroma * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(mid * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 3:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(match * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(mid * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Chroma * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 4:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(mid * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(match * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Chroma * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 5:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Chroma * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(match * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(mid * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	}
	return this1;
};
vision_ds_Color.setHSChromaMatch = function(this1,Hue,Saturation,Chroma,Match,Alpha) {
	Hue %= 360;
	var hueD = Hue / 60;
	var mid = Chroma * (1 - Math.abs(hueD % 2 - 1)) + Match;
	Chroma += Match;
	switch(hueD | 0) {
	case 0:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Chroma * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(mid * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Match * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 1:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(mid * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Chroma * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Match * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 2:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Match * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Chroma * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(mid * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 3:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Match * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(mid * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Chroma * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 4:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(mid * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Match * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Chroma * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	case 5:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Chroma * 255);
		this1 &= -16711681;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Match * 255);
		this1 &= -65281;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(mid * 255);
		this1 &= -256;
		this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		break;
	}
	return this1;
};
vision_ds_Color.grayscale = function(this1,simple) {
	if(simple == null) {
		simple = false;
	}
	var gray = simple ? ((this1 >> 16 & 255) + (this1 >> 8 & 255) + (this1 & 255)) / 3 | 0 : 0.2126 * (this1 >> 16 & 255) + 0.7152 * (this1 >> 8 & 255) + 0.0722 * (this1 & 255) | 0;
	var Alpha = this1 >> 24 & 255;
	if(Alpha == null) {
		Alpha = 255;
	}
	this1 &= -16711681;
	this1 |= (gray > 255 ? 255 : gray < 0 ? 0 : gray) << 16;
	this1 &= -65281;
	this1 |= (gray > 255 ? 255 : gray < 0 ? 0 : gray) << 8;
	this1 &= -256;
	this1 |= gray > 255 ? 255 : gray < 0 ? 0 : gray;
	this1 &= 16777215;
	this1 |= (Alpha > 255 ? 255 : Alpha < 0 ? 0 : Alpha) << 24;
	this1 = this1;
	return this1;
};
vision_ds_Color.blackOrWhite = function(this1,threshold) {
	if(threshold == null) {
		threshold = 128;
	}
	var values = [this1 >> 16 & 255,this1 >> 8 & 255,this1 & 255];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var colorValue = max;
	var a = this1 >> 24 & 255;
	if(colorValue > threshold) {
		this1 = -1;
	} else {
		this1 = -16777216;
	}
	this1 &= 16777215;
	this1 |= (a > 255 ? 255 : a < 0 ? 0 : a) << 24;
	return this1;
};
vision_ds_Color._new = function(value) {
	if(value == null) {
		value = 0;
	}
	return value;
};
vision_ds_Color.getThis = function(this1) {
	return this1;
};
vision_ds_Color.validate = function(this1) {
};
vision_ds_Color.get_red = function(this1) {
	return this1 >> 16 & 255;
};
vision_ds_Color.get_green = function(this1) {
	return this1 >> 8 & 255;
};
vision_ds_Color.get_blue = function(this1) {
	return this1 & 255;
};
vision_ds_Color.get_alpha = function(this1) {
	return this1 >> 24 & 255;
};
vision_ds_Color.get_redFloat = function(this1) {
	return (this1 >> 16 & 255) / 255;
};
vision_ds_Color.get_greenFloat = function(this1) {
	return (this1 >> 8 & 255) / 255;
};
vision_ds_Color.get_blueFloat = function(this1) {
	return (this1 & 255) / 255;
};
vision_ds_Color.get_alphaFloat = function(this1) {
	return (this1 >> 24 & 255) / 255;
};
vision_ds_Color.set_red = function(this1,value) {
	this1 &= -16711681;
	this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
	return value;
};
vision_ds_Color.set_green = function(this1,value) {
	this1 &= -65281;
	this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
	return value;
};
vision_ds_Color.set_blue = function(this1,value) {
	this1 &= -256;
	this1 |= value > 255 ? 255 : value < 0 ? 0 : value;
	return value;
};
vision_ds_Color.set_alpha = function(this1,value) {
	this1 &= 16777215;
	this1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
	return value;
};
vision_ds_Color.set_redFloat = function(this1,value) {
	var value1 = Math.round(value * 255);
	this1 &= -16711681;
	this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
	return value;
};
vision_ds_Color.set_greenFloat = function(this1,value) {
	var value1 = Math.round(value * 255);
	this1 &= -65281;
	this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
	return value;
};
vision_ds_Color.set_blueFloat = function(this1,value) {
	var value1 = Math.round(value * 255);
	this1 &= -256;
	this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
	return value;
};
vision_ds_Color.set_alphaFloat = function(this1,value) {
	var value1 = Math.round(value * 255);
	this1 &= 16777215;
	this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
	return value;
};
vision_ds_Color.get_cyan = function(this1) {
	return (1 - (this1 >> 16 & 255) / 255 - (1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
};
vision_ds_Color.get_magenta = function(this1) {
	return (1 - (this1 >> 8 & 255) / 255 - (1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
};
vision_ds_Color.get_yellow = function(this1) {
	return (1 - (this1 & 255) / 255 - (1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
};
vision_ds_Color.get_black = function(this1) {
	return 1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
};
vision_ds_Color.set_cyan = function(this1,value) {
	var Magenta = (1 - (this1 >> 8 & 255) / 255 - (1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
	var Yellow = (1 - (this1 & 255) / 255 - (1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
	var Black = 1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
	var Alpha = (this1 >> 24 & 255) / 255;
	if(Alpha == null) {
		Alpha = 1;
	}
	var value1 = (1 - value) * (1 - Black);
	var value2 = Math.round(value1 * 255);
	this1 &= -16711681;
	this1 |= (value2 > 255 ? 255 : value2 < 0 ? 0 : value2) << 16;
	var value1 = (1 - Magenta) * (1 - Black);
	var value2 = Math.round(value1 * 255);
	this1 &= -65281;
	this1 |= (value2 > 255 ? 255 : value2 < 0 ? 0 : value2) << 8;
	var value1 = (1 - Yellow) * (1 - Black);
	var value2 = Math.round(value1 * 255);
	this1 &= -256;
	this1 |= value2 > 255 ? 255 : value2 < 0 ? 0 : value2;
	var value1 = Math.round(Alpha * 255);
	this1 &= 16777215;
	this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
	return value;
};
vision_ds_Color.set_magenta = function(this1,value) {
	var Yellow = (1 - (this1 & 255) / 255 - (1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
	var Black = 1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
	var Alpha = (this1 >> 24 & 255) / 255;
	if(Alpha == null) {
		Alpha = 1;
	}
	var value1 = (1 - (1 - (this1 >> 16 & 255) / 255 - (1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) * (1 - Black);
	var value2 = Math.round(value1 * 255);
	this1 &= -16711681;
	this1 |= (value2 > 255 ? 255 : value2 < 0 ? 0 : value2) << 16;
	var value1 = (1 - value) * (1 - Black);
	var value2 = Math.round(value1 * 255);
	this1 &= -65281;
	this1 |= (value2 > 255 ? 255 : value2 < 0 ? 0 : value2) << 8;
	var value1 = (1 - Yellow) * (1 - Black);
	var value2 = Math.round(value1 * 255);
	this1 &= -256;
	this1 |= value2 > 255 ? 255 : value2 < 0 ? 0 : value2;
	var value1 = Math.round(Alpha * 255);
	this1 &= 16777215;
	this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
	return value;
};
vision_ds_Color.set_yellow = function(this1,value) {
	var Magenta = (1 - (this1 >> 8 & 255) / 255 - (1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
	var Black = 1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
	var Alpha = (this1 >> 24 & 255) / 255;
	if(Alpha == null) {
		Alpha = 1;
	}
	var value1 = (1 - (1 - (this1 >> 16 & 255) / 255 - (1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) * (1 - Black);
	var value2 = Math.round(value1 * 255);
	this1 &= -16711681;
	this1 |= (value2 > 255 ? 255 : value2 < 0 ? 0 : value2) << 16;
	var value1 = (1 - Magenta) * (1 - Black);
	var value2 = Math.round(value1 * 255);
	this1 &= -65281;
	this1 |= (value2 > 255 ? 255 : value2 < 0 ? 0 : value2) << 8;
	var value1 = (1 - value) * (1 - Black);
	var value2 = Math.round(value1 * 255);
	this1 &= -256;
	this1 |= value2 > 255 ? 255 : value2 < 0 ? 0 : value2;
	var value1 = Math.round(Alpha * 255);
	this1 &= 16777215;
	this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
	return value;
};
vision_ds_Color.set_black = function(this1,value) {
	var Magenta = (1 - (this1 >> 8 & 255) / 255 - (1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
	var Yellow = (1 - (this1 & 255) / 255 - (1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
	var Alpha = (this1 >> 24 & 255) / 255;
	if(Alpha == null) {
		Alpha = 1;
	}
	var value1 = (1 - (1 - (this1 >> 16 & 255) / 255 - (1 - Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) * (1 - value);
	var value2 = Math.round(value1 * 255);
	this1 &= -16711681;
	this1 |= (value2 > 255 ? 255 : value2 < 0 ? 0 : value2) << 16;
	var value1 = (1 - Magenta) * (1 - value);
	var value2 = Math.round(value1 * 255);
	this1 &= -65281;
	this1 |= (value2 > 255 ? 255 : value2 < 0 ? 0 : value2) << 8;
	var value1 = (1 - Yellow) * (1 - value);
	var value2 = Math.round(value1 * 255);
	this1 &= -256;
	this1 |= value2 > 255 ? 255 : value2 < 0 ? 0 : value2;
	var value1 = Math.round(Alpha * 255);
	this1 &= 16777215;
	this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
	return value;
};
vision_ds_Color.get_hue = function(this1) {
	var hueRad = Math.atan2(Math.sqrt(3) * ((this1 >> 8 & 255) / 255 - (this1 & 255) / 255),2 * ((this1 >> 16 & 255) / 255) - (this1 >> 8 & 255) / 255 - (this1 & 255) / 255);
	var hue = 0;
	if(hueRad != 0) {
		hue = 180 / Math.PI * Math.atan2(Math.sqrt(3) * ((this1 >> 8 & 255) / 255 - (this1 & 255) / 255),2 * ((this1 >> 16 & 255) / 255) - (this1 >> 8 & 255) / 255 - (this1 & 255) / 255);
	}
	if(hue < 0) {
		return hue + 360;
	} else {
		return hue;
	}
};
vision_ds_Color.get_brightness = function(this1) {
	return Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
};
vision_ds_Color.get_saturation = function(this1) {
	return (Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)) - Math.min((this1 >> 16 & 255) / 255,Math.min((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
};
vision_ds_Color.get_lightness = function(this1) {
	return (Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)) + Math.min((this1 >> 16 & 255) / 255,Math.min((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) / 2;
};
vision_ds_Color.set_hue = function(this1,value) {
	var Brightness = Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
	var Alpha = (this1 >> 24 & 255) / 255;
	var chroma = Brightness * ((Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)) - Math.min((this1 >> 16 & 255) / 255,Math.min((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)));
	var match = Brightness - chroma;
	var Hue = value;
	var Chroma = chroma;
	Hue %= 360;
	var hueD = Hue / 60;
	var mid = Chroma * (1 - Math.abs(hueD % 2 - 1)) + match;
	Chroma += match;
	switch(hueD | 0) {
	case 0:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(Chroma * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(mid * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(match * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 1:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(mid * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(Chroma * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(match * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 2:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(match * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(Chroma * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(mid * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 3:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(match * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(mid * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(Chroma * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 4:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(mid * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(match * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(Chroma * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 5:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(Chroma * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(match * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(mid * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	}
	return value;
};
vision_ds_Color.set_saturation = function(this1,value) {
	var Hue = vision_ds_Color.get_hue(this1);
	var Brightness = Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
	var Alpha = (this1 >> 24 & 255) / 255;
	var chroma = Brightness * value;
	var match = Brightness - chroma;
	var Hue1 = Hue;
	var Chroma = chroma;
	Hue1 %= 360;
	var hueD = Hue1 / 60;
	var mid = Chroma * (1 - Math.abs(hueD % 2 - 1)) + match;
	Chroma += match;
	switch(hueD | 0) {
	case 0:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(Chroma * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(mid * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(match * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 1:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(mid * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(Chroma * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(match * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 2:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(match * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(Chroma * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(mid * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 3:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(match * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(mid * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(Chroma * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 4:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(mid * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(match * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(Chroma * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 5:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(Chroma * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(match * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(mid * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	}
	return value;
};
vision_ds_Color.set_brightness = function(this1,value) {
	var Hue = vision_ds_Color.get_hue(this1);
	var Alpha = (this1 >> 24 & 255) / 255;
	var chroma = value * ((Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)) - Math.min((this1 >> 16 & 255) / 255,Math.min((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)));
	var match = value - chroma;
	var Hue1 = Hue;
	var Chroma = chroma;
	Hue1 %= 360;
	var hueD = Hue1 / 60;
	var mid = Chroma * (1 - Math.abs(hueD % 2 - 1)) + match;
	Chroma += match;
	switch(hueD | 0) {
	case 0:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(Chroma * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(mid * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(match * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 1:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(mid * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(Chroma * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(match * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 2:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(match * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(Chroma * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(mid * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 3:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(match * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(mid * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(Chroma * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 4:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(mid * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(match * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(Chroma * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 5:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(Chroma * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(match * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(mid * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	}
	return value;
};
vision_ds_Color.set_lightness = function(this1,value) {
	var Hue = vision_ds_Color.get_hue(this1);
	var Alpha = (this1 >> 24 & 255) / 255;
	var chroma = (1 - Math.abs(2 * value - 1)) * ((Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)) - Math.min((this1 >> 16 & 255) / 255,Math.min((this1 >> 8 & 255) / 255,(this1 & 255) / 255))) / Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255)));
	var match = value - chroma / 2;
	var Hue1 = Hue;
	var Chroma = chroma;
	Hue1 %= 360;
	var hueD = Hue1 / 60;
	var mid = Chroma * (1 - Math.abs(hueD % 2 - 1)) + match;
	Chroma += match;
	switch(hueD | 0) {
	case 0:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(Chroma * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(mid * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(match * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 1:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(mid * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(Chroma * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(match * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 2:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(match * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(Chroma * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(mid * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 3:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(match * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(mid * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(Chroma * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 4:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(mid * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(match * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(Chroma * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	case 5:
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value1 = Math.round(Chroma * 255);
		this1 &= -16711681;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 16;
		var value1 = Math.round(match * 255);
		this1 &= -65281;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 8;
		var value1 = Math.round(mid * 255);
		this1 &= -256;
		this1 |= value1 > 255 ? 255 : value1 < 0 ? 0 : value1;
		var value1 = Math.round(Alpha1 * 255);
		this1 &= 16777215;
		this1 |= (value1 > 255 ? 255 : value1 < 0 ? 0 : value1) << 24;
		break;
	}
	return value;
};
vision_ds_Color.set_rgb = function(this1,value) {
	this1 = this1 & -16777216 | value & 16777215;
	return value;
};
vision_ds_Color.get_rgb = function(this1) {
	return this1 & 16777215;
};
vision_ds_Color.maxColor = function(this1) {
	return Math.max((this1 >> 16 & 255) / 255,Math.max((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
};
vision_ds_Color.minColor = function(this1) {
	return Math.min((this1 >> 16 & 255) / 255,Math.min((this1 >> 8 & 255) / 255,(this1 & 255) / 255));
};
vision_ds_Color.boundChannel = function(this1,value) {
	if(value > 255) {
		return 255;
	} else if(value < 0) {
		return 0;
	} else {
		return value;
	}
};
vision_ds_Color.toString = function(this1) {
	var Alpha = true;
	var Prefix = true;
	if(Prefix == null) {
		Prefix = true;
	}
	if(Alpha == null) {
		Alpha = true;
	}
	var tmp = Alpha ? StringTools.hex(this1 >> 24 & 255,2) : "";
	return (Prefix ? "0x" : "") + tmp + StringTools.hex(this1 >> 16 & 255,2) + StringTools.hex(this1 >> 8 & 255,2) + StringTools.hex(this1 & 255,2);
};
vision_ds_Color.toInt = function(this1) {
	return this1;
};
vision_ds_Color.color_greater_than_color = function(lhs,rhs) {
	return lhs > rhs;
};
vision_ds_Color.color_greater_than_int = function(lhs,rhs) {
	return lhs > rhs;
};
vision_ds_Color.int_greater_than_color = function(lhs,rhs) {
	return lhs > rhs;
};
vision_ds_Color.color_greater_than_float = function(lhs,rhs) {
	return lhs > rhs;
};
vision_ds_Color.float_greater_than_color = function(lhs,rhs) {
	return lhs > rhs;
};
vision_ds_Color.color_greater_than_equal_color = function(lhs,rhs) {
	return lhs >= rhs;
};
vision_ds_Color.color_greater_than_equal_int = function(lhs,rhs) {
	return lhs >= rhs;
};
vision_ds_Color.int_greater_than_equal_color = function(lhs,rhs) {
	return lhs >= rhs;
};
vision_ds_Color.color_greater_than_equal_float = function(lhs,rhs) {
	return lhs >= rhs;
};
vision_ds_Color.float_greater_than_equal_color = function(lhs,rhs) {
	return lhs >= rhs;
};
vision_ds_Color.color_less_than_color = function(lhs,rhs) {
	return lhs < rhs;
};
vision_ds_Color.color_less_than_int = function(lhs,rhs) {
	return lhs < rhs;
};
vision_ds_Color.int_less_than_color = function(lhs,rhs) {
	return lhs < rhs;
};
vision_ds_Color.color_less_than_float = function(lhs,rhs) {
	return lhs < rhs;
};
vision_ds_Color.float_less_than_color = function(lhs,rhs) {
	return lhs < rhs;
};
vision_ds_Color.color_less_than_equal_color = function(lhs,rhs) {
	return lhs <= rhs;
};
vision_ds_Color.color_less_than_equal_int = function(lhs,rhs) {
	return lhs <= rhs;
};
vision_ds_Color.int_less_than_equal_color = function(lhs,rhs) {
	return lhs <= rhs;
};
vision_ds_Color.color_less_than_equal_float = function(lhs,rhs) {
	return lhs <= rhs;
};
vision_ds_Color.float_less_than_equal_color = function(lhs,rhs) {
	return lhs <= rhs;
};
vision_ds_Color.color_equal_color = function(lhs,rhs) {
	return lhs == rhs;
};
vision_ds_Color.color_equal_int = function(lhs,rhs) {
	return lhs == rhs;
};
vision_ds_Color.int_equal_color = function(lhs,rhs) {
	return lhs == rhs;
};
vision_ds_Color.color_equal_float = function(lhs,rhs) {
	return lhs == rhs;
};
vision_ds_Color.float_equal_color = function(lhs,rhs) {
	return lhs == rhs;
};
vision_ds_Color.color_not_equal_color = function(lhs,rhs) {
	return lhs != rhs;
};
vision_ds_Color.color_not_equal_int = function(lhs,rhs) {
	return lhs != rhs;
};
vision_ds_Color.int_not_equal_color = function(lhs,rhs) {
	return lhs != rhs;
};
vision_ds_Color.color_not_equal_float = function(lhs,rhs) {
	return lhs != rhs;
};
vision_ds_Color.float_not_equal_color = function(lhs,rhs) {
	return lhs != rhs;
};
vision_ds_Color.color_bitwise_and_color = function(lhs,rhs) {
	return lhs & rhs;
};
vision_ds_Color.color_bitwise_and_int = function(lhs,rhs) {
	return lhs & rhs;
};
vision_ds_Color.int_bitwise_and_color = function(lhs,rhs) {
	return lhs & rhs;
};
vision_ds_Color.color_bitwise_or_color = function(lhs,rhs) {
	return lhs | rhs;
};
vision_ds_Color.color_bitwise_or_int = function(lhs,rhs) {
	return lhs | rhs;
};
vision_ds_Color.int_bitwise_or_color = function(lhs,rhs) {
	return lhs | rhs;
};
vision_ds_Color.color_bitwise_xor_color = function(lhs,rhs) {
	return lhs ^ rhs;
};
vision_ds_Color.color_bitwise_xor_int = function(lhs,rhs) {
	return lhs ^ rhs;
};
vision_ds_Color.int_bitwise_xor_color = function(lhs,rhs) {
	return lhs ^ rhs;
};
vision_ds_Color.color_bitwise_left_shift_color = function(lhs,rhs) {
	return lhs << rhs;
};
vision_ds_Color.color_bitwise_left_shift_int = function(lhs,rhs) {
	return lhs << rhs;
};
vision_ds_Color.int_bitwise_left_shift_color = function(lhs,rhs) {
	return lhs << rhs;
};
vision_ds_Color.color_bitwise_right_shift_color = function(lhs,rhs) {
	return lhs >> rhs;
};
vision_ds_Color.color_bitwise_right_shift_int = function(lhs,rhs) {
	return lhs >> rhs;
};
vision_ds_Color.int_bitwise_right_shift_color = function(lhs,rhs) {
	return lhs >> rhs;
};
vision_ds_Color.color_bitwise_unsigned_right_shift_color = function(lhs,rhs) {
	return lhs >>> rhs;
};
vision_ds_Color.color_bitwise_unsigned_right_shift_int = function(lhs,rhs) {
	return lhs >>> rhs;
};
vision_ds_Color.int_bitwise_unsigned_right_shift_color = function(lhs,rhs) {
	return lhs >>> rhs;
};
var vision_ds_Image = {};
vision_ds_Image.__properties__ = {set_view:"set_view",get_view:"get_view",get_height:"get_height",get_width:"get_width",get_underlying:"get_underlying"};
vision_ds_Image.get_underlying = function(this1) {
	return this1;
};
vision_ds_Image.get_width = function(this1) {
	return this1.getUInt16(0);
};
vision_ds_Image.get_height = function(this1) {
	return Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
};
vision_ds_Image.get_view = function(this1) {
	var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
	var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
	var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
	var this2 = this1.b;
	var tmp = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
	return new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[tmp]);
};
vision_ds_Image.set_view = function(this1,view) {
	this1.setUInt16(vision_ds_Image.WIDTH_BYTES,view.x);
	this1.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP,view.y);
	this1.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES,view.width >= this1.getUInt16(0) ? 0 : view.width);
	this1.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP,view.height >= Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) ? 0 : view.width);
	this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] = view.shape;
	return view;
};
vision_ds_Image._new = function(width,height,color) {
	if(color == null) {
		color = 0;
	}
	var length = width * height * 4 + vision_ds_Image.OFFSET;
	var this1 = new haxe_io_Bytes(new ArrayBuffer(length));
	this1.fill(0,length,0);
	var this2 = this1;
	this2.setUInt16(0,width);
	this2.setUInt16(vision_ds_Image.WIDTH_BYTES,0);
	this2.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP,0);
	this2.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES,0);
	this2.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP,0);
	this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] = 0;
	var i = vision_ds_Image.OFFSET;
	while(i < this2.length) {
		this2.b[i] = color >> 24 & 255;
		this2.b[i + 1] = color >> 16 & 255;
		this2.b[i + 2] = color >> 8 & 255;
		this2.b[i + 3] = color & 255;
		i += 4;
	}
	return this2;
};
vision_ds_Image.getColorFromStartingBytePos = function(this1,position) {
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	return value;
};
vision_ds_Image.setColorFromStartingBytePos = function(this1,position,c) {
	position += vision_ds_Image.OFFSET;
	this1.b[position] = c >> 24 & 255;
	this1.b[position + 1] = c >> 16 & 255;
	this1.b[position + 2] = c >> 8 & 255;
	this1.b[position + 3] = c & 255;
	return c;
};
vision_ds_Image.getPixel = function(this1,x,y) {
	if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x;
		var this_y = y;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y * this1.getUInt16(0) + x) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	return value;
};
vision_ds_Image.getSafePixel = function(this1,x,y) {
	var ma = this1.getUInt16(0) - 1;
	var values = [x,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [y,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y = min;
	if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x;
		var this_y = y;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y * this1.getUInt16(0) + x) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	return value;
};
vision_ds_Image.getUnsafePixel = function(this1,x,y) {
	var position = (y * this1.getUInt16(0) + x) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	return value;
};
vision_ds_Image.getFloatingPixel = function(this1,x,y) {
	var tmp;
	var x1 = Math.ceil(x);
	var y1 = Math.ceil(y);
	if(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
		var x1 = Math.floor(x);
		var y1 = Math.floor(y);
		tmp = !(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)));
	} else {
		tmp = true;
	}
	if(tmp) {
		x = vision_tools_MathTools.boundFloat(x,0,this1.getUInt16(0) - 1);
		y = vision_tools_MathTools.boundFloat(y,0,Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1);
	}
	var yFraction = y - (y | 0);
	var xFraction = x - (x | 0);
	var x1 = 1 - yFraction;
	var x2 = x | 0;
	var y1 = y | 0;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = (1 - xFraction) * (value >> 16 & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x3 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [y | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x3 >= 0 && y1 >= 0 && x3 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x3;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x3) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x3 = x1 * (x2 + xFraction * (value >> 16 & 255));
	var x1 = 1 - xFraction;
	var ma = this1.getUInt16(0) - 1;
	var values = [x | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x2 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = x1 * (value >> 16 & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x1 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x1;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x1) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var red = x3 + yFraction * (x2 + xFraction * (value >> 16 & 255)) | 0;
	var x1 = 1 - yFraction;
	var x2 = x | 0;
	var y1 = y | 0;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = (1 - xFraction) * (value >> 8 & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x3 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [y | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x3 >= 0 && y1 >= 0 && x3 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x3;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x3) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x3 = x1 * (x2 + xFraction * (value >> 8 & 255));
	var x1 = 1 - xFraction;
	var ma = this1.getUInt16(0) - 1;
	var values = [x | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x2 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = x1 * (value >> 8 & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x1 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x1;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x1) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var green = x3 + yFraction * (x2 + xFraction * (value >> 8 & 255)) | 0;
	var x1 = 1 - yFraction;
	var x2 = x | 0;
	var y1 = y | 0;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = (1 - xFraction) * (value & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x3 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [y | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x3 >= 0 && y1 >= 0 && x3 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x3;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x3) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x3 = x1 * (x2 + xFraction * (value & 255));
	var x1 = 1 - xFraction;
	var ma = this1.getUInt16(0) - 1;
	var values = [x | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x2 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = x1 * (value & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x1 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x1;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x1) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var blue = x3 + yFraction * (x2 + xFraction * (value & 255)) | 0;
	var x1 = 1 - yFraction;
	var x2 = x | 0;
	var y1 = y | 0;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = (1 - xFraction) * (value >> 24 & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x3 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [y | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x3 >= 0 && y1 >= 0 && x3 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x3;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x3) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x3 = x1 * (x2 + xFraction * (value >> 24 & 255));
	var x1 = 1 - xFraction;
	var ma = this1.getUInt16(0) - 1;
	var values = [x | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x2 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = x1 * (value >> 24 & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y = min;
	if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x;
		var this_y = y;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y * this1.getUInt16(0) + x) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var alpha = x3 + yFraction * (x2 + xFraction * (value >> 24 & 255)) | 0;
	var Alpha = alpha;
	if(Alpha == null) {
		Alpha = 255;
	}
	var color = 0;
	var Alpha1 = Alpha;
	if(Alpha1 == null) {
		Alpha1 = 255;
	}
	color &= -16711681;
	color |= (red > 255 ? 255 : red < 0 ? 0 : red) << 16;
	color &= -65281;
	color |= (green > 255 ? 255 : green < 0 ? 0 : green) << 8;
	color &= -256;
	color |= blue > 255 ? 255 : blue < 0 ? 0 : blue;
	color &= 16777215;
	color |= (Alpha1 > 255 ? 255 : Alpha1 < 0 ? 0 : Alpha1) << 24;
	return color;
};
vision_ds_Image.setPixel = function(this1,x,y,color) {
	if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x;
		var this_y = y;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
		var v = null;
		var tmp;
		if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
			tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
		} else {
			var has = false;
			var view;
			if(v != null) {
				view = v;
			} else {
				var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
				var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
				var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
				var this2 = this1.b;
				var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
				view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
			}
			switch(view.shape) {
			case 0:
				has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
				break;
			case 1:
				has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
				break;
			case 2:case 3:
				if(view.width > view.height) {
					var a = view.width / 2;
					var b = view.height / 2;
					var c = Math.sqrt(a * a - b * b);
					var x1 = view.x + view.width / 2 - c;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f1_x = x1;
					var f1_y = y1;
					var x1 = view.x + view.width / 2 + c;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f2_x = x1;
					var f2_y = y1;
					var p_x = x;
					var p_y = y;
					var x1 = p_x - f1_x;
					var y1 = p_y - f1_y;
					var x2 = p_x - f2_x;
					var y2 = p_y - f2_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
					if(view.shape == 3) {
						has = !has;
					}
				} else if(view.height > view.width) {
					var a = view.height / 2;
					var b = view.width / 2;
					var c = Math.sqrt(a * a - b * b);
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2 - c;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f1_x = x1;
					var f1_y = y1;
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2 + c;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f2_x = x1;
					var f2_y = y1;
					var p_x = x;
					var p_y = y;
					var x1 = p_x - f1_x;
					var y1 = p_y - f1_y;
					var x2 = p_x - f2_x;
					var y2 = p_y - f2_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
					if(view.shape == 3) {
						has = !has;
					}
				} else {
					var x1 = x;
					var y1 = y;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var point1_x = x1;
					var point1_y = y1;
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var point2_x = x1;
					var point2_y = y1;
					var x1 = point2_x - point1_x;
					var y1 = point2_y - point1_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
					if(view.shape == 3) {
						has = !has;
					}
				}
				break;
			case 4:
				has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
				break;
			case 5:
				has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
				break;
			}
			tmp = has;
		}
		if(tmp) {
			var position = (y * this1.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = color >> 24 & 255;
			this1.b[position + 1] = color >> 16 & 255;
			this1.b[position + 2] = color >> 8 & 255;
			this1.b[position + 3] = color & 255;
		}
	} else {
		var position = (y * this1.getUInt16(0) + x) * 4;
		position += vision_ds_Image.OFFSET;
		this1.b[position] = color >> 24 & 255;
		this1.b[position + 1] = color >> 16 & 255;
		this1.b[position + 2] = color >> 8 & 255;
		this1.b[position + 3] = color & 255;
	}
};
vision_ds_Image.setSafePixel = function(this1,x,y,color) {
	var ma = this1.getUInt16(0) - 1;
	var values = [x,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	x = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [y,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	y = min;
	if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
		var v = null;
		var tmp;
		if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
			tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
		} else {
			var has = false;
			var view;
			if(v != null) {
				view = v;
			} else {
				var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
				var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
				var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
				var this2 = this1.b;
				var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
				view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
			}
			switch(view.shape) {
			case 0:
				has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
				break;
			case 1:
				has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
				break;
			case 2:case 3:
				if(view.width > view.height) {
					var a = view.width / 2;
					var b = view.height / 2;
					var c = Math.sqrt(a * a - b * b);
					var x1 = view.x + view.width / 2 - c;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f1_x = x1;
					var f1_y = y1;
					var x1 = view.x + view.width / 2 + c;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f2_x = x1;
					var f2_y = y1;
					var p_x = x;
					var p_y = y;
					var x1 = p_x - f1_x;
					var y1 = p_y - f1_y;
					var x2 = p_x - f2_x;
					var y2 = p_y - f2_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
					if(view.shape == 3) {
						has = !has;
					}
				} else if(view.height > view.width) {
					var a = view.height / 2;
					var b = view.width / 2;
					var c = Math.sqrt(a * a - b * b);
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2 - c;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f1_x = x1;
					var f1_y = y1;
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2 + c;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f2_x = x1;
					var f2_y = y1;
					var p_x = x;
					var p_y = y;
					var x1 = p_x - f1_x;
					var y1 = p_y - f1_y;
					var x2 = p_x - f2_x;
					var y2 = p_y - f2_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
					if(view.shape == 3) {
						has = !has;
					}
				} else {
					var x1 = x;
					var y1 = y;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var point1_x = x1;
					var point1_y = y1;
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var point2_x = x1;
					var point2_y = y1;
					var x1 = point2_x - point1_x;
					var y1 = point2_y - point1_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
					if(view.shape == 3) {
						has = !has;
					}
				}
				break;
			case 4:
				has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
				break;
			case 5:
				has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
				break;
			}
			tmp = has;
		}
		if(tmp) {
			var position = (y * this1.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = color >> 24 & 255;
			this1.b[position + 1] = color >> 16 & 255;
			this1.b[position + 2] = color >> 8 & 255;
			this1.b[position + 3] = color & 255;
		}
	} else {
		var position = (y * this1.getUInt16(0) + x) * 4;
		position += vision_ds_Image.OFFSET;
		this1.b[position] = color >> 24 & 255;
		this1.b[position + 1] = color >> 16 & 255;
		this1.b[position + 2] = color >> 8 & 255;
		this1.b[position + 3] = color & 255;
	}
};
vision_ds_Image.setFloatingPixel = function(this1,x,y,color) {
	var tmp;
	var x1 = Math.ceil(x);
	var y1 = Math.ceil(y);
	if(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
		var x1 = Math.floor(x);
		var y1 = Math.floor(y);
		tmp = !(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)));
	} else {
		tmp = true;
	}
	if(tmp) {
		vision_ds_Image.setFloatingPixel(this1,vision_tools_MathTools.boundFloat(x,0,this1.getUInt16(0) - 1),vision_tools_MathTools.boundFloat(y,0,Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1),color);
		return;
	}
	var yFraction = y - (y | 0);
	var xFraction = x - (x | 0);
	var x1 = Math.floor(x);
	var y1 = Math.floor(y);
	var Red = (1 - xFraction + (1 - yFraction)) / 2 * ((color >> 16 & 255) / 255);
	var Green = (1 - xFraction + (1 - yFraction)) / 2 * ((color >> 8 & 255) / 255);
	var Blue = (1 - xFraction + (1 - yFraction)) / 2 * ((color & 255) / 255);
	var Alpha = (color >> 24 & 255) / 255;
	if(Alpha == null) {
		Alpha = 1;
	}
	var color1 = 0;
	var Alpha1 = Alpha;
	if(Alpha1 == null) {
		Alpha1 = 1;
	}
	var value = Math.round(Red * 255);
	color1 &= -16711681;
	color1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
	var value = Math.round(Green * 255);
	color1 &= -65281;
	color1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
	var value = Math.round(Blue * 255);
	color1 &= -256;
	color1 |= value > 255 ? 255 : value < 0 ? 0 : value;
	var value = Math.round(Alpha1 * 255);
	color1 &= 16777215;
	color1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
	var color2 = color1;
	if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x1;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
		var v = null;
		var tmp;
		if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
			tmp = x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
		} else {
			var has = false;
			var view;
			if(v != null) {
				view = v;
			} else {
				var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
				var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
				var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
				var this2 = this1.b;
				var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
				view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
			}
			switch(view.shape) {
			case 0:
				has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
				break;
			case 1:
				has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
				break;
			case 2:case 3:
				if(view.width > view.height) {
					var a = view.width / 2;
					var b = view.height / 2;
					var c = Math.sqrt(a * a - b * b);
					var x2 = view.x + view.width / 2 - c;
					var y2 = view.y + view.height / 2;
					if(y2 == null) {
						y2 = 0;
					}
					if(x2 == null) {
						x2 = 0;
					}
					var f1_x = x2;
					var f1_y = y2;
					var x2 = view.x + view.width / 2 + c;
					var y2 = view.y + view.height / 2;
					if(y2 == null) {
						y2 = 0;
					}
					if(x2 == null) {
						x2 = 0;
					}
					var f2_x = x2;
					var f2_y = y2;
					var p_x = x1;
					var p_y = y1;
					var x2 = p_x - f1_x;
					var y2 = p_y - f1_y;
					var x3 = p_x - f2_x;
					var y3 = p_y - f2_y;
					has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.width;
					if(view.shape == 3) {
						has = !has;
					}
				} else if(view.height > view.width) {
					var a = view.height / 2;
					var b = view.width / 2;
					var c = Math.sqrt(a * a - b * b);
					var x2 = view.x + view.width / 2;
					var y2 = view.y + view.height / 2 - c;
					if(y2 == null) {
						y2 = 0;
					}
					if(x2 == null) {
						x2 = 0;
					}
					var f1_x = x2;
					var f1_y = y2;
					var x2 = view.x + view.width / 2;
					var y2 = view.y + view.height / 2 + c;
					if(y2 == null) {
						y2 = 0;
					}
					if(x2 == null) {
						x2 = 0;
					}
					var f2_x = x2;
					var f2_y = y2;
					var p_x = x1;
					var p_y = y1;
					var x2 = p_x - f1_x;
					var y2 = p_y - f1_y;
					var x3 = p_x - f2_x;
					var y3 = p_y - f2_y;
					has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.height;
					if(view.shape == 3) {
						has = !has;
					}
				} else {
					var x2 = x1;
					var y2 = y1;
					if(y2 == null) {
						y2 = 0;
					}
					if(x2 == null) {
						x2 = 0;
					}
					var point1_x = x2;
					var point1_y = y2;
					var x2 = view.x + view.width / 2;
					var y2 = view.y + view.height / 2;
					if(y2 == null) {
						y2 = 0;
					}
					if(x2 == null) {
						x2 = 0;
					}
					var point2_x = x2;
					var point2_y = y2;
					var x2 = point2_x - point1_x;
					var y2 = point2_y - point1_y;
					has = Math.sqrt(x2 * x2 + y2 * y2) <= view.width / 2;
					if(view.shape == 3) {
						has = !has;
					}
				}
				break;
			case 4:
				has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
				break;
			case 5:
				has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
				break;
			}
			tmp = has;
		}
		if(tmp) {
			var position = (y1 * this1.getUInt16(0) + x1) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = color2 >> 24 & 255;
			this1.b[position + 1] = color2 >> 16 & 255;
			this1.b[position + 2] = color2 >> 8 & 255;
			this1.b[position + 3] = color2 & 255;
		}
	} else {
		var position = (y1 * this1.getUInt16(0) + x1) * 4;
		position += vision_ds_Image.OFFSET;
		this1.b[position] = color2 >> 24 & 255;
		this1.b[position + 1] = color2 >> 16 & 255;
		this1.b[position + 2] = color2 >> 8 & 255;
		this1.b[position + 3] = color2 & 255;
	}
	if(y != (y | 0)) {
		var x1 = Math.floor(x);
		var y1 = Math.ceil(y);
		var Red = (1 - xFraction + yFraction) / 2 * ((color >> 16 & 255) / 255);
		var Green = (1 - xFraction + yFraction) / 2 * ((color >> 8 & 255) / 255);
		var Blue = (1 - xFraction + yFraction) / 2 * ((color & 255) / 255);
		var Alpha = (color >> 24 & 255) / 255;
		if(Alpha == null) {
			Alpha = 1;
		}
		var color1 = 0;
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Red * 255);
		color1 &= -16711681;
		color1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Green * 255);
		color1 &= -65281;
		color1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Blue * 255);
		color1 &= -256;
		color1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color1 &= 16777215;
		color1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		var color2 = color1;
		if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x1;
			var this_y = y1;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
					break;
				case 1:
					has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x2 = view.x + view.width / 2 - c;
						var y2 = view.y + view.height / 2;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var f1_x = x2;
						var f1_y = y2;
						var x2 = view.x + view.width / 2 + c;
						var y2 = view.y + view.height / 2;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var f2_x = x2;
						var f2_y = y2;
						var p_x = x1;
						var p_y = y1;
						var x2 = p_x - f1_x;
						var y2 = p_y - f1_y;
						var x3 = p_x - f2_x;
						var y3 = p_y - f2_y;
						has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a = view.height / 2;
						var b = view.width / 2;
						var c = Math.sqrt(a * a - b * b);
						var x2 = view.x + view.width / 2;
						var y2 = view.y + view.height / 2 - c;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var f1_x = x2;
						var f1_y = y2;
						var x2 = view.x + view.width / 2;
						var y2 = view.y + view.height / 2 + c;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var f2_x = x2;
						var f2_y = y2;
						var p_x = x1;
						var p_y = y1;
						var x2 = p_x - f1_x;
						var y2 = p_y - f1_y;
						var x3 = p_x - f2_x;
						var y3 = p_y - f2_y;
						has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x2 = x1;
						var y2 = y1;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var point1_x = x2;
						var point1_y = y2;
						var x2 = view.x + view.width / 2;
						var y2 = view.y + view.height / 2;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var point2_x = x2;
						var point2_y = y2;
						var x2 = point2_x - point1_x;
						var y2 = point2_y - point1_y;
						has = Math.sqrt(x2 * x2 + y2 * y2) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y1 * this1.getUInt16(0) + x1) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color2 >> 24 & 255;
				this1.b[position + 1] = color2 >> 16 & 255;
				this1.b[position + 2] = color2 >> 8 & 255;
				this1.b[position + 3] = color2 & 255;
			}
		} else {
			var position = (y1 * this1.getUInt16(0) + x1) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = color2 >> 24 & 255;
			this1.b[position + 1] = color2 >> 16 & 255;
			this1.b[position + 2] = color2 >> 8 & 255;
			this1.b[position + 3] = color2 & 255;
		}
	}
	if(x != (x | 0)) {
		var x1 = Math.ceil(x);
		var y1 = Math.floor(y);
		var Red = (xFraction + (1 - yFraction)) / 2 * ((color >> 16 & 255) / 255);
		var Green = (xFraction + (1 - yFraction)) / 2 * ((color >> 8 & 255) / 255);
		var Blue = (xFraction + (1 - yFraction)) / 2 * ((color & 255) / 255);
		var Alpha = (color >> 24 & 255) / 255;
		if(Alpha == null) {
			Alpha = 1;
		}
		var color1 = 0;
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Red * 255);
		color1 &= -16711681;
		color1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Green * 255);
		color1 &= -65281;
		color1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Blue * 255);
		color1 &= -256;
		color1 |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color1 &= 16777215;
		color1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		var color2 = color1;
		if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x1;
			var this_y = y1;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
					break;
				case 1:
					has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x2 = view.x + view.width / 2 - c;
						var y2 = view.y + view.height / 2;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var f1_x = x2;
						var f1_y = y2;
						var x2 = view.x + view.width / 2 + c;
						var y2 = view.y + view.height / 2;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var f2_x = x2;
						var f2_y = y2;
						var p_x = x1;
						var p_y = y1;
						var x2 = p_x - f1_x;
						var y2 = p_y - f1_y;
						var x3 = p_x - f2_x;
						var y3 = p_y - f2_y;
						has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a = view.height / 2;
						var b = view.width / 2;
						var c = Math.sqrt(a * a - b * b);
						var x2 = view.x + view.width / 2;
						var y2 = view.y + view.height / 2 - c;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var f1_x = x2;
						var f1_y = y2;
						var x2 = view.x + view.width / 2;
						var y2 = view.y + view.height / 2 + c;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var f2_x = x2;
						var f2_y = y2;
						var p_x = x1;
						var p_y = y1;
						var x2 = p_x - f1_x;
						var y2 = p_y - f1_y;
						var x3 = p_x - f2_x;
						var y3 = p_y - f2_y;
						has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x2 = x1;
						var y2 = y1;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var point1_x = x2;
						var point1_y = y2;
						var x2 = view.x + view.width / 2;
						var y2 = view.y + view.height / 2;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var point2_x = x2;
						var point2_y = y2;
						var x2 = point2_x - point1_x;
						var y2 = point2_y - point1_y;
						has = Math.sqrt(x2 * x2 + y2 * y2) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y1 * this1.getUInt16(0) + x1) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color2 >> 24 & 255;
				this1.b[position + 1] = color2 >> 16 & 255;
				this1.b[position + 2] = color2 >> 8 & 255;
				this1.b[position + 3] = color2 & 255;
			}
		} else {
			var position = (y1 * this1.getUInt16(0) + x1) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = color2 >> 24 & 255;
			this1.b[position + 1] = color2 >> 16 & 255;
			this1.b[position + 2] = color2 >> 8 & 255;
			this1.b[position + 3] = color2 & 255;
		}
	}
	if(x != (x | 0) && y != (y | 0)) {
		var x1 = Math.ceil(x);
		var y1 = Math.ceil(y);
		var Red = (xFraction + yFraction) / 2 * ((color >> 16 & 255) / 255);
		var Green = (xFraction + yFraction) / 2 * ((color >> 8 & 255) / 255);
		var Blue = (xFraction + yFraction) / 2 * ((color & 255) / 255);
		var Alpha = (color >> 24 & 255) / 255;
		if(Alpha == null) {
			Alpha = 1;
		}
		var color = 0;
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Red * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Green * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Blue * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		var color1 = color;
		if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x1;
			var this_y = y1;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
					break;
				case 1:
					has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x = view.x + view.width / 2 - c;
						var y = view.y + view.height / 2;
						if(y == null) {
							y = 0;
						}
						if(x == null) {
							x = 0;
						}
						var f1_x = x;
						var f1_y = y;
						var x = view.x + view.width / 2 + c;
						var y = view.y + view.height / 2;
						if(y == null) {
							y = 0;
						}
						if(x == null) {
							x = 0;
						}
						var f2_x = x;
						var f2_y = y;
						var p_x = x1;
						var p_y = y1;
						var x = p_x - f1_x;
						var y = p_y - f1_y;
						var x2 = p_x - f2_x;
						var y2 = p_y - f2_y;
						has = Math.sqrt(x * x + y * y) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a = view.height / 2;
						var b = view.width / 2;
						var c = Math.sqrt(a * a - b * b);
						var x = view.x + view.width / 2;
						var y = view.y + view.height / 2 - c;
						if(y == null) {
							y = 0;
						}
						if(x == null) {
							x = 0;
						}
						var f1_x = x;
						var f1_y = y;
						var x = view.x + view.width / 2;
						var y = view.y + view.height / 2 + c;
						if(y == null) {
							y = 0;
						}
						if(x == null) {
							x = 0;
						}
						var f2_x = x;
						var f2_y = y;
						var p_x = x1;
						var p_y = y1;
						var x = p_x - f1_x;
						var y = p_y - f1_y;
						var x2 = p_x - f2_x;
						var y2 = p_y - f2_y;
						has = Math.sqrt(x * x + y * y) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x = x1;
						var y = y1;
						if(y == null) {
							y = 0;
						}
						if(x == null) {
							x = 0;
						}
						var point1_x = x;
						var point1_y = y;
						var x = view.x + view.width / 2;
						var y = view.y + view.height / 2;
						if(y == null) {
							y = 0;
						}
						if(x == null) {
							x = 0;
						}
						var point2_x = x;
						var point2_y = y;
						var x = point2_x - point1_x;
						var y = point2_y - point1_y;
						has = Math.sqrt(x * x + y * y) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y1 * this1.getUInt16(0) + x1) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color1 >> 24 & 255;
				this1.b[position + 1] = color1 >> 16 & 255;
				this1.b[position + 2] = color1 >> 8 & 255;
				this1.b[position + 3] = color1 & 255;
			}
		} else {
			var position = (y1 * this1.getUInt16(0) + x1) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = color1 >> 24 & 255;
			this1.b[position + 1] = color1 >> 16 & 255;
			this1.b[position + 2] = color1 >> 8 & 255;
			this1.b[position + 3] = color1 & 255;
		}
	}
};
vision_ds_Image.setUnsafePixel = function(this1,x,y,color) {
	var position = (y * this1.getUInt16(0) + x) * 4;
	position += vision_ds_Image.OFFSET;
	this1.b[position] = color >> 24 & 255;
	this1.b[position + 1] = color >> 16 & 255;
	this1.b[position + 2] = color >> 8 & 255;
	this1.b[position + 3] = color & 255;
};
vision_ds_Image.paintPixel = function(this1,x,y,color) {
	if(x < 0 || x >= this1.getUInt16(0) || y < 0 || y >= Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
		var this_x = x;
		var this_y = y;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	} else if((color >> 24 & 255) / 255 == 1) {
		if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x;
			var this_y = y;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
					break;
				case 1:
					has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x1 = view.x + view.width / 2 - c;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f1_x = x1;
						var f1_y = y1;
						var x1 = view.x + view.width / 2 + c;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f2_x = x1;
						var f2_y = y1;
						var p_x = x;
						var p_y = y;
						var x1 = p_x - f1_x;
						var y1 = p_y - f1_y;
						var x2 = p_x - f2_x;
						var y2 = p_y - f2_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a = view.height / 2;
						var b = view.width / 2;
						var c = Math.sqrt(a * a - b * b);
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2 - c;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f1_x = x1;
						var f1_y = y1;
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2 + c;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f2_x = x1;
						var f2_y = y1;
						var p_x = x;
						var p_y = y;
						var x1 = p_x - f1_x;
						var y1 = p_y - f1_y;
						var x2 = p_x - f2_x;
						var y2 = p_y - f2_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x1 = x;
						var y1 = y;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var point1_x = x1;
						var point1_y = y1;
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var point2_x = x1;
						var point2_y = y1;
						var x1 = point2_x - point1_x;
						var y1 = point2_y - point1_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color >> 24 & 255;
				this1.b[position + 1] = color >> 16 & 255;
				this1.b[position + 2] = color >> 8 & 255;
				this1.b[position + 3] = color & 255;
			}
		} else {
			var position = (y * this1.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = color >> 24 & 255;
			this1.b[position + 1] = color >> 16 & 255;
			this1.b[position + 2] = color >> 8 & 255;
			this1.b[position + 3] = color & 255;
		}
	} else {
		if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x;
			var this_y = y;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		}
		var position = (y * this1.getUInt16(0) + x) * 4;
		position += vision_ds_Image.OFFSET;
		var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
		if(value == null) {
			value = 0;
		}
		var oldColor = value;
		var Red = (color >> 16 & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor >> 16 & 255) / 255 * (1 - (color >> 24 & 255) / 255);
		var Green = (color >> 8 & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor >> 8 & 255) / 255 * (1 - (color >> 24 & 255) / 255);
		var Blue = (color & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor & 255) / 255 * (1 - (color >> 24 & 255) / 255);
		var Alpha = (oldColor >> 24 & 255) / 255 + (1 - (oldColor >> 24 & 255) / 255) * ((color >> 24 & 255) / 255);
		if(Alpha == null) {
			Alpha = 1;
		}
		var color = 0;
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Red * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Green * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Blue * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		var newColor = color;
		if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x;
			var this_y = y;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
					break;
				case 1:
					has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x1 = view.x + view.width / 2 - c;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f1_x = x1;
						var f1_y = y1;
						var x1 = view.x + view.width / 2 + c;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f2_x = x1;
						var f2_y = y1;
						var p_x = x;
						var p_y = y;
						var x1 = p_x - f1_x;
						var y1 = p_y - f1_y;
						var x2 = p_x - f2_x;
						var y2 = p_y - f2_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a = view.height / 2;
						var b = view.width / 2;
						var c = Math.sqrt(a * a - b * b);
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2 - c;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f1_x = x1;
						var f1_y = y1;
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2 + c;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f2_x = x1;
						var f2_y = y1;
						var p_x = x;
						var p_y = y;
						var x1 = p_x - f1_x;
						var y1 = p_y - f1_y;
						var x2 = p_x - f2_x;
						var y2 = p_y - f2_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x1 = x;
						var y1 = y;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var point1_x = x1;
						var point1_y = y1;
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var point2_x = x1;
						var point2_y = y1;
						var x1 = point2_x - point1_x;
						var y1 = point2_y - point1_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = newColor >> 24 & 255;
				this1.b[position + 1] = newColor >> 16 & 255;
				this1.b[position + 2] = newColor >> 8 & 255;
				this1.b[position + 3] = newColor & 255;
			}
		} else {
			var position = (y * this1.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = newColor >> 24 & 255;
			this1.b[position + 1] = newColor >> 16 & 255;
			this1.b[position + 2] = newColor >> 8 & 255;
			this1.b[position + 3] = newColor & 255;
		}
	}
};
vision_ds_Image.paintFloatingPixel = function(this1,x,y,color) {
	if(x < 0 || x >= this1.getUInt16(0) || y < 0 || y >= Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
		vision_ds_Image.paintFloatingPixel(this1,vision_tools_MathTools.boundFloat(x,0,this1.getUInt16(0) - 1),vision_tools_MathTools.boundFloat(y,0,Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1),color);
	} else if(x == (x | 0) && y == (y | 0)) {
		var x1 = Math.floor(x);
		var y1 = Math.floor(y);
		if(x1 < 0 || x1 >= this1.getUInt16(0) || y1 < 0 || y1 >= Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
			var this_x = x1;
			var this_y = y1;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		} else if((color >> 24 & 255) / 255 == 1) {
			if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = x1;
				var this_y = y1;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
						break;
					case 1:
						has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x2 = view.x + view.width / 2 - c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f1_x = x2;
							var f1_y = y2;
							var x2 = view.x + view.width / 2 + c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f2_x = x2;
							var f2_y = y2;
							var p_x = x1;
							var p_y = y1;
							var x2 = p_x - f1_x;
							var y2 = p_y - f1_y;
							var x3 = p_x - f2_x;
							var y3 = p_y - f2_y;
							has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a = view.height / 2;
							var b = view.width / 2;
							var c = Math.sqrt(a * a - b * b);
							var x2 = view.x + view.width / 2;
							var y2 = view.y + view.height / 2 - c;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f1_x = x2;
							var f1_y = y2;
							var x2 = view.x + view.width / 2;
							var y2 = view.y + view.height / 2 + c;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f2_x = x2;
							var f2_y = y2;
							var p_x = x1;
							var p_y = y1;
							var x2 = p_x - f1_x;
							var y2 = p_y - f1_y;
							var x3 = p_x - f2_x;
							var y3 = p_y - f2_y;
							has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x2 = x1;
							var y2 = y1;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var point1_x = x2;
							var point1_y = y2;
							var x2 = view.x + view.width / 2;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var point2_x = x2;
							var point2_y = y2;
							var x2 = point2_x - point1_x;
							var y2 = point2_y - point1_y;
							has = Math.sqrt(x2 * x2 + y2 * y2) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y1 * this1.getUInt16(0) + x1) * 4;
					position += vision_ds_Image.OFFSET;
					this1.b[position] = color >> 24 & 255;
					this1.b[position + 1] = color >> 16 & 255;
					this1.b[position + 2] = color >> 8 & 255;
					this1.b[position + 3] = color & 255;
				}
			} else {
				var position = (y1 * this1.getUInt16(0) + x1) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color >> 24 & 255;
				this1.b[position + 1] = color >> 16 & 255;
				this1.b[position + 2] = color >> 8 & 255;
				this1.b[position + 3] = color & 255;
			}
		} else {
			if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = x1;
				var this_y = y1;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			}
			var position = (y1 * this1.getUInt16(0) + x1) * 4;
			position += vision_ds_Image.OFFSET;
			var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
			if(value == null) {
				value = 0;
			}
			var oldColor = value;
			var Red = (color >> 16 & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor >> 16 & 255) / 255 * (1 - (color >> 24 & 255) / 255);
			var Green = (color >> 8 & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor >> 8 & 255) / 255 * (1 - (color >> 24 & 255) / 255);
			var Blue = (color & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor & 255) / 255 * (1 - (color >> 24 & 255) / 255);
			var Alpha = (oldColor >> 24 & 255) / 255 + (1 - (oldColor >> 24 & 255) / 255) * ((color >> 24 & 255) / 255);
			if(Alpha == null) {
				Alpha = 1;
			}
			var color1 = 0;
			var Alpha1 = Alpha;
			if(Alpha1 == null) {
				Alpha1 = 1;
			}
			var value = Math.round(Red * 255);
			color1 &= -16711681;
			color1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
			var value = Math.round(Green * 255);
			color1 &= -65281;
			color1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
			var value = Math.round(Blue * 255);
			color1 &= -256;
			color1 |= value > 255 ? 255 : value < 0 ? 0 : value;
			var value = Math.round(Alpha1 * 255);
			color1 &= 16777215;
			color1 |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
			var newColor = color1;
			if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = x1;
				var this_y = y1;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
						break;
					case 1:
						has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x2 = view.x + view.width / 2 - c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f1_x = x2;
							var f1_y = y2;
							var x2 = view.x + view.width / 2 + c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f2_x = x2;
							var f2_y = y2;
							var p_x = x1;
							var p_y = y1;
							var x2 = p_x - f1_x;
							var y2 = p_y - f1_y;
							var x3 = p_x - f2_x;
							var y3 = p_y - f2_y;
							has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a = view.height / 2;
							var b = view.width / 2;
							var c = Math.sqrt(a * a - b * b);
							var x2 = view.x + view.width / 2;
							var y2 = view.y + view.height / 2 - c;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f1_x = x2;
							var f1_y = y2;
							var x2 = view.x + view.width / 2;
							var y2 = view.y + view.height / 2 + c;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f2_x = x2;
							var f2_y = y2;
							var p_x = x1;
							var p_y = y1;
							var x2 = p_x - f1_x;
							var y2 = p_y - f1_y;
							var x3 = p_x - f2_x;
							var y3 = p_y - f2_y;
							has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x2 = x1;
							var y2 = y1;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var point1_x = x2;
							var point1_y = y2;
							var x2 = view.x + view.width / 2;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var point2_x = x2;
							var point2_y = y2;
							var x2 = point2_x - point1_x;
							var y2 = point2_y - point1_y;
							has = Math.sqrt(x2 * x2 + y2 * y2) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y1 * this1.getUInt16(0) + x1) * 4;
					position += vision_ds_Image.OFFSET;
					this1.b[position] = newColor >> 24 & 255;
					this1.b[position + 1] = newColor >> 16 & 255;
					this1.b[position + 2] = newColor >> 8 & 255;
					this1.b[position + 3] = newColor & 255;
				}
			} else {
				var position = (y1 * this1.getUInt16(0) + x1) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = newColor >> 24 & 255;
				this1.b[position + 1] = newColor >> 16 & 255;
				this1.b[position + 2] = newColor >> 8 & 255;
				this1.b[position + 3] = newColor & 255;
			}
		}
	} else {
		var yFraction = y - (y | 0);
		var xFraction = x - (x | 0);
		var ix = Math.floor(x);
		var iy = Math.floor(y);
		var _g = 0;
		var _g1 = [0,1];
		while(_g < _g1.length) {
			var posX = _g1[_g];
			++_g;
			if(posX == 1 && x == ix) {
				continue;
			}
			var _g2 = 0;
			var _g3 = [0,1];
			while(_g2 < _g3.length) {
				var posY = _g3[_g2];
				++_g2;
				if(posY == 1 && y == iy) {
					continue;
				}
				var x1 = ix + posX;
				var y1 = iy + posY;
				if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x = x1;
					var this_y = y1;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
				}
				var position = (y1 * this1.getUInt16(0) + x1) * 4;
				position += vision_ds_Image.OFFSET;
				var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
				if(value == null) {
					value = 0;
				}
				var oldColor = value;
				var value1 = ((posX == 0 ? 1 - xFraction : xFraction) + (posY == 0 ? 1 - yFraction : yFraction)) / 2;
				var value2 = Math.round(value1 * 255);
				color &= 16777215;
				color |= (value2 > 255 ? 255 : value2 < 0 ? 0 : value2) << 24;
				var Red = (color >> 16 & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor >> 16 & 255) / 255 * (1 - (color >> 24 & 255) / 255);
				var Green = (color >> 8 & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor >> 8 & 255) / 255 * (1 - (color >> 24 & 255) / 255);
				var Blue = (color & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor & 255) / 255 * (1 - (color >> 24 & 255) / 255);
				var Alpha = (oldColor >> 24 & 255) / 255 + (1 - (oldColor >> 24 & 255) / 255) * ((color >> 24 & 255) / 255);
				if(Alpha == null) {
					Alpha = 1;
				}
				var color1 = 0;
				var Alpha1 = Alpha;
				if(Alpha1 == null) {
					Alpha1 = 1;
				}
				var value3 = Math.round(Red * 255);
				color1 &= -16711681;
				color1 |= (value3 > 255 ? 255 : value3 < 0 ? 0 : value3) << 16;
				var value4 = Math.round(Green * 255);
				color1 &= -65281;
				color1 |= (value4 > 255 ? 255 : value4 < 0 ? 0 : value4) << 8;
				var value5 = Math.round(Blue * 255);
				color1 &= -256;
				color1 |= value5 > 255 ? 255 : value5 < 0 ? 0 : value5;
				var value6 = Math.round(Alpha1 * 255);
				color1 &= 16777215;
				color1 |= (value6 > 255 ? 255 : value6 < 0 ? 0 : value6) << 24;
				var newColor = color1;
				var x2 = ix + posX;
				var y2 = iy + posY;
				if(!(x2 >= 0 && y2 >= 0 && x2 < this1.getUInt16(0) && y2 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x1 = x2;
					var this_y1 = y2;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x1,this_y1)));
				} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
					var v = null;
					var tmp;
					if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
						tmp = x2 >= 0 && y2 >= 0 && x2 < this1.getUInt16(0) && y2 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
					} else {
						var has = false;
						var view;
						if(v != null) {
							view = v;
						} else {
							var _g4 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
							var _g5 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
							var _g6 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
							var this2 = this1.b;
							var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
							view = new vision_ds_ImageView(_g4,_g5,_g6,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
						}
						switch(view.shape) {
						case 0:
							has = x2 < view.x + view.width && y2 < view.y + view.height && x2 >= view.x && y2 >= view.y;
							break;
						case 1:
							has = !(x2 < view.x + view.width && y2 < view.y + view.height && x2 >= view.x && y2 >= view.y);
							break;
						case 2:case 3:
							if(view.width > view.height) {
								var a = view.width / 2;
								var b = view.height / 2;
								var c = Math.sqrt(a * a - b * b);
								var x3 = view.x + view.width / 2 - c;
								var y3 = view.y + view.height / 2;
								if(y3 == null) {
									y3 = 0;
								}
								if(x3 == null) {
									x3 = 0;
								}
								var f1_x = x3;
								var f1_y = y3;
								var x4 = view.x + view.width / 2 + c;
								var y4 = view.y + view.height / 2;
								if(y4 == null) {
									y4 = 0;
								}
								if(x4 == null) {
									x4 = 0;
								}
								var f2_x = x4;
								var f2_y = y4;
								var p_x = x2;
								var p_y = y2;
								var x5 = p_x - f1_x;
								var y5 = p_y - f1_y;
								var x6 = p_x - f2_x;
								var y6 = p_y - f2_y;
								has = Math.sqrt(x5 * x5 + y5 * y5) + Math.sqrt(x6 * x6 + y6 * y6) <= view.width;
								if(view.shape == 3) {
									has = !has;
								}
							} else if(view.height > view.width) {
								var a1 = view.height / 2;
								var b1 = view.width / 2;
								var c1 = Math.sqrt(a1 * a1 - b1 * b1);
								var x7 = view.x + view.width / 2;
								var y7 = view.y + view.height / 2 - c1;
								if(y7 == null) {
									y7 = 0;
								}
								if(x7 == null) {
									x7 = 0;
								}
								var f1_x1 = x7;
								var f1_y1 = y7;
								var x8 = view.x + view.width / 2;
								var y8 = view.y + view.height / 2 + c1;
								if(y8 == null) {
									y8 = 0;
								}
								if(x8 == null) {
									x8 = 0;
								}
								var f2_x1 = x8;
								var f2_y1 = y8;
								var p_x1 = x2;
								var p_y1 = y2;
								var x9 = p_x1 - f1_x1;
								var y9 = p_y1 - f1_y1;
								var x10 = p_x1 - f2_x1;
								var y10 = p_y1 - f2_y1;
								has = Math.sqrt(x9 * x9 + y9 * y9) + Math.sqrt(x10 * x10 + y10 * y10) <= view.height;
								if(view.shape == 3) {
									has = !has;
								}
							} else {
								var x11 = x2;
								var y11 = y2;
								if(y11 == null) {
									y11 = 0;
								}
								if(x11 == null) {
									x11 = 0;
								}
								var point1_x = x11;
								var point1_y = y11;
								var x12 = view.x + view.width / 2;
								var y12 = view.y + view.height / 2;
								if(y12 == null) {
									y12 = 0;
								}
								if(x12 == null) {
									x12 = 0;
								}
								var point2_x = x12;
								var point2_y = y12;
								var x13 = point2_x - point1_x;
								var y13 = point2_y - point1_y;
								has = Math.sqrt(x13 * x13 + y13 * y13) <= view.width / 2;
								if(view.shape == 3) {
									has = !has;
								}
							}
							break;
						case 4:
							has = Math.abs(x2 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y2 - view.y - view.height / 2) / (view.height / 2) <= 1;
							break;
						case 5:
							has = !(Math.abs(x2 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y2 - view.y - view.height / 2) / (view.height / 2) <= 1);
							break;
						}
						tmp = has;
					}
					if(tmp) {
						var position1 = (y2 * this1.getUInt16(0) + x2) * 4;
						position1 += vision_ds_Image.OFFSET;
						this1.b[position1] = newColor >> 24 & 255;
						this1.b[position1 + 1] = newColor >> 16 & 255;
						this1.b[position1 + 2] = newColor >> 8 & 255;
						this1.b[position1 + 3] = newColor & 255;
					}
				} else {
					var position2 = (y2 * this1.getUInt16(0) + x2) * 4;
					position2 += vision_ds_Image.OFFSET;
					this1.b[position2] = newColor >> 24 & 255;
					this1.b[position2 + 1] = newColor >> 16 & 255;
					this1.b[position2 + 2] = newColor >> 8 & 255;
					this1.b[position2 + 3] = newColor & 255;
				}
			}
		}
	}
};
vision_ds_Image.paintSafePixel = function(this1,x,y,color) {
	var ma = this1.getUInt16(0) - 1;
	var values = [x,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [y,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y = min;
	if(x < 0 || x >= this1.getUInt16(0) || y < 0 || y >= Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
		var this_x = x;
		var this_y = y;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	} else if((color >> 24 & 255) / 255 == 1) {
		if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x;
			var this_y = y;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
					break;
				case 1:
					has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x1 = view.x + view.width / 2 - c;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f1_x = x1;
						var f1_y = y1;
						var x1 = view.x + view.width / 2 + c;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f2_x = x1;
						var f2_y = y1;
						var p_x = x;
						var p_y = y;
						var x1 = p_x - f1_x;
						var y1 = p_y - f1_y;
						var x2 = p_x - f2_x;
						var y2 = p_y - f2_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a = view.height / 2;
						var b = view.width / 2;
						var c = Math.sqrt(a * a - b * b);
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2 - c;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f1_x = x1;
						var f1_y = y1;
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2 + c;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f2_x = x1;
						var f2_y = y1;
						var p_x = x;
						var p_y = y;
						var x1 = p_x - f1_x;
						var y1 = p_y - f1_y;
						var x2 = p_x - f2_x;
						var y2 = p_y - f2_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x1 = x;
						var y1 = y;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var point1_x = x1;
						var point1_y = y1;
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var point2_x = x1;
						var point2_y = y1;
						var x1 = point2_x - point1_x;
						var y1 = point2_y - point1_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color >> 24 & 255;
				this1.b[position + 1] = color >> 16 & 255;
				this1.b[position + 2] = color >> 8 & 255;
				this1.b[position + 3] = color & 255;
			}
		} else {
			var position = (y * this1.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = color >> 24 & 255;
			this1.b[position + 1] = color >> 16 & 255;
			this1.b[position + 2] = color >> 8 & 255;
			this1.b[position + 3] = color & 255;
		}
	} else {
		if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x;
			var this_y = y;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		}
		var position = (y * this1.getUInt16(0) + x) * 4;
		position += vision_ds_Image.OFFSET;
		var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
		if(value == null) {
			value = 0;
		}
		var oldColor = value;
		var Red = (color >> 16 & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor >> 16 & 255) / 255 * (1 - (color >> 24 & 255) / 255);
		var Green = (color >> 8 & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor >> 8 & 255) / 255 * (1 - (color >> 24 & 255) / 255);
		var Blue = (color & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor & 255) / 255 * (1 - (color >> 24 & 255) / 255);
		var Alpha = (oldColor >> 24 & 255) / 255 + (1 - (oldColor >> 24 & 255) / 255) * ((color >> 24 & 255) / 255);
		if(Alpha == null) {
			Alpha = 1;
		}
		var color = 0;
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Red * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Green * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Blue * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		var newColor = color;
		if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x;
			var this_y = y;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
					break;
				case 1:
					has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x1 = view.x + view.width / 2 - c;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f1_x = x1;
						var f1_y = y1;
						var x1 = view.x + view.width / 2 + c;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f2_x = x1;
						var f2_y = y1;
						var p_x = x;
						var p_y = y;
						var x1 = p_x - f1_x;
						var y1 = p_y - f1_y;
						var x2 = p_x - f2_x;
						var y2 = p_y - f2_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a = view.height / 2;
						var b = view.width / 2;
						var c = Math.sqrt(a * a - b * b);
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2 - c;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f1_x = x1;
						var f1_y = y1;
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2 + c;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f2_x = x1;
						var f2_y = y1;
						var p_x = x;
						var p_y = y;
						var x1 = p_x - f1_x;
						var y1 = p_y - f1_y;
						var x2 = p_x - f2_x;
						var y2 = p_y - f2_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x1 = x;
						var y1 = y;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var point1_x = x1;
						var point1_y = y1;
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var point2_x = x1;
						var point2_y = y1;
						var x1 = point2_x - point1_x;
						var y1 = point2_y - point1_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = newColor >> 24 & 255;
				this1.b[position + 1] = newColor >> 16 & 255;
				this1.b[position + 2] = newColor >> 8 & 255;
				this1.b[position + 3] = newColor & 255;
			}
		} else {
			var position = (y * this1.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = newColor >> 24 & 255;
			this1.b[position + 1] = newColor >> 16 & 255;
			this1.b[position + 2] = newColor >> 8 & 255;
			this1.b[position + 3] = newColor & 255;
		}
	}
};
vision_ds_Image.paintUnsafePixel = function(this1,x,y,color) {
	var position = (y * this1.getUInt16(0) + x) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var oldColor = value;
	var Red = (color >> 16 & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor >> 16 & 255) / 255 * (1 - (color >> 24 & 255) / 255);
	var Green = (color >> 8 & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor >> 8 & 255) / 255 * (1 - (color >> 24 & 255) / 255);
	var Blue = (color & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor & 255) / 255 * (1 - (color >> 24 & 255) / 255);
	var Alpha = (oldColor >> 24 & 255) / 255 + (1 - (oldColor >> 24 & 255) / 255) * ((color >> 24 & 255) / 255);
	if(Alpha == null) {
		Alpha = 1;
	}
	var color = 0;
	var Alpha1 = Alpha;
	if(Alpha1 == null) {
		Alpha1 = 1;
	}
	var value = Math.round(Red * 255);
	color &= -16711681;
	color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
	var value = Math.round(Green * 255);
	color &= -65281;
	color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
	var value = Math.round(Blue * 255);
	color &= -256;
	color |= value > 255 ? 255 : value < 0 ? 0 : value;
	var value = Math.round(Alpha1 * 255);
	color &= 16777215;
	color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
	var newColor = color;
	var position = (y * this1.getUInt16(0) + x) * 4;
	position += vision_ds_Image.OFFSET;
	this1.b[position] = newColor >> 24 & 255;
	this1.b[position + 1] = newColor >> 16 & 255;
	this1.b[position + 2] = newColor >> 8 & 255;
	this1.b[position + 3] = newColor & 255;
};
vision_ds_Image.hasPixel = function(this1,x,y) {
	if(x >= 0 && y >= 0 && x < this1.getUInt16(0)) {
		return y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
	} else {
		return false;
	}
};
vision_ds_Image.movePixel = function(this1,fromX,fromY,toX,toY,oldPixelResetColor) {
	if(!(fromX >= 0 && fromY >= 0 && fromX < this1.getUInt16(0) && fromY < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = fromX;
		var this_y = fromY;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (fromY * this1.getUInt16(0) + fromX) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var color = value;
	if(!(toX >= 0 && toY >= 0 && toX < this1.getUInt16(0) && toY < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = toX;
		var this_y = toY;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
		var v = null;
		var tmp;
		if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
			tmp = toX >= 0 && toY >= 0 && toX < this1.getUInt16(0) && toY < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
		} else {
			var has = false;
			var view;
			if(v != null) {
				view = v;
			} else {
				var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
				var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
				var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
				var this2 = this1.b;
				var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
				view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
			}
			switch(view.shape) {
			case 0:
				has = toX < view.x + view.width && toY < view.y + view.height && toX >= view.x && toY >= view.y;
				break;
			case 1:
				has = !(toX < view.x + view.width && toY < view.y + view.height && toX >= view.x && toY >= view.y);
				break;
			case 2:case 3:
				if(view.width > view.height) {
					var a = view.width / 2;
					var b = view.height / 2;
					var c = Math.sqrt(a * a - b * b);
					var x = view.x + view.width / 2 - c;
					var y = view.y + view.height / 2;
					if(y == null) {
						y = 0;
					}
					if(x == null) {
						x = 0;
					}
					var f1_x = x;
					var f1_y = y;
					var x = view.x + view.width / 2 + c;
					var y = view.y + view.height / 2;
					if(y == null) {
						y = 0;
					}
					if(x == null) {
						x = 0;
					}
					var f2_x = x;
					var f2_y = y;
					var p_x = toX;
					var p_y = toY;
					var x = p_x - f1_x;
					var y = p_y - f1_y;
					var x1 = p_x - f2_x;
					var y1 = p_y - f2_y;
					has = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) <= view.width;
					if(view.shape == 3) {
						has = !has;
					}
				} else if(view.height > view.width) {
					var a = view.height / 2;
					var b = view.width / 2;
					var c = Math.sqrt(a * a - b * b);
					var x = view.x + view.width / 2;
					var y = view.y + view.height / 2 - c;
					if(y == null) {
						y = 0;
					}
					if(x == null) {
						x = 0;
					}
					var f1_x = x;
					var f1_y = y;
					var x = view.x + view.width / 2;
					var y = view.y + view.height / 2 + c;
					if(y == null) {
						y = 0;
					}
					if(x == null) {
						x = 0;
					}
					var f2_x = x;
					var f2_y = y;
					var p_x = toX;
					var p_y = toY;
					var x = p_x - f1_x;
					var y = p_y - f1_y;
					var x1 = p_x - f2_x;
					var y1 = p_y - f2_y;
					has = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) <= view.height;
					if(view.shape == 3) {
						has = !has;
					}
				} else {
					var x = toX;
					var y = toY;
					if(y == null) {
						y = 0;
					}
					if(x == null) {
						x = 0;
					}
					var point1_x = x;
					var point1_y = y;
					var x = view.x + view.width / 2;
					var y = view.y + view.height / 2;
					if(y == null) {
						y = 0;
					}
					if(x == null) {
						x = 0;
					}
					var point2_x = x;
					var point2_y = y;
					var x = point2_x - point1_x;
					var y = point2_y - point1_y;
					has = Math.sqrt(x * x + y * y) <= view.width / 2;
					if(view.shape == 3) {
						has = !has;
					}
				}
				break;
			case 4:
				has = Math.abs(toX - view.x - view.width / 2) / (view.width / 2) + Math.abs(toY - view.y - view.height / 2) / (view.height / 2) <= 1;
				break;
			case 5:
				has = !(Math.abs(toX - view.x - view.width / 2) / (view.width / 2) + Math.abs(toY - view.y - view.height / 2) / (view.height / 2) <= 1);
				break;
			}
			tmp = has;
		}
		if(tmp) {
			var position = (toY * this1.getUInt16(0) + toX) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = color >> 24 & 255;
			this1.b[position + 1] = color >> 16 & 255;
			this1.b[position + 2] = color >> 8 & 255;
			this1.b[position + 3] = color & 255;
		}
	} else {
		var position = (toY * this1.getUInt16(0) + toX) * 4;
		position += vision_ds_Image.OFFSET;
		this1.b[position] = color >> 24 & 255;
		this1.b[position + 1] = color >> 16 & 255;
		this1.b[position + 2] = color >> 8 & 255;
		this1.b[position + 3] = color & 255;
	}
	if(!(fromX >= 0 && fromY >= 0 && fromX < this1.getUInt16(0) && fromY < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = fromX;
		var this_y = fromY;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
		var v = null;
		var tmp;
		if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
			tmp = fromX >= 0 && fromY >= 0 && fromX < this1.getUInt16(0) && fromY < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
		} else {
			var has = false;
			var view;
			if(v != null) {
				view = v;
			} else {
				var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
				var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
				var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
				var this2 = this1.b;
				var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
				view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
			}
			switch(view.shape) {
			case 0:
				has = fromX < view.x + view.width && fromY < view.y + view.height && fromX >= view.x && fromY >= view.y;
				break;
			case 1:
				has = !(fromX < view.x + view.width && fromY < view.y + view.height && fromX >= view.x && fromY >= view.y);
				break;
			case 2:case 3:
				if(view.width > view.height) {
					var a = view.width / 2;
					var b = view.height / 2;
					var c = Math.sqrt(a * a - b * b);
					var x = view.x + view.width / 2 - c;
					var y = view.y + view.height / 2;
					if(y == null) {
						y = 0;
					}
					if(x == null) {
						x = 0;
					}
					var f1_x = x;
					var f1_y = y;
					var x = view.x + view.width / 2 + c;
					var y = view.y + view.height / 2;
					if(y == null) {
						y = 0;
					}
					if(x == null) {
						x = 0;
					}
					var f2_x = x;
					var f2_y = y;
					var p_x = fromX;
					var p_y = fromY;
					var x = p_x - f1_x;
					var y = p_y - f1_y;
					var x1 = p_x - f2_x;
					var y1 = p_y - f2_y;
					has = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) <= view.width;
					if(view.shape == 3) {
						has = !has;
					}
				} else if(view.height > view.width) {
					var a = view.height / 2;
					var b = view.width / 2;
					var c = Math.sqrt(a * a - b * b);
					var x = view.x + view.width / 2;
					var y = view.y + view.height / 2 - c;
					if(y == null) {
						y = 0;
					}
					if(x == null) {
						x = 0;
					}
					var f1_x = x;
					var f1_y = y;
					var x = view.x + view.width / 2;
					var y = view.y + view.height / 2 + c;
					if(y == null) {
						y = 0;
					}
					if(x == null) {
						x = 0;
					}
					var f2_x = x;
					var f2_y = y;
					var p_x = fromX;
					var p_y = fromY;
					var x = p_x - f1_x;
					var y = p_y - f1_y;
					var x1 = p_x - f2_x;
					var y1 = p_y - f2_y;
					has = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) <= view.height;
					if(view.shape == 3) {
						has = !has;
					}
				} else {
					var x = fromX;
					var y = fromY;
					if(y == null) {
						y = 0;
					}
					if(x == null) {
						x = 0;
					}
					var point1_x = x;
					var point1_y = y;
					var x = view.x + view.width / 2;
					var y = view.y + view.height / 2;
					if(y == null) {
						y = 0;
					}
					if(x == null) {
						x = 0;
					}
					var point2_x = x;
					var point2_y = y;
					var x = point2_x - point1_x;
					var y = point2_y - point1_y;
					has = Math.sqrt(x * x + y * y) <= view.width / 2;
					if(view.shape == 3) {
						has = !has;
					}
				}
				break;
			case 4:
				has = Math.abs(fromX - view.x - view.width / 2) / (view.width / 2) + Math.abs(fromY - view.y - view.height / 2) / (view.height / 2) <= 1;
				break;
			case 5:
				has = !(Math.abs(fromX - view.x - view.width / 2) / (view.width / 2) + Math.abs(fromY - view.y - view.height / 2) / (view.height / 2) <= 1);
				break;
			}
			tmp = has;
		}
		if(tmp) {
			var position = (fromY * this1.getUInt16(0) + fromX) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = oldPixelResetColor >> 24 & 255;
			this1.b[position + 1] = oldPixelResetColor >> 16 & 255;
			this1.b[position + 2] = oldPixelResetColor >> 8 & 255;
			this1.b[position + 3] = oldPixelResetColor & 255;
		}
	} else {
		var position = (fromY * this1.getUInt16(0) + fromX) * 4;
		position += vision_ds_Image.OFFSET;
		this1.b[position] = oldPixelResetColor >> 24 & 255;
		this1.b[position + 1] = oldPixelResetColor >> 16 & 255;
		this1.b[position + 2] = oldPixelResetColor >> 8 & 255;
		this1.b[position + 3] = oldPixelResetColor & 255;
	}
};
vision_ds_Image.moveSafePixel = function(this1,fromX,fromY,toX,toY,oldPixelResetColor) {
	var x = toX;
	var y = toY;
	var ma = this1.getUInt16(0) - 1;
	var values = [fromX,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x1 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [fromY,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x1;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x1) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var color = value;
	var ma = this1.getUInt16(0) - 1;
	var values = [x,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	x = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [y,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	y = min;
	if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
		var v = null;
		var tmp;
		if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
			tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
		} else {
			var has = false;
			var view;
			if(v != null) {
				view = v;
			} else {
				var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
				var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
				var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
				var this2 = this1.b;
				var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
				view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
			}
			switch(view.shape) {
			case 0:
				has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
				break;
			case 1:
				has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
				break;
			case 2:case 3:
				if(view.width > view.height) {
					var a = view.width / 2;
					var b = view.height / 2;
					var c = Math.sqrt(a * a - b * b);
					var x1 = view.x + view.width / 2 - c;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f1_x = x1;
					var f1_y = y1;
					var x1 = view.x + view.width / 2 + c;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f2_x = x1;
					var f2_y = y1;
					var p_x = x;
					var p_y = y;
					var x1 = p_x - f1_x;
					var y1 = p_y - f1_y;
					var x2 = p_x - f2_x;
					var y2 = p_y - f2_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
					if(view.shape == 3) {
						has = !has;
					}
				} else if(view.height > view.width) {
					var a = view.height / 2;
					var b = view.width / 2;
					var c = Math.sqrt(a * a - b * b);
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2 - c;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f1_x = x1;
					var f1_y = y1;
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2 + c;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f2_x = x1;
					var f2_y = y1;
					var p_x = x;
					var p_y = y;
					var x1 = p_x - f1_x;
					var y1 = p_y - f1_y;
					var x2 = p_x - f2_x;
					var y2 = p_y - f2_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
					if(view.shape == 3) {
						has = !has;
					}
				} else {
					var x1 = x;
					var y1 = y;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var point1_x = x1;
					var point1_y = y1;
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var point2_x = x1;
					var point2_y = y1;
					var x1 = point2_x - point1_x;
					var y1 = point2_y - point1_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
					if(view.shape == 3) {
						has = !has;
					}
				}
				break;
			case 4:
				has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
				break;
			case 5:
				has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
				break;
			}
			tmp = has;
		}
		if(tmp) {
			var position = (y * this1.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = color >> 24 & 255;
			this1.b[position + 1] = color >> 16 & 255;
			this1.b[position + 2] = color >> 8 & 255;
			this1.b[position + 3] = color & 255;
		}
	} else {
		var position = (y * this1.getUInt16(0) + x) * 4;
		position += vision_ds_Image.OFFSET;
		this1.b[position] = color >> 24 & 255;
		this1.b[position + 1] = color >> 16 & 255;
		this1.b[position + 2] = color >> 8 & 255;
		this1.b[position + 3] = color & 255;
	}
	var x = fromX;
	var y = fromY;
	var ma = this1.getUInt16(0) - 1;
	var values = [x,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	x = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [y,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	y = min;
	if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
		var v = null;
		var tmp;
		if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
			tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
		} else {
			var has = false;
			var view;
			if(v != null) {
				view = v;
			} else {
				var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
				var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
				var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
				var this2 = this1.b;
				var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
				view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
			}
			switch(view.shape) {
			case 0:
				has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
				break;
			case 1:
				has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
				break;
			case 2:case 3:
				if(view.width > view.height) {
					var a = view.width / 2;
					var b = view.height / 2;
					var c = Math.sqrt(a * a - b * b);
					var x1 = view.x + view.width / 2 - c;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f1_x = x1;
					var f1_y = y1;
					var x1 = view.x + view.width / 2 + c;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f2_x = x1;
					var f2_y = y1;
					var p_x = x;
					var p_y = y;
					var x1 = p_x - f1_x;
					var y1 = p_y - f1_y;
					var x2 = p_x - f2_x;
					var y2 = p_y - f2_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
					if(view.shape == 3) {
						has = !has;
					}
				} else if(view.height > view.width) {
					var a = view.height / 2;
					var b = view.width / 2;
					var c = Math.sqrt(a * a - b * b);
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2 - c;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f1_x = x1;
					var f1_y = y1;
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2 + c;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f2_x = x1;
					var f2_y = y1;
					var p_x = x;
					var p_y = y;
					var x1 = p_x - f1_x;
					var y1 = p_y - f1_y;
					var x2 = p_x - f2_x;
					var y2 = p_y - f2_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
					if(view.shape == 3) {
						has = !has;
					}
				} else {
					var x1 = x;
					var y1 = y;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var point1_x = x1;
					var point1_y = y1;
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var point2_x = x1;
					var point2_y = y1;
					var x1 = point2_x - point1_x;
					var y1 = point2_y - point1_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
					if(view.shape == 3) {
						has = !has;
					}
				}
				break;
			case 4:
				has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
				break;
			case 5:
				has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
				break;
			}
			tmp = has;
		}
		if(tmp) {
			var position = (y * this1.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = oldPixelResetColor >> 24 & 255;
			this1.b[position + 1] = oldPixelResetColor >> 16 & 255;
			this1.b[position + 2] = oldPixelResetColor >> 8 & 255;
			this1.b[position + 3] = oldPixelResetColor & 255;
		}
	} else {
		var position = (y * this1.getUInt16(0) + x) * 4;
		position += vision_ds_Image.OFFSET;
		this1.b[position] = oldPixelResetColor >> 24 & 255;
		this1.b[position + 1] = oldPixelResetColor >> 16 & 255;
		this1.b[position + 2] = oldPixelResetColor >> 8 & 255;
		this1.b[position + 3] = oldPixelResetColor & 255;
	}
};
vision_ds_Image.moveFloatingPixel = function(this1,fromX,fromY,toX,toY,oldPixelResetColor) {
	var x = fromX;
	var y = fromY;
	var tmp;
	var x1 = Math.ceil(x);
	var y1 = Math.ceil(y);
	if(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
		var x1 = Math.floor(x);
		var y1 = Math.floor(y);
		tmp = !(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)));
	} else {
		tmp = true;
	}
	if(tmp) {
		x = vision_tools_MathTools.boundFloat(x,0,this1.getUInt16(0) - 1);
		y = vision_tools_MathTools.boundFloat(y,0,Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1);
	}
	var yFraction = y - (y | 0);
	var xFraction = x - (x | 0);
	var x1 = 1 - yFraction;
	var x2 = x | 0;
	var y1 = y | 0;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = (1 - xFraction) * (value >> 16 & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x3 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [y | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x3 >= 0 && y1 >= 0 && x3 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x3;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x3) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x3 = x1 * (x2 + xFraction * (value >> 16 & 255));
	var x1 = 1 - xFraction;
	var ma = this1.getUInt16(0) - 1;
	var values = [x | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x2 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = x1 * (value >> 16 & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x1 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x1;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x1) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var red = x3 + yFraction * (x2 + xFraction * (value >> 16 & 255)) | 0;
	var x1 = 1 - yFraction;
	var x2 = x | 0;
	var y1 = y | 0;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = (1 - xFraction) * (value >> 8 & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x3 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [y | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x3 >= 0 && y1 >= 0 && x3 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x3;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x3) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x3 = x1 * (x2 + xFraction * (value >> 8 & 255));
	var x1 = 1 - xFraction;
	var ma = this1.getUInt16(0) - 1;
	var values = [x | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x2 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = x1 * (value >> 8 & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x1 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x1;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x1) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var green = x3 + yFraction * (x2 + xFraction * (value >> 8 & 255)) | 0;
	var x1 = 1 - yFraction;
	var x2 = x | 0;
	var y1 = y | 0;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = (1 - xFraction) * (value & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x3 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [y | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x3 >= 0 && y1 >= 0 && x3 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x3;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x3) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x3 = x1 * (x2 + xFraction * (value & 255));
	var x1 = 1 - xFraction;
	var ma = this1.getUInt16(0) - 1;
	var values = [x | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x2 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = x1 * (value & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x1 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x1;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x1) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var blue = x3 + yFraction * (x2 + xFraction * (value & 255)) | 0;
	var x1 = 1 - yFraction;
	var x2 = x | 0;
	var y1 = y | 0;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = (1 - xFraction) * (value >> 24 & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x3 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [y | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x3 >= 0 && y1 >= 0 && x3 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x3;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x3) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x3 = x1 * (x2 + xFraction * (value >> 24 & 255));
	var x1 = 1 - xFraction;
	var ma = this1.getUInt16(0) - 1;
	var values = [x | 0,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x2 = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y1 = min;
	if(!(x2 >= 0 && y1 >= 0 && x2 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x2;
		var this_y = y1;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y1 * this1.getUInt16(0) + x2) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var x2 = x1 * (value >> 24 & 255);
	var ma = this1.getUInt16(0) - 1;
	var values = [(x | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var x = min;
	var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var values = [(y | 0) + 1,0];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var y = min;
	if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x;
		var this_y = y;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y * this1.getUInt16(0) + x) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var alpha = x3 + yFraction * (x2 + xFraction * (value >> 24 & 255)) | 0;
	var Alpha = alpha;
	if(Alpha == null) {
		Alpha = 255;
	}
	var color = 0;
	var Alpha1 = Alpha;
	if(Alpha1 == null) {
		Alpha1 = 255;
	}
	color &= -16711681;
	color |= (red > 255 ? 255 : red < 0 ? 0 : red) << 16;
	color &= -65281;
	color |= (green > 255 ? 255 : green < 0 ? 0 : green) << 8;
	color &= -256;
	color |= blue > 255 ? 255 : blue < 0 ? 0 : blue;
	color &= 16777215;
	color |= (Alpha1 > 255 ? 255 : Alpha1 < 0 ? 0 : Alpha1) << 24;
	var color1 = color;
	var tmp;
	var x = Math.ceil(toX);
	var y = Math.ceil(toY);
	if(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
		var x = Math.floor(toX);
		var y = Math.floor(toY);
		tmp = !(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)));
	} else {
		tmp = true;
	}
	if(tmp) {
		var this2 = this1;
		var x = vision_tools_MathTools.boundFloat(toX,0,this1.getUInt16(0) - 1);
		var y = vision_tools_MathTools.boundFloat(toY,0,Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1);
		var tmp;
		var x1 = Math.ceil(x);
		var y1 = Math.ceil(y);
		if(x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4))) {
			var x1 = Math.floor(x);
			var y1 = Math.floor(y);
			tmp = !(x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4)));
		} else {
			tmp = true;
		}
		if(tmp) {
			vision_ds_Image.setFloatingPixel(this2,vision_tools_MathTools.boundFloat(x,0,this2.getUInt16(0) - 1),vision_tools_MathTools.boundFloat(y,0,Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4)) - 1),color1);
		} else {
			var yFraction = y - (y | 0);
			var xFraction = x - (x | 0);
			var x1 = Math.floor(x);
			var y1 = Math.floor(y);
			var Red = (1 - xFraction + (1 - yFraction)) / 2 * ((color1 >> 16 & 255) / 255);
			var Green = (1 - xFraction + (1 - yFraction)) / 2 * ((color1 >> 8 & 255) / 255);
			var Blue = (1 - xFraction + (1 - yFraction)) / 2 * ((color1 & 255) / 255);
			var Alpha = (color1 >> 24 & 255) / 255;
			if(Alpha == null) {
				Alpha = 1;
			}
			var color = 0;
			var Alpha1 = Alpha;
			if(Alpha1 == null) {
				Alpha1 = 1;
			}
			var value = Math.round(Red * 255);
			color &= -16711681;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
			var value = Math.round(Green * 255);
			color &= -65281;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
			var value = Math.round(Blue * 255);
			color &= -256;
			color |= value > 255 ? 255 : value < 0 ? 0 : value;
			var value = Math.round(Alpha1 * 255);
			color &= 16777215;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
			var color2 = color;
			if(!(x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4)))) {
				var this_x = x1;
				var this_y = y1;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this2,new vision_ds_Point2D(this_x,this_y)));
			} else if(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g = this2.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g1 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g2 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this3 = this2.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g,_g1,_g2,this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this3[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
						break;
					case 1:
						has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x2 = view.x + view.width / 2 - c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f1_x = x2;
							var f1_y = y2;
							var x2 = view.x + view.width / 2 + c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f2_x = x2;
							var f2_y = y2;
							var p_x = x1;
							var p_y = y1;
							var x2 = p_x - f1_x;
							var y2 = p_y - f1_y;
							var x3 = p_x - f2_x;
							var y3 = p_y - f2_y;
							has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a = view.height / 2;
							var b = view.width / 2;
							var c = Math.sqrt(a * a - b * b);
							var x2 = view.x + view.width / 2;
							var y2 = view.y + view.height / 2 - c;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f1_x = x2;
							var f1_y = y2;
							var x2 = view.x + view.width / 2;
							var y2 = view.y + view.height / 2 + c;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f2_x = x2;
							var f2_y = y2;
							var p_x = x1;
							var p_y = y1;
							var x2 = p_x - f1_x;
							var y2 = p_y - f1_y;
							var x3 = p_x - f2_x;
							var y3 = p_y - f2_y;
							has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x2 = x1;
							var y2 = y1;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var point1_x = x2;
							var point1_y = y2;
							var x2 = view.x + view.width / 2;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var point2_x = x2;
							var point2_y = y2;
							var x2 = point2_x - point1_x;
							var y2 = point2_y - point1_y;
							has = Math.sqrt(x2 * x2 + y2 * y2) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y1 * this2.getUInt16(0) + x1) * 4;
					position += vision_ds_Image.OFFSET;
					this2.b[position] = color2 >> 24 & 255;
					this2.b[position + 1] = color2 >> 16 & 255;
					this2.b[position + 2] = color2 >> 8 & 255;
					this2.b[position + 3] = color2 & 255;
				}
			} else {
				var position = (y1 * this2.getUInt16(0) + x1) * 4;
				position += vision_ds_Image.OFFSET;
				this2.b[position] = color2 >> 24 & 255;
				this2.b[position + 1] = color2 >> 16 & 255;
				this2.b[position + 2] = color2 >> 8 & 255;
				this2.b[position + 3] = color2 & 255;
			}
			if(y != (y | 0)) {
				var x1 = Math.floor(x);
				var y1 = Math.ceil(y);
				var Red = (1 - xFraction + yFraction) / 2 * ((color1 >> 16 & 255) / 255);
				var Green = (1 - xFraction + yFraction) / 2 * ((color1 >> 8 & 255) / 255);
				var Blue = (1 - xFraction + yFraction) / 2 * ((color1 & 255) / 255);
				var Alpha = (color1 >> 24 & 255) / 255;
				if(Alpha == null) {
					Alpha = 1;
				}
				var color = 0;
				var Alpha1 = Alpha;
				if(Alpha1 == null) {
					Alpha1 = 1;
				}
				var value = Math.round(Red * 255);
				color &= -16711681;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
				var value = Math.round(Green * 255);
				color &= -65281;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
				var value = Math.round(Blue * 255);
				color &= -256;
				color |= value > 255 ? 255 : value < 0 ? 0 : value;
				var value = Math.round(Alpha1 * 255);
				color &= 16777215;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
				var color2 = color;
				if(!(x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4)))) {
					var this_x = x1;
					var this_y = y1;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this2,new vision_ds_Point2D(this_x,this_y)));
				} else if(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
					var v = null;
					var tmp;
					if(!(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
						tmp = x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4));
					} else {
						var has = false;
						var view;
						if(v != null) {
							view = v;
						} else {
							var _g = this2.getUInt16(vision_ds_Image.WIDTH_BYTES);
							var _g1 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
							var _g2 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
							var this3 = this2.b;
							var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
							view = new vision_ds_ImageView(_g,_g1,_g2,this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this3[view1]);
						}
						switch(view.shape) {
						case 0:
							has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
							break;
						case 1:
							has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
							break;
						case 2:case 3:
							if(view.width > view.height) {
								var a = view.width / 2;
								var b = view.height / 2;
								var c = Math.sqrt(a * a - b * b);
								var x2 = view.x + view.width / 2 - c;
								var y2 = view.y + view.height / 2;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f1_x = x2;
								var f1_y = y2;
								var x2 = view.x + view.width / 2 + c;
								var y2 = view.y + view.height / 2;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f2_x = x2;
								var f2_y = y2;
								var p_x = x1;
								var p_y = y1;
								var x2 = p_x - f1_x;
								var y2 = p_y - f1_y;
								var x3 = p_x - f2_x;
								var y3 = p_y - f2_y;
								has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.width;
								if(view.shape == 3) {
									has = !has;
								}
							} else if(view.height > view.width) {
								var a = view.height / 2;
								var b = view.width / 2;
								var c = Math.sqrt(a * a - b * b);
								var x2 = view.x + view.width / 2;
								var y2 = view.y + view.height / 2 - c;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f1_x = x2;
								var f1_y = y2;
								var x2 = view.x + view.width / 2;
								var y2 = view.y + view.height / 2 + c;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f2_x = x2;
								var f2_y = y2;
								var p_x = x1;
								var p_y = y1;
								var x2 = p_x - f1_x;
								var y2 = p_y - f1_y;
								var x3 = p_x - f2_x;
								var y3 = p_y - f2_y;
								has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.height;
								if(view.shape == 3) {
									has = !has;
								}
							} else {
								var x2 = x1;
								var y2 = y1;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var point1_x = x2;
								var point1_y = y2;
								var x2 = view.x + view.width / 2;
								var y2 = view.y + view.height / 2;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var point2_x = x2;
								var point2_y = y2;
								var x2 = point2_x - point1_x;
								var y2 = point2_y - point1_y;
								has = Math.sqrt(x2 * x2 + y2 * y2) <= view.width / 2;
								if(view.shape == 3) {
									has = !has;
								}
							}
							break;
						case 4:
							has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
							break;
						case 5:
							has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
							break;
						}
						tmp = has;
					}
					if(tmp) {
						var position = (y1 * this2.getUInt16(0) + x1) * 4;
						position += vision_ds_Image.OFFSET;
						this2.b[position] = color2 >> 24 & 255;
						this2.b[position + 1] = color2 >> 16 & 255;
						this2.b[position + 2] = color2 >> 8 & 255;
						this2.b[position + 3] = color2 & 255;
					}
				} else {
					var position = (y1 * this2.getUInt16(0) + x1) * 4;
					position += vision_ds_Image.OFFSET;
					this2.b[position] = color2 >> 24 & 255;
					this2.b[position + 1] = color2 >> 16 & 255;
					this2.b[position + 2] = color2 >> 8 & 255;
					this2.b[position + 3] = color2 & 255;
				}
			}
			if(x != (x | 0)) {
				var x1 = Math.ceil(x);
				var y1 = Math.floor(y);
				var Red = (xFraction + (1 - yFraction)) / 2 * ((color1 >> 16 & 255) / 255);
				var Green = (xFraction + (1 - yFraction)) / 2 * ((color1 >> 8 & 255) / 255);
				var Blue = (xFraction + (1 - yFraction)) / 2 * ((color1 & 255) / 255);
				var Alpha = (color1 >> 24 & 255) / 255;
				if(Alpha == null) {
					Alpha = 1;
				}
				var color = 0;
				var Alpha1 = Alpha;
				if(Alpha1 == null) {
					Alpha1 = 1;
				}
				var value = Math.round(Red * 255);
				color &= -16711681;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
				var value = Math.round(Green * 255);
				color &= -65281;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
				var value = Math.round(Blue * 255);
				color &= -256;
				color |= value > 255 ? 255 : value < 0 ? 0 : value;
				var value = Math.round(Alpha1 * 255);
				color &= 16777215;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
				var color2 = color;
				if(!(x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4)))) {
					var this_x = x1;
					var this_y = y1;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this2,new vision_ds_Point2D(this_x,this_y)));
				} else if(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
					var v = null;
					var tmp;
					if(!(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
						tmp = x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4));
					} else {
						var has = false;
						var view;
						if(v != null) {
							view = v;
						} else {
							var _g = this2.getUInt16(vision_ds_Image.WIDTH_BYTES);
							var _g1 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
							var _g2 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
							var this3 = this2.b;
							var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
							view = new vision_ds_ImageView(_g,_g1,_g2,this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this3[view1]);
						}
						switch(view.shape) {
						case 0:
							has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
							break;
						case 1:
							has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
							break;
						case 2:case 3:
							if(view.width > view.height) {
								var a = view.width / 2;
								var b = view.height / 2;
								var c = Math.sqrt(a * a - b * b);
								var x2 = view.x + view.width / 2 - c;
								var y2 = view.y + view.height / 2;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f1_x = x2;
								var f1_y = y2;
								var x2 = view.x + view.width / 2 + c;
								var y2 = view.y + view.height / 2;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f2_x = x2;
								var f2_y = y2;
								var p_x = x1;
								var p_y = y1;
								var x2 = p_x - f1_x;
								var y2 = p_y - f1_y;
								var x3 = p_x - f2_x;
								var y3 = p_y - f2_y;
								has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.width;
								if(view.shape == 3) {
									has = !has;
								}
							} else if(view.height > view.width) {
								var a = view.height / 2;
								var b = view.width / 2;
								var c = Math.sqrt(a * a - b * b);
								var x2 = view.x + view.width / 2;
								var y2 = view.y + view.height / 2 - c;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f1_x = x2;
								var f1_y = y2;
								var x2 = view.x + view.width / 2;
								var y2 = view.y + view.height / 2 + c;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f2_x = x2;
								var f2_y = y2;
								var p_x = x1;
								var p_y = y1;
								var x2 = p_x - f1_x;
								var y2 = p_y - f1_y;
								var x3 = p_x - f2_x;
								var y3 = p_y - f2_y;
								has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.height;
								if(view.shape == 3) {
									has = !has;
								}
							} else {
								var x2 = x1;
								var y2 = y1;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var point1_x = x2;
								var point1_y = y2;
								var x2 = view.x + view.width / 2;
								var y2 = view.y + view.height / 2;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var point2_x = x2;
								var point2_y = y2;
								var x2 = point2_x - point1_x;
								var y2 = point2_y - point1_y;
								has = Math.sqrt(x2 * x2 + y2 * y2) <= view.width / 2;
								if(view.shape == 3) {
									has = !has;
								}
							}
							break;
						case 4:
							has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
							break;
						case 5:
							has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
							break;
						}
						tmp = has;
					}
					if(tmp) {
						var position = (y1 * this2.getUInt16(0) + x1) * 4;
						position += vision_ds_Image.OFFSET;
						this2.b[position] = color2 >> 24 & 255;
						this2.b[position + 1] = color2 >> 16 & 255;
						this2.b[position + 2] = color2 >> 8 & 255;
						this2.b[position + 3] = color2 & 255;
					}
				} else {
					var position = (y1 * this2.getUInt16(0) + x1) * 4;
					position += vision_ds_Image.OFFSET;
					this2.b[position] = color2 >> 24 & 255;
					this2.b[position + 1] = color2 >> 16 & 255;
					this2.b[position + 2] = color2 >> 8 & 255;
					this2.b[position + 3] = color2 & 255;
				}
			}
			if(x != (x | 0) && y != (y | 0)) {
				var x1 = Math.ceil(x);
				var y1 = Math.ceil(y);
				var Red = (xFraction + yFraction) / 2 * ((color1 >> 16 & 255) / 255);
				var Green = (xFraction + yFraction) / 2 * ((color1 >> 8 & 255) / 255);
				var Blue = (xFraction + yFraction) / 2 * ((color1 & 255) / 255);
				var Alpha = (color1 >> 24 & 255) / 255;
				if(Alpha == null) {
					Alpha = 1;
				}
				var color = 0;
				var Alpha1 = Alpha;
				if(Alpha1 == null) {
					Alpha1 = 1;
				}
				var value = Math.round(Red * 255);
				color &= -16711681;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
				var value = Math.round(Green * 255);
				color &= -65281;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
				var value = Math.round(Blue * 255);
				color &= -256;
				color |= value > 255 ? 255 : value < 0 ? 0 : value;
				var value = Math.round(Alpha1 * 255);
				color &= 16777215;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
				var color2 = color;
				if(!(x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4)))) {
					var this_x = x1;
					var this_y = y1;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this2,new vision_ds_Point2D(this_x,this_y)));
				} else if(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
					var v = null;
					var tmp;
					if(!(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
						tmp = x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4));
					} else {
						var has = false;
						var view;
						if(v != null) {
							view = v;
						} else {
							var _g = this2.getUInt16(vision_ds_Image.WIDTH_BYTES);
							var _g1 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
							var _g2 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
							var this3 = this2.b;
							var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
							view = new vision_ds_ImageView(_g,_g1,_g2,this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this3[view1]);
						}
						switch(view.shape) {
						case 0:
							has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
							break;
						case 1:
							has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
							break;
						case 2:case 3:
							if(view.width > view.height) {
								var a = view.width / 2;
								var b = view.height / 2;
								var c = Math.sqrt(a * a - b * b);
								var x = view.x + view.width / 2 - c;
								var y = view.y + view.height / 2;
								if(y == null) {
									y = 0;
								}
								if(x == null) {
									x = 0;
								}
								var f1_x = x;
								var f1_y = y;
								var x = view.x + view.width / 2 + c;
								var y = view.y + view.height / 2;
								if(y == null) {
									y = 0;
								}
								if(x == null) {
									x = 0;
								}
								var f2_x = x;
								var f2_y = y;
								var p_x = x1;
								var p_y = y1;
								var x = p_x - f1_x;
								var y = p_y - f1_y;
								var x2 = p_x - f2_x;
								var y2 = p_y - f2_y;
								has = Math.sqrt(x * x + y * y) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
								if(view.shape == 3) {
									has = !has;
								}
							} else if(view.height > view.width) {
								var a = view.height / 2;
								var b = view.width / 2;
								var c = Math.sqrt(a * a - b * b);
								var x = view.x + view.width / 2;
								var y = view.y + view.height / 2 - c;
								if(y == null) {
									y = 0;
								}
								if(x == null) {
									x = 0;
								}
								var f1_x = x;
								var f1_y = y;
								var x = view.x + view.width / 2;
								var y = view.y + view.height / 2 + c;
								if(y == null) {
									y = 0;
								}
								if(x == null) {
									x = 0;
								}
								var f2_x = x;
								var f2_y = y;
								var p_x = x1;
								var p_y = y1;
								var x = p_x - f1_x;
								var y = p_y - f1_y;
								var x2 = p_x - f2_x;
								var y2 = p_y - f2_y;
								has = Math.sqrt(x * x + y * y) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
								if(view.shape == 3) {
									has = !has;
								}
							} else {
								var x = x1;
								var y = y1;
								if(y == null) {
									y = 0;
								}
								if(x == null) {
									x = 0;
								}
								var point1_x = x;
								var point1_y = y;
								var x = view.x + view.width / 2;
								var y = view.y + view.height / 2;
								if(y == null) {
									y = 0;
								}
								if(x == null) {
									x = 0;
								}
								var point2_x = x;
								var point2_y = y;
								var x = point2_x - point1_x;
								var y = point2_y - point1_y;
								has = Math.sqrt(x * x + y * y) <= view.width / 2;
								if(view.shape == 3) {
									has = !has;
								}
							}
							break;
						case 4:
							has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
							break;
						case 5:
							has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
							break;
						}
						tmp = has;
					}
					if(tmp) {
						var position = (y1 * this2.getUInt16(0) + x1) * 4;
						position += vision_ds_Image.OFFSET;
						this2.b[position] = color2 >> 24 & 255;
						this2.b[position + 1] = color2 >> 16 & 255;
						this2.b[position + 2] = color2 >> 8 & 255;
						this2.b[position + 3] = color2 & 255;
					}
				} else {
					var position = (y1 * this2.getUInt16(0) + x1) * 4;
					position += vision_ds_Image.OFFSET;
					this2.b[position] = color2 >> 24 & 255;
					this2.b[position + 1] = color2 >> 16 & 255;
					this2.b[position + 2] = color2 >> 8 & 255;
					this2.b[position + 3] = color2 & 255;
				}
			}
		}
	} else {
		var yFraction = toY - (toY | 0);
		var xFraction = toX - (toX | 0);
		var x = Math.floor(toX);
		var y = Math.floor(toY);
		var Red = (1 - xFraction + (1 - yFraction)) / 2 * ((color1 >> 16 & 255) / 255);
		var Green = (1 - xFraction + (1 - yFraction)) / 2 * ((color1 >> 8 & 255) / 255);
		var Blue = (1 - xFraction + (1 - yFraction)) / 2 * ((color1 & 255) / 255);
		var Alpha = (color1 >> 24 & 255) / 255;
		if(Alpha == null) {
			Alpha = 1;
		}
		var color = 0;
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Red * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Green * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Blue * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		var color2 = color;
		if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x;
			var this_y = y;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
					break;
				case 1:
					has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x1 = view.x + view.width / 2 - c;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f1_x = x1;
						var f1_y = y1;
						var x1 = view.x + view.width / 2 + c;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f2_x = x1;
						var f2_y = y1;
						var p_x = x;
						var p_y = y;
						var x1 = p_x - f1_x;
						var y1 = p_y - f1_y;
						var x2 = p_x - f2_x;
						var y2 = p_y - f2_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a = view.height / 2;
						var b = view.width / 2;
						var c = Math.sqrt(a * a - b * b);
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2 - c;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f1_x = x1;
						var f1_y = y1;
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2 + c;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f2_x = x1;
						var f2_y = y1;
						var p_x = x;
						var p_y = y;
						var x1 = p_x - f1_x;
						var y1 = p_y - f1_y;
						var x2 = p_x - f2_x;
						var y2 = p_y - f2_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x1 = x;
						var y1 = y;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var point1_x = x1;
						var point1_y = y1;
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var point2_x = x1;
						var point2_y = y1;
						var x1 = point2_x - point1_x;
						var y1 = point2_y - point1_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color2 >> 24 & 255;
				this1.b[position + 1] = color2 >> 16 & 255;
				this1.b[position + 2] = color2 >> 8 & 255;
				this1.b[position + 3] = color2 & 255;
			}
		} else {
			var position = (y * this1.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = color2 >> 24 & 255;
			this1.b[position + 1] = color2 >> 16 & 255;
			this1.b[position + 2] = color2 >> 8 & 255;
			this1.b[position + 3] = color2 & 255;
		}
		if(toY != (toY | 0)) {
			var x = Math.floor(toX);
			var y = Math.ceil(toY);
			var Red = (1 - xFraction + yFraction) / 2 * ((color1 >> 16 & 255) / 255);
			var Green = (1 - xFraction + yFraction) / 2 * ((color1 >> 8 & 255) / 255);
			var Blue = (1 - xFraction + yFraction) / 2 * ((color1 & 255) / 255);
			var Alpha = (color1 >> 24 & 255) / 255;
			if(Alpha == null) {
				Alpha = 1;
			}
			var color = 0;
			var Alpha1 = Alpha;
			if(Alpha1 == null) {
				Alpha1 = 1;
			}
			var value = Math.round(Red * 255);
			color &= -16711681;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
			var value = Math.round(Green * 255);
			color &= -65281;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
			var value = Math.round(Blue * 255);
			color &= -256;
			color |= value > 255 ? 255 : value < 0 ? 0 : value;
			var value = Math.round(Alpha1 * 255);
			color &= 16777215;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
			var color2 = color;
			if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = x;
				var this_y = y;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
						break;
					case 1:
						has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2 - c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x1 = view.x + view.width / 2 + c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y1;
							var p_x = x;
							var p_y = y;
							var x1 = p_x - f1_x;
							var y1 = p_y - f1_y;
							var x2 = p_x - f2_x;
							var y2 = p_y - f2_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a = view.height / 2;
							var b = view.width / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2 - c;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2 + c;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y1;
							var p_x = x;
							var p_y = y;
							var x1 = p_x - f1_x;
							var y1 = p_y - f1_y;
							var x2 = p_x - f2_x;
							var y2 = p_y - f2_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x1 = x;
							var y1 = y;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var point1_x = x1;
							var point1_y = y1;
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var point2_x = x1;
							var point2_y = y1;
							var x1 = point2_x - point1_x;
							var y1 = point2_y - point1_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y * this1.getUInt16(0) + x) * 4;
					position += vision_ds_Image.OFFSET;
					this1.b[position] = color2 >> 24 & 255;
					this1.b[position + 1] = color2 >> 16 & 255;
					this1.b[position + 2] = color2 >> 8 & 255;
					this1.b[position + 3] = color2 & 255;
				}
			} else {
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color2 >> 24 & 255;
				this1.b[position + 1] = color2 >> 16 & 255;
				this1.b[position + 2] = color2 >> 8 & 255;
				this1.b[position + 3] = color2 & 255;
			}
		}
		if(toX != (toX | 0)) {
			var x = Math.ceil(toX);
			var y = Math.floor(toY);
			var Red = (xFraction + (1 - yFraction)) / 2 * ((color1 >> 16 & 255) / 255);
			var Green = (xFraction + (1 - yFraction)) / 2 * ((color1 >> 8 & 255) / 255);
			var Blue = (xFraction + (1 - yFraction)) / 2 * ((color1 & 255) / 255);
			var Alpha = (color1 >> 24 & 255) / 255;
			if(Alpha == null) {
				Alpha = 1;
			}
			var color = 0;
			var Alpha1 = Alpha;
			if(Alpha1 == null) {
				Alpha1 = 1;
			}
			var value = Math.round(Red * 255);
			color &= -16711681;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
			var value = Math.round(Green * 255);
			color &= -65281;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
			var value = Math.round(Blue * 255);
			color &= -256;
			color |= value > 255 ? 255 : value < 0 ? 0 : value;
			var value = Math.round(Alpha1 * 255);
			color &= 16777215;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
			var color2 = color;
			if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = x;
				var this_y = y;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
						break;
					case 1:
						has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2 - c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x1 = view.x + view.width / 2 + c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y1;
							var p_x = x;
							var p_y = y;
							var x1 = p_x - f1_x;
							var y1 = p_y - f1_y;
							var x2 = p_x - f2_x;
							var y2 = p_y - f2_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a = view.height / 2;
							var b = view.width / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2 - c;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2 + c;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y1;
							var p_x = x;
							var p_y = y;
							var x1 = p_x - f1_x;
							var y1 = p_y - f1_y;
							var x2 = p_x - f2_x;
							var y2 = p_y - f2_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x1 = x;
							var y1 = y;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var point1_x = x1;
							var point1_y = y1;
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var point2_x = x1;
							var point2_y = y1;
							var x1 = point2_x - point1_x;
							var y1 = point2_y - point1_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y * this1.getUInt16(0) + x) * 4;
					position += vision_ds_Image.OFFSET;
					this1.b[position] = color2 >> 24 & 255;
					this1.b[position + 1] = color2 >> 16 & 255;
					this1.b[position + 2] = color2 >> 8 & 255;
					this1.b[position + 3] = color2 & 255;
				}
			} else {
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color2 >> 24 & 255;
				this1.b[position + 1] = color2 >> 16 & 255;
				this1.b[position + 2] = color2 >> 8 & 255;
				this1.b[position + 3] = color2 & 255;
			}
		}
		if(toX != (toX | 0) && toY != (toY | 0)) {
			var x = Math.ceil(toX);
			var y = Math.ceil(toY);
			var Red = (xFraction + yFraction) / 2 * ((color1 >> 16 & 255) / 255);
			var Green = (xFraction + yFraction) / 2 * ((color1 >> 8 & 255) / 255);
			var Blue = (xFraction + yFraction) / 2 * ((color1 & 255) / 255);
			var Alpha = (color1 >> 24 & 255) / 255;
			if(Alpha == null) {
				Alpha = 1;
			}
			var color = 0;
			var Alpha1 = Alpha;
			if(Alpha1 == null) {
				Alpha1 = 1;
			}
			var value = Math.round(Red * 255);
			color &= -16711681;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
			var value = Math.round(Green * 255);
			color &= -65281;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
			var value = Math.round(Blue * 255);
			color &= -256;
			color |= value > 255 ? 255 : value < 0 ? 0 : value;
			var value = Math.round(Alpha1 * 255);
			color &= 16777215;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
			var color1 = color;
			if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = x;
				var this_y = y;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
						break;
					case 1:
						has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2 - c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x1 = view.x + view.width / 2 + c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y1;
							var p_x = x;
							var p_y = y;
							var x1 = p_x - f1_x;
							var y1 = p_y - f1_y;
							var x2 = p_x - f2_x;
							var y2 = p_y - f2_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a = view.height / 2;
							var b = view.width / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2 - c;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2 + c;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y1;
							var p_x = x;
							var p_y = y;
							var x1 = p_x - f1_x;
							var y1 = p_y - f1_y;
							var x2 = p_x - f2_x;
							var y2 = p_y - f2_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x1 = x;
							var y1 = y;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var point1_x = x1;
							var point1_y = y1;
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var point2_x = x1;
							var point2_y = y1;
							var x1 = point2_x - point1_x;
							var y1 = point2_y - point1_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y * this1.getUInt16(0) + x) * 4;
					position += vision_ds_Image.OFFSET;
					this1.b[position] = color1 >> 24 & 255;
					this1.b[position + 1] = color1 >> 16 & 255;
					this1.b[position + 2] = color1 >> 8 & 255;
					this1.b[position + 3] = color1 & 255;
				}
			} else {
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color1 >> 24 & 255;
				this1.b[position + 1] = color1 >> 16 & 255;
				this1.b[position + 2] = color1 >> 8 & 255;
				this1.b[position + 3] = color1 & 255;
			}
		}
	}
	var tmp;
	var x = Math.ceil(fromX);
	var y = Math.ceil(fromY);
	if(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
		var x = Math.floor(fromX);
		var y = Math.floor(fromY);
		tmp = !(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)));
	} else {
		tmp = true;
	}
	if(tmp) {
		var this2 = this1;
		var x = vision_tools_MathTools.boundFloat(fromX,0,this1.getUInt16(0) - 1);
		var y = vision_tools_MathTools.boundFloat(fromY,0,Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1);
		var tmp;
		var x1 = Math.ceil(x);
		var y1 = Math.ceil(y);
		if(x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4))) {
			var x1 = Math.floor(x);
			var y1 = Math.floor(y);
			tmp = !(x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4)));
		} else {
			tmp = true;
		}
		if(tmp) {
			vision_ds_Image.setFloatingPixel(this2,vision_tools_MathTools.boundFloat(x,0,this2.getUInt16(0) - 1),vision_tools_MathTools.boundFloat(y,0,Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4)) - 1),oldPixelResetColor);
		} else {
			var yFraction = y - (y | 0);
			var xFraction = x - (x | 0);
			var x1 = Math.floor(x);
			var y1 = Math.floor(y);
			var Red = (1 - xFraction + (1 - yFraction)) / 2 * ((oldPixelResetColor >> 16 & 255) / 255);
			var Green = (1 - xFraction + (1 - yFraction)) / 2 * ((oldPixelResetColor >> 8 & 255) / 255);
			var Blue = (1 - xFraction + (1 - yFraction)) / 2 * ((oldPixelResetColor & 255) / 255);
			var Alpha = (oldPixelResetColor >> 24 & 255) / 255;
			if(Alpha == null) {
				Alpha = 1;
			}
			var color = 0;
			var Alpha1 = Alpha;
			if(Alpha1 == null) {
				Alpha1 = 1;
			}
			var value = Math.round(Red * 255);
			color &= -16711681;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
			var value = Math.round(Green * 255);
			color &= -65281;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
			var value = Math.round(Blue * 255);
			color &= -256;
			color |= value > 255 ? 255 : value < 0 ? 0 : value;
			var value = Math.round(Alpha1 * 255);
			color &= 16777215;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
			var color1 = color;
			if(!(x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4)))) {
				var this_x = x1;
				var this_y = y1;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this2,new vision_ds_Point2D(this_x,this_y)));
			} else if(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g = this2.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g1 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g2 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this3 = this2.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g,_g1,_g2,this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this3[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
						break;
					case 1:
						has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x2 = view.x + view.width / 2 - c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f1_x = x2;
							var f1_y = y2;
							var x2 = view.x + view.width / 2 + c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f2_x = x2;
							var f2_y = y2;
							var p_x = x1;
							var p_y = y1;
							var x2 = p_x - f1_x;
							var y2 = p_y - f1_y;
							var x3 = p_x - f2_x;
							var y3 = p_y - f2_y;
							has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a = view.height / 2;
							var b = view.width / 2;
							var c = Math.sqrt(a * a - b * b);
							var x2 = view.x + view.width / 2;
							var y2 = view.y + view.height / 2 - c;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f1_x = x2;
							var f1_y = y2;
							var x2 = view.x + view.width / 2;
							var y2 = view.y + view.height / 2 + c;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f2_x = x2;
							var f2_y = y2;
							var p_x = x1;
							var p_y = y1;
							var x2 = p_x - f1_x;
							var y2 = p_y - f1_y;
							var x3 = p_x - f2_x;
							var y3 = p_y - f2_y;
							has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x2 = x1;
							var y2 = y1;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var point1_x = x2;
							var point1_y = y2;
							var x2 = view.x + view.width / 2;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var point2_x = x2;
							var point2_y = y2;
							var x2 = point2_x - point1_x;
							var y2 = point2_y - point1_y;
							has = Math.sqrt(x2 * x2 + y2 * y2) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y1 * this2.getUInt16(0) + x1) * 4;
					position += vision_ds_Image.OFFSET;
					this2.b[position] = color1 >> 24 & 255;
					this2.b[position + 1] = color1 >> 16 & 255;
					this2.b[position + 2] = color1 >> 8 & 255;
					this2.b[position + 3] = color1 & 255;
				}
			} else {
				var position = (y1 * this2.getUInt16(0) + x1) * 4;
				position += vision_ds_Image.OFFSET;
				this2.b[position] = color1 >> 24 & 255;
				this2.b[position + 1] = color1 >> 16 & 255;
				this2.b[position + 2] = color1 >> 8 & 255;
				this2.b[position + 3] = color1 & 255;
			}
			if(y != (y | 0)) {
				var x1 = Math.floor(x);
				var y1 = Math.ceil(y);
				var Red = (1 - xFraction + yFraction) / 2 * ((oldPixelResetColor >> 16 & 255) / 255);
				var Green = (1 - xFraction + yFraction) / 2 * ((oldPixelResetColor >> 8 & 255) / 255);
				var Blue = (1 - xFraction + yFraction) / 2 * ((oldPixelResetColor & 255) / 255);
				var Alpha = (oldPixelResetColor >> 24 & 255) / 255;
				if(Alpha == null) {
					Alpha = 1;
				}
				var color = 0;
				var Alpha1 = Alpha;
				if(Alpha1 == null) {
					Alpha1 = 1;
				}
				var value = Math.round(Red * 255);
				color &= -16711681;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
				var value = Math.round(Green * 255);
				color &= -65281;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
				var value = Math.round(Blue * 255);
				color &= -256;
				color |= value > 255 ? 255 : value < 0 ? 0 : value;
				var value = Math.round(Alpha1 * 255);
				color &= 16777215;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
				var color1 = color;
				if(!(x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4)))) {
					var this_x = x1;
					var this_y = y1;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this2,new vision_ds_Point2D(this_x,this_y)));
				} else if(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
					var v = null;
					var tmp;
					if(!(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
						tmp = x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4));
					} else {
						var has = false;
						var view;
						if(v != null) {
							view = v;
						} else {
							var _g = this2.getUInt16(vision_ds_Image.WIDTH_BYTES);
							var _g1 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
							var _g2 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
							var this3 = this2.b;
							var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
							view = new vision_ds_ImageView(_g,_g1,_g2,this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this3[view1]);
						}
						switch(view.shape) {
						case 0:
							has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
							break;
						case 1:
							has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
							break;
						case 2:case 3:
							if(view.width > view.height) {
								var a = view.width / 2;
								var b = view.height / 2;
								var c = Math.sqrt(a * a - b * b);
								var x2 = view.x + view.width / 2 - c;
								var y2 = view.y + view.height / 2;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f1_x = x2;
								var f1_y = y2;
								var x2 = view.x + view.width / 2 + c;
								var y2 = view.y + view.height / 2;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f2_x = x2;
								var f2_y = y2;
								var p_x = x1;
								var p_y = y1;
								var x2 = p_x - f1_x;
								var y2 = p_y - f1_y;
								var x3 = p_x - f2_x;
								var y3 = p_y - f2_y;
								has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.width;
								if(view.shape == 3) {
									has = !has;
								}
							} else if(view.height > view.width) {
								var a = view.height / 2;
								var b = view.width / 2;
								var c = Math.sqrt(a * a - b * b);
								var x2 = view.x + view.width / 2;
								var y2 = view.y + view.height / 2 - c;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f1_x = x2;
								var f1_y = y2;
								var x2 = view.x + view.width / 2;
								var y2 = view.y + view.height / 2 + c;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f2_x = x2;
								var f2_y = y2;
								var p_x = x1;
								var p_y = y1;
								var x2 = p_x - f1_x;
								var y2 = p_y - f1_y;
								var x3 = p_x - f2_x;
								var y3 = p_y - f2_y;
								has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.height;
								if(view.shape == 3) {
									has = !has;
								}
							} else {
								var x2 = x1;
								var y2 = y1;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var point1_x = x2;
								var point1_y = y2;
								var x2 = view.x + view.width / 2;
								var y2 = view.y + view.height / 2;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var point2_x = x2;
								var point2_y = y2;
								var x2 = point2_x - point1_x;
								var y2 = point2_y - point1_y;
								has = Math.sqrt(x2 * x2 + y2 * y2) <= view.width / 2;
								if(view.shape == 3) {
									has = !has;
								}
							}
							break;
						case 4:
							has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
							break;
						case 5:
							has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
							break;
						}
						tmp = has;
					}
					if(tmp) {
						var position = (y1 * this2.getUInt16(0) + x1) * 4;
						position += vision_ds_Image.OFFSET;
						this2.b[position] = color1 >> 24 & 255;
						this2.b[position + 1] = color1 >> 16 & 255;
						this2.b[position + 2] = color1 >> 8 & 255;
						this2.b[position + 3] = color1 & 255;
					}
				} else {
					var position = (y1 * this2.getUInt16(0) + x1) * 4;
					position += vision_ds_Image.OFFSET;
					this2.b[position] = color1 >> 24 & 255;
					this2.b[position + 1] = color1 >> 16 & 255;
					this2.b[position + 2] = color1 >> 8 & 255;
					this2.b[position + 3] = color1 & 255;
				}
			}
			if(x != (x | 0)) {
				var x1 = Math.ceil(x);
				var y1 = Math.floor(y);
				var Red = (xFraction + (1 - yFraction)) / 2 * ((oldPixelResetColor >> 16 & 255) / 255);
				var Green = (xFraction + (1 - yFraction)) / 2 * ((oldPixelResetColor >> 8 & 255) / 255);
				var Blue = (xFraction + (1 - yFraction)) / 2 * ((oldPixelResetColor & 255) / 255);
				var Alpha = (oldPixelResetColor >> 24 & 255) / 255;
				if(Alpha == null) {
					Alpha = 1;
				}
				var color = 0;
				var Alpha1 = Alpha;
				if(Alpha1 == null) {
					Alpha1 = 1;
				}
				var value = Math.round(Red * 255);
				color &= -16711681;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
				var value = Math.round(Green * 255);
				color &= -65281;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
				var value = Math.round(Blue * 255);
				color &= -256;
				color |= value > 255 ? 255 : value < 0 ? 0 : value;
				var value = Math.round(Alpha1 * 255);
				color &= 16777215;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
				var color1 = color;
				if(!(x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4)))) {
					var this_x = x1;
					var this_y = y1;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this2,new vision_ds_Point2D(this_x,this_y)));
				} else if(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
					var v = null;
					var tmp;
					if(!(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
						tmp = x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4));
					} else {
						var has = false;
						var view;
						if(v != null) {
							view = v;
						} else {
							var _g = this2.getUInt16(vision_ds_Image.WIDTH_BYTES);
							var _g1 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
							var _g2 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
							var this3 = this2.b;
							var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
							view = new vision_ds_ImageView(_g,_g1,_g2,this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this3[view1]);
						}
						switch(view.shape) {
						case 0:
							has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
							break;
						case 1:
							has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
							break;
						case 2:case 3:
							if(view.width > view.height) {
								var a = view.width / 2;
								var b = view.height / 2;
								var c = Math.sqrt(a * a - b * b);
								var x2 = view.x + view.width / 2 - c;
								var y2 = view.y + view.height / 2;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f1_x = x2;
								var f1_y = y2;
								var x2 = view.x + view.width / 2 + c;
								var y2 = view.y + view.height / 2;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f2_x = x2;
								var f2_y = y2;
								var p_x = x1;
								var p_y = y1;
								var x2 = p_x - f1_x;
								var y2 = p_y - f1_y;
								var x3 = p_x - f2_x;
								var y3 = p_y - f2_y;
								has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.width;
								if(view.shape == 3) {
									has = !has;
								}
							} else if(view.height > view.width) {
								var a = view.height / 2;
								var b = view.width / 2;
								var c = Math.sqrt(a * a - b * b);
								var x2 = view.x + view.width / 2;
								var y2 = view.y + view.height / 2 - c;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f1_x = x2;
								var f1_y = y2;
								var x2 = view.x + view.width / 2;
								var y2 = view.y + view.height / 2 + c;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f2_x = x2;
								var f2_y = y2;
								var p_x = x1;
								var p_y = y1;
								var x2 = p_x - f1_x;
								var y2 = p_y - f1_y;
								var x3 = p_x - f2_x;
								var y3 = p_y - f2_y;
								has = Math.sqrt(x2 * x2 + y2 * y2) + Math.sqrt(x3 * x3 + y3 * y3) <= view.height;
								if(view.shape == 3) {
									has = !has;
								}
							} else {
								var x2 = x1;
								var y2 = y1;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var point1_x = x2;
								var point1_y = y2;
								var x2 = view.x + view.width / 2;
								var y2 = view.y + view.height / 2;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var point2_x = x2;
								var point2_y = y2;
								var x2 = point2_x - point1_x;
								var y2 = point2_y - point1_y;
								has = Math.sqrt(x2 * x2 + y2 * y2) <= view.width / 2;
								if(view.shape == 3) {
									has = !has;
								}
							}
							break;
						case 4:
							has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
							break;
						case 5:
							has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
							break;
						}
						tmp = has;
					}
					if(tmp) {
						var position = (y1 * this2.getUInt16(0) + x1) * 4;
						position += vision_ds_Image.OFFSET;
						this2.b[position] = color1 >> 24 & 255;
						this2.b[position + 1] = color1 >> 16 & 255;
						this2.b[position + 2] = color1 >> 8 & 255;
						this2.b[position + 3] = color1 & 255;
					}
				} else {
					var position = (y1 * this2.getUInt16(0) + x1) * 4;
					position += vision_ds_Image.OFFSET;
					this2.b[position] = color1 >> 24 & 255;
					this2.b[position + 1] = color1 >> 16 & 255;
					this2.b[position + 2] = color1 >> 8 & 255;
					this2.b[position + 3] = color1 & 255;
				}
			}
			if(x != (x | 0) && y != (y | 0)) {
				var x1 = Math.ceil(x);
				var y1 = Math.ceil(y);
				var Red = (xFraction + yFraction) / 2 * ((oldPixelResetColor >> 16 & 255) / 255);
				var Green = (xFraction + yFraction) / 2 * ((oldPixelResetColor >> 8 & 255) / 255);
				var Blue = (xFraction + yFraction) / 2 * ((oldPixelResetColor & 255) / 255);
				var Alpha = (oldPixelResetColor >> 24 & 255) / 255;
				if(Alpha == null) {
					Alpha = 1;
				}
				var color = 0;
				var Alpha1 = Alpha;
				if(Alpha1 == null) {
					Alpha1 = 1;
				}
				var value = Math.round(Red * 255);
				color &= -16711681;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
				var value = Math.round(Green * 255);
				color &= -65281;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
				var value = Math.round(Blue * 255);
				color &= -256;
				color |= value > 255 ? 255 : value < 0 ? 0 : value;
				var value = Math.round(Alpha1 * 255);
				color &= 16777215;
				color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
				var color1 = color;
				if(!(x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4)))) {
					var this_x = x1;
					var this_y = y1;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this2,new vision_ds_Point2D(this_x,this_y)));
				} else if(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
					var v = null;
					var tmp;
					if(!(this2.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
						tmp = x1 >= 0 && y1 >= 0 && x1 < this2.getUInt16(0) && y1 < Math.ceil((this2.length - vision_ds_Image.OFFSET) / (this2.getUInt16(0) * 4));
					} else {
						var has = false;
						var view;
						if(v != null) {
							view = v;
						} else {
							var _g = this2.getUInt16(vision_ds_Image.WIDTH_BYTES);
							var _g1 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
							var _g2 = this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
							var this3 = this2.b;
							var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
							view = new vision_ds_ImageView(_g,_g1,_g2,this2.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this3[view1]);
						}
						switch(view.shape) {
						case 0:
							has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
							break;
						case 1:
							has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
							break;
						case 2:case 3:
							if(view.width > view.height) {
								var a = view.width / 2;
								var b = view.height / 2;
								var c = Math.sqrt(a * a - b * b);
								var x = view.x + view.width / 2 - c;
								var y = view.y + view.height / 2;
								if(y == null) {
									y = 0;
								}
								if(x == null) {
									x = 0;
								}
								var f1_x = x;
								var f1_y = y;
								var x = view.x + view.width / 2 + c;
								var y = view.y + view.height / 2;
								if(y == null) {
									y = 0;
								}
								if(x == null) {
									x = 0;
								}
								var f2_x = x;
								var f2_y = y;
								var p_x = x1;
								var p_y = y1;
								var x = p_x - f1_x;
								var y = p_y - f1_y;
								var x2 = p_x - f2_x;
								var y2 = p_y - f2_y;
								has = Math.sqrt(x * x + y * y) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
								if(view.shape == 3) {
									has = !has;
								}
							} else if(view.height > view.width) {
								var a = view.height / 2;
								var b = view.width / 2;
								var c = Math.sqrt(a * a - b * b);
								var x = view.x + view.width / 2;
								var y = view.y + view.height / 2 - c;
								if(y == null) {
									y = 0;
								}
								if(x == null) {
									x = 0;
								}
								var f1_x = x;
								var f1_y = y;
								var x = view.x + view.width / 2;
								var y = view.y + view.height / 2 + c;
								if(y == null) {
									y = 0;
								}
								if(x == null) {
									x = 0;
								}
								var f2_x = x;
								var f2_y = y;
								var p_x = x1;
								var p_y = y1;
								var x = p_x - f1_x;
								var y = p_y - f1_y;
								var x2 = p_x - f2_x;
								var y2 = p_y - f2_y;
								has = Math.sqrt(x * x + y * y) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
								if(view.shape == 3) {
									has = !has;
								}
							} else {
								var x = x1;
								var y = y1;
								if(y == null) {
									y = 0;
								}
								if(x == null) {
									x = 0;
								}
								var point1_x = x;
								var point1_y = y;
								var x = view.x + view.width / 2;
								var y = view.y + view.height / 2;
								if(y == null) {
									y = 0;
								}
								if(x == null) {
									x = 0;
								}
								var point2_x = x;
								var point2_y = y;
								var x = point2_x - point1_x;
								var y = point2_y - point1_y;
								has = Math.sqrt(x * x + y * y) <= view.width / 2;
								if(view.shape == 3) {
									has = !has;
								}
							}
							break;
						case 4:
							has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
							break;
						case 5:
							has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
							break;
						}
						tmp = has;
					}
					if(tmp) {
						var position = (y1 * this2.getUInt16(0) + x1) * 4;
						position += vision_ds_Image.OFFSET;
						this2.b[position] = color1 >> 24 & 255;
						this2.b[position + 1] = color1 >> 16 & 255;
						this2.b[position + 2] = color1 >> 8 & 255;
						this2.b[position + 3] = color1 & 255;
					}
				} else {
					var position = (y1 * this2.getUInt16(0) + x1) * 4;
					position += vision_ds_Image.OFFSET;
					this2.b[position] = color1 >> 24 & 255;
					this2.b[position + 1] = color1 >> 16 & 255;
					this2.b[position + 2] = color1 >> 8 & 255;
					this2.b[position + 3] = color1 & 255;
				}
			}
		}
	} else {
		var yFraction = fromY - (fromY | 0);
		var xFraction = fromX - (fromX | 0);
		var x = Math.floor(fromX);
		var y = Math.floor(fromY);
		var Red = (1 - xFraction + (1 - yFraction)) / 2 * ((oldPixelResetColor >> 16 & 255) / 255);
		var Green = (1 - xFraction + (1 - yFraction)) / 2 * ((oldPixelResetColor >> 8 & 255) / 255);
		var Blue = (1 - xFraction + (1 - yFraction)) / 2 * ((oldPixelResetColor & 255) / 255);
		var Alpha = (oldPixelResetColor >> 24 & 255) / 255;
		if(Alpha == null) {
			Alpha = 1;
		}
		var color = 0;
		var Alpha1 = Alpha;
		if(Alpha1 == null) {
			Alpha1 = 1;
		}
		var value = Math.round(Red * 255);
		color &= -16711681;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
		var value = Math.round(Green * 255);
		color &= -65281;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
		var value = Math.round(Blue * 255);
		color &= -256;
		color |= value > 255 ? 255 : value < 0 ? 0 : value;
		var value = Math.round(Alpha1 * 255);
		color &= 16777215;
		color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
		var color1 = color;
		if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x;
			var this_y = y;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
					break;
				case 1:
					has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x1 = view.x + view.width / 2 - c;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f1_x = x1;
						var f1_y = y1;
						var x1 = view.x + view.width / 2 + c;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f2_x = x1;
						var f2_y = y1;
						var p_x = x;
						var p_y = y;
						var x1 = p_x - f1_x;
						var y1 = p_y - f1_y;
						var x2 = p_x - f2_x;
						var y2 = p_y - f2_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a = view.height / 2;
						var b = view.width / 2;
						var c = Math.sqrt(a * a - b * b);
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2 - c;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f1_x = x1;
						var f1_y = y1;
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2 + c;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f2_x = x1;
						var f2_y = y1;
						var p_x = x;
						var p_y = y;
						var x1 = p_x - f1_x;
						var y1 = p_y - f1_y;
						var x2 = p_x - f2_x;
						var y2 = p_y - f2_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x1 = x;
						var y1 = y;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var point1_x = x1;
						var point1_y = y1;
						var x1 = view.x + view.width / 2;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var point2_x = x1;
						var point2_y = y1;
						var x1 = point2_x - point1_x;
						var y1 = point2_y - point1_y;
						has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color1 >> 24 & 255;
				this1.b[position + 1] = color1 >> 16 & 255;
				this1.b[position + 2] = color1 >> 8 & 255;
				this1.b[position + 3] = color1 & 255;
			}
		} else {
			var position = (y * this1.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = color1 >> 24 & 255;
			this1.b[position + 1] = color1 >> 16 & 255;
			this1.b[position + 2] = color1 >> 8 & 255;
			this1.b[position + 3] = color1 & 255;
		}
		if(fromY != (fromY | 0)) {
			var x = Math.floor(fromX);
			var y = Math.ceil(fromY);
			var Red = (1 - xFraction + yFraction) / 2 * ((oldPixelResetColor >> 16 & 255) / 255);
			var Green = (1 - xFraction + yFraction) / 2 * ((oldPixelResetColor >> 8 & 255) / 255);
			var Blue = (1 - xFraction + yFraction) / 2 * ((oldPixelResetColor & 255) / 255);
			var Alpha = (oldPixelResetColor >> 24 & 255) / 255;
			if(Alpha == null) {
				Alpha = 1;
			}
			var color = 0;
			var Alpha1 = Alpha;
			if(Alpha1 == null) {
				Alpha1 = 1;
			}
			var value = Math.round(Red * 255);
			color &= -16711681;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
			var value = Math.round(Green * 255);
			color &= -65281;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
			var value = Math.round(Blue * 255);
			color &= -256;
			color |= value > 255 ? 255 : value < 0 ? 0 : value;
			var value = Math.round(Alpha1 * 255);
			color &= 16777215;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
			var color1 = color;
			if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = x;
				var this_y = y;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
						break;
					case 1:
						has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2 - c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x1 = view.x + view.width / 2 + c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y1;
							var p_x = x;
							var p_y = y;
							var x1 = p_x - f1_x;
							var y1 = p_y - f1_y;
							var x2 = p_x - f2_x;
							var y2 = p_y - f2_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a = view.height / 2;
							var b = view.width / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2 - c;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2 + c;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y1;
							var p_x = x;
							var p_y = y;
							var x1 = p_x - f1_x;
							var y1 = p_y - f1_y;
							var x2 = p_x - f2_x;
							var y2 = p_y - f2_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x1 = x;
							var y1 = y;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var point1_x = x1;
							var point1_y = y1;
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var point2_x = x1;
							var point2_y = y1;
							var x1 = point2_x - point1_x;
							var y1 = point2_y - point1_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y * this1.getUInt16(0) + x) * 4;
					position += vision_ds_Image.OFFSET;
					this1.b[position] = color1 >> 24 & 255;
					this1.b[position + 1] = color1 >> 16 & 255;
					this1.b[position + 2] = color1 >> 8 & 255;
					this1.b[position + 3] = color1 & 255;
				}
			} else {
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color1 >> 24 & 255;
				this1.b[position + 1] = color1 >> 16 & 255;
				this1.b[position + 2] = color1 >> 8 & 255;
				this1.b[position + 3] = color1 & 255;
			}
		}
		if(fromX != (fromX | 0)) {
			var x = Math.ceil(fromX);
			var y = Math.floor(fromY);
			var Red = (xFraction + (1 - yFraction)) / 2 * ((oldPixelResetColor >> 16 & 255) / 255);
			var Green = (xFraction + (1 - yFraction)) / 2 * ((oldPixelResetColor >> 8 & 255) / 255);
			var Blue = (xFraction + (1 - yFraction)) / 2 * ((oldPixelResetColor & 255) / 255);
			var Alpha = (oldPixelResetColor >> 24 & 255) / 255;
			if(Alpha == null) {
				Alpha = 1;
			}
			var color = 0;
			var Alpha1 = Alpha;
			if(Alpha1 == null) {
				Alpha1 = 1;
			}
			var value = Math.round(Red * 255);
			color &= -16711681;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
			var value = Math.round(Green * 255);
			color &= -65281;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
			var value = Math.round(Blue * 255);
			color &= -256;
			color |= value > 255 ? 255 : value < 0 ? 0 : value;
			var value = Math.round(Alpha1 * 255);
			color &= 16777215;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
			var color1 = color;
			if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = x;
				var this_y = y;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
						break;
					case 1:
						has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2 - c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x1 = view.x + view.width / 2 + c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y1;
							var p_x = x;
							var p_y = y;
							var x1 = p_x - f1_x;
							var y1 = p_y - f1_y;
							var x2 = p_x - f2_x;
							var y2 = p_y - f2_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a = view.height / 2;
							var b = view.width / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2 - c;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2 + c;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y1;
							var p_x = x;
							var p_y = y;
							var x1 = p_x - f1_x;
							var y1 = p_y - f1_y;
							var x2 = p_x - f2_x;
							var y2 = p_y - f2_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x1 = x;
							var y1 = y;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var point1_x = x1;
							var point1_y = y1;
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var point2_x = x1;
							var point2_y = y1;
							var x1 = point2_x - point1_x;
							var y1 = point2_y - point1_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y * this1.getUInt16(0) + x) * 4;
					position += vision_ds_Image.OFFSET;
					this1.b[position] = color1 >> 24 & 255;
					this1.b[position + 1] = color1 >> 16 & 255;
					this1.b[position + 2] = color1 >> 8 & 255;
					this1.b[position + 3] = color1 & 255;
				}
			} else {
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color1 >> 24 & 255;
				this1.b[position + 1] = color1 >> 16 & 255;
				this1.b[position + 2] = color1 >> 8 & 255;
				this1.b[position + 3] = color1 & 255;
			}
		}
		if(fromX != (fromX | 0) && fromY != (fromY | 0)) {
			var x = Math.ceil(fromX);
			var y = Math.ceil(fromY);
			var Red = (xFraction + yFraction) / 2 * ((oldPixelResetColor >> 16 & 255) / 255);
			var Green = (xFraction + yFraction) / 2 * ((oldPixelResetColor >> 8 & 255) / 255);
			var Blue = (xFraction + yFraction) / 2 * ((oldPixelResetColor & 255) / 255);
			var Alpha = (oldPixelResetColor >> 24 & 255) / 255;
			if(Alpha == null) {
				Alpha = 1;
			}
			var color = 0;
			var Alpha1 = Alpha;
			if(Alpha1 == null) {
				Alpha1 = 1;
			}
			var value = Math.round(Red * 255);
			color &= -16711681;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 16;
			var value = Math.round(Green * 255);
			color &= -65281;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 8;
			var value = Math.round(Blue * 255);
			color &= -256;
			color |= value > 255 ? 255 : value < 0 ? 0 : value;
			var value = Math.round(Alpha1 * 255);
			color &= 16777215;
			color |= (value > 255 ? 255 : value < 0 ? 0 : value) << 24;
			var color1 = color;
			if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = x;
				var this_y = y;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
						break;
					case 1:
						has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2 - c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x1 = view.x + view.width / 2 + c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y1;
							var p_x = x;
							var p_y = y;
							var x1 = p_x - f1_x;
							var y1 = p_y - f1_y;
							var x2 = p_x - f2_x;
							var y2 = p_y - f2_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a = view.height / 2;
							var b = view.width / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2 - c;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2 + c;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y1;
							var p_x = x;
							var p_y = y;
							var x1 = p_x - f1_x;
							var y1 = p_y - f1_y;
							var x2 = p_x - f2_x;
							var y2 = p_y - f2_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x1 = x;
							var y1 = y;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var point1_x = x1;
							var point1_y = y1;
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var point2_x = x1;
							var point2_y = y1;
							var x1 = point2_x - point1_x;
							var y1 = point2_y - point1_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y * this1.getUInt16(0) + x) * 4;
					position += vision_ds_Image.OFFSET;
					this1.b[position] = color1 >> 24 & 255;
					this1.b[position + 1] = color1 >> 16 & 255;
					this1.b[position + 2] = color1 >> 8 & 255;
					this1.b[position + 3] = color1 & 255;
				}
			} else {
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color1 >> 24 & 255;
				this1.b[position + 1] = color1 >> 16 & 255;
				this1.b[position + 2] = color1 >> 8 & 255;
				this1.b[position + 3] = color1 & 255;
			}
		}
	}
};
vision_ds_Image.moveUnsafePixel = function(this1,fromX,fromY,toX,toY,oldPixelResetColor) {
	var position = (fromY * this1.getUInt16(0) + fromX) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var color = value;
	var position = (toY * this1.getUInt16(0) + toX) * 4;
	position += vision_ds_Image.OFFSET;
	this1.b[position] = color >> 24 & 255;
	this1.b[position + 1] = color >> 16 & 255;
	this1.b[position + 2] = color >> 8 & 255;
	this1.b[position + 3] = color & 255;
	var position = (fromY * this1.getUInt16(0) + fromX) * 4;
	position += vision_ds_Image.OFFSET;
	this1.b[position] = oldPixelResetColor >> 24 & 255;
	this1.b[position + 1] = oldPixelResetColor >> 16 & 255;
	this1.b[position + 2] = oldPixelResetColor >> 8 & 255;
	this1.b[position + 3] = oldPixelResetColor & 255;
};
vision_ds_Image.copyPixelFrom = function(this1,image,x,y) {
	if(!(x >= 0 && y >= 0 && x < image.getUInt16(0) && y < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
		var this_x = x;
		var this_y = y;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y * image.getUInt16(0) + x) * 4;
	position += vision_ds_Image.OFFSET;
	var value = image.b[position] << 24 | image.b[position + 1] << 16 | image.b[position + 2] << 8 | image.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var c = value;
	if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x;
		var this_y = y;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
		var v = null;
		var tmp;
		if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
			tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
		} else {
			var has = false;
			var view;
			if(v != null) {
				view = v;
			} else {
				var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
				var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
				var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
				var this2 = this1.b;
				var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
				view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
			}
			switch(view.shape) {
			case 0:
				has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
				break;
			case 1:
				has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
				break;
			case 2:case 3:
				if(view.width > view.height) {
					var a = view.width / 2;
					var b = view.height / 2;
					var c1 = Math.sqrt(a * a - b * b);
					var x1 = view.x + view.width / 2 - c1;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f1_x = x1;
					var f1_y = y1;
					var x1 = view.x + view.width / 2 + c1;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f2_x = x1;
					var f2_y = y1;
					var p_x = x;
					var p_y = y;
					var x1 = p_x - f1_x;
					var y1 = p_y - f1_y;
					var x2 = p_x - f2_x;
					var y2 = p_y - f2_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
					if(view.shape == 3) {
						has = !has;
					}
				} else if(view.height > view.width) {
					var a = view.height / 2;
					var b = view.width / 2;
					var c1 = Math.sqrt(a * a - b * b);
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2 - c1;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f1_x = x1;
					var f1_y = y1;
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2 + c1;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f2_x = x1;
					var f2_y = y1;
					var p_x = x;
					var p_y = y;
					var x1 = p_x - f1_x;
					var y1 = p_y - f1_y;
					var x2 = p_x - f2_x;
					var y2 = p_y - f2_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
					if(view.shape == 3) {
						has = !has;
					}
				} else {
					var x1 = x;
					var y1 = y;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var point1_x = x1;
					var point1_y = y1;
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var point2_x = x1;
					var point2_y = y1;
					var x1 = point2_x - point1_x;
					var y1 = point2_y - point1_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
					if(view.shape == 3) {
						has = !has;
					}
				}
				break;
			case 4:
				has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
				break;
			case 5:
				has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
				break;
			}
			tmp = has;
		}
		if(tmp) {
			var position = (y * this1.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			this1.b[position] = c >> 24 & 255;
			this1.b[position + 1] = c >> 16 & 255;
			this1.b[position + 2] = c >> 8 & 255;
			this1.b[position + 3] = c & 255;
		}
	} else {
		var position = (y * this1.getUInt16(0) + x) * 4;
		position += vision_ds_Image.OFFSET;
		this1.b[position] = c >> 24 & 255;
		this1.b[position + 1] = c >> 16 & 255;
		this1.b[position + 2] = c >> 8 & 255;
		this1.b[position + 3] = c & 255;
	}
	return c;
};
vision_ds_Image.copyPixelTo = function(this1,image,x,y) {
	var image1 = this1;
	if(!(x >= 0 && y >= 0 && x < image1.getUInt16(0) && y < Math.ceil((image1.length - vision_ds_Image.OFFSET) / (image1.getUInt16(0) * 4)))) {
		var this_x = x;
		var this_y = y;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y * image1.getUInt16(0) + x) * 4;
	position += vision_ds_Image.OFFSET;
	var value = image1.b[position] << 24 | image1.b[position + 1] << 16 | image1.b[position + 2] << 8 | image1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var c = value;
	if(!(x >= 0 && y >= 0 && x < image.getUInt16(0) && y < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
		var this_x = x;
		var this_y = y;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x,this_y)));
	} else if(image.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || image.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
		var v = null;
		var tmp;
		if(!(image.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || image.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
			tmp = x >= 0 && y >= 0 && x < image.getUInt16(0) && y < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4));
		} else {
			var has = false;
			var view;
			if(v != null) {
				view = v;
			} else {
				var _g = image.getUInt16(vision_ds_Image.WIDTH_BYTES);
				var _g1 = image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
				var _g2 = image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
				var image1 = image.b;
				var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
				view = new vision_ds_ImageView(_g,_g1,_g2,image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),image1[view1]);
			}
			switch(view.shape) {
			case 0:
				has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
				break;
			case 1:
				has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
				break;
			case 2:case 3:
				if(view.width > view.height) {
					var a = view.width / 2;
					var b = view.height / 2;
					var c1 = Math.sqrt(a * a - b * b);
					var x1 = view.x + view.width / 2 - c1;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f1_x = x1;
					var f1_y = y1;
					var x1 = view.x + view.width / 2 + c1;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f2_x = x1;
					var f2_y = y1;
					var p_x = x;
					var p_y = y;
					var x1 = p_x - f1_x;
					var y1 = p_y - f1_y;
					var x2 = p_x - f2_x;
					var y2 = p_y - f2_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
					if(view.shape == 3) {
						has = !has;
					}
				} else if(view.height > view.width) {
					var a = view.height / 2;
					var b = view.width / 2;
					var c1 = Math.sqrt(a * a - b * b);
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2 - c1;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f1_x = x1;
					var f1_y = y1;
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2 + c1;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var f2_x = x1;
					var f2_y = y1;
					var p_x = x;
					var p_y = y;
					var x1 = p_x - f1_x;
					var y1 = p_y - f1_y;
					var x2 = p_x - f2_x;
					var y2 = p_y - f2_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
					if(view.shape == 3) {
						has = !has;
					}
				} else {
					var x1 = x;
					var y1 = y;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var point1_x = x1;
					var point1_y = y1;
					var x1 = view.x + view.width / 2;
					var y1 = view.y + view.height / 2;
					if(y1 == null) {
						y1 = 0;
					}
					if(x1 == null) {
						x1 = 0;
					}
					var point2_x = x1;
					var point2_y = y1;
					var x1 = point2_x - point1_x;
					var y1 = point2_y - point1_y;
					has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
					if(view.shape == 3) {
						has = !has;
					}
				}
				break;
			case 4:
				has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
				break;
			case 5:
				has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
				break;
			}
			tmp = has;
		}
		if(tmp) {
			var position = (y * image.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			image.b[position] = c >> 24 & 255;
			image.b[position + 1] = c >> 16 & 255;
			image.b[position + 2] = c >> 8 & 255;
			image.b[position + 3] = c & 255;
		}
	} else {
		var position = (y * image.getUInt16(0) + x) * 4;
		position += vision_ds_Image.OFFSET;
		image.b[position] = c >> 24 & 255;
		image.b[position + 1] = c >> 16 & 255;
		image.b[position + 2] = c >> 8 & 255;
		image.b[position + 3] = c & 255;
	}
	return c;
};
vision_ds_Image.getImagePortion = function(this1,rect) {
	var width = rect.width;
	var color = 0;
	if(color == null) {
		color = 0;
	}
	var length = width * rect.height * 4 + vision_ds_Image.OFFSET;
	var this2 = new haxe_io_Bytes(new ArrayBuffer(length));
	this2.fill(0,length,0);
	var this3 = this2;
	this3.setUInt16(0,width);
	this3.setUInt16(vision_ds_Image.WIDTH_BYTES,0);
	this3.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP,0);
	this3.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES,0);
	this3.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP,0);
	this3.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] = 0;
	var i = vision_ds_Image.OFFSET;
	while(i < this3.length) {
		this3.b[i] = color >> 24 & 255;
		this3.b[i + 1] = color >> 16 & 255;
		this3.b[i + 2] = color >> 8 & 255;
		this3.b[i + 3] = color & 255;
		i += 4;
	}
	var subImage = this3;
	var _g = rect.x;
	var _g1 = rect.x + rect.width;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = rect.y;
		var _g3 = rect.y + rect.height;
		while(_g2 < _g3) {
			var y = _g2++;
			var x1 = x - rect.x;
			var y1 = y - rect.y;
			if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = x;
				var this_y = y;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			}
			var position = (y * this1.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
			if(value == null) {
				value = 0;
			}
			var color = value;
			if(!(x1 >= 0 && y1 >= 0 && x1 < subImage.getUInt16(0) && y1 < Math.ceil((subImage.length - vision_ds_Image.OFFSET) / (subImage.getUInt16(0) * 4)))) {
				var this_x1 = x1;
				var this_y1 = y1;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(subImage,new vision_ds_Point2D(this_x1,this_y1)));
			} else if(subImage.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || subImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || subImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || subImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || subImage.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(subImage.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || subImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || subImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || subImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || subImage.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x1 >= 0 && y1 >= 0 && x1 < subImage.getUInt16(0) && y1 < Math.ceil((subImage.length - vision_ds_Image.OFFSET) / (subImage.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g4 = subImage.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g5 = subImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g6 = subImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var subImage1 = subImage.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g4,_g5,_g6,subImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),subImage1[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
						break;
					case 1:
						has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x2 = view.x + view.width / 2 - c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f1_x = x2;
							var f1_y = y2;
							var x3 = view.x + view.width / 2 + c;
							var y3 = view.y + view.height / 2;
							if(y3 == null) {
								y3 = 0;
							}
							if(x3 == null) {
								x3 = 0;
							}
							var f2_x = x3;
							var f2_y = y3;
							var p_x = x1;
							var p_y = y1;
							var x4 = p_x - f1_x;
							var y4 = p_y - f1_y;
							var x5 = p_x - f2_x;
							var y5 = p_y - f2_y;
							has = Math.sqrt(x4 * x4 + y4 * y4) + Math.sqrt(x5 * x5 + y5 * y5) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a1 = view.height / 2;
							var b1 = view.width / 2;
							var c1 = Math.sqrt(a1 * a1 - b1 * b1);
							var x6 = view.x + view.width / 2;
							var y6 = view.y + view.height / 2 - c1;
							if(y6 == null) {
								y6 = 0;
							}
							if(x6 == null) {
								x6 = 0;
							}
							var f1_x1 = x6;
							var f1_y1 = y6;
							var x7 = view.x + view.width / 2;
							var y7 = view.y + view.height / 2 + c1;
							if(y7 == null) {
								y7 = 0;
							}
							if(x7 == null) {
								x7 = 0;
							}
							var f2_x1 = x7;
							var f2_y1 = y7;
							var p_x1 = x1;
							var p_y1 = y1;
							var x8 = p_x1 - f1_x1;
							var y8 = p_y1 - f1_y1;
							var x9 = p_x1 - f2_x1;
							var y9 = p_y1 - f2_y1;
							has = Math.sqrt(x8 * x8 + y8 * y8) + Math.sqrt(x9 * x9 + y9 * y9) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x10 = x1;
							var y10 = y1;
							if(y10 == null) {
								y10 = 0;
							}
							if(x10 == null) {
								x10 = 0;
							}
							var point1_x = x10;
							var point1_y = y10;
							var x11 = view.x + view.width / 2;
							var y11 = view.y + view.height / 2;
							if(y11 == null) {
								y11 = 0;
							}
							if(x11 == null) {
								x11 = 0;
							}
							var point2_x = x11;
							var point2_y = y11;
							var x12 = point2_x - point1_x;
							var y12 = point2_y - point1_y;
							has = Math.sqrt(x12 * x12 + y12 * y12) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position1 = (y1 * subImage.getUInt16(0) + x1) * 4;
					position1 += vision_ds_Image.OFFSET;
					subImage.b[position1] = color >> 24 & 255;
					subImage.b[position1 + 1] = color >> 16 & 255;
					subImage.b[position1 + 2] = color >> 8 & 255;
					subImage.b[position1 + 3] = color & 255;
				}
			} else {
				var position2 = (y1 * subImage.getUInt16(0) + x1) * 4;
				position2 += vision_ds_Image.OFFSET;
				subImage.b[position2] = color >> 24 & 255;
				subImage.b[position2 + 1] = color >> 16 & 255;
				subImage.b[position2 + 2] = color >> 8 & 255;
				subImage.b[position2 + 3] = color & 255;
			}
		}
	}
	return subImage;
};
vision_ds_Image.setImagePortion = function(this1,rect,image) {
	var _g = rect.x;
	var _g1 = rect.x + rect.width;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = rect.y;
		var _g3 = rect.y + rect.height;
		while(_g2 < _g3) {
			var y = _g2++;
			var x1 = x - rect.x;
			var y1 = y - rect.y;
			if(!(x1 >= 0 && y1 >= 0 && x1 < image.getUInt16(0) && y1 < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
				var this_x = x1;
				var this_y = y1;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x,this_y)));
			}
			var position = (y1 * image.getUInt16(0) + x1) * 4;
			position += vision_ds_Image.OFFSET;
			var value = image.b[position] << 24 | image.b[position + 1] << 16 | image.b[position + 2] << 8 | image.b[position + 3];
			if(value == null) {
				value = 0;
			}
			var color = value;
			if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x1 = x;
				var this_y1 = y;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x1,this_y1)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g4 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g5 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g6 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g4,_g5,_g6,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
						break;
					case 1:
						has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x2 = view.x + view.width / 2 - c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f1_x = x2;
							var f1_y = y2;
							var x3 = view.x + view.width / 2 + c;
							var y3 = view.y + view.height / 2;
							if(y3 == null) {
								y3 = 0;
							}
							if(x3 == null) {
								x3 = 0;
							}
							var f2_x = x3;
							var f2_y = y3;
							var p_x = x;
							var p_y = y;
							var x4 = p_x - f1_x;
							var y4 = p_y - f1_y;
							var x5 = p_x - f2_x;
							var y5 = p_y - f2_y;
							has = Math.sqrt(x4 * x4 + y4 * y4) + Math.sqrt(x5 * x5 + y5 * y5) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a1 = view.height / 2;
							var b1 = view.width / 2;
							var c1 = Math.sqrt(a1 * a1 - b1 * b1);
							var x6 = view.x + view.width / 2;
							var y6 = view.y + view.height / 2 - c1;
							if(y6 == null) {
								y6 = 0;
							}
							if(x6 == null) {
								x6 = 0;
							}
							var f1_x1 = x6;
							var f1_y1 = y6;
							var x7 = view.x + view.width / 2;
							var y7 = view.y + view.height / 2 + c1;
							if(y7 == null) {
								y7 = 0;
							}
							if(x7 == null) {
								x7 = 0;
							}
							var f2_x1 = x7;
							var f2_y1 = y7;
							var p_x1 = x;
							var p_y1 = y;
							var x8 = p_x1 - f1_x1;
							var y8 = p_y1 - f1_y1;
							var x9 = p_x1 - f2_x1;
							var y9 = p_y1 - f2_y1;
							has = Math.sqrt(x8 * x8 + y8 * y8) + Math.sqrt(x9 * x9 + y9 * y9) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x10 = x;
							var y10 = y;
							if(y10 == null) {
								y10 = 0;
							}
							if(x10 == null) {
								x10 = 0;
							}
							var point1_x = x10;
							var point1_y = y10;
							var x11 = view.x + view.width / 2;
							var y11 = view.y + view.height / 2;
							if(y11 == null) {
								y11 = 0;
							}
							if(x11 == null) {
								x11 = 0;
							}
							var point2_x = x11;
							var point2_y = y11;
							var x12 = point2_x - point1_x;
							var y12 = point2_y - point1_y;
							has = Math.sqrt(x12 * x12 + y12 * y12) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position1 = (y * this1.getUInt16(0) + x) * 4;
					position1 += vision_ds_Image.OFFSET;
					this1.b[position1] = color >> 24 & 255;
					this1.b[position1 + 1] = color >> 16 & 255;
					this1.b[position1 + 2] = color >> 8 & 255;
					this1.b[position1 + 3] = color & 255;
				}
			} else {
				var position2 = (y * this1.getUInt16(0) + x) * 4;
				position2 += vision_ds_Image.OFFSET;
				this1.b[position2] = color >> 24 & 255;
				this1.b[position2 + 1] = color >> 16 & 255;
				this1.b[position2 + 2] = color >> 8 & 255;
				this1.b[position2 + 3] = color & 255;
			}
		}
	}
};
vision_ds_Image.drawLine = function(this1,x1,y1,x2,y2,color) {
	var dx = Math.abs(x2 - x1);
	var dy = Math.abs(y2 - y1);
	var sx = x1 < x2 ? 1 : -1;
	var sy = y1 < y2 ? 1 : -1;
	var err = dx - dy;
	var safety = 0;
	while(safety++ < 10000) {
		var x = x1;
		var y = y1;
		var ma = this1.getUInt16(0) - 1;
		var values = [x,0];
		var max = values[0];
		var _g = 0;
		var _g1 = values.length;
		while(_g < _g1) {
			var i = _g++;
			if(values[i] > max) {
				max = values[i];
			}
		}
		var values1 = [max,ma];
		var min = values1[0];
		var _g2 = 0;
		var _g3 = values1.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			if(values1[i1] < min) {
				min = values1[i1];
			}
		}
		x = min;
		var ma1 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
		var values2 = [y,0];
		var max1 = values2[0];
		var _g4 = 0;
		var _g5 = values2.length;
		while(_g4 < _g5) {
			var i2 = _g4++;
			if(values2[i2] > max1) {
				max1 = values2[i2];
			}
		}
		var values3 = [max1,ma1];
		var min1 = values3[0];
		var _g6 = 0;
		var _g7 = values3.length;
		while(_g6 < _g7) {
			var i3 = _g6++;
			if(values3[i3] < min1) {
				min1 = values3[i3];
			}
		}
		y = min1;
		if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g8 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g9 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g10 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g8,_g9,_g10,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
					break;
				case 1:
					has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x3 = view.x + view.width / 2 - c;
						var y3 = view.y + view.height / 2;
						if(y3 == null) {
							y3 = 0;
						}
						if(x3 == null) {
							x3 = 0;
						}
						var f1_x = x3;
						var f1_y = y3;
						var x4 = view.x + view.width / 2 + c;
						var y4 = view.y + view.height / 2;
						if(y4 == null) {
							y4 = 0;
						}
						if(x4 == null) {
							x4 = 0;
						}
						var f2_x = x4;
						var f2_y = y4;
						var p_x = x;
						var p_y = y;
						var x5 = p_x - f1_x;
						var y5 = p_y - f1_y;
						var x6 = p_x - f2_x;
						var y6 = p_y - f2_y;
						has = Math.sqrt(x5 * x5 + y5 * y5) + Math.sqrt(x6 * x6 + y6 * y6) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a1 = view.height / 2;
						var b1 = view.width / 2;
						var c1 = Math.sqrt(a1 * a1 - b1 * b1);
						var x7 = view.x + view.width / 2;
						var y7 = view.y + view.height / 2 - c1;
						if(y7 == null) {
							y7 = 0;
						}
						if(x7 == null) {
							x7 = 0;
						}
						var f1_x1 = x7;
						var f1_y1 = y7;
						var x8 = view.x + view.width / 2;
						var y8 = view.y + view.height / 2 + c1;
						if(y8 == null) {
							y8 = 0;
						}
						if(x8 == null) {
							x8 = 0;
						}
						var f2_x1 = x8;
						var f2_y1 = y8;
						var p_x1 = x;
						var p_y1 = y;
						var x9 = p_x1 - f1_x1;
						var y9 = p_y1 - f1_y1;
						var x10 = p_x1 - f2_x1;
						var y10 = p_y1 - f2_y1;
						has = Math.sqrt(x9 * x9 + y9 * y9) + Math.sqrt(x10 * x10 + y10 * y10) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x11 = x;
						var y11 = y;
						if(y11 == null) {
							y11 = 0;
						}
						if(x11 == null) {
							x11 = 0;
						}
						var point1_x = x11;
						var point1_y = y11;
						var x12 = view.x + view.width / 2;
						var y12 = view.y + view.height / 2;
						if(y12 == null) {
							y12 = 0;
						}
						if(x12 == null) {
							x12 = 0;
						}
						var point2_x = x12;
						var point2_y = y12;
						var x13 = point2_x - point1_x;
						var y13 = point2_y - point1_y;
						has = Math.sqrt(x13 * x13 + y13 * y13) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color >> 24 & 255;
				this1.b[position + 1] = color >> 16 & 255;
				this1.b[position + 2] = color >> 8 & 255;
				this1.b[position + 3] = color & 255;
			}
		} else {
			var position1 = (y * this1.getUInt16(0) + x) * 4;
			position1 += vision_ds_Image.OFFSET;
			this1.b[position1] = color >> 24 & 255;
			this1.b[position1 + 1] = color >> 16 & 255;
			this1.b[position1 + 2] = color >> 8 & 255;
			this1.b[position1 + 3] = color & 255;
		}
		if(x1 == x2 && y1 == y2) {
			break;
		}
		var e2 = 2 * err;
		if(e2 > -dy) {
			err -= dy;
			x1 += sx;
		}
		if(e2 < dx) {
			err += dx;
			y1 += sy;
		}
	}
};
vision_ds_Image.drawRay2D = function(this1,line,color) {
	var px = line.point.x;
	var py = line.point.y;
	var x = (0 - (px > 0 ? py - line.slope * px : py + line.slope * px)) / line.slope;
	var y = 0;
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	var p_x = x;
	var p_y = y;
	var p1_x = p_x | 0;
	var p1_y = p_y | 0;
	var y = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
	var px = line.point.x;
	var py = line.point.y;
	var x = (y - (px > 0 ? py - line.slope * px : py + line.slope * px)) / line.slope;
	var y1 = y;
	if(y1 == null) {
		y1 = 0;
	}
	if(x == null) {
		x = 0;
	}
	var p_x = x;
	var p_y = y1;
	var p2_x = p_x | 0;
	var p2_y = p_y | 0;
	var x1 = p1_x;
	var y1 = p1_y;
	var x2 = p2_x;
	var y2 = p2_y;
	var dx = Math.abs(x2 - x1);
	var dy = Math.abs(y2 - y1);
	var sx = x1 < x2 ? 1 : -1;
	var sy = y1 < y2 ? 1 : -1;
	var err = dx - dy;
	var safetyNet = 0;
	while(safetyNet++ <= 10000) {
		if(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
			if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = x1;
				var this_y = y1;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
						break;
					case 1:
						has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x = view.x + view.width / 2 - c;
							var y = view.y + view.height / 2;
							if(y == null) {
								y = 0;
							}
							if(x == null) {
								x = 0;
							}
							var f1_x = x;
							var f1_y = y;
							var x3 = view.x + view.width / 2 + c;
							var y3 = view.y + view.height / 2;
							if(y3 == null) {
								y3 = 0;
							}
							if(x3 == null) {
								x3 = 0;
							}
							var f2_x = x3;
							var f2_y = y3;
							var p_x = x1;
							var p_y = y1;
							var x4 = p_x - f1_x;
							var y4 = p_y - f1_y;
							var x5 = p_x - f2_x;
							var y5 = p_y - f2_y;
							has = Math.sqrt(x4 * x4 + y4 * y4) + Math.sqrt(x5 * x5 + y5 * y5) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a1 = view.height / 2;
							var b1 = view.width / 2;
							var c1 = Math.sqrt(a1 * a1 - b1 * b1);
							var x6 = view.x + view.width / 2;
							var y6 = view.y + view.height / 2 - c1;
							if(y6 == null) {
								y6 = 0;
							}
							if(x6 == null) {
								x6 = 0;
							}
							var f1_x1 = x6;
							var f1_y1 = y6;
							var x7 = view.x + view.width / 2;
							var y7 = view.y + view.height / 2 + c1;
							if(y7 == null) {
								y7 = 0;
							}
							if(x7 == null) {
								x7 = 0;
							}
							var f2_x1 = x7;
							var f2_y1 = y7;
							var p_x1 = x1;
							var p_y1 = y1;
							var x8 = p_x1 - f1_x1;
							var y8 = p_y1 - f1_y1;
							var x9 = p_x1 - f2_x1;
							var y9 = p_y1 - f2_y1;
							has = Math.sqrt(x8 * x8 + y8 * y8) + Math.sqrt(x9 * x9 + y9 * y9) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x10 = x1;
							var y10 = y1;
							if(y10 == null) {
								y10 = 0;
							}
							if(x10 == null) {
								x10 = 0;
							}
							var point1_x = x10;
							var point1_y = y10;
							var x11 = view.x + view.width / 2;
							var y11 = view.y + view.height / 2;
							if(y11 == null) {
								y11 = 0;
							}
							if(x11 == null) {
								x11 = 0;
							}
							var point2_x = x11;
							var point2_y = y11;
							var x12 = point2_x - point1_x;
							var y12 = point2_y - point1_y;
							has = Math.sqrt(x12 * x12 + y12 * y12) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y1 * this1.getUInt16(0) + x1) * 4;
					position += vision_ds_Image.OFFSET;
					this1.b[position] = color >> 24 & 255;
					this1.b[position + 1] = color >> 16 & 255;
					this1.b[position + 2] = color >> 8 & 255;
					this1.b[position + 3] = color & 255;
				}
			} else {
				var position1 = (y1 * this1.getUInt16(0) + x1) * 4;
				position1 += vision_ds_Image.OFFSET;
				this1.b[position1] = color >> 24 & 255;
				this1.b[position1 + 1] = color >> 16 & 255;
				this1.b[position1 + 2] = color >> 8 & 255;
				this1.b[position1 + 3] = color & 255;
			}
		}
		if(x1 == x2 && y1 == y2) {
			break;
		}
		var e2 = 2 * err;
		if(e2 > -dy) {
			err -= dy;
			x1 += sx;
		}
		if(e2 < dx) {
			err += dx;
			y1 += sy;
		}
	}
};
vision_ds_Image.drawLine2D = function(this1,line,color) {
	var p = line.start;
	var p1_x = p.x | 0;
	var p1_y = p.y | 0;
	var p = line.end;
	var p2_x = p.x | 0;
	var p2_y = p.y | 0;
	var x1 = p1_x;
	var y1 = p1_y;
	var x2 = p2_x;
	var y2 = p2_y;
	var dx = Math.abs(x2 - x1);
	var dy = Math.abs(y2 - y1);
	var sx = x1 < x2 ? 1 : -1;
	var sy = y1 < y2 ? 1 : -1;
	var err = dx - dy;
	while(true) {
		if(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
			if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = x1;
				var this_y = y1;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
						break;
					case 1:
						has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x = view.x + view.width / 2 - c;
							var y = view.y + view.height / 2;
							if(y == null) {
								y = 0;
							}
							if(x == null) {
								x = 0;
							}
							var f1_x = x;
							var f1_y = y;
							var x3 = view.x + view.width / 2 + c;
							var y3 = view.y + view.height / 2;
							if(y3 == null) {
								y3 = 0;
							}
							if(x3 == null) {
								x3 = 0;
							}
							var f2_x = x3;
							var f2_y = y3;
							var p_x = x1;
							var p_y = y1;
							var x4 = p_x - f1_x;
							var y4 = p_y - f1_y;
							var x5 = p_x - f2_x;
							var y5 = p_y - f2_y;
							has = Math.sqrt(x4 * x4 + y4 * y4) + Math.sqrt(x5 * x5 + y5 * y5) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a1 = view.height / 2;
							var b1 = view.width / 2;
							var c1 = Math.sqrt(a1 * a1 - b1 * b1);
							var x6 = view.x + view.width / 2;
							var y6 = view.y + view.height / 2 - c1;
							if(y6 == null) {
								y6 = 0;
							}
							if(x6 == null) {
								x6 = 0;
							}
							var f1_x1 = x6;
							var f1_y1 = y6;
							var x7 = view.x + view.width / 2;
							var y7 = view.y + view.height / 2 + c1;
							if(y7 == null) {
								y7 = 0;
							}
							if(x7 == null) {
								x7 = 0;
							}
							var f2_x1 = x7;
							var f2_y1 = y7;
							var p_x1 = x1;
							var p_y1 = y1;
							var x8 = p_x1 - f1_x1;
							var y8 = p_y1 - f1_y1;
							var x9 = p_x1 - f2_x1;
							var y9 = p_y1 - f2_y1;
							has = Math.sqrt(x8 * x8 + y8 * y8) + Math.sqrt(x9 * x9 + y9 * y9) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x10 = x1;
							var y10 = y1;
							if(y10 == null) {
								y10 = 0;
							}
							if(x10 == null) {
								x10 = 0;
							}
							var point1_x = x10;
							var point1_y = y10;
							var x11 = view.x + view.width / 2;
							var y11 = view.y + view.height / 2;
							if(y11 == null) {
								y11 = 0;
							}
							if(x11 == null) {
								x11 = 0;
							}
							var point2_x = x11;
							var point2_y = y11;
							var x12 = point2_x - point1_x;
							var y12 = point2_y - point1_y;
							has = Math.sqrt(x12 * x12 + y12 * y12) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y1 * this1.getUInt16(0) + x1) * 4;
					position += vision_ds_Image.OFFSET;
					this1.b[position] = color >> 24 & 255;
					this1.b[position + 1] = color >> 16 & 255;
					this1.b[position + 2] = color >> 8 & 255;
					this1.b[position + 3] = color & 255;
				}
			} else {
				var position1 = (y1 * this1.getUInt16(0) + x1) * 4;
				position1 += vision_ds_Image.OFFSET;
				this1.b[position1] = color >> 24 & 255;
				this1.b[position1 + 1] = color >> 16 & 255;
				this1.b[position1 + 2] = color >> 8 & 255;
				this1.b[position1 + 3] = color & 255;
			}
		}
		if(x1 == x2 && y1 == y2) {
			break;
		}
		var e2 = 2 * err;
		if(e2 > -dy) {
			err -= dy;
			x1 += sx;
		}
		if(e2 < dx) {
			err += dx;
			y1 += sy;
		}
	}
};
vision_ds_Image.fillRect = function(this1,x,y,width,height,color) {
	var _g = x;
	var _g1 = x + width;
	while(_g < _g1) {
		var X = _g++;
		var _g2 = y;
		var _g3 = y + height;
		while(_g2 < _g3) {
			var Y = _g2++;
			if(!(X >= 0 && Y >= 0 && X < this1.getUInt16(0) && Y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = X;
				var this_y = Y;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = X >= 0 && Y >= 0 && X < this1.getUInt16(0) && Y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g4 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g5 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g6 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g4,_g5,_g6,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = X < view.x + view.width && Y < view.y + view.height && X >= view.x && Y >= view.y;
						break;
					case 1:
						has = !(X < view.x + view.width && Y < view.y + view.height && X >= view.x && Y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x = view.x + view.width / 2 - c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x == null) {
								x = 0;
							}
							var f1_x = x;
							var f1_y = y1;
							var x1 = view.x + view.width / 2 + c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y2;
							var p_x = X;
							var p_y = Y;
							var x2 = p_x - f1_x;
							var y3 = p_y - f1_y;
							var x3 = p_x - f2_x;
							var y4 = p_y - f2_y;
							has = Math.sqrt(x2 * x2 + y3 * y3) + Math.sqrt(x3 * x3 + y4 * y4) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a1 = view.height / 2;
							var b1 = view.width / 2;
							var c1 = Math.sqrt(a1 * a1 - b1 * b1);
							var x4 = view.x + view.width / 2;
							var y5 = view.y + view.height / 2 - c1;
							if(y5 == null) {
								y5 = 0;
							}
							if(x4 == null) {
								x4 = 0;
							}
							var f1_x1 = x4;
							var f1_y1 = y5;
							var x5 = view.x + view.width / 2;
							var y6 = view.y + view.height / 2 + c1;
							if(y6 == null) {
								y6 = 0;
							}
							if(x5 == null) {
								x5 = 0;
							}
							var f2_x1 = x5;
							var f2_y1 = y6;
							var p_x1 = X;
							var p_y1 = Y;
							var x6 = p_x1 - f1_x1;
							var y7 = p_y1 - f1_y1;
							var x7 = p_x1 - f2_x1;
							var y8 = p_y1 - f2_y1;
							has = Math.sqrt(x6 * x6 + y7 * y7) + Math.sqrt(x7 * x7 + y8 * y8) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x8 = X;
							var y9 = Y;
							if(y9 == null) {
								y9 = 0;
							}
							if(x8 == null) {
								x8 = 0;
							}
							var point1_x = x8;
							var point1_y = y9;
							var x9 = view.x + view.width / 2;
							var y10 = view.y + view.height / 2;
							if(y10 == null) {
								y10 = 0;
							}
							if(x9 == null) {
								x9 = 0;
							}
							var point2_x = x9;
							var point2_y = y10;
							var x10 = point2_x - point1_x;
							var y11 = point2_y - point1_y;
							has = Math.sqrt(x10 * x10 + y11 * y11) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(X - view.x - view.width / 2) / (view.width / 2) + Math.abs(Y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(X - view.x - view.width / 2) / (view.width / 2) + Math.abs(Y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (Y * this1.getUInt16(0) + X) * 4;
					position += vision_ds_Image.OFFSET;
					this1.b[position] = color >> 24 & 255;
					this1.b[position + 1] = color >> 16 & 255;
					this1.b[position + 2] = color >> 8 & 255;
					this1.b[position + 3] = color & 255;
				}
			} else {
				var position1 = (Y * this1.getUInt16(0) + X) * 4;
				position1 += vision_ds_Image.OFFSET;
				this1.b[position1] = color >> 24 & 255;
				this1.b[position1 + 1] = color >> 16 & 255;
				this1.b[position1 + 2] = color >> 8 & 255;
				this1.b[position1 + 3] = color & 255;
			}
		}
	}
};
vision_ds_Image.drawRect = function(this1,x,y,width,height,color) {
	var x1 = x;
	var y1 = y;
	var x2 = x + width;
	var dx = Math.abs(x2 - x1);
	var dy = Math.abs(y - y1);
	var sx = x1 < x2 ? 1 : -1;
	var sy = y1 < y ? 1 : -1;
	var err = dx - dy;
	var safety = 0;
	while(safety++ < 10000) {
		var x3 = x1;
		var y2 = y1;
		var ma = this1.getUInt16(0) - 1;
		var values = [x3,0];
		var max = values[0];
		var _g = 0;
		var _g1 = values.length;
		while(_g < _g1) {
			var i = _g++;
			if(values[i] > max) {
				max = values[i];
			}
		}
		var values1 = [max,ma];
		var min = values1[0];
		var _g2 = 0;
		var _g3 = values1.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			if(values1[i1] < min) {
				min = values1[i1];
			}
		}
		x3 = min;
		var ma1 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
		var values2 = [y2,0];
		var max1 = values2[0];
		var _g4 = 0;
		var _g5 = values2.length;
		while(_g4 < _g5) {
			var i2 = _g4++;
			if(values2[i2] > max1) {
				max1 = values2[i2];
			}
		}
		var values3 = [max1,ma1];
		var min1 = values3[0];
		var _g6 = 0;
		var _g7 = values3.length;
		while(_g6 < _g7) {
			var i3 = _g6++;
			if(values3[i3] < min1) {
				min1 = values3[i3];
			}
		}
		y2 = min1;
		if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x3 >= 0 && y2 >= 0 && x3 < this1.getUInt16(0) && y2 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g8 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g9 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g10 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g8,_g9,_g10,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x3 < view.x + view.width && y2 < view.y + view.height && x3 >= view.x && y2 >= view.y;
					break;
				case 1:
					has = !(x3 < view.x + view.width && y2 < view.y + view.height && x3 >= view.x && y2 >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x4 = view.x + view.width / 2 - c;
						var y3 = view.y + view.height / 2;
						if(y3 == null) {
							y3 = 0;
						}
						if(x4 == null) {
							x4 = 0;
						}
						var f1_x = x4;
						var f1_y = y3;
						var x5 = view.x + view.width / 2 + c;
						var y4 = view.y + view.height / 2;
						if(y4 == null) {
							y4 = 0;
						}
						if(x5 == null) {
							x5 = 0;
						}
						var f2_x = x5;
						var f2_y = y4;
						var p_x = x3;
						var p_y = y2;
						var x6 = p_x - f1_x;
						var y5 = p_y - f1_y;
						var x7 = p_x - f2_x;
						var y6 = p_y - f2_y;
						has = Math.sqrt(x6 * x6 + y5 * y5) + Math.sqrt(x7 * x7 + y6 * y6) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a1 = view.height / 2;
						var b1 = view.width / 2;
						var c1 = Math.sqrt(a1 * a1 - b1 * b1);
						var x8 = view.x + view.width / 2;
						var y7 = view.y + view.height / 2 - c1;
						if(y7 == null) {
							y7 = 0;
						}
						if(x8 == null) {
							x8 = 0;
						}
						var f1_x1 = x8;
						var f1_y1 = y7;
						var x9 = view.x + view.width / 2;
						var y8 = view.y + view.height / 2 + c1;
						if(y8 == null) {
							y8 = 0;
						}
						if(x9 == null) {
							x9 = 0;
						}
						var f2_x1 = x9;
						var f2_y1 = y8;
						var p_x1 = x3;
						var p_y1 = y2;
						var x10 = p_x1 - f1_x1;
						var y9 = p_y1 - f1_y1;
						var x11 = p_x1 - f2_x1;
						var y10 = p_y1 - f2_y1;
						has = Math.sqrt(x10 * x10 + y9 * y9) + Math.sqrt(x11 * x11 + y10 * y10) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x12 = x3;
						var y11 = y2;
						if(y11 == null) {
							y11 = 0;
						}
						if(x12 == null) {
							x12 = 0;
						}
						var point1_x = x12;
						var point1_y = y11;
						var x13 = view.x + view.width / 2;
						var y12 = view.y + view.height / 2;
						if(y12 == null) {
							y12 = 0;
						}
						if(x13 == null) {
							x13 = 0;
						}
						var point2_x = x13;
						var point2_y = y12;
						var x14 = point2_x - point1_x;
						var y13 = point2_y - point1_y;
						has = Math.sqrt(x14 * x14 + y13 * y13) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x3 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y2 - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x3 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y2 - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y2 * this1.getUInt16(0) + x3) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color >> 24 & 255;
				this1.b[position + 1] = color >> 16 & 255;
				this1.b[position + 2] = color >> 8 & 255;
				this1.b[position + 3] = color & 255;
			}
		} else {
			var position1 = (y2 * this1.getUInt16(0) + x3) * 4;
			position1 += vision_ds_Image.OFFSET;
			this1.b[position1] = color >> 24 & 255;
			this1.b[position1 + 1] = color >> 16 & 255;
			this1.b[position1 + 2] = color >> 8 & 255;
			this1.b[position1 + 3] = color & 255;
		}
		if(x1 == x2 && y1 == y) {
			break;
		}
		var e2 = 2 * err;
		if(e2 > -dy) {
			err -= dy;
			x1 += sx;
		}
		if(e2 < dx) {
			err += dx;
			y1 += sy;
		}
	}
	var x1 = x + width;
	var y1 = y;
	var x2 = x + width;
	var y2 = y + height;
	var dx = Math.abs(x2 - x1);
	var dy = Math.abs(y2 - y1);
	var sx = x1 < x2 ? 1 : -1;
	var sy = y1 < y2 ? 1 : -1;
	var err = dx - dy;
	var safety = 0;
	while(safety++ < 10000) {
		var x3 = x1;
		var y3 = y1;
		var ma = this1.getUInt16(0) - 1;
		var values = [x3,0];
		var max = values[0];
		var _g = 0;
		var _g1 = values.length;
		while(_g < _g1) {
			var i = _g++;
			if(values[i] > max) {
				max = values[i];
			}
		}
		var values1 = [max,ma];
		var min = values1[0];
		var _g2 = 0;
		var _g3 = values1.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			if(values1[i1] < min) {
				min = values1[i1];
			}
		}
		x3 = min;
		var ma1 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
		var values2 = [y3,0];
		var max1 = values2[0];
		var _g4 = 0;
		var _g5 = values2.length;
		while(_g4 < _g5) {
			var i2 = _g4++;
			if(values2[i2] > max1) {
				max1 = values2[i2];
			}
		}
		var values3 = [max1,ma1];
		var min1 = values3[0];
		var _g6 = 0;
		var _g7 = values3.length;
		while(_g6 < _g7) {
			var i3 = _g6++;
			if(values3[i3] < min1) {
				min1 = values3[i3];
			}
		}
		y3 = min1;
		if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x3 >= 0 && y3 >= 0 && x3 < this1.getUInt16(0) && y3 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g8 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g9 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g10 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g8,_g9,_g10,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x3 < view.x + view.width && y3 < view.y + view.height && x3 >= view.x && y3 >= view.y;
					break;
				case 1:
					has = !(x3 < view.x + view.width && y3 < view.y + view.height && x3 >= view.x && y3 >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x4 = view.x + view.width / 2 - c;
						var y4 = view.y + view.height / 2;
						if(y4 == null) {
							y4 = 0;
						}
						if(x4 == null) {
							x4 = 0;
						}
						var f1_x = x4;
						var f1_y = y4;
						var x5 = view.x + view.width / 2 + c;
						var y5 = view.y + view.height / 2;
						if(y5 == null) {
							y5 = 0;
						}
						if(x5 == null) {
							x5 = 0;
						}
						var f2_x = x5;
						var f2_y = y5;
						var p_x = x3;
						var p_y = y3;
						var x6 = p_x - f1_x;
						var y6 = p_y - f1_y;
						var x7 = p_x - f2_x;
						var y7 = p_y - f2_y;
						has = Math.sqrt(x6 * x6 + y6 * y6) + Math.sqrt(x7 * x7 + y7 * y7) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a1 = view.height / 2;
						var b1 = view.width / 2;
						var c1 = Math.sqrt(a1 * a1 - b1 * b1);
						var x8 = view.x + view.width / 2;
						var y8 = view.y + view.height / 2 - c1;
						if(y8 == null) {
							y8 = 0;
						}
						if(x8 == null) {
							x8 = 0;
						}
						var f1_x1 = x8;
						var f1_y1 = y8;
						var x9 = view.x + view.width / 2;
						var y9 = view.y + view.height / 2 + c1;
						if(y9 == null) {
							y9 = 0;
						}
						if(x9 == null) {
							x9 = 0;
						}
						var f2_x1 = x9;
						var f2_y1 = y9;
						var p_x1 = x3;
						var p_y1 = y3;
						var x10 = p_x1 - f1_x1;
						var y10 = p_y1 - f1_y1;
						var x11 = p_x1 - f2_x1;
						var y11 = p_y1 - f2_y1;
						has = Math.sqrt(x10 * x10 + y10 * y10) + Math.sqrt(x11 * x11 + y11 * y11) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x12 = x3;
						var y12 = y3;
						if(y12 == null) {
							y12 = 0;
						}
						if(x12 == null) {
							x12 = 0;
						}
						var point1_x = x12;
						var point1_y = y12;
						var x13 = view.x + view.width / 2;
						var y13 = view.y + view.height / 2;
						if(y13 == null) {
							y13 = 0;
						}
						if(x13 == null) {
							x13 = 0;
						}
						var point2_x = x13;
						var point2_y = y13;
						var x14 = point2_x - point1_x;
						var y14 = point2_y - point1_y;
						has = Math.sqrt(x14 * x14 + y14 * y14) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x3 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y3 - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x3 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y3 - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y3 * this1.getUInt16(0) + x3) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color >> 24 & 255;
				this1.b[position + 1] = color >> 16 & 255;
				this1.b[position + 2] = color >> 8 & 255;
				this1.b[position + 3] = color & 255;
			}
		} else {
			var position1 = (y3 * this1.getUInt16(0) + x3) * 4;
			position1 += vision_ds_Image.OFFSET;
			this1.b[position1] = color >> 24 & 255;
			this1.b[position1 + 1] = color >> 16 & 255;
			this1.b[position1 + 2] = color >> 8 & 255;
			this1.b[position1 + 3] = color & 255;
		}
		if(x1 == x2 && y1 == y2) {
			break;
		}
		var e2 = 2 * err;
		if(e2 > -dy) {
			err -= dy;
			x1 += sx;
		}
		if(e2 < dx) {
			err += dx;
			y1 += sy;
		}
	}
	var x1 = x + width;
	var y1 = y + height;
	var y2 = y + height;
	var dx = Math.abs(x - x1);
	var dy = Math.abs(y2 - y1);
	var sx = x1 < x ? 1 : -1;
	var sy = y1 < y2 ? 1 : -1;
	var err = dx - dy;
	var safety = 0;
	while(safety++ < 10000) {
		var x2 = x1;
		var y3 = y1;
		var ma = this1.getUInt16(0) - 1;
		var values = [x2,0];
		var max = values[0];
		var _g = 0;
		var _g1 = values.length;
		while(_g < _g1) {
			var i = _g++;
			if(values[i] > max) {
				max = values[i];
			}
		}
		var values1 = [max,ma];
		var min = values1[0];
		var _g2 = 0;
		var _g3 = values1.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			if(values1[i1] < min) {
				min = values1[i1];
			}
		}
		x2 = min;
		var ma1 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
		var values2 = [y3,0];
		var max1 = values2[0];
		var _g4 = 0;
		var _g5 = values2.length;
		while(_g4 < _g5) {
			var i2 = _g4++;
			if(values2[i2] > max1) {
				max1 = values2[i2];
			}
		}
		var values3 = [max1,ma1];
		var min1 = values3[0];
		var _g6 = 0;
		var _g7 = values3.length;
		while(_g6 < _g7) {
			var i3 = _g6++;
			if(values3[i3] < min1) {
				min1 = values3[i3];
			}
		}
		y3 = min1;
		if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x2 >= 0 && y3 >= 0 && x2 < this1.getUInt16(0) && y3 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g8 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g9 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g10 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g8,_g9,_g10,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x2 < view.x + view.width && y3 < view.y + view.height && x2 >= view.x && y3 >= view.y;
					break;
				case 1:
					has = !(x2 < view.x + view.width && y3 < view.y + view.height && x2 >= view.x && y3 >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x3 = view.x + view.width / 2 - c;
						var y4 = view.y + view.height / 2;
						if(y4 == null) {
							y4 = 0;
						}
						if(x3 == null) {
							x3 = 0;
						}
						var f1_x = x3;
						var f1_y = y4;
						var x4 = view.x + view.width / 2 + c;
						var y5 = view.y + view.height / 2;
						if(y5 == null) {
							y5 = 0;
						}
						if(x4 == null) {
							x4 = 0;
						}
						var f2_x = x4;
						var f2_y = y5;
						var p_x = x2;
						var p_y = y3;
						var x5 = p_x - f1_x;
						var y6 = p_y - f1_y;
						var x6 = p_x - f2_x;
						var y7 = p_y - f2_y;
						has = Math.sqrt(x5 * x5 + y6 * y6) + Math.sqrt(x6 * x6 + y7 * y7) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a1 = view.height / 2;
						var b1 = view.width / 2;
						var c1 = Math.sqrt(a1 * a1 - b1 * b1);
						var x7 = view.x + view.width / 2;
						var y8 = view.y + view.height / 2 - c1;
						if(y8 == null) {
							y8 = 0;
						}
						if(x7 == null) {
							x7 = 0;
						}
						var f1_x1 = x7;
						var f1_y1 = y8;
						var x8 = view.x + view.width / 2;
						var y9 = view.y + view.height / 2 + c1;
						if(y9 == null) {
							y9 = 0;
						}
						if(x8 == null) {
							x8 = 0;
						}
						var f2_x1 = x8;
						var f2_y1 = y9;
						var p_x1 = x2;
						var p_y1 = y3;
						var x9 = p_x1 - f1_x1;
						var y10 = p_y1 - f1_y1;
						var x10 = p_x1 - f2_x1;
						var y11 = p_y1 - f2_y1;
						has = Math.sqrt(x9 * x9 + y10 * y10) + Math.sqrt(x10 * x10 + y11 * y11) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x11 = x2;
						var y12 = y3;
						if(y12 == null) {
							y12 = 0;
						}
						if(x11 == null) {
							x11 = 0;
						}
						var point1_x = x11;
						var point1_y = y12;
						var x12 = view.x + view.width / 2;
						var y13 = view.y + view.height / 2;
						if(y13 == null) {
							y13 = 0;
						}
						if(x12 == null) {
							x12 = 0;
						}
						var point2_x = x12;
						var point2_y = y13;
						var x13 = point2_x - point1_x;
						var y14 = point2_y - point1_y;
						has = Math.sqrt(x13 * x13 + y14 * y14) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x2 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y3 - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x2 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y3 - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y3 * this1.getUInt16(0) + x2) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color >> 24 & 255;
				this1.b[position + 1] = color >> 16 & 255;
				this1.b[position + 2] = color >> 8 & 255;
				this1.b[position + 3] = color & 255;
			}
		} else {
			var position1 = (y3 * this1.getUInt16(0) + x2) * 4;
			position1 += vision_ds_Image.OFFSET;
			this1.b[position1] = color >> 24 & 255;
			this1.b[position1 + 1] = color >> 16 & 255;
			this1.b[position1 + 2] = color >> 8 & 255;
			this1.b[position1 + 3] = color & 255;
		}
		if(x1 == x && y1 == y2) {
			break;
		}
		var e2 = 2 * err;
		if(e2 > -dy) {
			err -= dy;
			x1 += sx;
		}
		if(e2 < dx) {
			err += dx;
			y1 += sy;
		}
	}
	var x1 = x;
	var y1 = y + height;
	var dx = Math.abs(x - x1);
	var dy = Math.abs(y - y1);
	var sx = x1 < x ? 1 : -1;
	var sy = y1 < y ? 1 : -1;
	var err = dx - dy;
	var safety = 0;
	while(safety++ < 10000) {
		var x2 = x1;
		var y2 = y1;
		var ma = this1.getUInt16(0) - 1;
		var values = [x2,0];
		var max = values[0];
		var _g = 0;
		var _g1 = values.length;
		while(_g < _g1) {
			var i = _g++;
			if(values[i] > max) {
				max = values[i];
			}
		}
		var values1 = [max,ma];
		var min = values1[0];
		var _g2 = 0;
		var _g3 = values1.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			if(values1[i1] < min) {
				min = values1[i1];
			}
		}
		x2 = min;
		var ma1 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
		var values2 = [y2,0];
		var max1 = values2[0];
		var _g4 = 0;
		var _g5 = values2.length;
		while(_g4 < _g5) {
			var i2 = _g4++;
			if(values2[i2] > max1) {
				max1 = values2[i2];
			}
		}
		var values3 = [max1,ma1];
		var min1 = values3[0];
		var _g6 = 0;
		var _g7 = values3.length;
		while(_g6 < _g7) {
			var i3 = _g6++;
			if(values3[i3] < min1) {
				min1 = values3[i3];
			}
		}
		y2 = min1;
		if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x2 >= 0 && y2 >= 0 && x2 < this1.getUInt16(0) && y2 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g8 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g9 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g10 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g8,_g9,_g10,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x2 < view.x + view.width && y2 < view.y + view.height && x2 >= view.x && y2 >= view.y;
					break;
				case 1:
					has = !(x2 < view.x + view.width && y2 < view.y + view.height && x2 >= view.x && y2 >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x3 = view.x + view.width / 2 - c;
						var y3 = view.y + view.height / 2;
						if(y3 == null) {
							y3 = 0;
						}
						if(x3 == null) {
							x3 = 0;
						}
						var f1_x = x3;
						var f1_y = y3;
						var x4 = view.x + view.width / 2 + c;
						var y4 = view.y + view.height / 2;
						if(y4 == null) {
							y4 = 0;
						}
						if(x4 == null) {
							x4 = 0;
						}
						var f2_x = x4;
						var f2_y = y4;
						var p_x = x2;
						var p_y = y2;
						var x5 = p_x - f1_x;
						var y5 = p_y - f1_y;
						var x6 = p_x - f2_x;
						var y6 = p_y - f2_y;
						has = Math.sqrt(x5 * x5 + y5 * y5) + Math.sqrt(x6 * x6 + y6 * y6) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a1 = view.height / 2;
						var b1 = view.width / 2;
						var c1 = Math.sqrt(a1 * a1 - b1 * b1);
						var x7 = view.x + view.width / 2;
						var y7 = view.y + view.height / 2 - c1;
						if(y7 == null) {
							y7 = 0;
						}
						if(x7 == null) {
							x7 = 0;
						}
						var f1_x1 = x7;
						var f1_y1 = y7;
						var x8 = view.x + view.width / 2;
						var y8 = view.y + view.height / 2 + c1;
						if(y8 == null) {
							y8 = 0;
						}
						if(x8 == null) {
							x8 = 0;
						}
						var f2_x1 = x8;
						var f2_y1 = y8;
						var p_x1 = x2;
						var p_y1 = y2;
						var x9 = p_x1 - f1_x1;
						var y9 = p_y1 - f1_y1;
						var x10 = p_x1 - f2_x1;
						var y10 = p_y1 - f2_y1;
						has = Math.sqrt(x9 * x9 + y9 * y9) + Math.sqrt(x10 * x10 + y10 * y10) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x11 = x2;
						var y11 = y2;
						if(y11 == null) {
							y11 = 0;
						}
						if(x11 == null) {
							x11 = 0;
						}
						var point1_x = x11;
						var point1_y = y11;
						var x12 = view.x + view.width / 2;
						var y12 = view.y + view.height / 2;
						if(y12 == null) {
							y12 = 0;
						}
						if(x12 == null) {
							x12 = 0;
						}
						var point2_x = x12;
						var point2_y = y12;
						var x13 = point2_x - point1_x;
						var y13 = point2_y - point1_y;
						has = Math.sqrt(x13 * x13 + y13 * y13) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x2 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y2 - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x2 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y2 - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y2 * this1.getUInt16(0) + x2) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color >> 24 & 255;
				this1.b[position + 1] = color >> 16 & 255;
				this1.b[position + 2] = color >> 8 & 255;
				this1.b[position + 3] = color & 255;
			}
		} else {
			var position1 = (y2 * this1.getUInt16(0) + x2) * 4;
			position1 += vision_ds_Image.OFFSET;
			this1.b[position1] = color >> 24 & 255;
			this1.b[position1 + 1] = color >> 16 & 255;
			this1.b[position1 + 2] = color >> 8 & 255;
			this1.b[position1 + 3] = color & 255;
		}
		if(x1 == x && y1 == y) {
			break;
		}
		var e2 = 2 * err;
		if(e2 > -dy) {
			err -= dy;
			x1 += sx;
		}
		if(e2 < dx) {
			err += dx;
			y1 += sy;
		}
	}
};
vision_ds_Image.drawQuadraticBezier = function(this1,line,control,color,accuracy) {
	if(accuracy == null) {
		accuracy = 1000;
	}
	var bezier = function(t,p0,p1,p2) {
		var t2 = t * t;
		var t3 = t2 * t;
		var x = p0.x * (1 - t) * (1 - t) + p1.x * 2 * t * (1 - t) + p2.x * t * t;
		var y = p0.y * (1 - t) * (1 - t) + p1.y * 2 * t * (1 - t) + p2.y * t * t;
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		var p_x = x;
		var p_y = y;
		return new vision_ds__$IntPoint2D_Impl(p_x | 0,p_y | 0);
	};
	var p = line.start;
	var p0 = new vision_ds__$IntPoint2D_Impl(p.x | 0,p.y | 0);
	var p = line.end;
	var p1 = new vision_ds__$IntPoint2D_Impl(p.x | 0,p.y | 0);
	var x = control.x;
	var y = control.y;
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	var p_x = x;
	var p_y = y;
	var p2 = new vision_ds__$IntPoint2D_Impl(p_x | 0,p_y | 0);
	var i = 0.;
	var step = 1 / accuracy;
	while(i <= 1) {
		var p = bezier(i,p0,p1,p2);
		var x = p.x;
		var y = p.y;
		if(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
			var x1 = p.x;
			var y1 = p.y;
			if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = x1;
				var this_y = y1;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
						break;
					case 1:
						has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x2 = view.x + view.width / 2 - c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f1_x = x2;
							var f1_y = y2;
							var x3 = view.x + view.width / 2 + c;
							var y3 = view.y + view.height / 2;
							if(y3 == null) {
								y3 = 0;
							}
							if(x3 == null) {
								x3 = 0;
							}
							var f2_x = x3;
							var f2_y = y3;
							var p_x = x1;
							var p_y = y1;
							var x4 = p_x - f1_x;
							var y4 = p_y - f1_y;
							var x5 = p_x - f2_x;
							var y5 = p_y - f2_y;
							has = Math.sqrt(x4 * x4 + y4 * y4) + Math.sqrt(x5 * x5 + y5 * y5) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a1 = view.height / 2;
							var b1 = view.width / 2;
							var c1 = Math.sqrt(a1 * a1 - b1 * b1);
							var x6 = view.x + view.width / 2;
							var y6 = view.y + view.height / 2 - c1;
							if(y6 == null) {
								y6 = 0;
							}
							if(x6 == null) {
								x6 = 0;
							}
							var f1_x1 = x6;
							var f1_y1 = y6;
							var x7 = view.x + view.width / 2;
							var y7 = view.y + view.height / 2 + c1;
							if(y7 == null) {
								y7 = 0;
							}
							if(x7 == null) {
								x7 = 0;
							}
							var f2_x1 = x7;
							var f2_y1 = y7;
							var p_x1 = x1;
							var p_y1 = y1;
							var x8 = p_x1 - f1_x1;
							var y8 = p_y1 - f1_y1;
							var x9 = p_x1 - f2_x1;
							var y9 = p_y1 - f2_y1;
							has = Math.sqrt(x8 * x8 + y8 * y8) + Math.sqrt(x9 * x9 + y9 * y9) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x10 = x1;
							var y10 = y1;
							if(y10 == null) {
								y10 = 0;
							}
							if(x10 == null) {
								x10 = 0;
							}
							var point1_x = x10;
							var point1_y = y10;
							var x11 = view.x + view.width / 2;
							var y11 = view.y + view.height / 2;
							if(y11 == null) {
								y11 = 0;
							}
							if(x11 == null) {
								x11 = 0;
							}
							var point2_x = x11;
							var point2_y = y11;
							var x12 = point2_x - point1_x;
							var y12 = point2_y - point1_y;
							has = Math.sqrt(x12 * x12 + y12 * y12) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y1 * this1.getUInt16(0) + x1) * 4;
					position += vision_ds_Image.OFFSET;
					this1.b[position] = color >> 24 & 255;
					this1.b[position + 1] = color >> 16 & 255;
					this1.b[position + 2] = color >> 8 & 255;
					this1.b[position + 3] = color & 255;
				}
			} else {
				var position1 = (y1 * this1.getUInt16(0) + x1) * 4;
				position1 += vision_ds_Image.OFFSET;
				this1.b[position1] = color >> 24 & 255;
				this1.b[position1 + 1] = color >> 16 & 255;
				this1.b[position1 + 2] = color >> 8 & 255;
				this1.b[position1 + 3] = color & 255;
			}
		}
		i += step;
	}
};
vision_ds_Image.drawCubicBezier = function(this1,line,control1,control2,color,accuracy) {
	if(accuracy == null) {
		accuracy = 1000;
	}
	var i = 0.;
	var step = 1 / accuracy;
	while(i < 1) {
		var p = line.start;
		var p0_x = p.x | 0;
		var p0_y = p.y | 0;
		var p1 = line.end;
		var p1_x = p1.x | 0;
		var p1_y = p1.y | 0;
		var cX = 3 * (p1_x - p0_x);
		var bX = 3 * (control1.x - p1_x) - cX;
		var aX = control2.x - p0_x - cX - bX;
		var cY = 3 * (p1_y - p0_y);
		var bY = 3 * (control1.y - p1_y) - cY;
		var aY = control2.y - p0_y - cY - bY;
		var x = aX * Math.pow(i,3) + bX * Math.pow(i,2) + cX * i + p0_x;
		var y = aY * Math.pow(i,3) + bY * Math.pow(i,2) + cY * i + p0_y;
		var x1 = x;
		var y1 = y;
		if(y1 == null) {
			y1 = 0;
		}
		if(x1 == null) {
			x1 = 0;
		}
		var p_x = x1;
		var p_y = y1;
		var p_x1 = p_x | 0;
		var p_y1 = p_y | 0;
		var x2 = p_x1;
		var y2 = p_y1;
		if(x2 >= 0 && y2 >= 0 && x2 < this1.getUInt16(0) && y2 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
			var x3 = p_x1;
			var y3 = p_y1;
			if(!(x3 >= 0 && y3 >= 0 && x3 < this1.getUInt16(0) && y3 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = x3;
				var this_y = y3;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x3 >= 0 && y3 >= 0 && x3 < this1.getUInt16(0) && y3 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x3 < view.x + view.width && y3 < view.y + view.height && x3 >= view.x && y3 >= view.y;
						break;
					case 1:
						has = !(x3 < view.x + view.width && y3 < view.y + view.height && x3 >= view.x && y3 >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x4 = view.x + view.width / 2 - c;
							var y4 = view.y + view.height / 2;
							if(y4 == null) {
								y4 = 0;
							}
							if(x4 == null) {
								x4 = 0;
							}
							var f1_x = x4;
							var f1_y = y4;
							var x5 = view.x + view.width / 2 + c;
							var y5 = view.y + view.height / 2;
							if(y5 == null) {
								y5 = 0;
							}
							if(x5 == null) {
								x5 = 0;
							}
							var f2_x = x5;
							var f2_y = y5;
							var p_x2 = x3;
							var p_y2 = y3;
							var x6 = p_x2 - f1_x;
							var y6 = p_y2 - f1_y;
							var x7 = p_x2 - f2_x;
							var y7 = p_y2 - f2_y;
							has = Math.sqrt(x6 * x6 + y6 * y6) + Math.sqrt(x7 * x7 + y7 * y7) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a1 = view.height / 2;
							var b1 = view.width / 2;
							var c1 = Math.sqrt(a1 * a1 - b1 * b1);
							var x8 = view.x + view.width / 2;
							var y8 = view.y + view.height / 2 - c1;
							if(y8 == null) {
								y8 = 0;
							}
							if(x8 == null) {
								x8 = 0;
							}
							var f1_x1 = x8;
							var f1_y1 = y8;
							var x9 = view.x + view.width / 2;
							var y9 = view.y + view.height / 2 + c1;
							if(y9 == null) {
								y9 = 0;
							}
							if(x9 == null) {
								x9 = 0;
							}
							var f2_x1 = x9;
							var f2_y1 = y9;
							var p_x3 = x3;
							var p_y3 = y3;
							var x10 = p_x3 - f1_x1;
							var y10 = p_y3 - f1_y1;
							var x11 = p_x3 - f2_x1;
							var y11 = p_y3 - f2_y1;
							has = Math.sqrt(x10 * x10 + y10 * y10) + Math.sqrt(x11 * x11 + y11 * y11) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x12 = x3;
							var y12 = y3;
							if(y12 == null) {
								y12 = 0;
							}
							if(x12 == null) {
								x12 = 0;
							}
							var point1_x = x12;
							var point1_y = y12;
							var x13 = view.x + view.width / 2;
							var y13 = view.y + view.height / 2;
							if(y13 == null) {
								y13 = 0;
							}
							if(x13 == null) {
								x13 = 0;
							}
							var point2_x = x13;
							var point2_y = y13;
							var x14 = point2_x - point1_x;
							var y14 = point2_y - point1_y;
							has = Math.sqrt(x14 * x14 + y14 * y14) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x3 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y3 - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x3 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y3 - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y3 * this1.getUInt16(0) + x3) * 4;
					position += vision_ds_Image.OFFSET;
					this1.b[position] = color >> 24 & 255;
					this1.b[position + 1] = color >> 16 & 255;
					this1.b[position + 2] = color >> 8 & 255;
					this1.b[position + 3] = color & 255;
				}
			} else {
				var position1 = (y3 * this1.getUInt16(0) + x3) * 4;
				position1 += vision_ds_Image.OFFSET;
				this1.b[position1] = color >> 24 & 255;
				this1.b[position1 + 1] = color >> 16 & 255;
				this1.b[position1 + 2] = color >> 8 & 255;
				this1.b[position1 + 3] = color & 255;
			}
		}
		i += step;
	}
};
vision_ds_Image.fillCircle = function(this1,X,Y,r,color) {
	var points = [];
	var x = -r;
	var y = 0;
	var err = 2 - 2 * r;
	do {
		var x1 = X + x;
		var y1 = Y - y;
		if(y1 == null) {
			y1 = 0;
		}
		if(x1 == null) {
			x1 = 0;
		}
		var p_x = x1;
		var p_y = y1;
		points.push(new vision_ds__$IntPoint2D_Impl(p_x | 0,p_y | 0));
		var x2 = X - x;
		var y2 = Y + y;
		if(y2 == null) {
			y2 = 0;
		}
		if(x2 == null) {
			x2 = 0;
		}
		var p_x1 = x2;
		var p_y1 = y2;
		points.push(new vision_ds__$IntPoint2D_Impl(p_x1 | 0,p_y1 | 0));
		var x3 = X - y;
		var y3 = Y - x;
		if(y3 == null) {
			y3 = 0;
		}
		if(x3 == null) {
			x3 = 0;
		}
		var p_x2 = x3;
		var p_y2 = y3;
		points.push(new vision_ds__$IntPoint2D_Impl(p_x2 | 0,p_y2 | 0));
		var x4 = X + y;
		var y4 = Y + x;
		if(y4 == null) {
			y4 = 0;
		}
		if(x4 == null) {
			x4 = 0;
		}
		var p_x3 = x4;
		var p_y3 = y4;
		points.push(new vision_ds__$IntPoint2D_Impl(p_x3 | 0,p_y3 | 0));
		r = err;
		if(r <= y) {
			err += ++y * 2 + 1;
		}
		if(r > x || err > y) {
			err += ++x * 2 + 1;
		}
	} while(x < 0);
	var values = [];
	var _g = 0;
	while(_g < points.length) {
		var p = points[_g];
		++_g;
		if(values[p.x] == null) {
			values[p.x] = [];
		}
		values[p.x].push(p.y);
	}
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var y = _g++;
		if(values[y] == null) {
			continue;
		}
		var values1 = values[y];
		var min = values1[0];
		var _g2 = 0;
		var _g3 = values1.length;
		while(_g2 < _g3) {
			var i = _g2++;
			if(values1[i] < min) {
				min = values1[i];
			}
		}
		var min1 = min;
		var values2 = values[y];
		var max = values2[0];
		var _g4 = 0;
		var _g5 = values2.length;
		while(_g4 < _g5) {
			var i1 = _g4++;
			if(values2[i1] > max) {
				max = values2[i1];
			}
		}
		var max1 = max;
		var _g6 = min1;
		var _g7 = max1 + 1;
		while(_g6 < _g7) {
			var i2 = _g6++;
			if(!(i2 >= 0 && y >= 0 && i2 < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = i2;
				var this_y = y;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = i2 >= 0 && y >= 0 && i2 < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g8 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g9 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g10 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g8,_g9,_g10,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = i2 < view.x + view.width && y < view.y + view.height && i2 >= view.x && y >= view.y;
						break;
					case 1:
						has = !(i2 < view.x + view.width && y < view.y + view.height && i2 >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x = view.x + view.width / 2 - c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x == null) {
								x = 0;
							}
							var f1_x = x;
							var f1_y = y1;
							var x1 = view.x + view.width / 2 + c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y2;
							var p_x = i2;
							var p_y = y;
							var x2 = p_x - f1_x;
							var y3 = p_y - f1_y;
							var x3 = p_x - f2_x;
							var y4 = p_y - f2_y;
							has = Math.sqrt(x2 * x2 + y3 * y3) + Math.sqrt(x3 * x3 + y4 * y4) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a1 = view.height / 2;
							var b1 = view.width / 2;
							var c1 = Math.sqrt(a1 * a1 - b1 * b1);
							var x4 = view.x + view.width / 2;
							var y5 = view.y + view.height / 2 - c1;
							if(y5 == null) {
								y5 = 0;
							}
							if(x4 == null) {
								x4 = 0;
							}
							var f1_x1 = x4;
							var f1_y1 = y5;
							var x5 = view.x + view.width / 2;
							var y6 = view.y + view.height / 2 + c1;
							if(y6 == null) {
								y6 = 0;
							}
							if(x5 == null) {
								x5 = 0;
							}
							var f2_x1 = x5;
							var f2_y1 = y6;
							var p_x1 = i2;
							var p_y1 = y;
							var x6 = p_x1 - f1_x1;
							var y7 = p_y1 - f1_y1;
							var x7 = p_x1 - f2_x1;
							var y8 = p_y1 - f2_y1;
							has = Math.sqrt(x6 * x6 + y7 * y7) + Math.sqrt(x7 * x7 + y8 * y8) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x8 = i2;
							var y9 = y;
							if(y9 == null) {
								y9 = 0;
							}
							if(x8 == null) {
								x8 = 0;
							}
							var point1_x = x8;
							var point1_y = y9;
							var x9 = view.x + view.width / 2;
							var y10 = view.y + view.height / 2;
							if(y10 == null) {
								y10 = 0;
							}
							if(x9 == null) {
								x9 = 0;
							}
							var point2_x = x9;
							var point2_y = y10;
							var x10 = point2_x - point1_x;
							var y11 = point2_y - point1_y;
							has = Math.sqrt(x10 * x10 + y11 * y11) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(i2 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(i2 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y * this1.getUInt16(0) + i2) * 4;
					position += vision_ds_Image.OFFSET;
					this1.b[position] = color >> 24 & 255;
					this1.b[position + 1] = color >> 16 & 255;
					this1.b[position + 2] = color >> 8 & 255;
					this1.b[position + 3] = color & 255;
				}
			} else {
				var position1 = (y * this1.getUInt16(0) + i2) * 4;
				position1 += vision_ds_Image.OFFSET;
				this1.b[position1] = color >> 24 & 255;
				this1.b[position1 + 1] = color >> 16 & 255;
				this1.b[position1 + 2] = color >> 8 & 255;
				this1.b[position1 + 3] = color & 255;
			}
		}
	}
};
vision_ds_Image.drawCircle = function(this1,X,Y,r,color) {
	var x = -r;
	var y = 0;
	var err = 2 - 2 * r;
	do {
		var x1 = X + x;
		var y1 = Y - y;
		if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x1;
			var this_y = y1;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
					break;
				case 1:
					has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x2 = view.x + view.width / 2 - c;
						var y2 = view.y + view.height / 2;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var f1_x = x2;
						var f1_y = y2;
						var x3 = view.x + view.width / 2 + c;
						var y3 = view.y + view.height / 2;
						if(y3 == null) {
							y3 = 0;
						}
						if(x3 == null) {
							x3 = 0;
						}
						var f2_x = x3;
						var f2_y = y3;
						var p_x = x1;
						var p_y = y1;
						var x4 = p_x - f1_x;
						var y4 = p_y - f1_y;
						var x5 = p_x - f2_x;
						var y5 = p_y - f2_y;
						has = Math.sqrt(x4 * x4 + y4 * y4) + Math.sqrt(x5 * x5 + y5 * y5) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a1 = view.height / 2;
						var b1 = view.width / 2;
						var c1 = Math.sqrt(a1 * a1 - b1 * b1);
						var x6 = view.x + view.width / 2;
						var y6 = view.y + view.height / 2 - c1;
						if(y6 == null) {
							y6 = 0;
						}
						if(x6 == null) {
							x6 = 0;
						}
						var f1_x1 = x6;
						var f1_y1 = y6;
						var x7 = view.x + view.width / 2;
						var y7 = view.y + view.height / 2 + c1;
						if(y7 == null) {
							y7 = 0;
						}
						if(x7 == null) {
							x7 = 0;
						}
						var f2_x1 = x7;
						var f2_y1 = y7;
						var p_x1 = x1;
						var p_y1 = y1;
						var x8 = p_x1 - f1_x1;
						var y8 = p_y1 - f1_y1;
						var x9 = p_x1 - f2_x1;
						var y9 = p_y1 - f2_y1;
						has = Math.sqrt(x8 * x8 + y8 * y8) + Math.sqrt(x9 * x9 + y9 * y9) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x10 = x1;
						var y10 = y1;
						if(y10 == null) {
							y10 = 0;
						}
						if(x10 == null) {
							x10 = 0;
						}
						var point1_x = x10;
						var point1_y = y10;
						var x11 = view.x + view.width / 2;
						var y11 = view.y + view.height / 2;
						if(y11 == null) {
							y11 = 0;
						}
						if(x11 == null) {
							x11 = 0;
						}
						var point2_x = x11;
						var point2_y = y11;
						var x12 = point2_x - point1_x;
						var y12 = point2_y - point1_y;
						has = Math.sqrt(x12 * x12 + y12 * y12) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y1 * this1.getUInt16(0) + x1) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color >> 24 & 255;
				this1.b[position + 1] = color >> 16 & 255;
				this1.b[position + 2] = color >> 8 & 255;
				this1.b[position + 3] = color & 255;
			}
		} else {
			var position1 = (y1 * this1.getUInt16(0) + x1) * 4;
			position1 += vision_ds_Image.OFFSET;
			this1.b[position1] = color >> 24 & 255;
			this1.b[position1 + 1] = color >> 16 & 255;
			this1.b[position1 + 2] = color >> 8 & 255;
			this1.b[position1 + 3] = color & 255;
		}
		var x13 = X - x;
		var y13 = Y + y;
		if(!(x13 >= 0 && y13 >= 0 && x13 < this1.getUInt16(0) && y13 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x1 = x13;
			var this_y1 = y13;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x1,this_y1)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v1 = null;
			var tmp1;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v1 == null) {
				tmp1 = x13 >= 0 && y13 >= 0 && x13 < this1.getUInt16(0) && y13 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has1 = false;
				var view2;
				if(v1 != null) {
					view2 = v1;
				} else {
					var _g3 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g4 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g5 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this3 = this1.b;
					var view3 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view2 = new vision_ds_ImageView(_g3,_g4,_g5,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this3[view3]);
				}
				switch(view2.shape) {
				case 0:
					has1 = x13 < view2.x + view2.width && y13 < view2.y + view2.height && x13 >= view2.x && y13 >= view2.y;
					break;
				case 1:
					has1 = !(x13 < view2.x + view2.width && y13 < view2.y + view2.height && x13 >= view2.x && y13 >= view2.y);
					break;
				case 2:case 3:
					if(view2.width > view2.height) {
						var a2 = view2.width / 2;
						var b2 = view2.height / 2;
						var c2 = Math.sqrt(a2 * a2 - b2 * b2);
						var x14 = view2.x + view2.width / 2 - c2;
						var y14 = view2.y + view2.height / 2;
						if(y14 == null) {
							y14 = 0;
						}
						if(x14 == null) {
							x14 = 0;
						}
						var f1_x2 = x14;
						var f1_y2 = y14;
						var x15 = view2.x + view2.width / 2 + c2;
						var y15 = view2.y + view2.height / 2;
						if(y15 == null) {
							y15 = 0;
						}
						if(x15 == null) {
							x15 = 0;
						}
						var f2_x2 = x15;
						var f2_y2 = y15;
						var p_x2 = x13;
						var p_y2 = y13;
						var x16 = p_x2 - f1_x2;
						var y16 = p_y2 - f1_y2;
						var x17 = p_x2 - f2_x2;
						var y17 = p_y2 - f2_y2;
						has1 = Math.sqrt(x16 * x16 + y16 * y16) + Math.sqrt(x17 * x17 + y17 * y17) <= view2.width;
						if(view2.shape == 3) {
							has1 = !has1;
						}
					} else if(view2.height > view2.width) {
						var a3 = view2.height / 2;
						var b3 = view2.width / 2;
						var c3 = Math.sqrt(a3 * a3 - b3 * b3);
						var x18 = view2.x + view2.width / 2;
						var y18 = view2.y + view2.height / 2 - c3;
						if(y18 == null) {
							y18 = 0;
						}
						if(x18 == null) {
							x18 = 0;
						}
						var f1_x3 = x18;
						var f1_y3 = y18;
						var x19 = view2.x + view2.width / 2;
						var y19 = view2.y + view2.height / 2 + c3;
						if(y19 == null) {
							y19 = 0;
						}
						if(x19 == null) {
							x19 = 0;
						}
						var f2_x3 = x19;
						var f2_y3 = y19;
						var p_x3 = x13;
						var p_y3 = y13;
						var x20 = p_x3 - f1_x3;
						var y20 = p_y3 - f1_y3;
						var x21 = p_x3 - f2_x3;
						var y21 = p_y3 - f2_y3;
						has1 = Math.sqrt(x20 * x20 + y20 * y20) + Math.sqrt(x21 * x21 + y21 * y21) <= view2.height;
						if(view2.shape == 3) {
							has1 = !has1;
						}
					} else {
						var x22 = x13;
						var y22 = y13;
						if(y22 == null) {
							y22 = 0;
						}
						if(x22 == null) {
							x22 = 0;
						}
						var point1_x1 = x22;
						var point1_y1 = y22;
						var x23 = view2.x + view2.width / 2;
						var y23 = view2.y + view2.height / 2;
						if(y23 == null) {
							y23 = 0;
						}
						if(x23 == null) {
							x23 = 0;
						}
						var point2_x1 = x23;
						var point2_y1 = y23;
						var x24 = point2_x1 - point1_x1;
						var y24 = point2_y1 - point1_y1;
						has1 = Math.sqrt(x24 * x24 + y24 * y24) <= view2.width / 2;
						if(view2.shape == 3) {
							has1 = !has1;
						}
					}
					break;
				case 4:
					has1 = Math.abs(x13 - view2.x - view2.width / 2) / (view2.width / 2) + Math.abs(y13 - view2.y - view2.height / 2) / (view2.height / 2) <= 1;
					break;
				case 5:
					has1 = !(Math.abs(x13 - view2.x - view2.width / 2) / (view2.width / 2) + Math.abs(y13 - view2.y - view2.height / 2) / (view2.height / 2) <= 1);
					break;
				}
				tmp1 = has1;
			}
			if(tmp1) {
				var position2 = (y13 * this1.getUInt16(0) + x13) * 4;
				position2 += vision_ds_Image.OFFSET;
				this1.b[position2] = color >> 24 & 255;
				this1.b[position2 + 1] = color >> 16 & 255;
				this1.b[position2 + 2] = color >> 8 & 255;
				this1.b[position2 + 3] = color & 255;
			}
		} else {
			var position3 = (y13 * this1.getUInt16(0) + x13) * 4;
			position3 += vision_ds_Image.OFFSET;
			this1.b[position3] = color >> 24 & 255;
			this1.b[position3 + 1] = color >> 16 & 255;
			this1.b[position3 + 2] = color >> 8 & 255;
			this1.b[position3 + 3] = color & 255;
		}
		var x25 = X - y;
		var y25 = Y - x;
		if(!(x25 >= 0 && y25 >= 0 && x25 < this1.getUInt16(0) && y25 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x2 = x25;
			var this_y2 = y25;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x2,this_y2)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v2 = null;
			var tmp2;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v2 == null) {
				tmp2 = x25 >= 0 && y25 >= 0 && x25 < this1.getUInt16(0) && y25 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has2 = false;
				var view4;
				if(v2 != null) {
					view4 = v2;
				} else {
					var _g6 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g7 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g8 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this4 = this1.b;
					var view5 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view4 = new vision_ds_ImageView(_g6,_g7,_g8,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this4[view5]);
				}
				switch(view4.shape) {
				case 0:
					has2 = x25 < view4.x + view4.width && y25 < view4.y + view4.height && x25 >= view4.x && y25 >= view4.y;
					break;
				case 1:
					has2 = !(x25 < view4.x + view4.width && y25 < view4.y + view4.height && x25 >= view4.x && y25 >= view4.y);
					break;
				case 2:case 3:
					if(view4.width > view4.height) {
						var a4 = view4.width / 2;
						var b4 = view4.height / 2;
						var c4 = Math.sqrt(a4 * a4 - b4 * b4);
						var x26 = view4.x + view4.width / 2 - c4;
						var y26 = view4.y + view4.height / 2;
						if(y26 == null) {
							y26 = 0;
						}
						if(x26 == null) {
							x26 = 0;
						}
						var f1_x4 = x26;
						var f1_y4 = y26;
						var x27 = view4.x + view4.width / 2 + c4;
						var y27 = view4.y + view4.height / 2;
						if(y27 == null) {
							y27 = 0;
						}
						if(x27 == null) {
							x27 = 0;
						}
						var f2_x4 = x27;
						var f2_y4 = y27;
						var p_x4 = x25;
						var p_y4 = y25;
						var x28 = p_x4 - f1_x4;
						var y28 = p_y4 - f1_y4;
						var x29 = p_x4 - f2_x4;
						var y29 = p_y4 - f2_y4;
						has2 = Math.sqrt(x28 * x28 + y28 * y28) + Math.sqrt(x29 * x29 + y29 * y29) <= view4.width;
						if(view4.shape == 3) {
							has2 = !has2;
						}
					} else if(view4.height > view4.width) {
						var a5 = view4.height / 2;
						var b5 = view4.width / 2;
						var c5 = Math.sqrt(a5 * a5 - b5 * b5);
						var x30 = view4.x + view4.width / 2;
						var y30 = view4.y + view4.height / 2 - c5;
						if(y30 == null) {
							y30 = 0;
						}
						if(x30 == null) {
							x30 = 0;
						}
						var f1_x5 = x30;
						var f1_y5 = y30;
						var x31 = view4.x + view4.width / 2;
						var y31 = view4.y + view4.height / 2 + c5;
						if(y31 == null) {
							y31 = 0;
						}
						if(x31 == null) {
							x31 = 0;
						}
						var f2_x5 = x31;
						var f2_y5 = y31;
						var p_x5 = x25;
						var p_y5 = y25;
						var x32 = p_x5 - f1_x5;
						var y32 = p_y5 - f1_y5;
						var x33 = p_x5 - f2_x5;
						var y33 = p_y5 - f2_y5;
						has2 = Math.sqrt(x32 * x32 + y32 * y32) + Math.sqrt(x33 * x33 + y33 * y33) <= view4.height;
						if(view4.shape == 3) {
							has2 = !has2;
						}
					} else {
						var x34 = x25;
						var y34 = y25;
						if(y34 == null) {
							y34 = 0;
						}
						if(x34 == null) {
							x34 = 0;
						}
						var point1_x2 = x34;
						var point1_y2 = y34;
						var x35 = view4.x + view4.width / 2;
						var y35 = view4.y + view4.height / 2;
						if(y35 == null) {
							y35 = 0;
						}
						if(x35 == null) {
							x35 = 0;
						}
						var point2_x2 = x35;
						var point2_y2 = y35;
						var x36 = point2_x2 - point1_x2;
						var y36 = point2_y2 - point1_y2;
						has2 = Math.sqrt(x36 * x36 + y36 * y36) <= view4.width / 2;
						if(view4.shape == 3) {
							has2 = !has2;
						}
					}
					break;
				case 4:
					has2 = Math.abs(x25 - view4.x - view4.width / 2) / (view4.width / 2) + Math.abs(y25 - view4.y - view4.height / 2) / (view4.height / 2) <= 1;
					break;
				case 5:
					has2 = !(Math.abs(x25 - view4.x - view4.width / 2) / (view4.width / 2) + Math.abs(y25 - view4.y - view4.height / 2) / (view4.height / 2) <= 1);
					break;
				}
				tmp2 = has2;
			}
			if(tmp2) {
				var position4 = (y25 * this1.getUInt16(0) + x25) * 4;
				position4 += vision_ds_Image.OFFSET;
				this1.b[position4] = color >> 24 & 255;
				this1.b[position4 + 1] = color >> 16 & 255;
				this1.b[position4 + 2] = color >> 8 & 255;
				this1.b[position4 + 3] = color & 255;
			}
		} else {
			var position5 = (y25 * this1.getUInt16(0) + x25) * 4;
			position5 += vision_ds_Image.OFFSET;
			this1.b[position5] = color >> 24 & 255;
			this1.b[position5 + 1] = color >> 16 & 255;
			this1.b[position5 + 2] = color >> 8 & 255;
			this1.b[position5 + 3] = color & 255;
		}
		var x37 = X + y;
		var y37 = Y + x;
		if(!(x37 >= 0 && y37 >= 0 && x37 < this1.getUInt16(0) && y37 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x3 = x37;
			var this_y3 = y37;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x3,this_y3)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v3 = null;
			var tmp3;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v3 == null) {
				tmp3 = x37 >= 0 && y37 >= 0 && x37 < this1.getUInt16(0) && y37 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has3 = false;
				var view6;
				if(v3 != null) {
					view6 = v3;
				} else {
					var _g9 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g10 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g11 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this5 = this1.b;
					var view7 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view6 = new vision_ds_ImageView(_g9,_g10,_g11,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this5[view7]);
				}
				switch(view6.shape) {
				case 0:
					has3 = x37 < view6.x + view6.width && y37 < view6.y + view6.height && x37 >= view6.x && y37 >= view6.y;
					break;
				case 1:
					has3 = !(x37 < view6.x + view6.width && y37 < view6.y + view6.height && x37 >= view6.x && y37 >= view6.y);
					break;
				case 2:case 3:
					if(view6.width > view6.height) {
						var a6 = view6.width / 2;
						var b6 = view6.height / 2;
						var c6 = Math.sqrt(a6 * a6 - b6 * b6);
						var x38 = view6.x + view6.width / 2 - c6;
						var y38 = view6.y + view6.height / 2;
						if(y38 == null) {
							y38 = 0;
						}
						if(x38 == null) {
							x38 = 0;
						}
						var f1_x6 = x38;
						var f1_y6 = y38;
						var x39 = view6.x + view6.width / 2 + c6;
						var y39 = view6.y + view6.height / 2;
						if(y39 == null) {
							y39 = 0;
						}
						if(x39 == null) {
							x39 = 0;
						}
						var f2_x6 = x39;
						var f2_y6 = y39;
						var p_x6 = x37;
						var p_y6 = y37;
						var x40 = p_x6 - f1_x6;
						var y40 = p_y6 - f1_y6;
						var x41 = p_x6 - f2_x6;
						var y41 = p_y6 - f2_y6;
						has3 = Math.sqrt(x40 * x40 + y40 * y40) + Math.sqrt(x41 * x41 + y41 * y41) <= view6.width;
						if(view6.shape == 3) {
							has3 = !has3;
						}
					} else if(view6.height > view6.width) {
						var a7 = view6.height / 2;
						var b7 = view6.width / 2;
						var c7 = Math.sqrt(a7 * a7 - b7 * b7);
						var x42 = view6.x + view6.width / 2;
						var y42 = view6.y + view6.height / 2 - c7;
						if(y42 == null) {
							y42 = 0;
						}
						if(x42 == null) {
							x42 = 0;
						}
						var f1_x7 = x42;
						var f1_y7 = y42;
						var x43 = view6.x + view6.width / 2;
						var y43 = view6.y + view6.height / 2 + c7;
						if(y43 == null) {
							y43 = 0;
						}
						if(x43 == null) {
							x43 = 0;
						}
						var f2_x7 = x43;
						var f2_y7 = y43;
						var p_x7 = x37;
						var p_y7 = y37;
						var x44 = p_x7 - f1_x7;
						var y44 = p_y7 - f1_y7;
						var x45 = p_x7 - f2_x7;
						var y45 = p_y7 - f2_y7;
						has3 = Math.sqrt(x44 * x44 + y44 * y44) + Math.sqrt(x45 * x45 + y45 * y45) <= view6.height;
						if(view6.shape == 3) {
							has3 = !has3;
						}
					} else {
						var x46 = x37;
						var y46 = y37;
						if(y46 == null) {
							y46 = 0;
						}
						if(x46 == null) {
							x46 = 0;
						}
						var point1_x3 = x46;
						var point1_y3 = y46;
						var x47 = view6.x + view6.width / 2;
						var y47 = view6.y + view6.height / 2;
						if(y47 == null) {
							y47 = 0;
						}
						if(x47 == null) {
							x47 = 0;
						}
						var point2_x3 = x47;
						var point2_y3 = y47;
						var x48 = point2_x3 - point1_x3;
						var y48 = point2_y3 - point1_y3;
						has3 = Math.sqrt(x48 * x48 + y48 * y48) <= view6.width / 2;
						if(view6.shape == 3) {
							has3 = !has3;
						}
					}
					break;
				case 4:
					has3 = Math.abs(x37 - view6.x - view6.width / 2) / (view6.width / 2) + Math.abs(y37 - view6.y - view6.height / 2) / (view6.height / 2) <= 1;
					break;
				case 5:
					has3 = !(Math.abs(x37 - view6.x - view6.width / 2) / (view6.width / 2) + Math.abs(y37 - view6.y - view6.height / 2) / (view6.height / 2) <= 1);
					break;
				}
				tmp3 = has3;
			}
			if(tmp3) {
				var position6 = (y37 * this1.getUInt16(0) + x37) * 4;
				position6 += vision_ds_Image.OFFSET;
				this1.b[position6] = color >> 24 & 255;
				this1.b[position6 + 1] = color >> 16 & 255;
				this1.b[position6 + 2] = color >> 8 & 255;
				this1.b[position6 + 3] = color & 255;
			}
		} else {
			var position7 = (y37 * this1.getUInt16(0) + x37) * 4;
			position7 += vision_ds_Image.OFFSET;
			this1.b[position7] = color >> 24 & 255;
			this1.b[position7 + 1] = color >> 16 & 255;
			this1.b[position7 + 2] = color >> 8 & 255;
			this1.b[position7 + 3] = color & 255;
		}
		r = err;
		if(r <= y) {
			err += ++y * 2 + 1;
		}
		if(r > x || err > y) {
			err += ++x * 2 + 1;
		}
	} while(x < 0);
};
vision_ds_Image.drawEllipse = function(this1,centerX,centerY,radiusX,radiusY,color) {
	var twoASquare = 2 * radiusX * radiusX;
	var twoBSquare = 2 * radiusY * radiusY;
	var x = radiusX - 1;
	var b = true;
	var y = 0;
	var xChange = radiusY * radiusY * (1 - 2 * radiusX);
	var yChange = radiusX * radiusX;
	var ellipseError = 0;
	var stoppingX = twoBSquare * radiusX;
	var stoppingY = 0;
	while(stoppingX >= stoppingY) {
		var x1 = centerX + x;
		var y1 = centerY + y;
		if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x1;
			var this_y = y1;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
					break;
				case 1:
					has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b1 = view.height / 2;
						var c = Math.sqrt(a * a - b1 * b1);
						var x2 = view.x + view.width / 2 - c;
						var y2 = view.y + view.height / 2;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var f1_x = x2;
						var f1_y = y2;
						var x3 = view.x + view.width / 2 + c;
						var y3 = view.y + view.height / 2;
						if(y3 == null) {
							y3 = 0;
						}
						if(x3 == null) {
							x3 = 0;
						}
						var f2_x = x3;
						var f2_y = y3;
						var p_x = x1;
						var p_y = y1;
						var x4 = p_x - f1_x;
						var y4 = p_y - f1_y;
						var x5 = p_x - f2_x;
						var y5 = p_y - f2_y;
						has = Math.sqrt(x4 * x4 + y4 * y4) + Math.sqrt(x5 * x5 + y5 * y5) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a1 = view.height / 2;
						var b2 = view.width / 2;
						var c1 = Math.sqrt(a1 * a1 - b2 * b2);
						var x6 = view.x + view.width / 2;
						var y6 = view.y + view.height / 2 - c1;
						if(y6 == null) {
							y6 = 0;
						}
						if(x6 == null) {
							x6 = 0;
						}
						var f1_x1 = x6;
						var f1_y1 = y6;
						var x7 = view.x + view.width / 2;
						var y7 = view.y + view.height / 2 + c1;
						if(y7 == null) {
							y7 = 0;
						}
						if(x7 == null) {
							x7 = 0;
						}
						var f2_x1 = x7;
						var f2_y1 = y7;
						var p_x1 = x1;
						var p_y1 = y1;
						var x8 = p_x1 - f1_x1;
						var y8 = p_y1 - f1_y1;
						var x9 = p_x1 - f2_x1;
						var y9 = p_y1 - f2_y1;
						has = Math.sqrt(x8 * x8 + y8 * y8) + Math.sqrt(x9 * x9 + y9 * y9) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x10 = x1;
						var y10 = y1;
						if(y10 == null) {
							y10 = 0;
						}
						if(x10 == null) {
							x10 = 0;
						}
						var point1_x = x10;
						var point1_y = y10;
						var x11 = view.x + view.width / 2;
						var y11 = view.y + view.height / 2;
						if(y11 == null) {
							y11 = 0;
						}
						if(x11 == null) {
							x11 = 0;
						}
						var point2_x = x11;
						var point2_y = y11;
						var x12 = point2_x - point1_x;
						var y12 = point2_y - point1_y;
						has = Math.sqrt(x12 * x12 + y12 * y12) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y1 * this1.getUInt16(0) + x1) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color >> 24 & 255;
				this1.b[position + 1] = color >> 16 & 255;
				this1.b[position + 2] = color >> 8 & 255;
				this1.b[position + 3] = color & 255;
			}
		} else {
			var position1 = (y1 * this1.getUInt16(0) + x1) * 4;
			position1 += vision_ds_Image.OFFSET;
			this1.b[position1] = color >> 24 & 255;
			this1.b[position1 + 1] = color >> 16 & 255;
			this1.b[position1 + 2] = color >> 8 & 255;
			this1.b[position1 + 3] = color & 255;
		}
		var x13 = centerX - x;
		var y13 = centerY + y;
		if(!(x13 >= 0 && y13 >= 0 && x13 < this1.getUInt16(0) && y13 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x1 = x13;
			var this_y1 = y13;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x1,this_y1)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v1 = null;
			var tmp1;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v1 == null) {
				tmp1 = x13 >= 0 && y13 >= 0 && x13 < this1.getUInt16(0) && y13 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has1 = false;
				var view2;
				if(v1 != null) {
					view2 = v1;
				} else {
					var _g3 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g4 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g5 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this3 = this1.b;
					var view3 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view2 = new vision_ds_ImageView(_g3,_g4,_g5,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this3[view3]);
				}
				switch(view2.shape) {
				case 0:
					has1 = x13 < view2.x + view2.width && y13 < view2.y + view2.height && x13 >= view2.x && y13 >= view2.y;
					break;
				case 1:
					has1 = !(x13 < view2.x + view2.width && y13 < view2.y + view2.height && x13 >= view2.x && y13 >= view2.y);
					break;
				case 2:case 3:
					if(view2.width > view2.height) {
						var a2 = view2.width / 2;
						var b3 = view2.height / 2;
						var c2 = Math.sqrt(a2 * a2 - b3 * b3);
						var x14 = view2.x + view2.width / 2 - c2;
						var y14 = view2.y + view2.height / 2;
						if(y14 == null) {
							y14 = 0;
						}
						if(x14 == null) {
							x14 = 0;
						}
						var f1_x2 = x14;
						var f1_y2 = y14;
						var x15 = view2.x + view2.width / 2 + c2;
						var y15 = view2.y + view2.height / 2;
						if(y15 == null) {
							y15 = 0;
						}
						if(x15 == null) {
							x15 = 0;
						}
						var f2_x2 = x15;
						var f2_y2 = y15;
						var p_x2 = x13;
						var p_y2 = y13;
						var x16 = p_x2 - f1_x2;
						var y16 = p_y2 - f1_y2;
						var x17 = p_x2 - f2_x2;
						var y17 = p_y2 - f2_y2;
						has1 = Math.sqrt(x16 * x16 + y16 * y16) + Math.sqrt(x17 * x17 + y17 * y17) <= view2.width;
						if(view2.shape == 3) {
							has1 = !has1;
						}
					} else if(view2.height > view2.width) {
						var a3 = view2.height / 2;
						var b4 = view2.width / 2;
						var c3 = Math.sqrt(a3 * a3 - b4 * b4);
						var x18 = view2.x + view2.width / 2;
						var y18 = view2.y + view2.height / 2 - c3;
						if(y18 == null) {
							y18 = 0;
						}
						if(x18 == null) {
							x18 = 0;
						}
						var f1_x3 = x18;
						var f1_y3 = y18;
						var x19 = view2.x + view2.width / 2;
						var y19 = view2.y + view2.height / 2 + c3;
						if(y19 == null) {
							y19 = 0;
						}
						if(x19 == null) {
							x19 = 0;
						}
						var f2_x3 = x19;
						var f2_y3 = y19;
						var p_x3 = x13;
						var p_y3 = y13;
						var x20 = p_x3 - f1_x3;
						var y20 = p_y3 - f1_y3;
						var x21 = p_x3 - f2_x3;
						var y21 = p_y3 - f2_y3;
						has1 = Math.sqrt(x20 * x20 + y20 * y20) + Math.sqrt(x21 * x21 + y21 * y21) <= view2.height;
						if(view2.shape == 3) {
							has1 = !has1;
						}
					} else {
						var x22 = x13;
						var y22 = y13;
						if(y22 == null) {
							y22 = 0;
						}
						if(x22 == null) {
							x22 = 0;
						}
						var point1_x1 = x22;
						var point1_y1 = y22;
						var x23 = view2.x + view2.width / 2;
						var y23 = view2.y + view2.height / 2;
						if(y23 == null) {
							y23 = 0;
						}
						if(x23 == null) {
							x23 = 0;
						}
						var point2_x1 = x23;
						var point2_y1 = y23;
						var x24 = point2_x1 - point1_x1;
						var y24 = point2_y1 - point1_y1;
						has1 = Math.sqrt(x24 * x24 + y24 * y24) <= view2.width / 2;
						if(view2.shape == 3) {
							has1 = !has1;
						}
					}
					break;
				case 4:
					has1 = Math.abs(x13 - view2.x - view2.width / 2) / (view2.width / 2) + Math.abs(y13 - view2.y - view2.height / 2) / (view2.height / 2) <= 1;
					break;
				case 5:
					has1 = !(Math.abs(x13 - view2.x - view2.width / 2) / (view2.width / 2) + Math.abs(y13 - view2.y - view2.height / 2) / (view2.height / 2) <= 1);
					break;
				}
				tmp1 = has1;
			}
			if(tmp1) {
				var position2 = (y13 * this1.getUInt16(0) + x13) * 4;
				position2 += vision_ds_Image.OFFSET;
				this1.b[position2] = color >> 24 & 255;
				this1.b[position2 + 1] = color >> 16 & 255;
				this1.b[position2 + 2] = color >> 8 & 255;
				this1.b[position2 + 3] = color & 255;
			}
		} else {
			var position3 = (y13 * this1.getUInt16(0) + x13) * 4;
			position3 += vision_ds_Image.OFFSET;
			this1.b[position3] = color >> 24 & 255;
			this1.b[position3 + 1] = color >> 16 & 255;
			this1.b[position3 + 2] = color >> 8 & 255;
			this1.b[position3 + 3] = color & 255;
		}
		var x25 = centerX + x;
		var y25 = centerY - y;
		if(!(x25 >= 0 && y25 >= 0 && x25 < this1.getUInt16(0) && y25 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x2 = x25;
			var this_y2 = y25;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x2,this_y2)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v2 = null;
			var tmp2;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v2 == null) {
				tmp2 = x25 >= 0 && y25 >= 0 && x25 < this1.getUInt16(0) && y25 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has2 = false;
				var view4;
				if(v2 != null) {
					view4 = v2;
				} else {
					var _g6 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g7 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g8 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this4 = this1.b;
					var view5 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view4 = new vision_ds_ImageView(_g6,_g7,_g8,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this4[view5]);
				}
				switch(view4.shape) {
				case 0:
					has2 = x25 < view4.x + view4.width && y25 < view4.y + view4.height && x25 >= view4.x && y25 >= view4.y;
					break;
				case 1:
					has2 = !(x25 < view4.x + view4.width && y25 < view4.y + view4.height && x25 >= view4.x && y25 >= view4.y);
					break;
				case 2:case 3:
					if(view4.width > view4.height) {
						var a4 = view4.width / 2;
						var b5 = view4.height / 2;
						var c4 = Math.sqrt(a4 * a4 - b5 * b5);
						var x26 = view4.x + view4.width / 2 - c4;
						var y26 = view4.y + view4.height / 2;
						if(y26 == null) {
							y26 = 0;
						}
						if(x26 == null) {
							x26 = 0;
						}
						var f1_x4 = x26;
						var f1_y4 = y26;
						var x27 = view4.x + view4.width / 2 + c4;
						var y27 = view4.y + view4.height / 2;
						if(y27 == null) {
							y27 = 0;
						}
						if(x27 == null) {
							x27 = 0;
						}
						var f2_x4 = x27;
						var f2_y4 = y27;
						var p_x4 = x25;
						var p_y4 = y25;
						var x28 = p_x4 - f1_x4;
						var y28 = p_y4 - f1_y4;
						var x29 = p_x4 - f2_x4;
						var y29 = p_y4 - f2_y4;
						has2 = Math.sqrt(x28 * x28 + y28 * y28) + Math.sqrt(x29 * x29 + y29 * y29) <= view4.width;
						if(view4.shape == 3) {
							has2 = !has2;
						}
					} else if(view4.height > view4.width) {
						var a5 = view4.height / 2;
						var b6 = view4.width / 2;
						var c5 = Math.sqrt(a5 * a5 - b6 * b6);
						var x30 = view4.x + view4.width / 2;
						var y30 = view4.y + view4.height / 2 - c5;
						if(y30 == null) {
							y30 = 0;
						}
						if(x30 == null) {
							x30 = 0;
						}
						var f1_x5 = x30;
						var f1_y5 = y30;
						var x31 = view4.x + view4.width / 2;
						var y31 = view4.y + view4.height / 2 + c5;
						if(y31 == null) {
							y31 = 0;
						}
						if(x31 == null) {
							x31 = 0;
						}
						var f2_x5 = x31;
						var f2_y5 = y31;
						var p_x5 = x25;
						var p_y5 = y25;
						var x32 = p_x5 - f1_x5;
						var y32 = p_y5 - f1_y5;
						var x33 = p_x5 - f2_x5;
						var y33 = p_y5 - f2_y5;
						has2 = Math.sqrt(x32 * x32 + y32 * y32) + Math.sqrt(x33 * x33 + y33 * y33) <= view4.height;
						if(view4.shape == 3) {
							has2 = !has2;
						}
					} else {
						var x34 = x25;
						var y34 = y25;
						if(y34 == null) {
							y34 = 0;
						}
						if(x34 == null) {
							x34 = 0;
						}
						var point1_x2 = x34;
						var point1_y2 = y34;
						var x35 = view4.x + view4.width / 2;
						var y35 = view4.y + view4.height / 2;
						if(y35 == null) {
							y35 = 0;
						}
						if(x35 == null) {
							x35 = 0;
						}
						var point2_x2 = x35;
						var point2_y2 = y35;
						var x36 = point2_x2 - point1_x2;
						var y36 = point2_y2 - point1_y2;
						has2 = Math.sqrt(x36 * x36 + y36 * y36) <= view4.width / 2;
						if(view4.shape == 3) {
							has2 = !has2;
						}
					}
					break;
				case 4:
					has2 = Math.abs(x25 - view4.x - view4.width / 2) / (view4.width / 2) + Math.abs(y25 - view4.y - view4.height / 2) / (view4.height / 2) <= 1;
					break;
				case 5:
					has2 = !(Math.abs(x25 - view4.x - view4.width / 2) / (view4.width / 2) + Math.abs(y25 - view4.y - view4.height / 2) / (view4.height / 2) <= 1);
					break;
				}
				tmp2 = has2;
			}
			if(tmp2) {
				var position4 = (y25 * this1.getUInt16(0) + x25) * 4;
				position4 += vision_ds_Image.OFFSET;
				this1.b[position4] = color >> 24 & 255;
				this1.b[position4 + 1] = color >> 16 & 255;
				this1.b[position4 + 2] = color >> 8 & 255;
				this1.b[position4 + 3] = color & 255;
			}
		} else {
			var position5 = (y25 * this1.getUInt16(0) + x25) * 4;
			position5 += vision_ds_Image.OFFSET;
			this1.b[position5] = color >> 24 & 255;
			this1.b[position5 + 1] = color >> 16 & 255;
			this1.b[position5 + 2] = color >> 8 & 255;
			this1.b[position5 + 3] = color & 255;
		}
		var x37 = centerX - x;
		var y37 = centerY - y;
		if(!(x37 >= 0 && y37 >= 0 && x37 < this1.getUInt16(0) && y37 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x3 = x37;
			var this_y3 = y37;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x3,this_y3)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v3 = null;
			var tmp3;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v3 == null) {
				tmp3 = x37 >= 0 && y37 >= 0 && x37 < this1.getUInt16(0) && y37 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has3 = false;
				var view6;
				if(v3 != null) {
					view6 = v3;
				} else {
					var _g9 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g10 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g11 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this5 = this1.b;
					var view7 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view6 = new vision_ds_ImageView(_g9,_g10,_g11,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this5[view7]);
				}
				switch(view6.shape) {
				case 0:
					has3 = x37 < view6.x + view6.width && y37 < view6.y + view6.height && x37 >= view6.x && y37 >= view6.y;
					break;
				case 1:
					has3 = !(x37 < view6.x + view6.width && y37 < view6.y + view6.height && x37 >= view6.x && y37 >= view6.y);
					break;
				case 2:case 3:
					if(view6.width > view6.height) {
						var a6 = view6.width / 2;
						var b7 = view6.height / 2;
						var c6 = Math.sqrt(a6 * a6 - b7 * b7);
						var x38 = view6.x + view6.width / 2 - c6;
						var y38 = view6.y + view6.height / 2;
						if(y38 == null) {
							y38 = 0;
						}
						if(x38 == null) {
							x38 = 0;
						}
						var f1_x6 = x38;
						var f1_y6 = y38;
						var x39 = view6.x + view6.width / 2 + c6;
						var y39 = view6.y + view6.height / 2;
						if(y39 == null) {
							y39 = 0;
						}
						if(x39 == null) {
							x39 = 0;
						}
						var f2_x6 = x39;
						var f2_y6 = y39;
						var p_x6 = x37;
						var p_y6 = y37;
						var x40 = p_x6 - f1_x6;
						var y40 = p_y6 - f1_y6;
						var x41 = p_x6 - f2_x6;
						var y41 = p_y6 - f2_y6;
						has3 = Math.sqrt(x40 * x40 + y40 * y40) + Math.sqrt(x41 * x41 + y41 * y41) <= view6.width;
						if(view6.shape == 3) {
							has3 = !has3;
						}
					} else if(view6.height > view6.width) {
						var a7 = view6.height / 2;
						var b8 = view6.width / 2;
						var c7 = Math.sqrt(a7 * a7 - b8 * b8);
						var x42 = view6.x + view6.width / 2;
						var y42 = view6.y + view6.height / 2 - c7;
						if(y42 == null) {
							y42 = 0;
						}
						if(x42 == null) {
							x42 = 0;
						}
						var f1_x7 = x42;
						var f1_y7 = y42;
						var x43 = view6.x + view6.width / 2;
						var y43 = view6.y + view6.height / 2 + c7;
						if(y43 == null) {
							y43 = 0;
						}
						if(x43 == null) {
							x43 = 0;
						}
						var f2_x7 = x43;
						var f2_y7 = y43;
						var p_x7 = x37;
						var p_y7 = y37;
						var x44 = p_x7 - f1_x7;
						var y44 = p_y7 - f1_y7;
						var x45 = p_x7 - f2_x7;
						var y45 = p_y7 - f2_y7;
						has3 = Math.sqrt(x44 * x44 + y44 * y44) + Math.sqrt(x45 * x45 + y45 * y45) <= view6.height;
						if(view6.shape == 3) {
							has3 = !has3;
						}
					} else {
						var x46 = x37;
						var y46 = y37;
						if(y46 == null) {
							y46 = 0;
						}
						if(x46 == null) {
							x46 = 0;
						}
						var point1_x3 = x46;
						var point1_y3 = y46;
						var x47 = view6.x + view6.width / 2;
						var y47 = view6.y + view6.height / 2;
						if(y47 == null) {
							y47 = 0;
						}
						if(x47 == null) {
							x47 = 0;
						}
						var point2_x3 = x47;
						var point2_y3 = y47;
						var x48 = point2_x3 - point1_x3;
						var y48 = point2_y3 - point1_y3;
						has3 = Math.sqrt(x48 * x48 + y48 * y48) <= view6.width / 2;
						if(view6.shape == 3) {
							has3 = !has3;
						}
					}
					break;
				case 4:
					has3 = Math.abs(x37 - view6.x - view6.width / 2) / (view6.width / 2) + Math.abs(y37 - view6.y - view6.height / 2) / (view6.height / 2) <= 1;
					break;
				case 5:
					has3 = !(Math.abs(x37 - view6.x - view6.width / 2) / (view6.width / 2) + Math.abs(y37 - view6.y - view6.height / 2) / (view6.height / 2) <= 1);
					break;
				}
				tmp3 = has3;
			}
			if(tmp3) {
				var position6 = (y37 * this1.getUInt16(0) + x37) * 4;
				position6 += vision_ds_Image.OFFSET;
				this1.b[position6] = color >> 24 & 255;
				this1.b[position6 + 1] = color >> 16 & 255;
				this1.b[position6 + 2] = color >> 8 & 255;
				this1.b[position6 + 3] = color & 255;
			}
		} else {
			var position7 = (y37 * this1.getUInt16(0) + x37) * 4;
			position7 += vision_ds_Image.OFFSET;
			this1.b[position7] = color >> 24 & 255;
			this1.b[position7 + 1] = color >> 16 & 255;
			this1.b[position7 + 2] = color >> 8 & 255;
			this1.b[position7 + 3] = color & 255;
		}
		if(b) {
			++x;
			b = false;
		}
		if(ellipseError <= 0) {
			++y;
			stoppingY += twoASquare;
			ellipseError += yChange;
			yChange += twoASquare;
		}
		if(ellipseError > 0) {
			--x;
			stoppingX -= twoBSquare;
			ellipseError += xChange;
			xChange += twoBSquare;
		}
	}
	ellipseError = radiusY * radiusY / 4 - radiusX * radiusX * (radiusY - 0.5);
	x = 0;
	y = radiusY;
	xChange = radiusY * radiusY;
	yChange = radiusX * radiusX * (1 - 2 * radiusY);
	stoppingX = 0;
	stoppingY = twoASquare * radiusY;
	while(stoppingX <= stoppingY) {
		var x1 = centerX + x;
		var y1 = centerY + y;
		if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x1;
			var this_y = y1;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y;
					break;
				case 1:
					has = !(x1 < view.x + view.width && y1 < view.y + view.height && x1 >= view.x && y1 >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x2 = view.x + view.width / 2 - c;
						var y2 = view.y + view.height / 2;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var f1_x = x2;
						var f1_y = y2;
						var x3 = view.x + view.width / 2 + c;
						var y3 = view.y + view.height / 2;
						if(y3 == null) {
							y3 = 0;
						}
						if(x3 == null) {
							x3 = 0;
						}
						var f2_x = x3;
						var f2_y = y3;
						var p_x = x1;
						var p_y = y1;
						var x4 = p_x - f1_x;
						var y4 = p_y - f1_y;
						var x5 = p_x - f2_x;
						var y5 = p_y - f2_y;
						has = Math.sqrt(x4 * x4 + y4 * y4) + Math.sqrt(x5 * x5 + y5 * y5) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a1 = view.height / 2;
						var b1 = view.width / 2;
						var c1 = Math.sqrt(a1 * a1 - b1 * b1);
						var x6 = view.x + view.width / 2;
						var y6 = view.y + view.height / 2 - c1;
						if(y6 == null) {
							y6 = 0;
						}
						if(x6 == null) {
							x6 = 0;
						}
						var f1_x1 = x6;
						var f1_y1 = y6;
						var x7 = view.x + view.width / 2;
						var y7 = view.y + view.height / 2 + c1;
						if(y7 == null) {
							y7 = 0;
						}
						if(x7 == null) {
							x7 = 0;
						}
						var f2_x1 = x7;
						var f2_y1 = y7;
						var p_x1 = x1;
						var p_y1 = y1;
						var x8 = p_x1 - f1_x1;
						var y8 = p_y1 - f1_y1;
						var x9 = p_x1 - f2_x1;
						var y9 = p_y1 - f2_y1;
						has = Math.sqrt(x8 * x8 + y8 * y8) + Math.sqrt(x9 * x9 + y9 * y9) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x10 = x1;
						var y10 = y1;
						if(y10 == null) {
							y10 = 0;
						}
						if(x10 == null) {
							x10 = 0;
						}
						var point1_x = x10;
						var point1_y = y10;
						var x11 = view.x + view.width / 2;
						var y11 = view.y + view.height / 2;
						if(y11 == null) {
							y11 = 0;
						}
						if(x11 == null) {
							x11 = 0;
						}
						var point2_x = x11;
						var point2_y = y11;
						var x12 = point2_x - point1_x;
						var y12 = point2_y - point1_y;
						has = Math.sqrt(x12 * x12 + y12 * y12) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x1 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y1 - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y1 * this1.getUInt16(0) + x1) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color >> 24 & 255;
				this1.b[position + 1] = color >> 16 & 255;
				this1.b[position + 2] = color >> 8 & 255;
				this1.b[position + 3] = color & 255;
			}
		} else {
			var position1 = (y1 * this1.getUInt16(0) + x1) * 4;
			position1 += vision_ds_Image.OFFSET;
			this1.b[position1] = color >> 24 & 255;
			this1.b[position1 + 1] = color >> 16 & 255;
			this1.b[position1 + 2] = color >> 8 & 255;
			this1.b[position1 + 3] = color & 255;
		}
		var x13 = centerX - x;
		var y13 = centerY + y;
		if(!(x13 >= 0 && y13 >= 0 && x13 < this1.getUInt16(0) && y13 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x1 = x13;
			var this_y1 = y13;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x1,this_y1)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v1 = null;
			var tmp1;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v1 == null) {
				tmp1 = x13 >= 0 && y13 >= 0 && x13 < this1.getUInt16(0) && y13 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has1 = false;
				var view2;
				if(v1 != null) {
					view2 = v1;
				} else {
					var _g3 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g4 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g5 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this3 = this1.b;
					var view3 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view2 = new vision_ds_ImageView(_g3,_g4,_g5,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this3[view3]);
				}
				switch(view2.shape) {
				case 0:
					has1 = x13 < view2.x + view2.width && y13 < view2.y + view2.height && x13 >= view2.x && y13 >= view2.y;
					break;
				case 1:
					has1 = !(x13 < view2.x + view2.width && y13 < view2.y + view2.height && x13 >= view2.x && y13 >= view2.y);
					break;
				case 2:case 3:
					if(view2.width > view2.height) {
						var a2 = view2.width / 2;
						var b2 = view2.height / 2;
						var c2 = Math.sqrt(a2 * a2 - b2 * b2);
						var x14 = view2.x + view2.width / 2 - c2;
						var y14 = view2.y + view2.height / 2;
						if(y14 == null) {
							y14 = 0;
						}
						if(x14 == null) {
							x14 = 0;
						}
						var f1_x2 = x14;
						var f1_y2 = y14;
						var x15 = view2.x + view2.width / 2 + c2;
						var y15 = view2.y + view2.height / 2;
						if(y15 == null) {
							y15 = 0;
						}
						if(x15 == null) {
							x15 = 0;
						}
						var f2_x2 = x15;
						var f2_y2 = y15;
						var p_x2 = x13;
						var p_y2 = y13;
						var x16 = p_x2 - f1_x2;
						var y16 = p_y2 - f1_y2;
						var x17 = p_x2 - f2_x2;
						var y17 = p_y2 - f2_y2;
						has1 = Math.sqrt(x16 * x16 + y16 * y16) + Math.sqrt(x17 * x17 + y17 * y17) <= view2.width;
						if(view2.shape == 3) {
							has1 = !has1;
						}
					} else if(view2.height > view2.width) {
						var a3 = view2.height / 2;
						var b3 = view2.width / 2;
						var c3 = Math.sqrt(a3 * a3 - b3 * b3);
						var x18 = view2.x + view2.width / 2;
						var y18 = view2.y + view2.height / 2 - c3;
						if(y18 == null) {
							y18 = 0;
						}
						if(x18 == null) {
							x18 = 0;
						}
						var f1_x3 = x18;
						var f1_y3 = y18;
						var x19 = view2.x + view2.width / 2;
						var y19 = view2.y + view2.height / 2 + c3;
						if(y19 == null) {
							y19 = 0;
						}
						if(x19 == null) {
							x19 = 0;
						}
						var f2_x3 = x19;
						var f2_y3 = y19;
						var p_x3 = x13;
						var p_y3 = y13;
						var x20 = p_x3 - f1_x3;
						var y20 = p_y3 - f1_y3;
						var x21 = p_x3 - f2_x3;
						var y21 = p_y3 - f2_y3;
						has1 = Math.sqrt(x20 * x20 + y20 * y20) + Math.sqrt(x21 * x21 + y21 * y21) <= view2.height;
						if(view2.shape == 3) {
							has1 = !has1;
						}
					} else {
						var x22 = x13;
						var y22 = y13;
						if(y22 == null) {
							y22 = 0;
						}
						if(x22 == null) {
							x22 = 0;
						}
						var point1_x1 = x22;
						var point1_y1 = y22;
						var x23 = view2.x + view2.width / 2;
						var y23 = view2.y + view2.height / 2;
						if(y23 == null) {
							y23 = 0;
						}
						if(x23 == null) {
							x23 = 0;
						}
						var point2_x1 = x23;
						var point2_y1 = y23;
						var x24 = point2_x1 - point1_x1;
						var y24 = point2_y1 - point1_y1;
						has1 = Math.sqrt(x24 * x24 + y24 * y24) <= view2.width / 2;
						if(view2.shape == 3) {
							has1 = !has1;
						}
					}
					break;
				case 4:
					has1 = Math.abs(x13 - view2.x - view2.width / 2) / (view2.width / 2) + Math.abs(y13 - view2.y - view2.height / 2) / (view2.height / 2) <= 1;
					break;
				case 5:
					has1 = !(Math.abs(x13 - view2.x - view2.width / 2) / (view2.width / 2) + Math.abs(y13 - view2.y - view2.height / 2) / (view2.height / 2) <= 1);
					break;
				}
				tmp1 = has1;
			}
			if(tmp1) {
				var position2 = (y13 * this1.getUInt16(0) + x13) * 4;
				position2 += vision_ds_Image.OFFSET;
				this1.b[position2] = color >> 24 & 255;
				this1.b[position2 + 1] = color >> 16 & 255;
				this1.b[position2 + 2] = color >> 8 & 255;
				this1.b[position2 + 3] = color & 255;
			}
		} else {
			var position3 = (y13 * this1.getUInt16(0) + x13) * 4;
			position3 += vision_ds_Image.OFFSET;
			this1.b[position3] = color >> 24 & 255;
			this1.b[position3 + 1] = color >> 16 & 255;
			this1.b[position3 + 2] = color >> 8 & 255;
			this1.b[position3 + 3] = color & 255;
		}
		var x25 = centerX + x;
		var y25 = centerY - y;
		if(!(x25 >= 0 && y25 >= 0 && x25 < this1.getUInt16(0) && y25 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x2 = x25;
			var this_y2 = y25;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x2,this_y2)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v2 = null;
			var tmp2;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v2 == null) {
				tmp2 = x25 >= 0 && y25 >= 0 && x25 < this1.getUInt16(0) && y25 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has2 = false;
				var view4;
				if(v2 != null) {
					view4 = v2;
				} else {
					var _g6 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g7 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g8 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this4 = this1.b;
					var view5 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view4 = new vision_ds_ImageView(_g6,_g7,_g8,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this4[view5]);
				}
				switch(view4.shape) {
				case 0:
					has2 = x25 < view4.x + view4.width && y25 < view4.y + view4.height && x25 >= view4.x && y25 >= view4.y;
					break;
				case 1:
					has2 = !(x25 < view4.x + view4.width && y25 < view4.y + view4.height && x25 >= view4.x && y25 >= view4.y);
					break;
				case 2:case 3:
					if(view4.width > view4.height) {
						var a4 = view4.width / 2;
						var b4 = view4.height / 2;
						var c4 = Math.sqrt(a4 * a4 - b4 * b4);
						var x26 = view4.x + view4.width / 2 - c4;
						var y26 = view4.y + view4.height / 2;
						if(y26 == null) {
							y26 = 0;
						}
						if(x26 == null) {
							x26 = 0;
						}
						var f1_x4 = x26;
						var f1_y4 = y26;
						var x27 = view4.x + view4.width / 2 + c4;
						var y27 = view4.y + view4.height / 2;
						if(y27 == null) {
							y27 = 0;
						}
						if(x27 == null) {
							x27 = 0;
						}
						var f2_x4 = x27;
						var f2_y4 = y27;
						var p_x4 = x25;
						var p_y4 = y25;
						var x28 = p_x4 - f1_x4;
						var y28 = p_y4 - f1_y4;
						var x29 = p_x4 - f2_x4;
						var y29 = p_y4 - f2_y4;
						has2 = Math.sqrt(x28 * x28 + y28 * y28) + Math.sqrt(x29 * x29 + y29 * y29) <= view4.width;
						if(view4.shape == 3) {
							has2 = !has2;
						}
					} else if(view4.height > view4.width) {
						var a5 = view4.height / 2;
						var b5 = view4.width / 2;
						var c5 = Math.sqrt(a5 * a5 - b5 * b5);
						var x30 = view4.x + view4.width / 2;
						var y30 = view4.y + view4.height / 2 - c5;
						if(y30 == null) {
							y30 = 0;
						}
						if(x30 == null) {
							x30 = 0;
						}
						var f1_x5 = x30;
						var f1_y5 = y30;
						var x31 = view4.x + view4.width / 2;
						var y31 = view4.y + view4.height / 2 + c5;
						if(y31 == null) {
							y31 = 0;
						}
						if(x31 == null) {
							x31 = 0;
						}
						var f2_x5 = x31;
						var f2_y5 = y31;
						var p_x5 = x25;
						var p_y5 = y25;
						var x32 = p_x5 - f1_x5;
						var y32 = p_y5 - f1_y5;
						var x33 = p_x5 - f2_x5;
						var y33 = p_y5 - f2_y5;
						has2 = Math.sqrt(x32 * x32 + y32 * y32) + Math.sqrt(x33 * x33 + y33 * y33) <= view4.height;
						if(view4.shape == 3) {
							has2 = !has2;
						}
					} else {
						var x34 = x25;
						var y34 = y25;
						if(y34 == null) {
							y34 = 0;
						}
						if(x34 == null) {
							x34 = 0;
						}
						var point1_x2 = x34;
						var point1_y2 = y34;
						var x35 = view4.x + view4.width / 2;
						var y35 = view4.y + view4.height / 2;
						if(y35 == null) {
							y35 = 0;
						}
						if(x35 == null) {
							x35 = 0;
						}
						var point2_x2 = x35;
						var point2_y2 = y35;
						var x36 = point2_x2 - point1_x2;
						var y36 = point2_y2 - point1_y2;
						has2 = Math.sqrt(x36 * x36 + y36 * y36) <= view4.width / 2;
						if(view4.shape == 3) {
							has2 = !has2;
						}
					}
					break;
				case 4:
					has2 = Math.abs(x25 - view4.x - view4.width / 2) / (view4.width / 2) + Math.abs(y25 - view4.y - view4.height / 2) / (view4.height / 2) <= 1;
					break;
				case 5:
					has2 = !(Math.abs(x25 - view4.x - view4.width / 2) / (view4.width / 2) + Math.abs(y25 - view4.y - view4.height / 2) / (view4.height / 2) <= 1);
					break;
				}
				tmp2 = has2;
			}
			if(tmp2) {
				var position4 = (y25 * this1.getUInt16(0) + x25) * 4;
				position4 += vision_ds_Image.OFFSET;
				this1.b[position4] = color >> 24 & 255;
				this1.b[position4 + 1] = color >> 16 & 255;
				this1.b[position4 + 2] = color >> 8 & 255;
				this1.b[position4 + 3] = color & 255;
			}
		} else {
			var position5 = (y25 * this1.getUInt16(0) + x25) * 4;
			position5 += vision_ds_Image.OFFSET;
			this1.b[position5] = color >> 24 & 255;
			this1.b[position5 + 1] = color >> 16 & 255;
			this1.b[position5 + 2] = color >> 8 & 255;
			this1.b[position5 + 3] = color & 255;
		}
		var x37 = centerX - x;
		var y37 = centerY - y;
		if(!(x37 >= 0 && y37 >= 0 && x37 < this1.getUInt16(0) && y37 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x3 = x37;
			var this_y3 = y37;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x3,this_y3)));
		} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
			var v3 = null;
			var tmp3;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v3 == null) {
				tmp3 = x37 >= 0 && y37 >= 0 && x37 < this1.getUInt16(0) && y37 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has3 = false;
				var view6;
				if(v3 != null) {
					view6 = v3;
				} else {
					var _g9 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g10 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g11 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this5 = this1.b;
					var view7 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view6 = new vision_ds_ImageView(_g9,_g10,_g11,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this5[view7]);
				}
				switch(view6.shape) {
				case 0:
					has3 = x37 < view6.x + view6.width && y37 < view6.y + view6.height && x37 >= view6.x && y37 >= view6.y;
					break;
				case 1:
					has3 = !(x37 < view6.x + view6.width && y37 < view6.y + view6.height && x37 >= view6.x && y37 >= view6.y);
					break;
				case 2:case 3:
					if(view6.width > view6.height) {
						var a6 = view6.width / 2;
						var b6 = view6.height / 2;
						var c6 = Math.sqrt(a6 * a6 - b6 * b6);
						var x38 = view6.x + view6.width / 2 - c6;
						var y38 = view6.y + view6.height / 2;
						if(y38 == null) {
							y38 = 0;
						}
						if(x38 == null) {
							x38 = 0;
						}
						var f1_x6 = x38;
						var f1_y6 = y38;
						var x39 = view6.x + view6.width / 2 + c6;
						var y39 = view6.y + view6.height / 2;
						if(y39 == null) {
							y39 = 0;
						}
						if(x39 == null) {
							x39 = 0;
						}
						var f2_x6 = x39;
						var f2_y6 = y39;
						var p_x6 = x37;
						var p_y6 = y37;
						var x40 = p_x6 - f1_x6;
						var y40 = p_y6 - f1_y6;
						var x41 = p_x6 - f2_x6;
						var y41 = p_y6 - f2_y6;
						has3 = Math.sqrt(x40 * x40 + y40 * y40) + Math.sqrt(x41 * x41 + y41 * y41) <= view6.width;
						if(view6.shape == 3) {
							has3 = !has3;
						}
					} else if(view6.height > view6.width) {
						var a7 = view6.height / 2;
						var b7 = view6.width / 2;
						var c7 = Math.sqrt(a7 * a7 - b7 * b7);
						var x42 = view6.x + view6.width / 2;
						var y42 = view6.y + view6.height / 2 - c7;
						if(y42 == null) {
							y42 = 0;
						}
						if(x42 == null) {
							x42 = 0;
						}
						var f1_x7 = x42;
						var f1_y7 = y42;
						var x43 = view6.x + view6.width / 2;
						var y43 = view6.y + view6.height / 2 + c7;
						if(y43 == null) {
							y43 = 0;
						}
						if(x43 == null) {
							x43 = 0;
						}
						var f2_x7 = x43;
						var f2_y7 = y43;
						var p_x7 = x37;
						var p_y7 = y37;
						var x44 = p_x7 - f1_x7;
						var y44 = p_y7 - f1_y7;
						var x45 = p_x7 - f2_x7;
						var y45 = p_y7 - f2_y7;
						has3 = Math.sqrt(x44 * x44 + y44 * y44) + Math.sqrt(x45 * x45 + y45 * y45) <= view6.height;
						if(view6.shape == 3) {
							has3 = !has3;
						}
					} else {
						var x46 = x37;
						var y46 = y37;
						if(y46 == null) {
							y46 = 0;
						}
						if(x46 == null) {
							x46 = 0;
						}
						var point1_x3 = x46;
						var point1_y3 = y46;
						var x47 = view6.x + view6.width / 2;
						var y47 = view6.y + view6.height / 2;
						if(y47 == null) {
							y47 = 0;
						}
						if(x47 == null) {
							x47 = 0;
						}
						var point2_x3 = x47;
						var point2_y3 = y47;
						var x48 = point2_x3 - point1_x3;
						var y48 = point2_y3 - point1_y3;
						has3 = Math.sqrt(x48 * x48 + y48 * y48) <= view6.width / 2;
						if(view6.shape == 3) {
							has3 = !has3;
						}
					}
					break;
				case 4:
					has3 = Math.abs(x37 - view6.x - view6.width / 2) / (view6.width / 2) + Math.abs(y37 - view6.y - view6.height / 2) / (view6.height / 2) <= 1;
					break;
				case 5:
					has3 = !(Math.abs(x37 - view6.x - view6.width / 2) / (view6.width / 2) + Math.abs(y37 - view6.y - view6.height / 2) / (view6.height / 2) <= 1);
					break;
				}
				tmp3 = has3;
			}
			if(tmp3) {
				var position6 = (y37 * this1.getUInt16(0) + x37) * 4;
				position6 += vision_ds_Image.OFFSET;
				this1.b[position6] = color >> 24 & 255;
				this1.b[position6 + 1] = color >> 16 & 255;
				this1.b[position6 + 2] = color >> 8 & 255;
				this1.b[position6 + 3] = color & 255;
			}
		} else {
			var position7 = (y37 * this1.getUInt16(0) + x37) * 4;
			position7 += vision_ds_Image.OFFSET;
			this1.b[position7] = color >> 24 & 255;
			this1.b[position7 + 1] = color >> 16 & 255;
			this1.b[position7 + 2] = color >> 8 & 255;
			this1.b[position7 + 3] = color & 255;
		}
		if(ellipseError <= 0) {
			++x;
			stoppingX += twoBSquare;
			ellipseError += xChange;
			xChange += twoBSquare;
		}
		if(ellipseError > 0) {
			--y;
			stoppingY -= twoASquare;
			ellipseError += yChange;
			yChange += twoASquare;
		}
	}
};
vision_ds_Image.fillColorRecursive = function(this1,position,color) {
	var x = position.x;
	var y = position.y;
	if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x;
		var this_y = y;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position1 = (y * this1.getUInt16(0) + x) * 4;
	position1 += vision_ds_Image.OFFSET;
	var value = this1.b[position1] << 24 | this1.b[position1 + 1] << 16 | this1.b[position1 + 2] << 8 | this1.b[position1 + 3];
	if(value == null) {
		value = 0;
	}
	var originalColor = value;
	var expandFill = null;
	expandFill = function(x,y) {
		if(x < 0 || x >= Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) || y < 0 || y >= this1.getUInt16(0)) {
			return;
		}
		if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x;
			var this_y = y;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		}
		var position = (y * this1.getUInt16(0) + x) * 4;
		position += vision_ds_Image.OFFSET;
		var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
		if(value == null) {
			value = 0;
		}
		if(value == color) {
			return;
		}
		if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x;
			var this_y = y;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		}
		var position = (y * this1.getUInt16(0) + x) * 4;
		position += vision_ds_Image.OFFSET;
		var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
		if(value == null) {
			value = 0;
		}
		if(value == originalColor) {
			if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
				var this_x = x;
				var this_y = y;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
				var v = null;
				var expandFill1;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					expandFill1 = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
						break;
					case 1:
						has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2 - c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x1 = view.x + view.width / 2 + c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y1;
							var p_x = x;
							var p_y = y;
							var x1 = p_x - f1_x;
							var y1 = p_y - f1_y;
							var x2 = p_x - f2_x;
							var y2 = p_y - f2_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a = view.height / 2;
							var b = view.width / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2 - c;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2 + c;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f2_x = x1;
							var f2_y = y1;
							var p_x = x;
							var p_y = y;
							var x1 = p_x - f1_x;
							var y1 = p_y - f1_y;
							var x2 = p_x - f2_x;
							var y2 = p_y - f2_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x1 = x;
							var y1 = y;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var point1_x = x1;
							var point1_y = y1;
							var x1 = view.x + view.width / 2;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var point2_x = x1;
							var point2_y = y1;
							var x1 = point2_x - point1_x;
							var y1 = point2_y - point1_y;
							has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					expandFill1 = has;
				}
				if(expandFill1) {
					var position = (y * this1.getUInt16(0) + x) * 4;
					position += vision_ds_Image.OFFSET;
					this1.b[position] = color >> 24 & 255;
					this1.b[position + 1] = color >> 16 & 255;
					this1.b[position + 2] = color >> 8 & 255;
					this1.b[position + 3] = color & 255;
				}
			} else {
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				this1.b[position] = color >> 24 & 255;
				this1.b[position + 1] = color >> 16 & 255;
				this1.b[position + 2] = color >> 8 & 255;
				this1.b[position + 3] = color & 255;
			}
			expandFill(x + 1,y);
			expandFill(x - 1,y);
			expandFill(x,y + 1);
			expandFill(x,y - 1);
		}
	};
	expandFill(position.x,position.y);
};
vision_ds_Image.fillColor = function(this1,position,color) {
	var queue = new haxe_ds_List();
	var x = position.x;
	var y = position.y;
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	var p_x = x;
	var p_y = y;
	queue.push(new vision_ds__$IntPoint2D_Impl(p_x | 0,p_y | 0));
	var explored = [];
	var x = position.x;
	var y = position.y;
	if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
		var this_x = x;
		var this_y = y;
		throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
	}
	var position = (y * this1.getUInt16(0) + x) * 4;
	position += vision_ds_Image.OFFSET;
	var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
	if(value == null) {
		value = 0;
	}
	var originalColor = value;
	var pc = 0;
	while(queue.length > 0) {
		var v = queue.pop();
		explored.push(new haxe__$Int64__$_$_$Int64(v.x,v.y));
		var x = v.x + 1;
		var y = v.y;
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		var p_x = x;
		var p_y = y;
		var point_x = p_x | 0;
		var point_y = p_y | 0;
		if(pc >= 100000) {
			haxe_Log.trace("fillColor: too much iterations",{ fileName : "vision/ds/Image.hx", lineNumber : 997, className : "vision.ds._Image.Image_Impl_", methodName : "fillColor"});
			queue.clear();
		} else {
			var tmp;
			var x1 = point_x;
			var y1 = point_y;
			if(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
				var x2 = point_x;
				var y2 = point_y;
				if(!(x2 >= 0 && y2 >= 0 && x2 < this1.getUInt16(0) && y2 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x = x2;
					var this_y = y2;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
				}
				var position = (y2 * this1.getUInt16(0) + x2) * 4;
				position += vision_ds_Image.OFFSET;
				var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
				if(value == null) {
					value = 0;
				}
				tmp = value == originalColor;
			} else {
				tmp = false;
			}
			if(tmp && explored.indexOf(new haxe__$Int64__$_$_$Int64(point_x,point_y)) == -1) {
				++pc;
				var x3 = point_x;
				var y3 = point_y;
				if(y3 == null) {
					y3 = 0;
				}
				if(x3 == null) {
					x3 = 0;
				}
				var p_x1 = x3;
				var p_y1 = y3;
				queue.push(new vision_ds__$IntPoint2D_Impl(p_x1 | 0,p_y1 | 0));
				var x4 = point_x;
				var y4 = point_y;
				if(!(x4 >= 0 && y4 >= 0 && x4 < this1.getUInt16(0) && y4 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x1 = x4;
					var this_y1 = y4;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x1,this_y1)));
				} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
					var v1 = null;
					var tmp1;
					if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v1 == null) {
						tmp1 = x4 >= 0 && y4 >= 0 && x4 < this1.getUInt16(0) && y4 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
					} else {
						var has = false;
						var view;
						if(v1 != null) {
							view = v1;
						} else {
							var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
							var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
							var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
							var this2 = this1.b;
							var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
							view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
						}
						switch(view.shape) {
						case 0:
							has = x4 < view.x + view.width && y4 < view.y + view.height && x4 >= view.x && y4 >= view.y;
							break;
						case 1:
							has = !(x4 < view.x + view.width && y4 < view.y + view.height && x4 >= view.x && y4 >= view.y);
							break;
						case 2:case 3:
							if(view.width > view.height) {
								var a = view.width / 2;
								var b = view.height / 2;
								var c = Math.sqrt(a * a - b * b);
								var x5 = view.x + view.width / 2 - c;
								var y5 = view.y + view.height / 2;
								if(y5 == null) {
									y5 = 0;
								}
								if(x5 == null) {
									x5 = 0;
								}
								var f1_x = x5;
								var f1_y = y5;
								var x6 = view.x + view.width / 2 + c;
								var y6 = view.y + view.height / 2;
								if(y6 == null) {
									y6 = 0;
								}
								if(x6 == null) {
									x6 = 0;
								}
								var f2_x = x6;
								var f2_y = y6;
								var p_x2 = x4;
								var p_y2 = y4;
								var x7 = p_x2 - f1_x;
								var y7 = p_y2 - f1_y;
								var x8 = p_x2 - f2_x;
								var y8 = p_y2 - f2_y;
								has = Math.sqrt(x7 * x7 + y7 * y7) + Math.sqrt(x8 * x8 + y8 * y8) <= view.width;
								if(view.shape == 3) {
									has = !has;
								}
							} else if(view.height > view.width) {
								var a1 = view.height / 2;
								var b1 = view.width / 2;
								var c1 = Math.sqrt(a1 * a1 - b1 * b1);
								var x9 = view.x + view.width / 2;
								var y9 = view.y + view.height / 2 - c1;
								if(y9 == null) {
									y9 = 0;
								}
								if(x9 == null) {
									x9 = 0;
								}
								var f1_x1 = x9;
								var f1_y1 = y9;
								var x10 = view.x + view.width / 2;
								var y10 = view.y + view.height / 2 + c1;
								if(y10 == null) {
									y10 = 0;
								}
								if(x10 == null) {
									x10 = 0;
								}
								var f2_x1 = x10;
								var f2_y1 = y10;
								var p_x3 = x4;
								var p_y3 = y4;
								var x11 = p_x3 - f1_x1;
								var y11 = p_y3 - f1_y1;
								var x12 = p_x3 - f2_x1;
								var y12 = p_y3 - f2_y1;
								has = Math.sqrt(x11 * x11 + y11 * y11) + Math.sqrt(x12 * x12 + y12 * y12) <= view.height;
								if(view.shape == 3) {
									has = !has;
								}
							} else {
								var x13 = x4;
								var y13 = y4;
								if(y13 == null) {
									y13 = 0;
								}
								if(x13 == null) {
									x13 = 0;
								}
								var point1_x = x13;
								var point1_y = y13;
								var x14 = view.x + view.width / 2;
								var y14 = view.y + view.height / 2;
								if(y14 == null) {
									y14 = 0;
								}
								if(x14 == null) {
									x14 = 0;
								}
								var point2_x = x14;
								var point2_y = y14;
								var x15 = point2_x - point1_x;
								var y15 = point2_y - point1_y;
								has = Math.sqrt(x15 * x15 + y15 * y15) <= view.width / 2;
								if(view.shape == 3) {
									has = !has;
								}
							}
							break;
						case 4:
							has = Math.abs(x4 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y4 - view.y - view.height / 2) / (view.height / 2) <= 1;
							break;
						case 5:
							has = !(Math.abs(x4 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y4 - view.y - view.height / 2) / (view.height / 2) <= 1);
							break;
						}
						tmp1 = has;
					}
					if(tmp1) {
						var position1 = (y4 * this1.getUInt16(0) + x4) * 4;
						position1 += vision_ds_Image.OFFSET;
						this1.b[position1] = color >> 24 & 255;
						this1.b[position1 + 1] = color >> 16 & 255;
						this1.b[position1 + 2] = color >> 8 & 255;
						this1.b[position1 + 3] = color & 255;
					}
				} else {
					var position2 = (y4 * this1.getUInt16(0) + x4) * 4;
					position2 += vision_ds_Image.OFFSET;
					this1.b[position2] = color >> 24 & 255;
					this1.b[position2 + 1] = color >> 16 & 255;
					this1.b[position2 + 2] = color >> 8 & 255;
					this1.b[position2 + 3] = color & 255;
				}
			}
		}
		var x16 = v.x;
		var y16 = v.y + 1;
		if(y16 == null) {
			y16 = 0;
		}
		if(x16 == null) {
			x16 = 0;
		}
		var p_x4 = x16;
		var p_y4 = y16;
		var point_x1 = p_x4 | 0;
		var point_y1 = p_y4 | 0;
		if(pc >= 100000) {
			haxe_Log.trace("fillColor: too much iterations",{ fileName : "vision/ds/Image.hx", lineNumber : 997, className : "vision.ds._Image.Image_Impl_", methodName : "fillColor"});
			queue.clear();
		} else {
			var tmp2;
			var x17 = point_x1;
			var y17 = point_y1;
			if(x17 >= 0 && y17 >= 0 && x17 < this1.getUInt16(0) && y17 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
				var x18 = point_x1;
				var y18 = point_y1;
				if(!(x18 >= 0 && y18 >= 0 && x18 < this1.getUInt16(0) && y18 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x2 = x18;
					var this_y2 = y18;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x2,this_y2)));
				}
				var position3 = (y18 * this1.getUInt16(0) + x18) * 4;
				position3 += vision_ds_Image.OFFSET;
				var value1 = this1.b[position3] << 24 | this1.b[position3 + 1] << 16 | this1.b[position3 + 2] << 8 | this1.b[position3 + 3];
				if(value1 == null) {
					value1 = 0;
				}
				tmp2 = value1 == originalColor;
			} else {
				tmp2 = false;
			}
			if(tmp2 && explored.indexOf(new haxe__$Int64__$_$_$Int64(point_x1,point_y1)) == -1) {
				++pc;
				var x19 = point_x1;
				var y19 = point_y1;
				if(y19 == null) {
					y19 = 0;
				}
				if(x19 == null) {
					x19 = 0;
				}
				var p_x5 = x19;
				var p_y5 = y19;
				queue.push(new vision_ds__$IntPoint2D_Impl(p_x5 | 0,p_y5 | 0));
				var x20 = point_x1;
				var y20 = point_y1;
				if(!(x20 >= 0 && y20 >= 0 && x20 < this1.getUInt16(0) && y20 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x3 = x20;
					var this_y3 = y20;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x3,this_y3)));
				} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
					var v2 = null;
					var tmp3;
					if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v2 == null) {
						tmp3 = x20 >= 0 && y20 >= 0 && x20 < this1.getUInt16(0) && y20 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
					} else {
						var has1 = false;
						var view2;
						if(v2 != null) {
							view2 = v2;
						} else {
							var _g3 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
							var _g4 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
							var _g5 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
							var this3 = this1.b;
							var view3 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
							view2 = new vision_ds_ImageView(_g3,_g4,_g5,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this3[view3]);
						}
						switch(view2.shape) {
						case 0:
							has1 = x20 < view2.x + view2.width && y20 < view2.y + view2.height && x20 >= view2.x && y20 >= view2.y;
							break;
						case 1:
							has1 = !(x20 < view2.x + view2.width && y20 < view2.y + view2.height && x20 >= view2.x && y20 >= view2.y);
							break;
						case 2:case 3:
							if(view2.width > view2.height) {
								var a2 = view2.width / 2;
								var b2 = view2.height / 2;
								var c2 = Math.sqrt(a2 * a2 - b2 * b2);
								var x21 = view2.x + view2.width / 2 - c2;
								var y21 = view2.y + view2.height / 2;
								if(y21 == null) {
									y21 = 0;
								}
								if(x21 == null) {
									x21 = 0;
								}
								var f1_x2 = x21;
								var f1_y2 = y21;
								var x22 = view2.x + view2.width / 2 + c2;
								var y22 = view2.y + view2.height / 2;
								if(y22 == null) {
									y22 = 0;
								}
								if(x22 == null) {
									x22 = 0;
								}
								var f2_x2 = x22;
								var f2_y2 = y22;
								var p_x6 = x20;
								var p_y6 = y20;
								var x23 = p_x6 - f1_x2;
								var y23 = p_y6 - f1_y2;
								var x24 = p_x6 - f2_x2;
								var y24 = p_y6 - f2_y2;
								has1 = Math.sqrt(x23 * x23 + y23 * y23) + Math.sqrt(x24 * x24 + y24 * y24) <= view2.width;
								if(view2.shape == 3) {
									has1 = !has1;
								}
							} else if(view2.height > view2.width) {
								var a3 = view2.height / 2;
								var b3 = view2.width / 2;
								var c3 = Math.sqrt(a3 * a3 - b3 * b3);
								var x25 = view2.x + view2.width / 2;
								var y25 = view2.y + view2.height / 2 - c3;
								if(y25 == null) {
									y25 = 0;
								}
								if(x25 == null) {
									x25 = 0;
								}
								var f1_x3 = x25;
								var f1_y3 = y25;
								var x26 = view2.x + view2.width / 2;
								var y26 = view2.y + view2.height / 2 + c3;
								if(y26 == null) {
									y26 = 0;
								}
								if(x26 == null) {
									x26 = 0;
								}
								var f2_x3 = x26;
								var f2_y3 = y26;
								var p_x7 = x20;
								var p_y7 = y20;
								var x27 = p_x7 - f1_x3;
								var y27 = p_y7 - f1_y3;
								var x28 = p_x7 - f2_x3;
								var y28 = p_y7 - f2_y3;
								has1 = Math.sqrt(x27 * x27 + y27 * y27) + Math.sqrt(x28 * x28 + y28 * y28) <= view2.height;
								if(view2.shape == 3) {
									has1 = !has1;
								}
							} else {
								var x29 = x20;
								var y29 = y20;
								if(y29 == null) {
									y29 = 0;
								}
								if(x29 == null) {
									x29 = 0;
								}
								var point1_x1 = x29;
								var point1_y1 = y29;
								var x30 = view2.x + view2.width / 2;
								var y30 = view2.y + view2.height / 2;
								if(y30 == null) {
									y30 = 0;
								}
								if(x30 == null) {
									x30 = 0;
								}
								var point2_x1 = x30;
								var point2_y1 = y30;
								var x31 = point2_x1 - point1_x1;
								var y31 = point2_y1 - point1_y1;
								has1 = Math.sqrt(x31 * x31 + y31 * y31) <= view2.width / 2;
								if(view2.shape == 3) {
									has1 = !has1;
								}
							}
							break;
						case 4:
							has1 = Math.abs(x20 - view2.x - view2.width / 2) / (view2.width / 2) + Math.abs(y20 - view2.y - view2.height / 2) / (view2.height / 2) <= 1;
							break;
						case 5:
							has1 = !(Math.abs(x20 - view2.x - view2.width / 2) / (view2.width / 2) + Math.abs(y20 - view2.y - view2.height / 2) / (view2.height / 2) <= 1);
							break;
						}
						tmp3 = has1;
					}
					if(tmp3) {
						var position4 = (y20 * this1.getUInt16(0) + x20) * 4;
						position4 += vision_ds_Image.OFFSET;
						this1.b[position4] = color >> 24 & 255;
						this1.b[position4 + 1] = color >> 16 & 255;
						this1.b[position4 + 2] = color >> 8 & 255;
						this1.b[position4 + 3] = color & 255;
					}
				} else {
					var position5 = (y20 * this1.getUInt16(0) + x20) * 4;
					position5 += vision_ds_Image.OFFSET;
					this1.b[position5] = color >> 24 & 255;
					this1.b[position5 + 1] = color >> 16 & 255;
					this1.b[position5 + 2] = color >> 8 & 255;
					this1.b[position5 + 3] = color & 255;
				}
			}
		}
		var x32 = v.x - 1;
		var y32 = v.y;
		if(y32 == null) {
			y32 = 0;
		}
		if(x32 == null) {
			x32 = 0;
		}
		var p_x8 = x32;
		var p_y8 = y32;
		var point_x2 = p_x8 | 0;
		var point_y2 = p_y8 | 0;
		if(pc >= 100000) {
			haxe_Log.trace("fillColor: too much iterations",{ fileName : "vision/ds/Image.hx", lineNumber : 997, className : "vision.ds._Image.Image_Impl_", methodName : "fillColor"});
			queue.clear();
		} else {
			var tmp4;
			var x33 = point_x2;
			var y33 = point_y2;
			if(x33 >= 0 && y33 >= 0 && x33 < this1.getUInt16(0) && y33 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
				var x34 = point_x2;
				var y34 = point_y2;
				if(!(x34 >= 0 && y34 >= 0 && x34 < this1.getUInt16(0) && y34 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x4 = x34;
					var this_y4 = y34;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x4,this_y4)));
				}
				var position6 = (y34 * this1.getUInt16(0) + x34) * 4;
				position6 += vision_ds_Image.OFFSET;
				var value2 = this1.b[position6] << 24 | this1.b[position6 + 1] << 16 | this1.b[position6 + 2] << 8 | this1.b[position6 + 3];
				if(value2 == null) {
					value2 = 0;
				}
				tmp4 = value2 == originalColor;
			} else {
				tmp4 = false;
			}
			if(tmp4 && explored.indexOf(new haxe__$Int64__$_$_$Int64(point_x2,point_y2)) == -1) {
				++pc;
				var x35 = point_x2;
				var y35 = point_y2;
				if(y35 == null) {
					y35 = 0;
				}
				if(x35 == null) {
					x35 = 0;
				}
				var p_x9 = x35;
				var p_y9 = y35;
				queue.push(new vision_ds__$IntPoint2D_Impl(p_x9 | 0,p_y9 | 0));
				var x36 = point_x2;
				var y36 = point_y2;
				if(!(x36 >= 0 && y36 >= 0 && x36 < this1.getUInt16(0) && y36 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x5 = x36;
					var this_y5 = y36;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x5,this_y5)));
				} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
					var v3 = null;
					var tmp5;
					if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v3 == null) {
						tmp5 = x36 >= 0 && y36 >= 0 && x36 < this1.getUInt16(0) && y36 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
					} else {
						var has2 = false;
						var view4;
						if(v3 != null) {
							view4 = v3;
						} else {
							var _g6 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
							var _g7 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
							var _g8 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
							var this4 = this1.b;
							var view5 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
							view4 = new vision_ds_ImageView(_g6,_g7,_g8,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this4[view5]);
						}
						switch(view4.shape) {
						case 0:
							has2 = x36 < view4.x + view4.width && y36 < view4.y + view4.height && x36 >= view4.x && y36 >= view4.y;
							break;
						case 1:
							has2 = !(x36 < view4.x + view4.width && y36 < view4.y + view4.height && x36 >= view4.x && y36 >= view4.y);
							break;
						case 2:case 3:
							if(view4.width > view4.height) {
								var a4 = view4.width / 2;
								var b4 = view4.height / 2;
								var c4 = Math.sqrt(a4 * a4 - b4 * b4);
								var x37 = view4.x + view4.width / 2 - c4;
								var y37 = view4.y + view4.height / 2;
								if(y37 == null) {
									y37 = 0;
								}
								if(x37 == null) {
									x37 = 0;
								}
								var f1_x4 = x37;
								var f1_y4 = y37;
								var x38 = view4.x + view4.width / 2 + c4;
								var y38 = view4.y + view4.height / 2;
								if(y38 == null) {
									y38 = 0;
								}
								if(x38 == null) {
									x38 = 0;
								}
								var f2_x4 = x38;
								var f2_y4 = y38;
								var p_x10 = x36;
								var p_y10 = y36;
								var x39 = p_x10 - f1_x4;
								var y39 = p_y10 - f1_y4;
								var x40 = p_x10 - f2_x4;
								var y40 = p_y10 - f2_y4;
								has2 = Math.sqrt(x39 * x39 + y39 * y39) + Math.sqrt(x40 * x40 + y40 * y40) <= view4.width;
								if(view4.shape == 3) {
									has2 = !has2;
								}
							} else if(view4.height > view4.width) {
								var a5 = view4.height / 2;
								var b5 = view4.width / 2;
								var c5 = Math.sqrt(a5 * a5 - b5 * b5);
								var x41 = view4.x + view4.width / 2;
								var y41 = view4.y + view4.height / 2 - c5;
								if(y41 == null) {
									y41 = 0;
								}
								if(x41 == null) {
									x41 = 0;
								}
								var f1_x5 = x41;
								var f1_y5 = y41;
								var x42 = view4.x + view4.width / 2;
								var y42 = view4.y + view4.height / 2 + c5;
								if(y42 == null) {
									y42 = 0;
								}
								if(x42 == null) {
									x42 = 0;
								}
								var f2_x5 = x42;
								var f2_y5 = y42;
								var p_x11 = x36;
								var p_y11 = y36;
								var x43 = p_x11 - f1_x5;
								var y43 = p_y11 - f1_y5;
								var x44 = p_x11 - f2_x5;
								var y44 = p_y11 - f2_y5;
								has2 = Math.sqrt(x43 * x43 + y43 * y43) + Math.sqrt(x44 * x44 + y44 * y44) <= view4.height;
								if(view4.shape == 3) {
									has2 = !has2;
								}
							} else {
								var x45 = x36;
								var y45 = y36;
								if(y45 == null) {
									y45 = 0;
								}
								if(x45 == null) {
									x45 = 0;
								}
								var point1_x2 = x45;
								var point1_y2 = y45;
								var x46 = view4.x + view4.width / 2;
								var y46 = view4.y + view4.height / 2;
								if(y46 == null) {
									y46 = 0;
								}
								if(x46 == null) {
									x46 = 0;
								}
								var point2_x2 = x46;
								var point2_y2 = y46;
								var x47 = point2_x2 - point1_x2;
								var y47 = point2_y2 - point1_y2;
								has2 = Math.sqrt(x47 * x47 + y47 * y47) <= view4.width / 2;
								if(view4.shape == 3) {
									has2 = !has2;
								}
							}
							break;
						case 4:
							has2 = Math.abs(x36 - view4.x - view4.width / 2) / (view4.width / 2) + Math.abs(y36 - view4.y - view4.height / 2) / (view4.height / 2) <= 1;
							break;
						case 5:
							has2 = !(Math.abs(x36 - view4.x - view4.width / 2) / (view4.width / 2) + Math.abs(y36 - view4.y - view4.height / 2) / (view4.height / 2) <= 1);
							break;
						}
						tmp5 = has2;
					}
					if(tmp5) {
						var position7 = (y36 * this1.getUInt16(0) + x36) * 4;
						position7 += vision_ds_Image.OFFSET;
						this1.b[position7] = color >> 24 & 255;
						this1.b[position7 + 1] = color >> 16 & 255;
						this1.b[position7 + 2] = color >> 8 & 255;
						this1.b[position7 + 3] = color & 255;
					}
				} else {
					var position8 = (y36 * this1.getUInt16(0) + x36) * 4;
					position8 += vision_ds_Image.OFFSET;
					this1.b[position8] = color >> 24 & 255;
					this1.b[position8 + 1] = color >> 16 & 255;
					this1.b[position8 + 2] = color >> 8 & 255;
					this1.b[position8 + 3] = color & 255;
				}
			}
		}
		var x48 = v.x;
		var y48 = v.y - 1;
		if(y48 == null) {
			y48 = 0;
		}
		if(x48 == null) {
			x48 = 0;
		}
		var p_x12 = x48;
		var p_y12 = y48;
		var point_x3 = p_x12 | 0;
		var point_y3 = p_y12 | 0;
		if(pc >= 100000) {
			haxe_Log.trace("fillColor: too much iterations",{ fileName : "vision/ds/Image.hx", lineNumber : 997, className : "vision.ds._Image.Image_Impl_", methodName : "fillColor"});
			queue.clear();
		} else {
			var tmp6;
			var x49 = point_x3;
			var y49 = point_y3;
			if(x49 >= 0 && y49 >= 0 && x49 < this1.getUInt16(0) && y49 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
				var x50 = point_x3;
				var y50 = point_y3;
				if(!(x50 >= 0 && y50 >= 0 && x50 < this1.getUInt16(0) && y50 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x6 = x50;
					var this_y6 = y50;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x6,this_y6)));
				}
				var position9 = (y50 * this1.getUInt16(0) + x50) * 4;
				position9 += vision_ds_Image.OFFSET;
				var value3 = this1.b[position9] << 24 | this1.b[position9 + 1] << 16 | this1.b[position9 + 2] << 8 | this1.b[position9 + 3];
				if(value3 == null) {
					value3 = 0;
				}
				tmp6 = value3 == originalColor;
			} else {
				tmp6 = false;
			}
			if(tmp6 && explored.indexOf(new haxe__$Int64__$_$_$Int64(point_x3,point_y3)) == -1) {
				++pc;
				var x51 = point_x3;
				var y51 = point_y3;
				if(y51 == null) {
					y51 = 0;
				}
				if(x51 == null) {
					x51 = 0;
				}
				var p_x13 = x51;
				var p_y13 = y51;
				queue.push(new vision_ds__$IntPoint2D_Impl(p_x13 | 0,p_y13 | 0));
				var x52 = point_x3;
				var y52 = point_y3;
				if(!(x52 >= 0 && y52 >= 0 && x52 < this1.getUInt16(0) && y52 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x7 = x52;
					var this_y7 = y52;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x7,this_y7)));
				} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
					var v4 = null;
					var tmp7;
					if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v4 == null) {
						tmp7 = x52 >= 0 && y52 >= 0 && x52 < this1.getUInt16(0) && y52 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
					} else {
						var has3 = false;
						var view6;
						if(v4 != null) {
							view6 = v4;
						} else {
							var _g9 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
							var _g10 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
							var _g11 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
							var this5 = this1.b;
							var view7 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
							view6 = new vision_ds_ImageView(_g9,_g10,_g11,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this5[view7]);
						}
						switch(view6.shape) {
						case 0:
							has3 = x52 < view6.x + view6.width && y52 < view6.y + view6.height && x52 >= view6.x && y52 >= view6.y;
							break;
						case 1:
							has3 = !(x52 < view6.x + view6.width && y52 < view6.y + view6.height && x52 >= view6.x && y52 >= view6.y);
							break;
						case 2:case 3:
							if(view6.width > view6.height) {
								var a6 = view6.width / 2;
								var b6 = view6.height / 2;
								var c6 = Math.sqrt(a6 * a6 - b6 * b6);
								var x53 = view6.x + view6.width / 2 - c6;
								var y53 = view6.y + view6.height / 2;
								if(y53 == null) {
									y53 = 0;
								}
								if(x53 == null) {
									x53 = 0;
								}
								var f1_x6 = x53;
								var f1_y6 = y53;
								var x54 = view6.x + view6.width / 2 + c6;
								var y54 = view6.y + view6.height / 2;
								if(y54 == null) {
									y54 = 0;
								}
								if(x54 == null) {
									x54 = 0;
								}
								var f2_x6 = x54;
								var f2_y6 = y54;
								var p_x14 = x52;
								var p_y14 = y52;
								var x55 = p_x14 - f1_x6;
								var y55 = p_y14 - f1_y6;
								var x56 = p_x14 - f2_x6;
								var y56 = p_y14 - f2_y6;
								has3 = Math.sqrt(x55 * x55 + y55 * y55) + Math.sqrt(x56 * x56 + y56 * y56) <= view6.width;
								if(view6.shape == 3) {
									has3 = !has3;
								}
							} else if(view6.height > view6.width) {
								var a7 = view6.height / 2;
								var b7 = view6.width / 2;
								var c7 = Math.sqrt(a7 * a7 - b7 * b7);
								var x57 = view6.x + view6.width / 2;
								var y57 = view6.y + view6.height / 2 - c7;
								if(y57 == null) {
									y57 = 0;
								}
								if(x57 == null) {
									x57 = 0;
								}
								var f1_x7 = x57;
								var f1_y7 = y57;
								var x58 = view6.x + view6.width / 2;
								var y58 = view6.y + view6.height / 2 + c7;
								if(y58 == null) {
									y58 = 0;
								}
								if(x58 == null) {
									x58 = 0;
								}
								var f2_x7 = x58;
								var f2_y7 = y58;
								var p_x15 = x52;
								var p_y15 = y52;
								var x59 = p_x15 - f1_x7;
								var y59 = p_y15 - f1_y7;
								var x60 = p_x15 - f2_x7;
								var y60 = p_y15 - f2_y7;
								has3 = Math.sqrt(x59 * x59 + y59 * y59) + Math.sqrt(x60 * x60 + y60 * y60) <= view6.height;
								if(view6.shape == 3) {
									has3 = !has3;
								}
							} else {
								var x61 = x52;
								var y61 = y52;
								if(y61 == null) {
									y61 = 0;
								}
								if(x61 == null) {
									x61 = 0;
								}
								var point1_x3 = x61;
								var point1_y3 = y61;
								var x62 = view6.x + view6.width / 2;
								var y62 = view6.y + view6.height / 2;
								if(y62 == null) {
									y62 = 0;
								}
								if(x62 == null) {
									x62 = 0;
								}
								var point2_x3 = x62;
								var point2_y3 = y62;
								var x63 = point2_x3 - point1_x3;
								var y63 = point2_y3 - point1_y3;
								has3 = Math.sqrt(x63 * x63 + y63 * y63) <= view6.width / 2;
								if(view6.shape == 3) {
									has3 = !has3;
								}
							}
							break;
						case 4:
							has3 = Math.abs(x52 - view6.x - view6.width / 2) / (view6.width / 2) + Math.abs(y52 - view6.y - view6.height / 2) / (view6.height / 2) <= 1;
							break;
						case 5:
							has3 = !(Math.abs(x52 - view6.x - view6.width / 2) / (view6.width / 2) + Math.abs(y52 - view6.y - view6.height / 2) / (view6.height / 2) <= 1);
							break;
						}
						tmp7 = has3;
					}
					if(tmp7) {
						var position10 = (y52 * this1.getUInt16(0) + x52) * 4;
						position10 += vision_ds_Image.OFFSET;
						this1.b[position10] = color >> 24 & 255;
						this1.b[position10 + 1] = color >> 16 & 255;
						this1.b[position10 + 2] = color >> 8 & 255;
						this1.b[position10 + 3] = color & 255;
					}
				} else {
					var position11 = (y52 * this1.getUInt16(0) + x52) * 4;
					position11 += vision_ds_Image.OFFSET;
					this1.b[position11] = color >> 24 & 255;
					this1.b[position11 + 1] = color >> 16 & 255;
					this1.b[position11 + 2] = color >> 8 & 255;
					this1.b[position11 + 3] = color & 255;
				}
			}
		}
	}
};
vision_ds_Image.fillUntilColor = function(this1,position,color,borderColor) {
	var queue = new haxe_ds_List();
	var x = position.x;
	var y = position.y;
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	var p_x = x;
	var p_y = y;
	queue.push(new vision_ds__$IntPoint2D_Impl(p_x | 0,p_y | 0));
	var explored = [];
	var pc = 0;
	while(queue.length > 0) {
		var v = queue.pop();
		explored.push(new haxe__$Int64__$_$_$Int64(v.x,v.y));
		var x = v.x + 1;
		var y = v.y;
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		var p_x = x;
		var p_y = y;
		var point_x = p_x | 0;
		var point_y = p_y | 0;
		if(pc >= 100000) {
			haxe_Log.trace("fillColor: too much iterations",{ fileName : "vision/ds/Image.hx", lineNumber : 1033, className : "vision.ds._Image.Image_Impl_", methodName : "fillUntilColor"});
			queue.clear();
		} else {
			var x1 = point_x;
			var y1 = point_y;
			if(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
				if(explored.indexOf(new haxe__$Int64__$_$_$Int64(point_x,point_y)) == -1) {
					var x2 = point_x;
					var y2 = point_y;
					if(!(x2 >= 0 && y2 >= 0 && x2 < this1.getUInt16(0) && y2 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
						var this_x = x2;
						var this_y = y2;
						throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
					}
					var position = (y2 * this1.getUInt16(0) + x2) * 4;
					position += vision_ds_Image.OFFSET;
					var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
					if(value == null) {
						value = 0;
					}
					if(value != color) {
						var x3 = point_x;
						var y3 = point_y;
						if(!(x3 >= 0 && y3 >= 0 && x3 < this1.getUInt16(0) && y3 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
							var this_x1 = x3;
							var this_y1 = y3;
							throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x1,this_y1)));
						}
						var position1 = (y3 * this1.getUInt16(0) + x3) * 4;
						position1 += vision_ds_Image.OFFSET;
						var value1 = this1.b[position1] << 24 | this1.b[position1 + 1] << 16 | this1.b[position1 + 2] << 8 | this1.b[position1 + 3];
						if(value1 == null) {
							value1 = 0;
						}
						if(value1 != borderColor) {
							++pc;
							var x4 = point_x;
							var y4 = point_y;
							if(y4 == null) {
								y4 = 0;
							}
							if(x4 == null) {
								x4 = 0;
							}
							var p_x1 = x4;
							var p_y1 = y4;
							queue.push(new vision_ds__$IntPoint2D_Impl(p_x1 | 0,p_y1 | 0));
							var x5 = point_x;
							var y5 = point_y;
							if(!(x5 >= 0 && y5 >= 0 && x5 < this1.getUInt16(0) && y5 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
								var this_x2 = x5;
								var this_y2 = y5;
								throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x2,this_y2)));
							} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
								var v1 = null;
								var tmp;
								if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v1 == null) {
									tmp = x5 >= 0 && y5 >= 0 && x5 < this1.getUInt16(0) && y5 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
								} else {
									var has = false;
									var view;
									if(v1 != null) {
										view = v1;
									} else {
										var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
										var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
										var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
										var this2 = this1.b;
										var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
										view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
									}
									switch(view.shape) {
									case 0:
										has = x5 < view.x + view.width && y5 < view.y + view.height && x5 >= view.x && y5 >= view.y;
										break;
									case 1:
										has = !(x5 < view.x + view.width && y5 < view.y + view.height && x5 >= view.x && y5 >= view.y);
										break;
									case 2:case 3:
										if(view.width > view.height) {
											var a = view.width / 2;
											var b = view.height / 2;
											var c = Math.sqrt(a * a - b * b);
											var x6 = view.x + view.width / 2 - c;
											var y6 = view.y + view.height / 2;
											if(y6 == null) {
												y6 = 0;
											}
											if(x6 == null) {
												x6 = 0;
											}
											var f1_x = x6;
											var f1_y = y6;
											var x7 = view.x + view.width / 2 + c;
											var y7 = view.y + view.height / 2;
											if(y7 == null) {
												y7 = 0;
											}
											if(x7 == null) {
												x7 = 0;
											}
											var f2_x = x7;
											var f2_y = y7;
											var p_x2 = x5;
											var p_y2 = y5;
											var x8 = p_x2 - f1_x;
											var y8 = p_y2 - f1_y;
											var x9 = p_x2 - f2_x;
											var y9 = p_y2 - f2_y;
											has = Math.sqrt(x8 * x8 + y8 * y8) + Math.sqrt(x9 * x9 + y9 * y9) <= view.width;
											if(view.shape == 3) {
												has = !has;
											}
										} else if(view.height > view.width) {
											var a1 = view.height / 2;
											var b1 = view.width / 2;
											var c1 = Math.sqrt(a1 * a1 - b1 * b1);
											var x10 = view.x + view.width / 2;
											var y10 = view.y + view.height / 2 - c1;
											if(y10 == null) {
												y10 = 0;
											}
											if(x10 == null) {
												x10 = 0;
											}
											var f1_x1 = x10;
											var f1_y1 = y10;
											var x11 = view.x + view.width / 2;
											var y11 = view.y + view.height / 2 + c1;
											if(y11 == null) {
												y11 = 0;
											}
											if(x11 == null) {
												x11 = 0;
											}
											var f2_x1 = x11;
											var f2_y1 = y11;
											var p_x3 = x5;
											var p_y3 = y5;
											var x12 = p_x3 - f1_x1;
											var y12 = p_y3 - f1_y1;
											var x13 = p_x3 - f2_x1;
											var y13 = p_y3 - f2_y1;
											has = Math.sqrt(x12 * x12 + y12 * y12) + Math.sqrt(x13 * x13 + y13 * y13) <= view.height;
											if(view.shape == 3) {
												has = !has;
											}
										} else {
											var x14 = x5;
											var y14 = y5;
											if(y14 == null) {
												y14 = 0;
											}
											if(x14 == null) {
												x14 = 0;
											}
											var point1_x = x14;
											var point1_y = y14;
											var x15 = view.x + view.width / 2;
											var y15 = view.y + view.height / 2;
											if(y15 == null) {
												y15 = 0;
											}
											if(x15 == null) {
												x15 = 0;
											}
											var point2_x = x15;
											var point2_y = y15;
											var x16 = point2_x - point1_x;
											var y16 = point2_y - point1_y;
											has = Math.sqrt(x16 * x16 + y16 * y16) <= view.width / 2;
											if(view.shape == 3) {
												has = !has;
											}
										}
										break;
									case 4:
										has = Math.abs(x5 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y5 - view.y - view.height / 2) / (view.height / 2) <= 1;
										break;
									case 5:
										has = !(Math.abs(x5 - view.x - view.width / 2) / (view.width / 2) + Math.abs(y5 - view.y - view.height / 2) / (view.height / 2) <= 1);
										break;
									}
									tmp = has;
								}
								if(tmp) {
									var position2 = (y5 * this1.getUInt16(0) + x5) * 4;
									position2 += vision_ds_Image.OFFSET;
									this1.b[position2] = color >> 24 & 255;
									this1.b[position2 + 1] = color >> 16 & 255;
									this1.b[position2 + 2] = color >> 8 & 255;
									this1.b[position2 + 3] = color & 255;
								}
							} else {
								var position3 = (y5 * this1.getUInt16(0) + x5) * 4;
								position3 += vision_ds_Image.OFFSET;
								this1.b[position3] = color >> 24 & 255;
								this1.b[position3 + 1] = color >> 16 & 255;
								this1.b[position3 + 2] = color >> 8 & 255;
								this1.b[position3 + 3] = color & 255;
							}
						}
					}
				}
			}
		}
		var x17 = v.x;
		var y17 = v.y + 1;
		if(y17 == null) {
			y17 = 0;
		}
		if(x17 == null) {
			x17 = 0;
		}
		var p_x4 = x17;
		var p_y4 = y17;
		var point_x1 = p_x4 | 0;
		var point_y1 = p_y4 | 0;
		if(pc >= 100000) {
			haxe_Log.trace("fillColor: too much iterations",{ fileName : "vision/ds/Image.hx", lineNumber : 1033, className : "vision.ds._Image.Image_Impl_", methodName : "fillUntilColor"});
			queue.clear();
		} else {
			var x18 = point_x1;
			var y18 = point_y1;
			if(x18 >= 0 && y18 >= 0 && x18 < this1.getUInt16(0) && y18 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
				if(explored.indexOf(new haxe__$Int64__$_$_$Int64(point_x1,point_y1)) == -1) {
					var x19 = point_x1;
					var y19 = point_y1;
					if(!(x19 >= 0 && y19 >= 0 && x19 < this1.getUInt16(0) && y19 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
						var this_x3 = x19;
						var this_y3 = y19;
						throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x3,this_y3)));
					}
					var position4 = (y19 * this1.getUInt16(0) + x19) * 4;
					position4 += vision_ds_Image.OFFSET;
					var value2 = this1.b[position4] << 24 | this1.b[position4 + 1] << 16 | this1.b[position4 + 2] << 8 | this1.b[position4 + 3];
					if(value2 == null) {
						value2 = 0;
					}
					if(value2 != color) {
						var x20 = point_x1;
						var y20 = point_y1;
						if(!(x20 >= 0 && y20 >= 0 && x20 < this1.getUInt16(0) && y20 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
							var this_x4 = x20;
							var this_y4 = y20;
							throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x4,this_y4)));
						}
						var position5 = (y20 * this1.getUInt16(0) + x20) * 4;
						position5 += vision_ds_Image.OFFSET;
						var value3 = this1.b[position5] << 24 | this1.b[position5 + 1] << 16 | this1.b[position5 + 2] << 8 | this1.b[position5 + 3];
						if(value3 == null) {
							value3 = 0;
						}
						if(value3 != borderColor) {
							++pc;
							var x21 = point_x1;
							var y21 = point_y1;
							if(y21 == null) {
								y21 = 0;
							}
							if(x21 == null) {
								x21 = 0;
							}
							var p_x5 = x21;
							var p_y5 = y21;
							queue.push(new vision_ds__$IntPoint2D_Impl(p_x5 | 0,p_y5 | 0));
							var x22 = point_x1;
							var y22 = point_y1;
							if(!(x22 >= 0 && y22 >= 0 && x22 < this1.getUInt16(0) && y22 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
								var this_x5 = x22;
								var this_y5 = y22;
								throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x5,this_y5)));
							} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
								var v2 = null;
								var tmp1;
								if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v2 == null) {
									tmp1 = x22 >= 0 && y22 >= 0 && x22 < this1.getUInt16(0) && y22 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
								} else {
									var has1 = false;
									var view2;
									if(v2 != null) {
										view2 = v2;
									} else {
										var _g3 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
										var _g4 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
										var _g5 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
										var this3 = this1.b;
										var view3 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
										view2 = new vision_ds_ImageView(_g3,_g4,_g5,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this3[view3]);
									}
									switch(view2.shape) {
									case 0:
										has1 = x22 < view2.x + view2.width && y22 < view2.y + view2.height && x22 >= view2.x && y22 >= view2.y;
										break;
									case 1:
										has1 = !(x22 < view2.x + view2.width && y22 < view2.y + view2.height && x22 >= view2.x && y22 >= view2.y);
										break;
									case 2:case 3:
										if(view2.width > view2.height) {
											var a2 = view2.width / 2;
											var b2 = view2.height / 2;
											var c2 = Math.sqrt(a2 * a2 - b2 * b2);
											var x23 = view2.x + view2.width / 2 - c2;
											var y23 = view2.y + view2.height / 2;
											if(y23 == null) {
												y23 = 0;
											}
											if(x23 == null) {
												x23 = 0;
											}
											var f1_x2 = x23;
											var f1_y2 = y23;
											var x24 = view2.x + view2.width / 2 + c2;
											var y24 = view2.y + view2.height / 2;
											if(y24 == null) {
												y24 = 0;
											}
											if(x24 == null) {
												x24 = 0;
											}
											var f2_x2 = x24;
											var f2_y2 = y24;
											var p_x6 = x22;
											var p_y6 = y22;
											var x25 = p_x6 - f1_x2;
											var y25 = p_y6 - f1_y2;
											var x26 = p_x6 - f2_x2;
											var y26 = p_y6 - f2_y2;
											has1 = Math.sqrt(x25 * x25 + y25 * y25) + Math.sqrt(x26 * x26 + y26 * y26) <= view2.width;
											if(view2.shape == 3) {
												has1 = !has1;
											}
										} else if(view2.height > view2.width) {
											var a3 = view2.height / 2;
											var b3 = view2.width / 2;
											var c3 = Math.sqrt(a3 * a3 - b3 * b3);
											var x27 = view2.x + view2.width / 2;
											var y27 = view2.y + view2.height / 2 - c3;
											if(y27 == null) {
												y27 = 0;
											}
											if(x27 == null) {
												x27 = 0;
											}
											var f1_x3 = x27;
											var f1_y3 = y27;
											var x28 = view2.x + view2.width / 2;
											var y28 = view2.y + view2.height / 2 + c3;
											if(y28 == null) {
												y28 = 0;
											}
											if(x28 == null) {
												x28 = 0;
											}
											var f2_x3 = x28;
											var f2_y3 = y28;
											var p_x7 = x22;
											var p_y7 = y22;
											var x29 = p_x7 - f1_x3;
											var y29 = p_y7 - f1_y3;
											var x30 = p_x7 - f2_x3;
											var y30 = p_y7 - f2_y3;
											has1 = Math.sqrt(x29 * x29 + y29 * y29) + Math.sqrt(x30 * x30 + y30 * y30) <= view2.height;
											if(view2.shape == 3) {
												has1 = !has1;
											}
										} else {
											var x31 = x22;
											var y31 = y22;
											if(y31 == null) {
												y31 = 0;
											}
											if(x31 == null) {
												x31 = 0;
											}
											var point1_x1 = x31;
											var point1_y1 = y31;
											var x32 = view2.x + view2.width / 2;
											var y32 = view2.y + view2.height / 2;
											if(y32 == null) {
												y32 = 0;
											}
											if(x32 == null) {
												x32 = 0;
											}
											var point2_x1 = x32;
											var point2_y1 = y32;
											var x33 = point2_x1 - point1_x1;
											var y33 = point2_y1 - point1_y1;
											has1 = Math.sqrt(x33 * x33 + y33 * y33) <= view2.width / 2;
											if(view2.shape == 3) {
												has1 = !has1;
											}
										}
										break;
									case 4:
										has1 = Math.abs(x22 - view2.x - view2.width / 2) / (view2.width / 2) + Math.abs(y22 - view2.y - view2.height / 2) / (view2.height / 2) <= 1;
										break;
									case 5:
										has1 = !(Math.abs(x22 - view2.x - view2.width / 2) / (view2.width / 2) + Math.abs(y22 - view2.y - view2.height / 2) / (view2.height / 2) <= 1);
										break;
									}
									tmp1 = has1;
								}
								if(tmp1) {
									var position6 = (y22 * this1.getUInt16(0) + x22) * 4;
									position6 += vision_ds_Image.OFFSET;
									this1.b[position6] = color >> 24 & 255;
									this1.b[position6 + 1] = color >> 16 & 255;
									this1.b[position6 + 2] = color >> 8 & 255;
									this1.b[position6 + 3] = color & 255;
								}
							} else {
								var position7 = (y22 * this1.getUInt16(0) + x22) * 4;
								position7 += vision_ds_Image.OFFSET;
								this1.b[position7] = color >> 24 & 255;
								this1.b[position7 + 1] = color >> 16 & 255;
								this1.b[position7 + 2] = color >> 8 & 255;
								this1.b[position7 + 3] = color & 255;
							}
						}
					}
				}
			}
		}
		var x34 = v.x - 1;
		var y34 = v.y;
		if(y34 == null) {
			y34 = 0;
		}
		if(x34 == null) {
			x34 = 0;
		}
		var p_x8 = x34;
		var p_y8 = y34;
		var point_x2 = p_x8 | 0;
		var point_y2 = p_y8 | 0;
		if(pc >= 100000) {
			haxe_Log.trace("fillColor: too much iterations",{ fileName : "vision/ds/Image.hx", lineNumber : 1033, className : "vision.ds._Image.Image_Impl_", methodName : "fillUntilColor"});
			queue.clear();
		} else {
			var x35 = point_x2;
			var y35 = point_y2;
			if(x35 >= 0 && y35 >= 0 && x35 < this1.getUInt16(0) && y35 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
				if(explored.indexOf(new haxe__$Int64__$_$_$Int64(point_x2,point_y2)) == -1) {
					var x36 = point_x2;
					var y36 = point_y2;
					if(!(x36 >= 0 && y36 >= 0 && x36 < this1.getUInt16(0) && y36 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
						var this_x6 = x36;
						var this_y6 = y36;
						throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x6,this_y6)));
					}
					var position8 = (y36 * this1.getUInt16(0) + x36) * 4;
					position8 += vision_ds_Image.OFFSET;
					var value4 = this1.b[position8] << 24 | this1.b[position8 + 1] << 16 | this1.b[position8 + 2] << 8 | this1.b[position8 + 3];
					if(value4 == null) {
						value4 = 0;
					}
					if(value4 != color) {
						var x37 = point_x2;
						var y37 = point_y2;
						if(!(x37 >= 0 && y37 >= 0 && x37 < this1.getUInt16(0) && y37 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
							var this_x7 = x37;
							var this_y7 = y37;
							throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x7,this_y7)));
						}
						var position9 = (y37 * this1.getUInt16(0) + x37) * 4;
						position9 += vision_ds_Image.OFFSET;
						var value5 = this1.b[position9] << 24 | this1.b[position9 + 1] << 16 | this1.b[position9 + 2] << 8 | this1.b[position9 + 3];
						if(value5 == null) {
							value5 = 0;
						}
						if(value5 != borderColor) {
							++pc;
							var x38 = point_x2;
							var y38 = point_y2;
							if(y38 == null) {
								y38 = 0;
							}
							if(x38 == null) {
								x38 = 0;
							}
							var p_x9 = x38;
							var p_y9 = y38;
							queue.push(new vision_ds__$IntPoint2D_Impl(p_x9 | 0,p_y9 | 0));
							var x39 = point_x2;
							var y39 = point_y2;
							if(!(x39 >= 0 && y39 >= 0 && x39 < this1.getUInt16(0) && y39 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
								var this_x8 = x39;
								var this_y8 = y39;
								throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x8,this_y8)));
							} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
								var v3 = null;
								var tmp2;
								if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v3 == null) {
									tmp2 = x39 >= 0 && y39 >= 0 && x39 < this1.getUInt16(0) && y39 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
								} else {
									var has2 = false;
									var view4;
									if(v3 != null) {
										view4 = v3;
									} else {
										var _g6 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
										var _g7 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
										var _g8 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
										var this4 = this1.b;
										var view5 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
										view4 = new vision_ds_ImageView(_g6,_g7,_g8,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this4[view5]);
									}
									switch(view4.shape) {
									case 0:
										has2 = x39 < view4.x + view4.width && y39 < view4.y + view4.height && x39 >= view4.x && y39 >= view4.y;
										break;
									case 1:
										has2 = !(x39 < view4.x + view4.width && y39 < view4.y + view4.height && x39 >= view4.x && y39 >= view4.y);
										break;
									case 2:case 3:
										if(view4.width > view4.height) {
											var a4 = view4.width / 2;
											var b4 = view4.height / 2;
											var c4 = Math.sqrt(a4 * a4 - b4 * b4);
											var x40 = view4.x + view4.width / 2 - c4;
											var y40 = view4.y + view4.height / 2;
											if(y40 == null) {
												y40 = 0;
											}
											if(x40 == null) {
												x40 = 0;
											}
											var f1_x4 = x40;
											var f1_y4 = y40;
											var x41 = view4.x + view4.width / 2 + c4;
											var y41 = view4.y + view4.height / 2;
											if(y41 == null) {
												y41 = 0;
											}
											if(x41 == null) {
												x41 = 0;
											}
											var f2_x4 = x41;
											var f2_y4 = y41;
											var p_x10 = x39;
											var p_y10 = y39;
											var x42 = p_x10 - f1_x4;
											var y42 = p_y10 - f1_y4;
											var x43 = p_x10 - f2_x4;
											var y43 = p_y10 - f2_y4;
											has2 = Math.sqrt(x42 * x42 + y42 * y42) + Math.sqrt(x43 * x43 + y43 * y43) <= view4.width;
											if(view4.shape == 3) {
												has2 = !has2;
											}
										} else if(view4.height > view4.width) {
											var a5 = view4.height / 2;
											var b5 = view4.width / 2;
											var c5 = Math.sqrt(a5 * a5 - b5 * b5);
											var x44 = view4.x + view4.width / 2;
											var y44 = view4.y + view4.height / 2 - c5;
											if(y44 == null) {
												y44 = 0;
											}
											if(x44 == null) {
												x44 = 0;
											}
											var f1_x5 = x44;
											var f1_y5 = y44;
											var x45 = view4.x + view4.width / 2;
											var y45 = view4.y + view4.height / 2 + c5;
											if(y45 == null) {
												y45 = 0;
											}
											if(x45 == null) {
												x45 = 0;
											}
											var f2_x5 = x45;
											var f2_y5 = y45;
											var p_x11 = x39;
											var p_y11 = y39;
											var x46 = p_x11 - f1_x5;
											var y46 = p_y11 - f1_y5;
											var x47 = p_x11 - f2_x5;
											var y47 = p_y11 - f2_y5;
											has2 = Math.sqrt(x46 * x46 + y46 * y46) + Math.sqrt(x47 * x47 + y47 * y47) <= view4.height;
											if(view4.shape == 3) {
												has2 = !has2;
											}
										} else {
											var x48 = x39;
											var y48 = y39;
											if(y48 == null) {
												y48 = 0;
											}
											if(x48 == null) {
												x48 = 0;
											}
											var point1_x2 = x48;
											var point1_y2 = y48;
											var x49 = view4.x + view4.width / 2;
											var y49 = view4.y + view4.height / 2;
											if(y49 == null) {
												y49 = 0;
											}
											if(x49 == null) {
												x49 = 0;
											}
											var point2_x2 = x49;
											var point2_y2 = y49;
											var x50 = point2_x2 - point1_x2;
											var y50 = point2_y2 - point1_y2;
											has2 = Math.sqrt(x50 * x50 + y50 * y50) <= view4.width / 2;
											if(view4.shape == 3) {
												has2 = !has2;
											}
										}
										break;
									case 4:
										has2 = Math.abs(x39 - view4.x - view4.width / 2) / (view4.width / 2) + Math.abs(y39 - view4.y - view4.height / 2) / (view4.height / 2) <= 1;
										break;
									case 5:
										has2 = !(Math.abs(x39 - view4.x - view4.width / 2) / (view4.width / 2) + Math.abs(y39 - view4.y - view4.height / 2) / (view4.height / 2) <= 1);
										break;
									}
									tmp2 = has2;
								}
								if(tmp2) {
									var position10 = (y39 * this1.getUInt16(0) + x39) * 4;
									position10 += vision_ds_Image.OFFSET;
									this1.b[position10] = color >> 24 & 255;
									this1.b[position10 + 1] = color >> 16 & 255;
									this1.b[position10 + 2] = color >> 8 & 255;
									this1.b[position10 + 3] = color & 255;
								}
							} else {
								var position11 = (y39 * this1.getUInt16(0) + x39) * 4;
								position11 += vision_ds_Image.OFFSET;
								this1.b[position11] = color >> 24 & 255;
								this1.b[position11 + 1] = color >> 16 & 255;
								this1.b[position11 + 2] = color >> 8 & 255;
								this1.b[position11 + 3] = color & 255;
							}
						}
					}
				}
			}
		}
		var x51 = v.x;
		var y51 = v.y - 1;
		if(y51 == null) {
			y51 = 0;
		}
		if(x51 == null) {
			x51 = 0;
		}
		var p_x12 = x51;
		var p_y12 = y51;
		var point_x3 = p_x12 | 0;
		var point_y3 = p_y12 | 0;
		if(pc >= 100000) {
			haxe_Log.trace("fillColor: too much iterations",{ fileName : "vision/ds/Image.hx", lineNumber : 1033, className : "vision.ds._Image.Image_Impl_", methodName : "fillUntilColor"});
			queue.clear();
		} else {
			var x52 = point_x3;
			var y52 = point_y3;
			if(x52 >= 0 && y52 >= 0 && x52 < this1.getUInt16(0) && y52 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
				if(explored.indexOf(new haxe__$Int64__$_$_$Int64(point_x3,point_y3)) == -1) {
					var x53 = point_x3;
					var y53 = point_y3;
					if(!(x53 >= 0 && y53 >= 0 && x53 < this1.getUInt16(0) && y53 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
						var this_x9 = x53;
						var this_y9 = y53;
						throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x9,this_y9)));
					}
					var position12 = (y53 * this1.getUInt16(0) + x53) * 4;
					position12 += vision_ds_Image.OFFSET;
					var value6 = this1.b[position12] << 24 | this1.b[position12 + 1] << 16 | this1.b[position12 + 2] << 8 | this1.b[position12 + 3];
					if(value6 == null) {
						value6 = 0;
					}
					if(value6 != color) {
						var x54 = point_x3;
						var y54 = point_y3;
						if(!(x54 >= 0 && y54 >= 0 && x54 < this1.getUInt16(0) && y54 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
							var this_x10 = x54;
							var this_y10 = y54;
							throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x10,this_y10)));
						}
						var position13 = (y54 * this1.getUInt16(0) + x54) * 4;
						position13 += vision_ds_Image.OFFSET;
						var value7 = this1.b[position13] << 24 | this1.b[position13 + 1] << 16 | this1.b[position13 + 2] << 8 | this1.b[position13 + 3];
						if(value7 == null) {
							value7 = 0;
						}
						if(value7 != borderColor) {
							++pc;
							var x55 = point_x3;
							var y55 = point_y3;
							if(y55 == null) {
								y55 = 0;
							}
							if(x55 == null) {
								x55 = 0;
							}
							var p_x13 = x55;
							var p_y13 = y55;
							queue.push(new vision_ds__$IntPoint2D_Impl(p_x13 | 0,p_y13 | 0));
							var x56 = point_x3;
							var y56 = point_y3;
							if(!(x56 >= 0 && y56 >= 0 && x56 < this1.getUInt16(0) && y56 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
								var this_x11 = x56;
								var this_y11 = y56;
								throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x11,this_y11)));
							} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
								var v4 = null;
								var tmp3;
								if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v4 == null) {
									tmp3 = x56 >= 0 && y56 >= 0 && x56 < this1.getUInt16(0) && y56 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
								} else {
									var has3 = false;
									var view6;
									if(v4 != null) {
										view6 = v4;
									} else {
										var _g9 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
										var _g10 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
										var _g11 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
										var this5 = this1.b;
										var view7 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
										view6 = new vision_ds_ImageView(_g9,_g10,_g11,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this5[view7]);
									}
									switch(view6.shape) {
									case 0:
										has3 = x56 < view6.x + view6.width && y56 < view6.y + view6.height && x56 >= view6.x && y56 >= view6.y;
										break;
									case 1:
										has3 = !(x56 < view6.x + view6.width && y56 < view6.y + view6.height && x56 >= view6.x && y56 >= view6.y);
										break;
									case 2:case 3:
										if(view6.width > view6.height) {
											var a6 = view6.width / 2;
											var b6 = view6.height / 2;
											var c6 = Math.sqrt(a6 * a6 - b6 * b6);
											var x57 = view6.x + view6.width / 2 - c6;
											var y57 = view6.y + view6.height / 2;
											if(y57 == null) {
												y57 = 0;
											}
											if(x57 == null) {
												x57 = 0;
											}
											var f1_x6 = x57;
											var f1_y6 = y57;
											var x58 = view6.x + view6.width / 2 + c6;
											var y58 = view6.y + view6.height / 2;
											if(y58 == null) {
												y58 = 0;
											}
											if(x58 == null) {
												x58 = 0;
											}
											var f2_x6 = x58;
											var f2_y6 = y58;
											var p_x14 = x56;
											var p_y14 = y56;
											var x59 = p_x14 - f1_x6;
											var y59 = p_y14 - f1_y6;
											var x60 = p_x14 - f2_x6;
											var y60 = p_y14 - f2_y6;
											has3 = Math.sqrt(x59 * x59 + y59 * y59) + Math.sqrt(x60 * x60 + y60 * y60) <= view6.width;
											if(view6.shape == 3) {
												has3 = !has3;
											}
										} else if(view6.height > view6.width) {
											var a7 = view6.height / 2;
											var b7 = view6.width / 2;
											var c7 = Math.sqrt(a7 * a7 - b7 * b7);
											var x61 = view6.x + view6.width / 2;
											var y61 = view6.y + view6.height / 2 - c7;
											if(y61 == null) {
												y61 = 0;
											}
											if(x61 == null) {
												x61 = 0;
											}
											var f1_x7 = x61;
											var f1_y7 = y61;
											var x62 = view6.x + view6.width / 2;
											var y62 = view6.y + view6.height / 2 + c7;
											if(y62 == null) {
												y62 = 0;
											}
											if(x62 == null) {
												x62 = 0;
											}
											var f2_x7 = x62;
											var f2_y7 = y62;
											var p_x15 = x56;
											var p_y15 = y56;
											var x63 = p_x15 - f1_x7;
											var y63 = p_y15 - f1_y7;
											var x64 = p_x15 - f2_x7;
											var y64 = p_y15 - f2_y7;
											has3 = Math.sqrt(x63 * x63 + y63 * y63) + Math.sqrt(x64 * x64 + y64 * y64) <= view6.height;
											if(view6.shape == 3) {
												has3 = !has3;
											}
										} else {
											var x65 = x56;
											var y65 = y56;
											if(y65 == null) {
												y65 = 0;
											}
											if(x65 == null) {
												x65 = 0;
											}
											var point1_x3 = x65;
											var point1_y3 = y65;
											var x66 = view6.x + view6.width / 2;
											var y66 = view6.y + view6.height / 2;
											if(y66 == null) {
												y66 = 0;
											}
											if(x66 == null) {
												x66 = 0;
											}
											var point2_x3 = x66;
											var point2_y3 = y66;
											var x67 = point2_x3 - point1_x3;
											var y67 = point2_y3 - point1_y3;
											has3 = Math.sqrt(x67 * x67 + y67 * y67) <= view6.width / 2;
											if(view6.shape == 3) {
												has3 = !has3;
											}
										}
										break;
									case 4:
										has3 = Math.abs(x56 - view6.x - view6.width / 2) / (view6.width / 2) + Math.abs(y56 - view6.y - view6.height / 2) / (view6.height / 2) <= 1;
										break;
									case 5:
										has3 = !(Math.abs(x56 - view6.x - view6.width / 2) / (view6.width / 2) + Math.abs(y56 - view6.y - view6.height / 2) / (view6.height / 2) <= 1);
										break;
									}
									tmp3 = has3;
								}
								if(tmp3) {
									var position14 = (y56 * this1.getUInt16(0) + x56) * 4;
									position14 += vision_ds_Image.OFFSET;
									this1.b[position14] = color >> 24 & 255;
									this1.b[position14 + 1] = color >> 16 & 255;
									this1.b[position14 + 2] = color >> 8 & 255;
									this1.b[position14 + 3] = color & 255;
								}
							} else {
								var position15 = (y56 * this1.getUInt16(0) + x56) * 4;
								position15 += vision_ds_Image.OFFSET;
								this1.b[position15] = color >> 24 & 255;
								this1.b[position15 + 1] = color >> 16 & 255;
								this1.b[position15 + 2] = color >> 8 & 255;
								this1.b[position15 + 3] = color & 255;
							}
						}
					}
				}
			}
		}
	}
};
vision_ds_Image.clone = function(this1) {
	if(this1 == null) {
		haxe_Log.trace("Warning: Cloning a null image",{ fileName : "vision/ds/Image.hx", lineNumber : 1068, className : "vision.ds._Image.Image_Impl_", methodName : "clone"});
	}
	return this1.sub(0,this1.length);
};
vision_ds_Image.mirror = function(this1) {
	var inter = vision_ds_Image.clone(this1);
	if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0)) {
		var _g = 0;
		var _g1 = this1.getUInt16(0);
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			while(_g2 < _g3) {
				var y = _g2++;
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
				if(value == null) {
					value = 0;
				}
				var color = value;
				var x1 = inter.getUInt16(0) - x - 1;
				var position1 = (y * inter.getUInt16(0) + x1) * 4;
				position1 += vision_ds_Image.OFFSET;
				var value1 = inter.b[position1] << 24 | inter.b[position1 + 1] << 16 | inter.b[position1 + 2] << 8 | inter.b[position1 + 3];
				if(value1 == null) {
					value1 = 0;
				}
				var color1 = value1;
				var position2 = (y * this1.getUInt16(0) + x) * 4;
				position2 += vision_ds_Image.OFFSET;
				this1.b[position2] = color1 >> 24 & 255;
				this1.b[position2 + 1] = color1 >> 16 & 255;
				this1.b[position2 + 2] = color1 >> 8 & 255;
				this1.b[position2 + 3] = color1 & 255;
			}
		}
	} else {
		var _g = 0;
		var _g1 = this1.getUInt16(0);
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			while(_g2 < _g3) {
				var y = _g2++;
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g4 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g5 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g6 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g4,_g5,_g6,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
						break;
					case 1:
						has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2 - c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x2 = view.x + view.width / 2 + c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f2_x = x2;
							var f2_y = y2;
							var p_x = x;
							var p_y = y;
							var x3 = p_x - f1_x;
							var y3 = p_y - f1_y;
							var x4 = p_x - f2_x;
							var y4 = p_y - f2_y;
							has = Math.sqrt(x3 * x3 + y3 * y3) + Math.sqrt(x4 * x4 + y4 * y4) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a1 = view.height / 2;
							var b1 = view.width / 2;
							var c1 = Math.sqrt(a1 * a1 - b1 * b1);
							var x5 = view.x + view.width / 2;
							var y5 = view.y + view.height / 2 - c1;
							if(y5 == null) {
								y5 = 0;
							}
							if(x5 == null) {
								x5 = 0;
							}
							var f1_x1 = x5;
							var f1_y1 = y5;
							var x6 = view.x + view.width / 2;
							var y6 = view.y + view.height / 2 + c1;
							if(y6 == null) {
								y6 = 0;
							}
							if(x6 == null) {
								x6 = 0;
							}
							var f2_x1 = x6;
							var f2_y1 = y6;
							var p_x1 = x;
							var p_y1 = y;
							var x7 = p_x1 - f1_x1;
							var y7 = p_y1 - f1_y1;
							var x8 = p_x1 - f2_x1;
							var y8 = p_y1 - f2_y1;
							has = Math.sqrt(x7 * x7 + y7 * y7) + Math.sqrt(x8 * x8 + y8 * y8) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x9 = x;
							var y9 = y;
							if(y9 == null) {
								y9 = 0;
							}
							if(x9 == null) {
								x9 = 0;
							}
							var point1_x = x9;
							var point1_y = y9;
							var x10 = view.x + view.width / 2;
							var y10 = view.y + view.height / 2;
							if(y10 == null) {
								y10 = 0;
							}
							if(x10 == null) {
								x10 = 0;
							}
							var point2_x = x10;
							var point2_y = y10;
							var x11 = point2_x - point1_x;
							var y11 = point2_y - point1_y;
							has = Math.sqrt(x11 * x11 + y11 * y11) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y * this1.getUInt16(0) + x) * 4;
					position += vision_ds_Image.OFFSET;
					var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
					if(value == null) {
						value = 0;
					}
					var color = value;
					var x12 = inter.getUInt16(0) - x - 1;
					var position1 = (y * inter.getUInt16(0) + x12) * 4;
					position1 += vision_ds_Image.OFFSET;
					var value1 = inter.b[position1] << 24 | inter.b[position1 + 1] << 16 | inter.b[position1 + 2] << 8 | inter.b[position1 + 3];
					if(value1 == null) {
						value1 = 0;
					}
					var color1 = value1;
					var position2 = (y * this1.getUInt16(0) + x) * 4;
					position2 += vision_ds_Image.OFFSET;
					this1.b[position2] = color1 >> 24 & 255;
					this1.b[position2 + 1] = color1 >> 16 & 255;
					this1.b[position2 + 2] = color1 >> 8 & 255;
					this1.b[position2 + 3] = color1 & 255;
				}
			}
		}
	}
	return this1;
};
vision_ds_Image.flip = function(this1) {
	var inter = vision_ds_Image.clone(this1);
	if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0)) {
		var _g = 0;
		var _g1 = this1.getUInt16(0);
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			while(_g2 < _g3) {
				var y = _g2++;
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
				if(value == null) {
					value = 0;
				}
				var color = value;
				var position1 = ((Math.ceil((inter.length - vision_ds_Image.OFFSET) / (inter.getUInt16(0) * 4)) - y - 1) * inter.getUInt16(0) + x) * 4;
				position1 += vision_ds_Image.OFFSET;
				var value1 = inter.b[position1] << 24 | inter.b[position1 + 1] << 16 | inter.b[position1 + 2] << 8 | inter.b[position1 + 3];
				if(value1 == null) {
					value1 = 0;
				}
				var color1 = value1;
				var position2 = (y * this1.getUInt16(0) + x) * 4;
				position2 += vision_ds_Image.OFFSET;
				this1.b[position2] = color1 >> 24 & 255;
				this1.b[position2 + 1] = color1 >> 16 & 255;
				this1.b[position2 + 2] = color1 >> 8 & 255;
				this1.b[position2 + 3] = color1 & 255;
			}
		}
	} else {
		var _g = 0;
		var _g1 = this1.getUInt16(0);
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			while(_g2 < _g3) {
				var y = _g2++;
				var v = null;
				var tmp;
				if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g4 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g5 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g6 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var this2 = this1.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g4,_g5,_g6,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
						break;
					case 1:
						has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2 - c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x2 = view.x + view.width / 2 + c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f2_x = x2;
							var f2_y = y2;
							var p_x = x;
							var p_y = y;
							var x3 = p_x - f1_x;
							var y3 = p_y - f1_y;
							var x4 = p_x - f2_x;
							var y4 = p_y - f2_y;
							has = Math.sqrt(x3 * x3 + y3 * y3) + Math.sqrt(x4 * x4 + y4 * y4) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a1 = view.height / 2;
							var b1 = view.width / 2;
							var c1 = Math.sqrt(a1 * a1 - b1 * b1);
							var x5 = view.x + view.width / 2;
							var y5 = view.y + view.height / 2 - c1;
							if(y5 == null) {
								y5 = 0;
							}
							if(x5 == null) {
								x5 = 0;
							}
							var f1_x1 = x5;
							var f1_y1 = y5;
							var x6 = view.x + view.width / 2;
							var y6 = view.y + view.height / 2 + c1;
							if(y6 == null) {
								y6 = 0;
							}
							if(x6 == null) {
								x6 = 0;
							}
							var f2_x1 = x6;
							var f2_y1 = y6;
							var p_x1 = x;
							var p_y1 = y;
							var x7 = p_x1 - f1_x1;
							var y7 = p_y1 - f1_y1;
							var x8 = p_x1 - f2_x1;
							var y8 = p_y1 - f2_y1;
							has = Math.sqrt(x7 * x7 + y7 * y7) + Math.sqrt(x8 * x8 + y8 * y8) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x9 = x;
							var y9 = y;
							if(y9 == null) {
								y9 = 0;
							}
							if(x9 == null) {
								x9 = 0;
							}
							var point1_x = x9;
							var point1_y = y9;
							var x10 = view.x + view.width / 2;
							var y10 = view.y + view.height / 2;
							if(y10 == null) {
								y10 = 0;
							}
							if(x10 == null) {
								x10 = 0;
							}
							var point2_x = x10;
							var point2_y = y10;
							var x11 = point2_x - point1_x;
							var y11 = point2_y - point1_y;
							has = Math.sqrt(x11 * x11 + y11 * y11) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y * this1.getUInt16(0) + x) * 4;
					position += vision_ds_Image.OFFSET;
					var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
					if(value == null) {
						value = 0;
					}
					var color = value;
					var position1 = ((Math.ceil((inter.length - vision_ds_Image.OFFSET) / (inter.getUInt16(0) * 4)) - y - 1) * inter.getUInt16(0) + x) * 4;
					position1 += vision_ds_Image.OFFSET;
					var value1 = inter.b[position1] << 24 | inter.b[position1 + 1] << 16 | inter.b[position1 + 2] << 8 | inter.b[position1 + 3];
					if(value1 == null) {
						value1 = 0;
					}
					var color1 = value1;
					var position2 = (y * this1.getUInt16(0) + x) * 4;
					position2 += vision_ds_Image.OFFSET;
					this1.b[position2] = color1 >> 24 & 255;
					this1.b[position2 + 1] = color1 >> 16 & 255;
					this1.b[position2 + 2] = color1 >> 8 & 255;
					this1.b[position2 + 3] = color1 & 255;
				}
			}
		}
	}
	return this1;
};
vision_ds_Image.stamp = function(this1,X,Y,image) {
	var _g = X;
	var _g1 = X + image.getUInt16(0);
	while(_g < _g1) {
		var x = _g++;
		var _g2 = Y;
		var _g3 = Y + Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4));
		while(_g2 < _g3) {
			var y = _g2++;
			var position = ((y - Y) * image.getUInt16(0) + (x - X)) * 4;
			position += vision_ds_Image.OFFSET;
			var value = image.b[position] << 24 | image.b[position + 1] << 16 | image.b[position + 2] << 8 | image.b[position + 3];
			if(value == null) {
				value = 0;
			}
			var color = value;
			if(x < 0 || x >= this1.getUInt16(0) || y < 0 || y >= Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
				var this_x = x;
				var this_y = y;
				throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
			} else if((color >> 24 & 255) / 255 == 1) {
				if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x1 = x;
					var this_y1 = y;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x1,this_y1)));
				} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
					var v = null;
					var tmp;
					if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
						tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
					} else {
						var has = false;
						var view;
						if(v != null) {
							view = v;
						} else {
							var _g4 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
							var _g5 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
							var _g6 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
							var this2 = this1.b;
							var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
							view = new vision_ds_ImageView(_g4,_g5,_g6,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
						}
						switch(view.shape) {
						case 0:
							has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
							break;
						case 1:
							has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
							break;
						case 2:case 3:
							if(view.width > view.height) {
								var a = view.width / 2;
								var b = view.height / 2;
								var c = Math.sqrt(a * a - b * b);
								var x1 = view.x + view.width / 2 - c;
								var y1 = view.y + view.height / 2;
								if(y1 == null) {
									y1 = 0;
								}
								if(x1 == null) {
									x1 = 0;
								}
								var f1_x = x1;
								var f1_y = y1;
								var x2 = view.x + view.width / 2 + c;
								var y2 = view.y + view.height / 2;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f2_x = x2;
								var f2_y = y2;
								var p_x = x;
								var p_y = y;
								var x3 = p_x - f1_x;
								var y3 = p_y - f1_y;
								var x4 = p_x - f2_x;
								var y4 = p_y - f2_y;
								has = Math.sqrt(x3 * x3 + y3 * y3) + Math.sqrt(x4 * x4 + y4 * y4) <= view.width;
								if(view.shape == 3) {
									has = !has;
								}
							} else if(view.height > view.width) {
								var a1 = view.height / 2;
								var b1 = view.width / 2;
								var c1 = Math.sqrt(a1 * a1 - b1 * b1);
								var x5 = view.x + view.width / 2;
								var y5 = view.y + view.height / 2 - c1;
								if(y5 == null) {
									y5 = 0;
								}
								if(x5 == null) {
									x5 = 0;
								}
								var f1_x1 = x5;
								var f1_y1 = y5;
								var x6 = view.x + view.width / 2;
								var y6 = view.y + view.height / 2 + c1;
								if(y6 == null) {
									y6 = 0;
								}
								if(x6 == null) {
									x6 = 0;
								}
								var f2_x1 = x6;
								var f2_y1 = y6;
								var p_x1 = x;
								var p_y1 = y;
								var x7 = p_x1 - f1_x1;
								var y7 = p_y1 - f1_y1;
								var x8 = p_x1 - f2_x1;
								var y8 = p_y1 - f2_y1;
								has = Math.sqrt(x7 * x7 + y7 * y7) + Math.sqrt(x8 * x8 + y8 * y8) <= view.height;
								if(view.shape == 3) {
									has = !has;
								}
							} else {
								var x9 = x;
								var y9 = y;
								if(y9 == null) {
									y9 = 0;
								}
								if(x9 == null) {
									x9 = 0;
								}
								var point1_x = x9;
								var point1_y = y9;
								var x10 = view.x + view.width / 2;
								var y10 = view.y + view.height / 2;
								if(y10 == null) {
									y10 = 0;
								}
								if(x10 == null) {
									x10 = 0;
								}
								var point2_x = x10;
								var point2_y = y10;
								var x11 = point2_x - point1_x;
								var y11 = point2_y - point1_y;
								has = Math.sqrt(x11 * x11 + y11 * y11) <= view.width / 2;
								if(view.shape == 3) {
									has = !has;
								}
							}
							break;
						case 4:
							has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
							break;
						case 5:
							has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
							break;
						}
						tmp = has;
					}
					if(tmp) {
						var position1 = (y * this1.getUInt16(0) + x) * 4;
						position1 += vision_ds_Image.OFFSET;
						this1.b[position1] = color >> 24 & 255;
						this1.b[position1 + 1] = color >> 16 & 255;
						this1.b[position1 + 2] = color >> 8 & 255;
						this1.b[position1 + 3] = color & 255;
					}
				} else {
					var position2 = (y * this1.getUInt16(0) + x) * 4;
					position2 += vision_ds_Image.OFFSET;
					this1.b[position2] = color >> 24 & 255;
					this1.b[position2 + 1] = color >> 16 & 255;
					this1.b[position2 + 2] = color >> 8 & 255;
					this1.b[position2 + 3] = color & 255;
				}
			} else {
				if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x2 = x;
					var this_y2 = y;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x2,this_y2)));
				}
				var position3 = (y * this1.getUInt16(0) + x) * 4;
				position3 += vision_ds_Image.OFFSET;
				var value1 = this1.b[position3] << 24 | this1.b[position3 + 1] << 16 | this1.b[position3 + 2] << 8 | this1.b[position3 + 3];
				if(value1 == null) {
					value1 = 0;
				}
				var oldColor = value1;
				var Red = (color >> 16 & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor >> 16 & 255) / 255 * (1 - (color >> 24 & 255) / 255);
				var Green = (color >> 8 & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor >> 8 & 255) / 255 * (1 - (color >> 24 & 255) / 255);
				var Blue = (color & 255) / 255 * ((color >> 24 & 255) / 255) + (oldColor & 255) / 255 * (1 - (color >> 24 & 255) / 255);
				var Alpha = (oldColor >> 24 & 255) / 255 + (1 - (oldColor >> 24 & 255) / 255) * ((color >> 24 & 255) / 255);
				if(Alpha == null) {
					Alpha = 1;
				}
				var color1 = 0;
				var Alpha1 = Alpha;
				if(Alpha1 == null) {
					Alpha1 = 1;
				}
				var value2 = Math.round(Red * 255);
				color1 &= -16711681;
				color1 |= (value2 > 255 ? 255 : value2 < 0 ? 0 : value2) << 16;
				var value3 = Math.round(Green * 255);
				color1 &= -65281;
				color1 |= (value3 > 255 ? 255 : value3 < 0 ? 0 : value3) << 8;
				var value4 = Math.round(Blue * 255);
				color1 &= -256;
				color1 |= value4 > 255 ? 255 : value4 < 0 ? 0 : value4;
				var value5 = Math.round(Alpha1 * 255);
				color1 &= 16777215;
				color1 |= (value5 > 255 ? 255 : value5 < 0 ? 0 : value5) << 24;
				var newColor = color1;
				if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x3 = x;
					var this_y3 = y;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x3,this_y3)));
				} else if(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
					var v1 = null;
					var tmp1;
					if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v1 == null) {
						tmp1 = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
					} else {
						var has1 = false;
						var view2;
						if(v1 != null) {
							view2 = v1;
						} else {
							var _g7 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
							var _g8 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
							var _g9 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
							var this3 = this1.b;
							var view3 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
							view2 = new vision_ds_ImageView(_g7,_g8,_g9,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this3[view3]);
						}
						switch(view2.shape) {
						case 0:
							has1 = x < view2.x + view2.width && y < view2.y + view2.height && x >= view2.x && y >= view2.y;
							break;
						case 1:
							has1 = !(x < view2.x + view2.width && y < view2.y + view2.height && x >= view2.x && y >= view2.y);
							break;
						case 2:case 3:
							if(view2.width > view2.height) {
								var a2 = view2.width / 2;
								var b2 = view2.height / 2;
								var c2 = Math.sqrt(a2 * a2 - b2 * b2);
								var x12 = view2.x + view2.width / 2 - c2;
								var y12 = view2.y + view2.height / 2;
								if(y12 == null) {
									y12 = 0;
								}
								if(x12 == null) {
									x12 = 0;
								}
								var f1_x2 = x12;
								var f1_y2 = y12;
								var x13 = view2.x + view2.width / 2 + c2;
								var y13 = view2.y + view2.height / 2;
								if(y13 == null) {
									y13 = 0;
								}
								if(x13 == null) {
									x13 = 0;
								}
								var f2_x2 = x13;
								var f2_y2 = y13;
								var p_x2 = x;
								var p_y2 = y;
								var x14 = p_x2 - f1_x2;
								var y14 = p_y2 - f1_y2;
								var x15 = p_x2 - f2_x2;
								var y15 = p_y2 - f2_y2;
								has1 = Math.sqrt(x14 * x14 + y14 * y14) + Math.sqrt(x15 * x15 + y15 * y15) <= view2.width;
								if(view2.shape == 3) {
									has1 = !has1;
								}
							} else if(view2.height > view2.width) {
								var a3 = view2.height / 2;
								var b3 = view2.width / 2;
								var c3 = Math.sqrt(a3 * a3 - b3 * b3);
								var x16 = view2.x + view2.width / 2;
								var y16 = view2.y + view2.height / 2 - c3;
								if(y16 == null) {
									y16 = 0;
								}
								if(x16 == null) {
									x16 = 0;
								}
								var f1_x3 = x16;
								var f1_y3 = y16;
								var x17 = view2.x + view2.width / 2;
								var y17 = view2.y + view2.height / 2 + c3;
								if(y17 == null) {
									y17 = 0;
								}
								if(x17 == null) {
									x17 = 0;
								}
								var f2_x3 = x17;
								var f2_y3 = y17;
								var p_x3 = x;
								var p_y3 = y;
								var x18 = p_x3 - f1_x3;
								var y18 = p_y3 - f1_y3;
								var x19 = p_x3 - f2_x3;
								var y19 = p_y3 - f2_y3;
								has1 = Math.sqrt(x18 * x18 + y18 * y18) + Math.sqrt(x19 * x19 + y19 * y19) <= view2.height;
								if(view2.shape == 3) {
									has1 = !has1;
								}
							} else {
								var x20 = x;
								var y20 = y;
								if(y20 == null) {
									y20 = 0;
								}
								if(x20 == null) {
									x20 = 0;
								}
								var point1_x1 = x20;
								var point1_y1 = y20;
								var x21 = view2.x + view2.width / 2;
								var y21 = view2.y + view2.height / 2;
								if(y21 == null) {
									y21 = 0;
								}
								if(x21 == null) {
									x21 = 0;
								}
								var point2_x1 = x21;
								var point2_y1 = y21;
								var x22 = point2_x1 - point1_x1;
								var y22 = point2_y1 - point1_y1;
								has1 = Math.sqrt(x22 * x22 + y22 * y22) <= view2.width / 2;
								if(view2.shape == 3) {
									has1 = !has1;
								}
							}
							break;
						case 4:
							has1 = Math.abs(x - view2.x - view2.width / 2) / (view2.width / 2) + Math.abs(y - view2.y - view2.height / 2) / (view2.height / 2) <= 1;
							break;
						case 5:
							has1 = !(Math.abs(x - view2.x - view2.width / 2) / (view2.width / 2) + Math.abs(y - view2.y - view2.height / 2) / (view2.height / 2) <= 1);
							break;
						}
						tmp1 = has1;
					}
					if(tmp1) {
						var position4 = (y * this1.getUInt16(0) + x) * 4;
						position4 += vision_ds_Image.OFFSET;
						this1.b[position4] = newColor >> 24 & 255;
						this1.b[position4 + 1] = newColor >> 16 & 255;
						this1.b[position4 + 2] = newColor >> 8 & 255;
						this1.b[position4 + 3] = newColor & 255;
					}
				} else {
					var position5 = (y * this1.getUInt16(0) + x) * 4;
					position5 += vision_ds_Image.OFFSET;
					this1.b[position5] = newColor >> 24 & 255;
					this1.b[position5 + 1] = newColor >> 16 & 255;
					this1.b[position5 + 2] = newColor >> 8 & 255;
					this1.b[position5 + 3] = newColor & 255;
				}
			}
		}
	}
	return this1;
};
vision_ds_Image.resize = function(this1,newWidth,newHeight,algorithm) {
	if(newHeight == null) {
		newHeight = -1;
	}
	if(newWidth == null) {
		newWidth = -1;
	}
	if(newWidth == -1 && newHeight == -1) {
		return this1;
	}
	if(newWidth == -1) {
		newWidth = newHeight / Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) * this1.getUInt16(0) | 0;
	} else if(newHeight == -1) {
		newHeight = newWidth / this1.getUInt16(0) * Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) | 0;
	}
	haxe_Log.trace(newWidth,{ fileName : "vision/ds/Image.hx", lineNumber : 1128, className : "vision.ds._Image.Image_Impl_", methodName : "resize", customParams : [newHeight]});
	if(algorithm == null) {
		algorithm = vision_tools_ImageTools.defaultResizeAlgorithm;
	}
	switch(algorithm) {
	case 0:
		var length = newWidth * newHeight * 4 + vision_ds_Image.OFFSET;
		var this2 = new haxe_io_Bytes(new ArrayBuffer(length));
		this2.fill(0,length,0);
		var this3 = this2;
		this3.setUInt16(0,newWidth);
		this3.setUInt16(vision_ds_Image.WIDTH_BYTES,0);
		this3.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP,0);
		this3.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES,0);
		this3.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP,0);
		this3.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] = 0;
		var i = vision_ds_Image.OFFSET;
		while(i < this3.length) {
			this3.b[i] = 0;
			this3.b[i + 1] = 0;
			this3.b[i + 2] = 0;
			this3.b[i + 3] = 0;
			i += 4;
		}
		var image = this3;
		var xMultiplier = this1.getUInt16(0) / image.getUInt16(0);
		var yMultiplier = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) / Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4));
		var _g = 0;
		var _g1 = image.getUInt16(0);
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4));
			while(_g2 < _g3) {
				var y = _g2++;
				var position = (y * image.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				var value = image.b[position] << 24 | image.b[position + 1] << 16 | image.b[position + 2] << 8 | image.b[position + 3];
				if(value == null) {
					value = 0;
				}
				var color = value;
				var x1 = Math.floor(x * xMultiplier);
				var y1 = Math.floor(y * yMultiplier);
				if(!(x1 >= 0 && y1 >= 0 && x1 < this1.getUInt16(0) && y1 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x = x1;
					var this_y = y1;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
				}
				var position1 = (y1 * this1.getUInt16(0) + x1) * 4;
				position1 += vision_ds_Image.OFFSET;
				var value1 = this1.b[position1] << 24 | this1.b[position1 + 1] << 16 | this1.b[position1 + 2] << 8 | this1.b[position1 + 3];
				if(value1 == null) {
					value1 = 0;
				}
				var color1 = value1;
				if(!(x >= 0 && y >= 0 && x < image.getUInt16(0) && y < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)))) {
					var this_x1 = x;
					var this_y1 = y;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(image,new vision_ds_Point2D(this_x1,this_y1)));
				} else if(image.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || image.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
					var v = null;
					var tmp;
					if(!(image.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || image.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
						tmp = x >= 0 && y >= 0 && x < image.getUInt16(0) && y < Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4));
					} else {
						var has = false;
						var view;
						if(v != null) {
							view = v;
						} else {
							var _g4 = image.getUInt16(vision_ds_Image.WIDTH_BYTES);
							var _g5 = image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
							var _g6 = image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
							var image1 = image.b;
							var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
							view = new vision_ds_ImageView(_g4,_g5,_g6,image.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),image1[view1]);
						}
						switch(view.shape) {
						case 0:
							has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
							break;
						case 1:
							has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
							break;
						case 2:case 3:
							if(view.width > view.height) {
								var a = view.width / 2;
								var b = view.height / 2;
								var c = Math.sqrt(a * a - b * b);
								var x2 = view.x + view.width / 2 - c;
								var y2 = view.y + view.height / 2;
								if(y2 == null) {
									y2 = 0;
								}
								if(x2 == null) {
									x2 = 0;
								}
								var f1_x = x2;
								var f1_y = y2;
								var x3 = view.x + view.width / 2 + c;
								var y3 = view.y + view.height / 2;
								if(y3 == null) {
									y3 = 0;
								}
								if(x3 == null) {
									x3 = 0;
								}
								var f2_x = x3;
								var f2_y = y3;
								var p_x = x;
								var p_y = y;
								var x4 = p_x - f1_x;
								var y4 = p_y - f1_y;
								var x5 = p_x - f2_x;
								var y5 = p_y - f2_y;
								has = Math.sqrt(x4 * x4 + y4 * y4) + Math.sqrt(x5 * x5 + y5 * y5) <= view.width;
								if(view.shape == 3) {
									has = !has;
								}
							} else if(view.height > view.width) {
								var a1 = view.height / 2;
								var b1 = view.width / 2;
								var c1 = Math.sqrt(a1 * a1 - b1 * b1);
								var x6 = view.x + view.width / 2;
								var y6 = view.y + view.height / 2 - c1;
								if(y6 == null) {
									y6 = 0;
								}
								if(x6 == null) {
									x6 = 0;
								}
								var f1_x1 = x6;
								var f1_y1 = y6;
								var x7 = view.x + view.width / 2;
								var y7 = view.y + view.height / 2 + c1;
								if(y7 == null) {
									y7 = 0;
								}
								if(x7 == null) {
									x7 = 0;
								}
								var f2_x1 = x7;
								var f2_y1 = y7;
								var p_x1 = x;
								var p_y1 = y;
								var x8 = p_x1 - f1_x1;
								var y8 = p_y1 - f1_y1;
								var x9 = p_x1 - f2_x1;
								var y9 = p_y1 - f2_y1;
								has = Math.sqrt(x8 * x8 + y8 * y8) + Math.sqrt(x9 * x9 + y9 * y9) <= view.height;
								if(view.shape == 3) {
									has = !has;
								}
							} else {
								var x10 = x;
								var y10 = y;
								if(y10 == null) {
									y10 = 0;
								}
								if(x10 == null) {
									x10 = 0;
								}
								var point1_x = x10;
								var point1_y = y10;
								var x11 = view.x + view.width / 2;
								var y11 = view.y + view.height / 2;
								if(y11 == null) {
									y11 = 0;
								}
								if(x11 == null) {
									x11 = 0;
								}
								var point2_x = x11;
								var point2_y = y11;
								var x12 = point2_x - point1_x;
								var y12 = point2_y - point1_y;
								has = Math.sqrt(x12 * x12 + y12 * y12) <= view.width / 2;
								if(view.shape == 3) {
									has = !has;
								}
							}
							break;
						case 4:
							has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
							break;
						case 5:
							has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
							break;
						}
						tmp = has;
					}
					if(tmp) {
						var position2 = (y * image.getUInt16(0) + x) * 4;
						position2 += vision_ds_Image.OFFSET;
						image.b[position2] = color1 >> 24 & 255;
						image.b[position2 + 1] = color1 >> 16 & 255;
						image.b[position2 + 2] = color1 >> 8 & 255;
						image.b[position2 + 3] = color1 & 255;
					}
				} else {
					var position3 = (y * image.getUInt16(0) + x) * 4;
					position3 += vision_ds_Image.OFFSET;
					image.b[position3] = color1 >> 24 & 255;
					image.b[position3 + 1] = color1 >> 16 & 255;
					image.b[position3 + 2] = color1 >> 8 & 255;
					image.b[position3 + 3] = color1 & 255;
				}
			}
		}
		this1 = image;
		break;
	case 1:
		this1 = vision_algorithms_BilinearInterpolation.interpolate(this1,newWidth,newHeight);
		break;
	case 2:
		throw haxe_Exception.thrown(new vision_exceptions_Unimplemented("Bicubic Interpolation"));
	}
	return this1;
};
vision_ds_Image.rotate = function(this1,angle,degrees,expandImageBounds) {
	if(expandImageBounds == null) {
		expandImageBounds = true;
	}
	if(degrees == null) {
		degrees = true;
	}
	var x = this1.getUInt16(0) / 2;
	var y = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) / 2;
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	var center_x = x;
	var center_y = y;
	var radians = degrees ? angle * Math.PI / 180 : angle;
	var sinTheta = Math.sin(angle);
	var cosTheta = Math.cos(angle);
	var newWidth = expandImageBounds ? Math.ceil(Math.abs(this1.getUInt16(0) * cosTheta) + Math.abs(Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) * sinTheta)) : this1.getUInt16(0);
	var newHeight = expandImageBounds ? Math.ceil(Math.abs(this1.getUInt16(0) * sinTheta) + Math.abs(Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) * cosTheta)) : Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
	var length = newWidth * newHeight * 4 + vision_ds_Image.OFFSET;
	var this2 = new haxe_io_Bytes(new ArrayBuffer(length));
	this2.fill(0,length,0);
	var this3 = this2;
	this3.setUInt16(0,newWidth);
	this3.setUInt16(vision_ds_Image.WIDTH_BYTES,0);
	this3.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP,0);
	this3.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES,0);
	this3.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP,0);
	this3.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] = 0;
	var i = vision_ds_Image.OFFSET;
	while(i < this3.length) {
		this3.b[i] = 0;
		this3.b[i + 1] = 0;
		this3.b[i + 2] = 0;
		this3.b[i + 3] = 0;
		i += 4;
	}
	var rotatedImage = this3;
	var centerX = newWidth / 2;
	var centerY = newHeight / 2;
	var originalCenterX = this1.getUInt16(0) / 2;
	var originalCenterY = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) / 2;
	var _g = 0;
	var _g1 = rotatedImage.getUInt16(0);
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = Math.ceil((rotatedImage.length - vision_ds_Image.OFFSET) / (rotatedImage.getUInt16(0) * 4));
		while(_g2 < _g3) {
			var y = _g2++;
			var rotatedX = cosTheta * (x - centerX) + sinTheta * (y - centerY) + originalCenterX;
			var rotatedY = -sinTheta * (x - centerX) + cosTheta * (y - centerY) + originalCenterY;
			if(rotatedX >= 0 && rotatedX < this1.getUInt16(0) && rotatedY >= 0 && rotatedY < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
				var x1 = rotatedX;
				var y1 = rotatedY;
				var tmp;
				var x2 = Math.ceil(x1);
				var y2 = Math.ceil(y1);
				if(x2 >= 0 && y2 >= 0 && x2 < this1.getUInt16(0) && y2 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4))) {
					var x3 = Math.floor(x1);
					var y3 = Math.floor(y1);
					tmp = !(x3 >= 0 && y3 >= 0 && x3 < this1.getUInt16(0) && y3 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)));
				} else {
					tmp = true;
				}
				if(tmp) {
					x1 = vision_tools_MathTools.boundFloat(x1,0,this1.getUInt16(0) - 1);
					y1 = vision_tools_MathTools.boundFloat(y1,0,Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1);
				}
				var yFraction = y1 - (y1 | 0);
				var xFraction = x1 - (x1 | 0);
				var x4 = 1 - yFraction;
				var x5 = x1 | 0;
				var y4 = y1 | 0;
				if(!(x5 >= 0 && y4 >= 0 && x5 < this1.getUInt16(0) && y4 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x = x5;
					var this_y = y4;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
				}
				var position = (y4 * this1.getUInt16(0) + x5) * 4;
				position += vision_ds_Image.OFFSET;
				var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
				if(value == null) {
					value = 0;
				}
				var x6 = (1 - xFraction) * (value >> 16 & 255);
				var ma = this1.getUInt16(0) - 1;
				var values = [(x1 | 0) + 1,0];
				var max = values[0];
				var _g4 = 0;
				var _g5 = values.length;
				while(_g4 < _g5) {
					var i = _g4++;
					if(values[i] > max) {
						max = values[i];
					}
				}
				var values1 = [max,ma];
				var min = values1[0];
				var _g6 = 0;
				var _g7 = values1.length;
				while(_g6 < _g7) {
					var i1 = _g6++;
					if(values1[i1] < min) {
						min = values1[i1];
					}
				}
				var x7 = min;
				var ma1 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
				var values2 = [y1 | 0,0];
				var max1 = values2[0];
				var _g8 = 0;
				var _g9 = values2.length;
				while(_g8 < _g9) {
					var i2 = _g8++;
					if(values2[i2] > max1) {
						max1 = values2[i2];
					}
				}
				var values3 = [max1,ma1];
				var min1 = values3[0];
				var _g10 = 0;
				var _g11 = values3.length;
				while(_g10 < _g11) {
					var i3 = _g10++;
					if(values3[i3] < min1) {
						min1 = values3[i3];
					}
				}
				var y5 = min1;
				if(!(x7 >= 0 && y5 >= 0 && x7 < this1.getUInt16(0) && y5 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x1 = x7;
					var this_y1 = y5;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x1,this_y1)));
				}
				var position1 = (y5 * this1.getUInt16(0) + x7) * 4;
				position1 += vision_ds_Image.OFFSET;
				var value1 = this1.b[position1] << 24 | this1.b[position1 + 1] << 16 | this1.b[position1 + 2] << 8 | this1.b[position1 + 3];
				if(value1 == null) {
					value1 = 0;
				}
				var x8 = x4 * (x6 + xFraction * (value1 >> 16 & 255));
				var x9 = 1 - xFraction;
				var ma2 = this1.getUInt16(0) - 1;
				var values4 = [x1 | 0,0];
				var max2 = values4[0];
				var _g12 = 0;
				var _g13 = values4.length;
				while(_g12 < _g13) {
					var i4 = _g12++;
					if(values4[i4] > max2) {
						max2 = values4[i4];
					}
				}
				var values5 = [max2,ma2];
				var min2 = values5[0];
				var _g14 = 0;
				var _g15 = values5.length;
				while(_g14 < _g15) {
					var i5 = _g14++;
					if(values5[i5] < min2) {
						min2 = values5[i5];
					}
				}
				var x10 = min2;
				var ma3 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
				var values6 = [(y1 | 0) + 1,0];
				var max3 = values6[0];
				var _g16 = 0;
				var _g17 = values6.length;
				while(_g16 < _g17) {
					var i6 = _g16++;
					if(values6[i6] > max3) {
						max3 = values6[i6];
					}
				}
				var values7 = [max3,ma3];
				var min3 = values7[0];
				var _g18 = 0;
				var _g19 = values7.length;
				while(_g18 < _g19) {
					var i7 = _g18++;
					if(values7[i7] < min3) {
						min3 = values7[i7];
					}
				}
				var y6 = min3;
				if(!(x10 >= 0 && y6 >= 0 && x10 < this1.getUInt16(0) && y6 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x2 = x10;
					var this_y2 = y6;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x2,this_y2)));
				}
				var position2 = (y6 * this1.getUInt16(0) + x10) * 4;
				position2 += vision_ds_Image.OFFSET;
				var value2 = this1.b[position2] << 24 | this1.b[position2 + 1] << 16 | this1.b[position2 + 2] << 8 | this1.b[position2 + 3];
				if(value2 == null) {
					value2 = 0;
				}
				var x11 = x9 * (value2 >> 16 & 255);
				var ma4 = this1.getUInt16(0) - 1;
				var values8 = [(x1 | 0) + 1,0];
				var max4 = values8[0];
				var _g20 = 0;
				var _g21 = values8.length;
				while(_g20 < _g21) {
					var i8 = _g20++;
					if(values8[i8] > max4) {
						max4 = values8[i8];
					}
				}
				var values9 = [max4,ma4];
				var min4 = values9[0];
				var _g22 = 0;
				var _g23 = values9.length;
				while(_g22 < _g23) {
					var i9 = _g22++;
					if(values9[i9] < min4) {
						min4 = values9[i9];
					}
				}
				var x12 = min4;
				var ma5 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
				var values10 = [(y1 | 0) + 1,0];
				var max5 = values10[0];
				var _g24 = 0;
				var _g25 = values10.length;
				while(_g24 < _g25) {
					var i10 = _g24++;
					if(values10[i10] > max5) {
						max5 = values10[i10];
					}
				}
				var values11 = [max5,ma5];
				var min5 = values11[0];
				var _g26 = 0;
				var _g27 = values11.length;
				while(_g26 < _g27) {
					var i11 = _g26++;
					if(values11[i11] < min5) {
						min5 = values11[i11];
					}
				}
				var y7 = min5;
				if(!(x12 >= 0 && y7 >= 0 && x12 < this1.getUInt16(0) && y7 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x3 = x12;
					var this_y3 = y7;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x3,this_y3)));
				}
				var position3 = (y7 * this1.getUInt16(0) + x12) * 4;
				position3 += vision_ds_Image.OFFSET;
				var value3 = this1.b[position3] << 24 | this1.b[position3 + 1] << 16 | this1.b[position3 + 2] << 8 | this1.b[position3 + 3];
				if(value3 == null) {
					value3 = 0;
				}
				var red = x8 + yFraction * (x11 + xFraction * (value3 >> 16 & 255)) | 0;
				var x13 = 1 - yFraction;
				var x14 = x1 | 0;
				var y8 = y1 | 0;
				if(!(x14 >= 0 && y8 >= 0 && x14 < this1.getUInt16(0) && y8 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x4 = x14;
					var this_y4 = y8;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x4,this_y4)));
				}
				var position4 = (y8 * this1.getUInt16(0) + x14) * 4;
				position4 += vision_ds_Image.OFFSET;
				var value4 = this1.b[position4] << 24 | this1.b[position4 + 1] << 16 | this1.b[position4 + 2] << 8 | this1.b[position4 + 3];
				if(value4 == null) {
					value4 = 0;
				}
				var x15 = (1 - xFraction) * (value4 >> 8 & 255);
				var ma6 = this1.getUInt16(0) - 1;
				var values12 = [(x1 | 0) + 1,0];
				var max6 = values12[0];
				var _g28 = 0;
				var _g29 = values12.length;
				while(_g28 < _g29) {
					var i12 = _g28++;
					if(values12[i12] > max6) {
						max6 = values12[i12];
					}
				}
				var values13 = [max6,ma6];
				var min6 = values13[0];
				var _g30 = 0;
				var _g31 = values13.length;
				while(_g30 < _g31) {
					var i13 = _g30++;
					if(values13[i13] < min6) {
						min6 = values13[i13];
					}
				}
				var x16 = min6;
				var ma7 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
				var values14 = [y1 | 0,0];
				var max7 = values14[0];
				var _g32 = 0;
				var _g33 = values14.length;
				while(_g32 < _g33) {
					var i14 = _g32++;
					if(values14[i14] > max7) {
						max7 = values14[i14];
					}
				}
				var values15 = [max7,ma7];
				var min7 = values15[0];
				var _g34 = 0;
				var _g35 = values15.length;
				while(_g34 < _g35) {
					var i15 = _g34++;
					if(values15[i15] < min7) {
						min7 = values15[i15];
					}
				}
				var y9 = min7;
				if(!(x16 >= 0 && y9 >= 0 && x16 < this1.getUInt16(0) && y9 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x5 = x16;
					var this_y5 = y9;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x5,this_y5)));
				}
				var position5 = (y9 * this1.getUInt16(0) + x16) * 4;
				position5 += vision_ds_Image.OFFSET;
				var value5 = this1.b[position5] << 24 | this1.b[position5 + 1] << 16 | this1.b[position5 + 2] << 8 | this1.b[position5 + 3];
				if(value5 == null) {
					value5 = 0;
				}
				var x17 = x13 * (x15 + xFraction * (value5 >> 8 & 255));
				var x18 = 1 - xFraction;
				var ma8 = this1.getUInt16(0) - 1;
				var values16 = [x1 | 0,0];
				var max8 = values16[0];
				var _g36 = 0;
				var _g37 = values16.length;
				while(_g36 < _g37) {
					var i16 = _g36++;
					if(values16[i16] > max8) {
						max8 = values16[i16];
					}
				}
				var values17 = [max8,ma8];
				var min8 = values17[0];
				var _g38 = 0;
				var _g39 = values17.length;
				while(_g38 < _g39) {
					var i17 = _g38++;
					if(values17[i17] < min8) {
						min8 = values17[i17];
					}
				}
				var x19 = min8;
				var ma9 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
				var values18 = [(y1 | 0) + 1,0];
				var max9 = values18[0];
				var _g40 = 0;
				var _g41 = values18.length;
				while(_g40 < _g41) {
					var i18 = _g40++;
					if(values18[i18] > max9) {
						max9 = values18[i18];
					}
				}
				var values19 = [max9,ma9];
				var min9 = values19[0];
				var _g42 = 0;
				var _g43 = values19.length;
				while(_g42 < _g43) {
					var i19 = _g42++;
					if(values19[i19] < min9) {
						min9 = values19[i19];
					}
				}
				var y10 = min9;
				if(!(x19 >= 0 && y10 >= 0 && x19 < this1.getUInt16(0) && y10 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x6 = x19;
					var this_y6 = y10;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x6,this_y6)));
				}
				var position6 = (y10 * this1.getUInt16(0) + x19) * 4;
				position6 += vision_ds_Image.OFFSET;
				var value6 = this1.b[position6] << 24 | this1.b[position6 + 1] << 16 | this1.b[position6 + 2] << 8 | this1.b[position6 + 3];
				if(value6 == null) {
					value6 = 0;
				}
				var x20 = x18 * (value6 >> 8 & 255);
				var ma10 = this1.getUInt16(0) - 1;
				var values20 = [(x1 | 0) + 1,0];
				var max10 = values20[0];
				var _g44 = 0;
				var _g45 = values20.length;
				while(_g44 < _g45) {
					var i20 = _g44++;
					if(values20[i20] > max10) {
						max10 = values20[i20];
					}
				}
				var values21 = [max10,ma10];
				var min10 = values21[0];
				var _g46 = 0;
				var _g47 = values21.length;
				while(_g46 < _g47) {
					var i21 = _g46++;
					if(values21[i21] < min10) {
						min10 = values21[i21];
					}
				}
				var x21 = min10;
				var ma11 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
				var values22 = [(y1 | 0) + 1,0];
				var max11 = values22[0];
				var _g48 = 0;
				var _g49 = values22.length;
				while(_g48 < _g49) {
					var i22 = _g48++;
					if(values22[i22] > max11) {
						max11 = values22[i22];
					}
				}
				var values23 = [max11,ma11];
				var min11 = values23[0];
				var _g50 = 0;
				var _g51 = values23.length;
				while(_g50 < _g51) {
					var i23 = _g50++;
					if(values23[i23] < min11) {
						min11 = values23[i23];
					}
				}
				var y11 = min11;
				if(!(x21 >= 0 && y11 >= 0 && x21 < this1.getUInt16(0) && y11 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x7 = x21;
					var this_y7 = y11;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x7,this_y7)));
				}
				var position7 = (y11 * this1.getUInt16(0) + x21) * 4;
				position7 += vision_ds_Image.OFFSET;
				var value7 = this1.b[position7] << 24 | this1.b[position7 + 1] << 16 | this1.b[position7 + 2] << 8 | this1.b[position7 + 3];
				if(value7 == null) {
					value7 = 0;
				}
				var green = x17 + yFraction * (x20 + xFraction * (value7 >> 8 & 255)) | 0;
				var x22 = 1 - yFraction;
				var x23 = x1 | 0;
				var y12 = y1 | 0;
				if(!(x23 >= 0 && y12 >= 0 && x23 < this1.getUInt16(0) && y12 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x8 = x23;
					var this_y8 = y12;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x8,this_y8)));
				}
				var position8 = (y12 * this1.getUInt16(0) + x23) * 4;
				position8 += vision_ds_Image.OFFSET;
				var value8 = this1.b[position8] << 24 | this1.b[position8 + 1] << 16 | this1.b[position8 + 2] << 8 | this1.b[position8 + 3];
				if(value8 == null) {
					value8 = 0;
				}
				var x24 = (1 - xFraction) * (value8 & 255);
				var ma12 = this1.getUInt16(0) - 1;
				var values24 = [(x1 | 0) + 1,0];
				var max12 = values24[0];
				var _g52 = 0;
				var _g53 = values24.length;
				while(_g52 < _g53) {
					var i24 = _g52++;
					if(values24[i24] > max12) {
						max12 = values24[i24];
					}
				}
				var values25 = [max12,ma12];
				var min12 = values25[0];
				var _g54 = 0;
				var _g55 = values25.length;
				while(_g54 < _g55) {
					var i25 = _g54++;
					if(values25[i25] < min12) {
						min12 = values25[i25];
					}
				}
				var x25 = min12;
				var ma13 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
				var values26 = [y1 | 0,0];
				var max13 = values26[0];
				var _g56 = 0;
				var _g57 = values26.length;
				while(_g56 < _g57) {
					var i26 = _g56++;
					if(values26[i26] > max13) {
						max13 = values26[i26];
					}
				}
				var values27 = [max13,ma13];
				var min13 = values27[0];
				var _g58 = 0;
				var _g59 = values27.length;
				while(_g58 < _g59) {
					var i27 = _g58++;
					if(values27[i27] < min13) {
						min13 = values27[i27];
					}
				}
				var y13 = min13;
				if(!(x25 >= 0 && y13 >= 0 && x25 < this1.getUInt16(0) && y13 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x9 = x25;
					var this_y9 = y13;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x9,this_y9)));
				}
				var position9 = (y13 * this1.getUInt16(0) + x25) * 4;
				position9 += vision_ds_Image.OFFSET;
				var value9 = this1.b[position9] << 24 | this1.b[position9 + 1] << 16 | this1.b[position9 + 2] << 8 | this1.b[position9 + 3];
				if(value9 == null) {
					value9 = 0;
				}
				var x26 = x22 * (x24 + xFraction * (value9 & 255));
				var x27 = 1 - xFraction;
				var ma14 = this1.getUInt16(0) - 1;
				var values28 = [x1 | 0,0];
				var max14 = values28[0];
				var _g60 = 0;
				var _g61 = values28.length;
				while(_g60 < _g61) {
					var i28 = _g60++;
					if(values28[i28] > max14) {
						max14 = values28[i28];
					}
				}
				var values29 = [max14,ma14];
				var min14 = values29[0];
				var _g62 = 0;
				var _g63 = values29.length;
				while(_g62 < _g63) {
					var i29 = _g62++;
					if(values29[i29] < min14) {
						min14 = values29[i29];
					}
				}
				var x28 = min14;
				var ma15 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
				var values30 = [(y1 | 0) + 1,0];
				var max15 = values30[0];
				var _g64 = 0;
				var _g65 = values30.length;
				while(_g64 < _g65) {
					var i30 = _g64++;
					if(values30[i30] > max15) {
						max15 = values30[i30];
					}
				}
				var values31 = [max15,ma15];
				var min15 = values31[0];
				var _g66 = 0;
				var _g67 = values31.length;
				while(_g66 < _g67) {
					var i31 = _g66++;
					if(values31[i31] < min15) {
						min15 = values31[i31];
					}
				}
				var y14 = min15;
				if(!(x28 >= 0 && y14 >= 0 && x28 < this1.getUInt16(0) && y14 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x10 = x28;
					var this_y10 = y14;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x10,this_y10)));
				}
				var position10 = (y14 * this1.getUInt16(0) + x28) * 4;
				position10 += vision_ds_Image.OFFSET;
				var value10 = this1.b[position10] << 24 | this1.b[position10 + 1] << 16 | this1.b[position10 + 2] << 8 | this1.b[position10 + 3];
				if(value10 == null) {
					value10 = 0;
				}
				var x29 = x27 * (value10 & 255);
				var ma16 = this1.getUInt16(0) - 1;
				var values32 = [(x1 | 0) + 1,0];
				var max16 = values32[0];
				var _g68 = 0;
				var _g69 = values32.length;
				while(_g68 < _g69) {
					var i32 = _g68++;
					if(values32[i32] > max16) {
						max16 = values32[i32];
					}
				}
				var values33 = [max16,ma16];
				var min16 = values33[0];
				var _g70 = 0;
				var _g71 = values33.length;
				while(_g70 < _g71) {
					var i33 = _g70++;
					if(values33[i33] < min16) {
						min16 = values33[i33];
					}
				}
				var x30 = min16;
				var ma17 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
				var values34 = [(y1 | 0) + 1,0];
				var max17 = values34[0];
				var _g72 = 0;
				var _g73 = values34.length;
				while(_g72 < _g73) {
					var i34 = _g72++;
					if(values34[i34] > max17) {
						max17 = values34[i34];
					}
				}
				var values35 = [max17,ma17];
				var min17 = values35[0];
				var _g74 = 0;
				var _g75 = values35.length;
				while(_g74 < _g75) {
					var i35 = _g74++;
					if(values35[i35] < min17) {
						min17 = values35[i35];
					}
				}
				var y15 = min17;
				if(!(x30 >= 0 && y15 >= 0 && x30 < this1.getUInt16(0) && y15 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x11 = x30;
					var this_y11 = y15;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x11,this_y11)));
				}
				var position11 = (y15 * this1.getUInt16(0) + x30) * 4;
				position11 += vision_ds_Image.OFFSET;
				var value11 = this1.b[position11] << 24 | this1.b[position11 + 1] << 16 | this1.b[position11 + 2] << 8 | this1.b[position11 + 3];
				if(value11 == null) {
					value11 = 0;
				}
				var blue = x26 + yFraction * (x29 + xFraction * (value11 & 255)) | 0;
				var x31 = 1 - yFraction;
				var x32 = x1 | 0;
				var y16 = y1 | 0;
				if(!(x32 >= 0 && y16 >= 0 && x32 < this1.getUInt16(0) && y16 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x12 = x32;
					var this_y12 = y16;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x12,this_y12)));
				}
				var position12 = (y16 * this1.getUInt16(0) + x32) * 4;
				position12 += vision_ds_Image.OFFSET;
				var value12 = this1.b[position12] << 24 | this1.b[position12 + 1] << 16 | this1.b[position12 + 2] << 8 | this1.b[position12 + 3];
				if(value12 == null) {
					value12 = 0;
				}
				var x33 = (1 - xFraction) * (value12 >> 24 & 255);
				var ma18 = this1.getUInt16(0) - 1;
				var values36 = [(x1 | 0) + 1,0];
				var max18 = values36[0];
				var _g76 = 0;
				var _g77 = values36.length;
				while(_g76 < _g77) {
					var i36 = _g76++;
					if(values36[i36] > max18) {
						max18 = values36[i36];
					}
				}
				var values37 = [max18,ma18];
				var min18 = values37[0];
				var _g78 = 0;
				var _g79 = values37.length;
				while(_g78 < _g79) {
					var i37 = _g78++;
					if(values37[i37] < min18) {
						min18 = values37[i37];
					}
				}
				var x34 = min18;
				var ma19 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
				var values38 = [y1 | 0,0];
				var max19 = values38[0];
				var _g80 = 0;
				var _g81 = values38.length;
				while(_g80 < _g81) {
					var i38 = _g80++;
					if(values38[i38] > max19) {
						max19 = values38[i38];
					}
				}
				var values39 = [max19,ma19];
				var min19 = values39[0];
				var _g82 = 0;
				var _g83 = values39.length;
				while(_g82 < _g83) {
					var i39 = _g82++;
					if(values39[i39] < min19) {
						min19 = values39[i39];
					}
				}
				var y17 = min19;
				if(!(x34 >= 0 && y17 >= 0 && x34 < this1.getUInt16(0) && y17 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x13 = x34;
					var this_y13 = y17;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x13,this_y13)));
				}
				var position13 = (y17 * this1.getUInt16(0) + x34) * 4;
				position13 += vision_ds_Image.OFFSET;
				var value13 = this1.b[position13] << 24 | this1.b[position13 + 1] << 16 | this1.b[position13 + 2] << 8 | this1.b[position13 + 3];
				if(value13 == null) {
					value13 = 0;
				}
				var x35 = x31 * (x33 + xFraction * (value13 >> 24 & 255));
				var x36 = 1 - xFraction;
				var ma20 = this1.getUInt16(0) - 1;
				var values40 = [x1 | 0,0];
				var max20 = values40[0];
				var _g84 = 0;
				var _g85 = values40.length;
				while(_g84 < _g85) {
					var i40 = _g84++;
					if(values40[i40] > max20) {
						max20 = values40[i40];
					}
				}
				var values41 = [max20,ma20];
				var min20 = values41[0];
				var _g86 = 0;
				var _g87 = values41.length;
				while(_g86 < _g87) {
					var i41 = _g86++;
					if(values41[i41] < min20) {
						min20 = values41[i41];
					}
				}
				var x37 = min20;
				var ma21 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
				var values42 = [(y1 | 0) + 1,0];
				var max21 = values42[0];
				var _g88 = 0;
				var _g89 = values42.length;
				while(_g88 < _g89) {
					var i42 = _g88++;
					if(values42[i42] > max21) {
						max21 = values42[i42];
					}
				}
				var values43 = [max21,ma21];
				var min21 = values43[0];
				var _g90 = 0;
				var _g91 = values43.length;
				while(_g90 < _g91) {
					var i43 = _g90++;
					if(values43[i43] < min21) {
						min21 = values43[i43];
					}
				}
				var y18 = min21;
				if(!(x37 >= 0 && y18 >= 0 && x37 < this1.getUInt16(0) && y18 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x14 = x37;
					var this_y14 = y18;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x14,this_y14)));
				}
				var position14 = (y18 * this1.getUInt16(0) + x37) * 4;
				position14 += vision_ds_Image.OFFSET;
				var value14 = this1.b[position14] << 24 | this1.b[position14 + 1] << 16 | this1.b[position14 + 2] << 8 | this1.b[position14 + 3];
				if(value14 == null) {
					value14 = 0;
				}
				var x38 = x36 * (value14 >> 24 & 255);
				var ma22 = this1.getUInt16(0) - 1;
				var values44 = [(x1 | 0) + 1,0];
				var max22 = values44[0];
				var _g92 = 0;
				var _g93 = values44.length;
				while(_g92 < _g93) {
					var i44 = _g92++;
					if(values44[i44] > max22) {
						max22 = values44[i44];
					}
				}
				var values45 = [max22,ma22];
				var min22 = values45[0];
				var _g94 = 0;
				var _g95 = values45.length;
				while(_g94 < _g95) {
					var i45 = _g94++;
					if(values45[i45] < min22) {
						min22 = values45[i45];
					}
				}
				var x39 = min22;
				var ma23 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
				var values46 = [(y1 | 0) + 1,0];
				var max23 = values46[0];
				var _g96 = 0;
				var _g97 = values46.length;
				while(_g96 < _g97) {
					var i46 = _g96++;
					if(values46[i46] > max23) {
						max23 = values46[i46];
					}
				}
				var values47 = [max23,ma23];
				var min23 = values47[0];
				var _g98 = 0;
				var _g99 = values47.length;
				while(_g98 < _g99) {
					var i47 = _g98++;
					if(values47[i47] < min23) {
						min23 = values47[i47];
					}
				}
				var y19 = min23;
				if(!(x39 >= 0 && y19 >= 0 && x39 < this1.getUInt16(0) && y19 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
					var this_x15 = x39;
					var this_y15 = y19;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x15,this_y15)));
				}
				var position15 = (y19 * this1.getUInt16(0) + x39) * 4;
				position15 += vision_ds_Image.OFFSET;
				var value15 = this1.b[position15] << 24 | this1.b[position15 + 1] << 16 | this1.b[position15 + 2] << 8 | this1.b[position15 + 3];
				if(value15 == null) {
					value15 = 0;
				}
				var alpha = x35 + yFraction * (x38 + xFraction * (value15 >> 24 & 255)) | 0;
				var Alpha = alpha;
				if(Alpha == null) {
					Alpha = 255;
				}
				var color = 0;
				var Alpha1 = Alpha;
				if(Alpha1 == null) {
					Alpha1 = 255;
				}
				color &= -16711681;
				color |= (red > 255 ? 255 : red < 0 ? 0 : red) << 16;
				color &= -65281;
				color |= (green > 255 ? 255 : green < 0 ? 0 : green) << 8;
				color &= -256;
				color |= blue > 255 ? 255 : blue < 0 ? 0 : blue;
				color &= 16777215;
				color |= (Alpha1 > 255 ? 255 : Alpha1 < 0 ? 0 : Alpha1) << 24;
				var pixelValue = color;
				if(!(x >= 0 && y >= 0 && x < rotatedImage.getUInt16(0) && y < Math.ceil((rotatedImage.length - vision_ds_Image.OFFSET) / (rotatedImage.getUInt16(0) * 4)))) {
					var this_x16 = x;
					var this_y16 = y;
					throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(rotatedImage,new vision_ds_Point2D(this_x16,this_y16)));
				} else if(rotatedImage.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || rotatedImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || rotatedImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || rotatedImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || rotatedImage.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) {
					var v = null;
					var tmp1;
					if(!(rotatedImage.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || rotatedImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || rotatedImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || rotatedImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || rotatedImage.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
						tmp1 = x >= 0 && y >= 0 && x < rotatedImage.getUInt16(0) && y < Math.ceil((rotatedImage.length - vision_ds_Image.OFFSET) / (rotatedImage.getUInt16(0) * 4));
					} else {
						var has = false;
						var view;
						if(v != null) {
							view = v;
						} else {
							var _g100 = rotatedImage.getUInt16(vision_ds_Image.WIDTH_BYTES);
							var _g101 = rotatedImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
							var _g102 = rotatedImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
							var rotatedImage1 = rotatedImage.b;
							var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
							view = new vision_ds_ImageView(_g100,_g101,_g102,rotatedImage.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),rotatedImage1[view1]);
						}
						switch(view.shape) {
						case 0:
							has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
							break;
						case 1:
							has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
							break;
						case 2:case 3:
							if(view.width > view.height) {
								var a = view.width / 2;
								var b = view.height / 2;
								var c = Math.sqrt(a * a - b * b);
								var x40 = view.x + view.width / 2 - c;
								var y20 = view.y + view.height / 2;
								if(y20 == null) {
									y20 = 0;
								}
								if(x40 == null) {
									x40 = 0;
								}
								var f1_x = x40;
								var f1_y = y20;
								var x41 = view.x + view.width / 2 + c;
								var y21 = view.y + view.height / 2;
								if(y21 == null) {
									y21 = 0;
								}
								if(x41 == null) {
									x41 = 0;
								}
								var f2_x = x41;
								var f2_y = y21;
								var p_x = x;
								var p_y = y;
								var x42 = p_x - f1_x;
								var y22 = p_y - f1_y;
								var x43 = p_x - f2_x;
								var y23 = p_y - f2_y;
								has = Math.sqrt(x42 * x42 + y22 * y22) + Math.sqrt(x43 * x43 + y23 * y23) <= view.width;
								if(view.shape == 3) {
									has = !has;
								}
							} else if(view.height > view.width) {
								var a1 = view.height / 2;
								var b1 = view.width / 2;
								var c1 = Math.sqrt(a1 * a1 - b1 * b1);
								var x44 = view.x + view.width / 2;
								var y24 = view.y + view.height / 2 - c1;
								if(y24 == null) {
									y24 = 0;
								}
								if(x44 == null) {
									x44 = 0;
								}
								var f1_x1 = x44;
								var f1_y1 = y24;
								var x45 = view.x + view.width / 2;
								var y25 = view.y + view.height / 2 + c1;
								if(y25 == null) {
									y25 = 0;
								}
								if(x45 == null) {
									x45 = 0;
								}
								var f2_x1 = x45;
								var f2_y1 = y25;
								var p_x1 = x;
								var p_y1 = y;
								var x46 = p_x1 - f1_x1;
								var y26 = p_y1 - f1_y1;
								var x47 = p_x1 - f2_x1;
								var y27 = p_y1 - f2_y1;
								has = Math.sqrt(x46 * x46 + y26 * y26) + Math.sqrt(x47 * x47 + y27 * y27) <= view.height;
								if(view.shape == 3) {
									has = !has;
								}
							} else {
								var x48 = x;
								var y28 = y;
								if(y28 == null) {
									y28 = 0;
								}
								if(x48 == null) {
									x48 = 0;
								}
								var point1_x = x48;
								var point1_y = y28;
								var x49 = view.x + view.width / 2;
								var y29 = view.y + view.height / 2;
								if(y29 == null) {
									y29 = 0;
								}
								if(x49 == null) {
									x49 = 0;
								}
								var point2_x = x49;
								var point2_y = y29;
								var x50 = point2_x - point1_x;
								var y30 = point2_y - point1_y;
								has = Math.sqrt(x50 * x50 + y30 * y30) <= view.width / 2;
								if(view.shape == 3) {
									has = !has;
								}
							}
							break;
						case 4:
							has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
							break;
						case 5:
							has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
							break;
						}
						tmp1 = has;
					}
					if(tmp1) {
						var position16 = (y * rotatedImage.getUInt16(0) + x) * 4;
						position16 += vision_ds_Image.OFFSET;
						rotatedImage.b[position16] = pixelValue >> 24 & 255;
						rotatedImage.b[position16 + 1] = pixelValue >> 16 & 255;
						rotatedImage.b[position16 + 2] = pixelValue >> 8 & 255;
						rotatedImage.b[position16 + 3] = pixelValue & 255;
					}
				} else {
					var position17 = (y * rotatedImage.getUInt16(0) + x) * 4;
					position17 += vision_ds_Image.OFFSET;
					rotatedImage.b[position17] = pixelValue >> 24 & 255;
					rotatedImage.b[position17 + 1] = pixelValue >> 16 & 255;
					rotatedImage.b[position17 + 2] = pixelValue >> 8 & 255;
					rotatedImage.b[position17 + 3] = pixelValue & 255;
				}
			}
		}
	}
	this1 = rotatedImage;
	return this1;
};
vision_ds_Image.toString = function(this1,special) {
	if(special == null) {
		special = true;
	}
	if(!special) {
		return Std.string(this1);
	}
	var s = "\n";
	var prevY = 0;
	var _g = 0;
	var _g1 = this1.getUInt16(0);
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
		while(_g2 < _g3) {
			var y = _g2++;
			var position = (y * this1.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
			if(value == null) {
				value = 0;
			}
			if(prevY != y) {
				prevY = y;
				s += "\n";
			}
			s += vision_ds_Color.toString(value);
		}
	}
	return s;
};
vision_ds_Image.forEachPixel = function(this1,callback) {
	var _g = 0;
	var _g1 = this1.getUInt16(0);
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
		while(_g2 < _g3) {
			var y = _g2++;
			var position = (y * this1.getUInt16(0) + x) * 4;
			position += vision_ds_Image.OFFSET;
			var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
			if(value == null) {
				value = 0;
			}
			callback(x,y,value);
		}
	}
};
vision_ds_Image.forEachPixelInView = function(this1,callback) {
	if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0)) {
		var _g = 0;
		var _g1 = this1.getUInt16(0);
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			while(_g2 < _g3) {
				var y = _g2++;
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
				if(value == null) {
					value = 0;
				}
				callback(x,y,value);
			}
		}
		return;
	}
	var _g = 0;
	var _g1 = this1.getUInt16(0);
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
		while(_g2 < _g3) {
			var y = _g2++;
			var v = null;
			var tmp;
			if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
				tmp = x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
			} else {
				var has = false;
				var view;
				if(v != null) {
					view = v;
				} else {
					var _g4 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
					var _g5 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
					var _g6 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
					var this2 = this1.b;
					var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
					view = new vision_ds_ImageView(_g4,_g5,_g6,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
				}
				switch(view.shape) {
				case 0:
					has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
					break;
				case 1:
					has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
					break;
				case 2:case 3:
					if(view.width > view.height) {
						var a = view.width / 2;
						var b = view.height / 2;
						var c = Math.sqrt(a * a - b * b);
						var x1 = view.x + view.width / 2 - c;
						var y1 = view.y + view.height / 2;
						if(y1 == null) {
							y1 = 0;
						}
						if(x1 == null) {
							x1 = 0;
						}
						var f1_x = x1;
						var f1_y = y1;
						var x2 = view.x + view.width / 2 + c;
						var y2 = view.y + view.height / 2;
						if(y2 == null) {
							y2 = 0;
						}
						if(x2 == null) {
							x2 = 0;
						}
						var f2_x = x2;
						var f2_y = y2;
						var p_x = x;
						var p_y = y;
						var x3 = p_x - f1_x;
						var y3 = p_y - f1_y;
						var x4 = p_x - f2_x;
						var y4 = p_y - f2_y;
						has = Math.sqrt(x3 * x3 + y3 * y3) + Math.sqrt(x4 * x4 + y4 * y4) <= view.width;
						if(view.shape == 3) {
							has = !has;
						}
					} else if(view.height > view.width) {
						var a1 = view.height / 2;
						var b1 = view.width / 2;
						var c1 = Math.sqrt(a1 * a1 - b1 * b1);
						var x5 = view.x + view.width / 2;
						var y5 = view.y + view.height / 2 - c1;
						if(y5 == null) {
							y5 = 0;
						}
						if(x5 == null) {
							x5 = 0;
						}
						var f1_x1 = x5;
						var f1_y1 = y5;
						var x6 = view.x + view.width / 2;
						var y6 = view.y + view.height / 2 + c1;
						if(y6 == null) {
							y6 = 0;
						}
						if(x6 == null) {
							x6 = 0;
						}
						var f2_x1 = x6;
						var f2_y1 = y6;
						var p_x1 = x;
						var p_y1 = y;
						var x7 = p_x1 - f1_x1;
						var y7 = p_y1 - f1_y1;
						var x8 = p_x1 - f2_x1;
						var y8 = p_y1 - f2_y1;
						has = Math.sqrt(x7 * x7 + y7 * y7) + Math.sqrt(x8 * x8 + y8 * y8) <= view.height;
						if(view.shape == 3) {
							has = !has;
						}
					} else {
						var x9 = x;
						var y9 = y;
						if(y9 == null) {
							y9 = 0;
						}
						if(x9 == null) {
							x9 = 0;
						}
						var point1_x = x9;
						var point1_y = y9;
						var x10 = view.x + view.width / 2;
						var y10 = view.y + view.height / 2;
						if(y10 == null) {
							y10 = 0;
						}
						if(x10 == null) {
							x10 = 0;
						}
						var point2_x = x10;
						var point2_y = y10;
						var x11 = point2_x - point1_x;
						var y11 = point2_y - point1_y;
						has = Math.sqrt(x11 * x11 + y11 * y11) <= view.width / 2;
						if(view.shape == 3) {
							has = !has;
						}
					}
					break;
				case 4:
					has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
					break;
				case 5:
					has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
					break;
				}
				tmp = has;
			}
			if(tmp) {
				var position = (y * this1.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
				if(value == null) {
					value = 0;
				}
				callback(x,y,value);
			}
		}
	}
};
vision_ds_Image.iterator = function(this1) {
	return new vision_ds__$Image_PixelIterator(this1);
};
vision_ds_Image.center = function(this1) {
	return new vision_ds_Point2D(this1.getUInt16(0) / 2,Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) / 2);
};
vision_ds_Image.hasView = function(this1) {
	if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0)) {
		return this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0;
	} else {
		return true;
	}
};
vision_ds_Image.setView = function(this1,view) {
	this1.setUInt16(vision_ds_Image.WIDTH_BYTES,view.x);
	this1.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP,view.y);
	this1.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES,view.width >= this1.getUInt16(0) ? 0 : view.width);
	this1.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP,view.height >= Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) ? 0 : view.width);
	this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] = view.shape;
	return this1;
};
vision_ds_Image.getView = function(this1) {
	var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
	var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
	var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
	var this2 = this1.b;
	var tmp = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
	return new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[tmp]);
};
vision_ds_Image.removeView = function(this1) {
	this1.setUInt16(vision_ds_Image.WIDTH_BYTES,0);
	this1.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP,0);
	this1.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES,0);
	this1.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP,0);
	this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] = 0;
	return this1;
};
vision_ds_Image.hasPixelInView = function(this1,x,y,v) {
	if(!(this1.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || this1.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
		if(x >= 0 && y >= 0 && x < this1.getUInt16(0)) {
			return y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
		} else {
			return false;
		}
	}
	var has = false;
	var view;
	if(v != null) {
		view = v;
	} else {
		var _g = this1.getUInt16(vision_ds_Image.WIDTH_BYTES);
		var _g1 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
		var _g2 = this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
		var this2 = this1.b;
		var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
		view = new vision_ds_ImageView(_g,_g1,_g2,this1.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),this2[view1]);
	}
	switch(view.shape) {
	case 0:
		has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
		break;
	case 1:
		has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
		break;
	case 2:case 3:
		if(view.width > view.height) {
			var a = view.width / 2;
			var b = view.height / 2;
			var c = Math.sqrt(a * a - b * b);
			var x1 = view.x + view.width / 2 - c;
			var y1 = view.y + view.height / 2;
			if(y1 == null) {
				y1 = 0;
			}
			if(x1 == null) {
				x1 = 0;
			}
			var f1_x = x1;
			var f1_y = y1;
			var x1 = view.x + view.width / 2 + c;
			var y1 = view.y + view.height / 2;
			if(y1 == null) {
				y1 = 0;
			}
			if(x1 == null) {
				x1 = 0;
			}
			var f2_x = x1;
			var f2_y = y1;
			var p_x = x;
			var p_y = y;
			var x1 = p_x - f1_x;
			var y1 = p_y - f1_y;
			var x2 = p_x - f2_x;
			var y2 = p_y - f2_y;
			has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.width;
			if(view.shape == 3) {
				has = !has;
			}
		} else if(view.height > view.width) {
			var a = view.height / 2;
			var b = view.width / 2;
			var c = Math.sqrt(a * a - b * b);
			var x1 = view.x + view.width / 2;
			var y1 = view.y + view.height / 2 - c;
			if(y1 == null) {
				y1 = 0;
			}
			if(x1 == null) {
				x1 = 0;
			}
			var f1_x = x1;
			var f1_y = y1;
			var x1 = view.x + view.width / 2;
			var y1 = view.y + view.height / 2 + c;
			if(y1 == null) {
				y1 = 0;
			}
			if(x1 == null) {
				x1 = 0;
			}
			var f2_x = x1;
			var f2_y = y1;
			var p_x = x;
			var p_y = y;
			var x1 = p_x - f1_x;
			var y1 = p_y - f1_y;
			var x2 = p_x - f2_x;
			var y2 = p_y - f2_y;
			has = Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2) <= view.height;
			if(view.shape == 3) {
				has = !has;
			}
		} else {
			var x1 = x;
			var y1 = y;
			if(y1 == null) {
				y1 = 0;
			}
			if(x1 == null) {
				x1 = 0;
			}
			var point1_x = x1;
			var point1_y = y1;
			var x1 = view.x + view.width / 2;
			var y1 = view.y + view.height / 2;
			if(y1 == null) {
				y1 = 0;
			}
			if(x1 == null) {
				x1 = 0;
			}
			var point2_x = x1;
			var point2_y = y1;
			var x1 = point2_x - point1_x;
			var y1 = point2_y - point1_y;
			has = Math.sqrt(x1 * x1 + y1 * y1) <= view.width / 2;
			if(view.shape == 3) {
				has = !has;
			}
		}
		break;
	case 4:
		has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
		break;
	case 5:
		has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
		break;
	}
	return has;
};
vision_ds_Image.fromJsCanvas = function(canvas) {
	return vision_tools_ImageTools.fromJsCanvas(canvas);
};
vision_ds_Image.toJsCanvas = function(this1) {
	return vision_tools_ImageTools.toJsCanvas(this1);
};
vision_ds_Image.fromJsImage = function(image) {
	return vision_tools_ImageTools.fromJsImage(image);
};
vision_ds_Image.toJsImage = function(this1) {
	return vision_tools_ImageTools.toJsImage(this1);
};
vision_ds_Image.from2DArray = function(array) {
	var h = array.length;
	var w = array[0].length;
	var length = w * h * 4 + vision_ds_Image.OFFSET;
	var this1 = new haxe_io_Bytes(new ArrayBuffer(length));
	this1.fill(0,length,0);
	var byteArray = this1;
	var flat = [];
	var _g = 0;
	while(_g < array.length) {
		var item = array[_g];
		++_g;
		flat = flat.concat(item);
	}
	var flat1 = flat;
	var _g = 0;
	var _g1 = flat1.length;
	while(_g < _g1) {
		var i = _g++;
		var color = flat1[i];
		byteArray.b[vision_ds_Image.OFFSET + i * 4] = color >> 24 & 255;
		byteArray.b[vision_ds_Image.OFFSET + i * 4 + 1] = color >> 16 & 255;
		byteArray.b[vision_ds_Image.OFFSET + i * 4 + 2] = color >> 8 & 255;
		byteArray.b[vision_ds_Image.OFFSET + i * 4 + 3] = color & 255;
	}
	byteArray.setUInt16(0,w);
	byteArray.setUInt16(vision_ds_Image.WIDTH_BYTES,0);
	byteArray.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP,0);
	byteArray.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES,0);
	byteArray.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP,0);
	byteArray.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] = 0;
	return byteArray;
};
vision_ds_Image.to2DArray = function(this1) {
	var arr = [];
	var _g = 0;
	var _g1 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4));
	while(_g < _g1) {
		var i = _g++;
		arr[i] = [];
		var _g2 = 0;
		var _g3 = this1.getUInt16(0);
		while(_g2 < _g3) {
			var j = _g2++;
			var arr1 = arr[i];
			var position = (i * this1.getUInt16(0) + j) * 4;
			position += vision_ds_Image.OFFSET;
			var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
			if(value == null) {
				value = 0;
			}
			arr1[j] = value;
		}
	}
	return arr;
};
vision_ds_Image.fromBytes = function(bytes,width,height) {
	var h = height != null ? height : Math.ceil(bytes.length / 4 / width);
	var length = width * h * 4 + vision_ds_Image.OFFSET;
	var this1 = new haxe_io_Bytes(new ArrayBuffer(length));
	this1.fill(0,length,0);
	var array = this1;
	array.fill(0,array.length,0);
	array.setUInt16(0,width);
	array.setUInt16(vision_ds_Image.WIDTH_BYTES,0);
	array.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP,0);
	array.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES,0);
	array.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP,0);
	array.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] = 0;
	array.blit(vision_ds_Image.OFFSET,bytes,0,bytes.length);
	return array;
};
vision_ds_Image.image_or_image = function(lhs,rhs) {
	if(!(lhs.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || lhs.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0)) {
		var _g = 0;
		var _g1 = lhs.getUInt16(0);
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = Math.ceil((lhs.length - vision_ds_Image.OFFSET) / (lhs.getUInt16(0) * 4));
			while(_g2 < _g3) {
				var y = _g2++;
				var position = (y * lhs.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				var value = lhs.b[position] << 24 | lhs.b[position + 1] << 16 | lhs.b[position + 2] << 8 | lhs.b[position + 3];
				if(value == null) {
					value = 0;
				}
				var position1 = (y * rhs.getUInt16(0) + x) * 4;
				position1 += vision_ds_Image.OFFSET;
				var value1 = rhs.b[position1] << 24 | rhs.b[position1 + 1] << 16 | rhs.b[position1 + 2] << 8 | rhs.b[position1 + 3];
				if(value1 == null) {
					value1 = 0;
				}
				var color = value | value1;
				var position2 = (y * lhs.getUInt16(0) + x) * 4;
				position2 += vision_ds_Image.OFFSET;
				lhs.b[position2] = color >> 24 & 255;
				lhs.b[position2 + 1] = color >> 16 & 255;
				lhs.b[position2 + 2] = color >> 8 & 255;
				lhs.b[position2 + 3] = color & 255;
			}
		}
	} else {
		var _g = 0;
		var _g1 = lhs.getUInt16(0);
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = Math.ceil((lhs.length - vision_ds_Image.OFFSET) / (lhs.getUInt16(0) * 4));
			while(_g2 < _g3) {
				var y = _g2++;
				var v = null;
				var tmp;
				if(!(lhs.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || lhs.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x >= 0 && y >= 0 && x < lhs.getUInt16(0) && y < Math.ceil((lhs.length - vision_ds_Image.OFFSET) / (lhs.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g4 = lhs.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g5 = lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g6 = lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var lhs1 = lhs.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g4,_g5,_g6,lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),lhs1[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
						break;
					case 1:
						has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2 - c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x2 = view.x + view.width / 2 + c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f2_x = x2;
							var f2_y = y2;
							var p_x = x;
							var p_y = y;
							var x3 = p_x - f1_x;
							var y3 = p_y - f1_y;
							var x4 = p_x - f2_x;
							var y4 = p_y - f2_y;
							has = Math.sqrt(x3 * x3 + y3 * y3) + Math.sqrt(x4 * x4 + y4 * y4) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a1 = view.height / 2;
							var b1 = view.width / 2;
							var c1 = Math.sqrt(a1 * a1 - b1 * b1);
							var x5 = view.x + view.width / 2;
							var y5 = view.y + view.height / 2 - c1;
							if(y5 == null) {
								y5 = 0;
							}
							if(x5 == null) {
								x5 = 0;
							}
							var f1_x1 = x5;
							var f1_y1 = y5;
							var x6 = view.x + view.width / 2;
							var y6 = view.y + view.height / 2 + c1;
							if(y6 == null) {
								y6 = 0;
							}
							if(x6 == null) {
								x6 = 0;
							}
							var f2_x1 = x6;
							var f2_y1 = y6;
							var p_x1 = x;
							var p_y1 = y;
							var x7 = p_x1 - f1_x1;
							var y7 = p_y1 - f1_y1;
							var x8 = p_x1 - f2_x1;
							var y8 = p_y1 - f2_y1;
							has = Math.sqrt(x7 * x7 + y7 * y7) + Math.sqrt(x8 * x8 + y8 * y8) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x9 = x;
							var y9 = y;
							if(y9 == null) {
								y9 = 0;
							}
							if(x9 == null) {
								x9 = 0;
							}
							var point1_x = x9;
							var point1_y = y9;
							var x10 = view.x + view.width / 2;
							var y10 = view.y + view.height / 2;
							if(y10 == null) {
								y10 = 0;
							}
							if(x10 == null) {
								x10 = 0;
							}
							var point2_x = x10;
							var point2_y = y10;
							var x11 = point2_x - point1_x;
							var y11 = point2_y - point1_y;
							has = Math.sqrt(x11 * x11 + y11 * y11) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y * lhs.getUInt16(0) + x) * 4;
					position += vision_ds_Image.OFFSET;
					var value = lhs.b[position] << 24 | lhs.b[position + 1] << 16 | lhs.b[position + 2] << 8 | lhs.b[position + 3];
					if(value == null) {
						value = 0;
					}
					var position1 = (y * rhs.getUInt16(0) + x) * 4;
					position1 += vision_ds_Image.OFFSET;
					var value1 = rhs.b[position1] << 24 | rhs.b[position1 + 1] << 16 | rhs.b[position1 + 2] << 8 | rhs.b[position1 + 3];
					if(value1 == null) {
						value1 = 0;
					}
					var color = value | value1;
					var position2 = (y * lhs.getUInt16(0) + x) * 4;
					position2 += vision_ds_Image.OFFSET;
					lhs.b[position2] = color >> 24 & 255;
					lhs.b[position2 + 1] = color >> 16 & 255;
					lhs.b[position2 + 2] = color >> 8 & 255;
					lhs.b[position2 + 3] = color & 255;
				}
			}
		}
	}
	return lhs;
};
vision_ds_Image.image_xor_image = function(lhs,rhs) {
	if(!(lhs.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || lhs.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0)) {
		var _g = 0;
		var _g1 = lhs.getUInt16(0);
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = Math.ceil((lhs.length - vision_ds_Image.OFFSET) / (lhs.getUInt16(0) * 4));
			while(_g2 < _g3) {
				var y = _g2++;
				var position = (y * lhs.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				var value = lhs.b[position] << 24 | lhs.b[position + 1] << 16 | lhs.b[position + 2] << 8 | lhs.b[position + 3];
				if(value == null) {
					value = 0;
				}
				var position1 = (y * rhs.getUInt16(0) + x) * 4;
				position1 += vision_ds_Image.OFFSET;
				var value1 = rhs.b[position1] << 24 | rhs.b[position1 + 1] << 16 | rhs.b[position1 + 2] << 8 | rhs.b[position1 + 3];
				if(value1 == null) {
					value1 = 0;
				}
				var color = value ^ value1;
				var position2 = (y * lhs.getUInt16(0) + x) * 4;
				position2 += vision_ds_Image.OFFSET;
				lhs.b[position2] = color >> 24 & 255;
				lhs.b[position2 + 1] = color >> 16 & 255;
				lhs.b[position2 + 2] = color >> 8 & 255;
				lhs.b[position2 + 3] = color & 255;
			}
		}
	} else {
		var _g = 0;
		var _g1 = lhs.getUInt16(0);
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = Math.ceil((lhs.length - vision_ds_Image.OFFSET) / (lhs.getUInt16(0) * 4));
			while(_g2 < _g3) {
				var y = _g2++;
				var v = null;
				var tmp;
				if(!(lhs.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || lhs.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x >= 0 && y >= 0 && x < lhs.getUInt16(0) && y < Math.ceil((lhs.length - vision_ds_Image.OFFSET) / (lhs.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g4 = lhs.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g5 = lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g6 = lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var lhs1 = lhs.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g4,_g5,_g6,lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),lhs1[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
						break;
					case 1:
						has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2 - c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x2 = view.x + view.width / 2 + c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f2_x = x2;
							var f2_y = y2;
							var p_x = x;
							var p_y = y;
							var x3 = p_x - f1_x;
							var y3 = p_y - f1_y;
							var x4 = p_x - f2_x;
							var y4 = p_y - f2_y;
							has = Math.sqrt(x3 * x3 + y3 * y3) + Math.sqrt(x4 * x4 + y4 * y4) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a1 = view.height / 2;
							var b1 = view.width / 2;
							var c1 = Math.sqrt(a1 * a1 - b1 * b1);
							var x5 = view.x + view.width / 2;
							var y5 = view.y + view.height / 2 - c1;
							if(y5 == null) {
								y5 = 0;
							}
							if(x5 == null) {
								x5 = 0;
							}
							var f1_x1 = x5;
							var f1_y1 = y5;
							var x6 = view.x + view.width / 2;
							var y6 = view.y + view.height / 2 + c1;
							if(y6 == null) {
								y6 = 0;
							}
							if(x6 == null) {
								x6 = 0;
							}
							var f2_x1 = x6;
							var f2_y1 = y6;
							var p_x1 = x;
							var p_y1 = y;
							var x7 = p_x1 - f1_x1;
							var y7 = p_y1 - f1_y1;
							var x8 = p_x1 - f2_x1;
							var y8 = p_y1 - f2_y1;
							has = Math.sqrt(x7 * x7 + y7 * y7) + Math.sqrt(x8 * x8 + y8 * y8) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x9 = x;
							var y9 = y;
							if(y9 == null) {
								y9 = 0;
							}
							if(x9 == null) {
								x9 = 0;
							}
							var point1_x = x9;
							var point1_y = y9;
							var x10 = view.x + view.width / 2;
							var y10 = view.y + view.height / 2;
							if(y10 == null) {
								y10 = 0;
							}
							if(x10 == null) {
								x10 = 0;
							}
							var point2_x = x10;
							var point2_y = y10;
							var x11 = point2_x - point1_x;
							var y11 = point2_y - point1_y;
							has = Math.sqrt(x11 * x11 + y11 * y11) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y * lhs.getUInt16(0) + x) * 4;
					position += vision_ds_Image.OFFSET;
					var value = lhs.b[position] << 24 | lhs.b[position + 1] << 16 | lhs.b[position + 2] << 8 | lhs.b[position + 3];
					if(value == null) {
						value = 0;
					}
					var position1 = (y * rhs.getUInt16(0) + x) * 4;
					position1 += vision_ds_Image.OFFSET;
					var value1 = rhs.b[position1] << 24 | rhs.b[position1 + 1] << 16 | rhs.b[position1 + 2] << 8 | rhs.b[position1 + 3];
					if(value1 == null) {
						value1 = 0;
					}
					var color = value ^ value1;
					var position2 = (y * lhs.getUInt16(0) + x) * 4;
					position2 += vision_ds_Image.OFFSET;
					lhs.b[position2] = color >> 24 & 255;
					lhs.b[position2 + 1] = color >> 16 & 255;
					lhs.b[position2 + 2] = color >> 8 & 255;
					lhs.b[position2 + 3] = color & 255;
				}
			}
		}
	}
	return lhs;
};
vision_ds_Image.image_and_image = function(lhs,rhs) {
	if(!(lhs.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || lhs.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0)) {
		var _g = 0;
		var _g1 = lhs.getUInt16(0);
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = Math.ceil((lhs.length - vision_ds_Image.OFFSET) / (lhs.getUInt16(0) * 4));
			while(_g2 < _g3) {
				var y = _g2++;
				var position = (y * lhs.getUInt16(0) + x) * 4;
				position += vision_ds_Image.OFFSET;
				var value = lhs.b[position] << 24 | lhs.b[position + 1] << 16 | lhs.b[position + 2] << 8 | lhs.b[position + 3];
				if(value == null) {
					value = 0;
				}
				var position1 = (y * rhs.getUInt16(0) + x) * 4;
				position1 += vision_ds_Image.OFFSET;
				var value1 = rhs.b[position1] << 24 | rhs.b[position1 + 1] << 16 | rhs.b[position1 + 2] << 8 | rhs.b[position1 + 3];
				if(value1 == null) {
					value1 = 0;
				}
				var color = value & value1;
				var position2 = (y * lhs.getUInt16(0) + x) * 4;
				position2 += vision_ds_Image.OFFSET;
				lhs.b[position2] = color >> 24 & 255;
				lhs.b[position2 + 1] = color >> 16 & 255;
				lhs.b[position2 + 2] = color >> 8 & 255;
				lhs.b[position2 + 3] = color & 255;
			}
		}
	} else {
		var _g = 0;
		var _g1 = lhs.getUInt16(0);
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = Math.ceil((lhs.length - vision_ds_Image.OFFSET) / (lhs.getUInt16(0) * 4));
			while(_g2 < _g3) {
				var y = _g2++;
				var v = null;
				var tmp;
				if(!(lhs.getUInt16(vision_ds_Image.WIDTH_BYTES) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES) != 0 || lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP) != 0 || lhs.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] != 0) && v == null) {
					tmp = x >= 0 && y >= 0 && x < lhs.getUInt16(0) && y < Math.ceil((lhs.length - vision_ds_Image.OFFSET) / (lhs.getUInt16(0) * 4));
				} else {
					var has = false;
					var view;
					if(v != null) {
						view = v;
					} else {
						var _g4 = lhs.getUInt16(vision_ds_Image.WIDTH_BYTES);
						var _g5 = lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP);
						var _g6 = lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES);
						var lhs1 = lhs.b;
						var view1 = vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES;
						view = new vision_ds_ImageView(_g4,_g5,_g6,lhs.getUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP),lhs1[view1]);
					}
					switch(view.shape) {
					case 0:
						has = x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y;
						break;
					case 1:
						has = !(x < view.x + view.width && y < view.y + view.height && x >= view.x && y >= view.y);
						break;
					case 2:case 3:
						if(view.width > view.height) {
							var a = view.width / 2;
							var b = view.height / 2;
							var c = Math.sqrt(a * a - b * b);
							var x1 = view.x + view.width / 2 - c;
							var y1 = view.y + view.height / 2;
							if(y1 == null) {
								y1 = 0;
							}
							if(x1 == null) {
								x1 = 0;
							}
							var f1_x = x1;
							var f1_y = y1;
							var x2 = view.x + view.width / 2 + c;
							var y2 = view.y + view.height / 2;
							if(y2 == null) {
								y2 = 0;
							}
							if(x2 == null) {
								x2 = 0;
							}
							var f2_x = x2;
							var f2_y = y2;
							var p_x = x;
							var p_y = y;
							var x3 = p_x - f1_x;
							var y3 = p_y - f1_y;
							var x4 = p_x - f2_x;
							var y4 = p_y - f2_y;
							has = Math.sqrt(x3 * x3 + y3 * y3) + Math.sqrt(x4 * x4 + y4 * y4) <= view.width;
							if(view.shape == 3) {
								has = !has;
							}
						} else if(view.height > view.width) {
							var a1 = view.height / 2;
							var b1 = view.width / 2;
							var c1 = Math.sqrt(a1 * a1 - b1 * b1);
							var x5 = view.x + view.width / 2;
							var y5 = view.y + view.height / 2 - c1;
							if(y5 == null) {
								y5 = 0;
							}
							if(x5 == null) {
								x5 = 0;
							}
							var f1_x1 = x5;
							var f1_y1 = y5;
							var x6 = view.x + view.width / 2;
							var y6 = view.y + view.height / 2 + c1;
							if(y6 == null) {
								y6 = 0;
							}
							if(x6 == null) {
								x6 = 0;
							}
							var f2_x1 = x6;
							var f2_y1 = y6;
							var p_x1 = x;
							var p_y1 = y;
							var x7 = p_x1 - f1_x1;
							var y7 = p_y1 - f1_y1;
							var x8 = p_x1 - f2_x1;
							var y8 = p_y1 - f2_y1;
							has = Math.sqrt(x7 * x7 + y7 * y7) + Math.sqrt(x8 * x8 + y8 * y8) <= view.height;
							if(view.shape == 3) {
								has = !has;
							}
						} else {
							var x9 = x;
							var y9 = y;
							if(y9 == null) {
								y9 = 0;
							}
							if(x9 == null) {
								x9 = 0;
							}
							var point1_x = x9;
							var point1_y = y9;
							var x10 = view.x + view.width / 2;
							var y10 = view.y + view.height / 2;
							if(y10 == null) {
								y10 = 0;
							}
							if(x10 == null) {
								x10 = 0;
							}
							var point2_x = x10;
							var point2_y = y10;
							var x11 = point2_x - point1_x;
							var y11 = point2_y - point1_y;
							has = Math.sqrt(x11 * x11 + y11 * y11) <= view.width / 2;
							if(view.shape == 3) {
								has = !has;
							}
						}
						break;
					case 4:
						has = Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1;
						break;
					case 5:
						has = !(Math.abs(x - view.x - view.width / 2) / (view.width / 2) + Math.abs(y - view.y - view.height / 2) / (view.height / 2) <= 1);
						break;
					}
					tmp = has;
				}
				if(tmp) {
					var position = (y * lhs.getUInt16(0) + x) * 4;
					position += vision_ds_Image.OFFSET;
					var value = lhs.b[position] << 24 | lhs.b[position + 1] << 16 | lhs.b[position + 2] << 8 | lhs.b[position + 3];
					if(value == null) {
						value = 0;
					}
					var position1 = (y * rhs.getUInt16(0) + x) * 4;
					position1 += vision_ds_Image.OFFSET;
					var value1 = rhs.b[position1] << 24 | rhs.b[position1 + 1] << 16 | rhs.b[position1 + 2] << 8 | rhs.b[position1 + 3];
					if(value1 == null) {
						value1 = 0;
					}
					var color = value & value1;
					var position2 = (y * lhs.getUInt16(0) + x) * 4;
					position2 += vision_ds_Image.OFFSET;
					lhs.b[position2] = color >> 24 & 255;
					lhs.b[position2 + 1] = color >> 16 & 255;
					lhs.b[position2 + 2] = color >> 8 & 255;
					lhs.b[position2 + 3] = color & 255;
				}
			}
		}
	}
	return lhs;
};
var vision_ds__$Image_PixelIterator = function(img) {
	this.i = 4;
	this.img = img;
};
$hxClasses["vision.ds._Image.PixelIterator"] = vision_ds__$Image_PixelIterator;
vision_ds__$Image_PixelIterator.__name__ = "vision.ds._Image.PixelIterator";
vision_ds__$Image_PixelIterator.prototype = {
	i: null
	,img: null
	,next: function() {
		var x = this.i % this.img.getUInt16(0);
		var y = Math.floor(this.i / this.img.getUInt16(0));
		var this1 = this.img;
		if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x;
			var this_y = y;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		}
		var position = (y * this1.getUInt16(0) + x) * 4;
		position += vision_ds_Image.OFFSET;
		var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
		if(value == null) {
			value = 0;
		}
		var pixel = new vision_ds_Pixel(x,y,value);
		this.i += 4;
		return pixel;
	}
	,hasNext: function() {
		return this.i < this.img.length;
	}
	,__class__: vision_ds__$Image_PixelIterator
};
var vision_ds_ImageView = function(x,y,width,height,shape) {
	this.shape = 0;
	this.height = 0;
	this.width = 0;
	this.y = 0;
	this.x = 0;
	if(x != null) {
		this.x = x;
	}
	if(y != null) {
		this.y = y;
	}
	if(width != null) {
		this.width = width;
	}
	if(height != null) {
		this.height = height;
	}
	if(shape != null) {
		this.shape = shape;
	}
};
$hxClasses["vision.ds.ImageView"] = vision_ds_ImageView;
vision_ds_ImageView.__name__ = "vision.ds.ImageView";
vision_ds_ImageView.prototype = {
	x: null
	,y: null
	,width: null
	,height: null
	,shape: null
	,toString: function() {
		return "{shape: " + this.shape + ", x: " + this.x + ", y: " + this.y + ", width: " + this.width + ", height: " + this.height + "}";
	}
	,__class__: vision_ds_ImageView
};
var vision_ds__$IntPoint2D_Impl = function(x,y) {
	this.x = x;
	this.y = y;
};
$hxClasses["vision.ds._IntPoint2D.Impl"] = vision_ds__$IntPoint2D_Impl;
vision_ds__$IntPoint2D_Impl.__name__ = "vision.ds._IntPoint2D.Impl";
vision_ds__$IntPoint2D_Impl.prototype = {
	x: null
	,y: null
	,__class__: vision_ds__$IntPoint2D_Impl
};
var vision_ds_IntPoint2D = {};
vision_ds_IntPoint2D.__properties__ = {set_y:"set_y",get_y:"get_y",set_x:"set_x",get_x:"get_x"};
vision_ds_IntPoint2D.get_y = function(this1) {
	return this1.y;
};
vision_ds_IntPoint2D.get_x = function(this1) {
	return this1.x;
};
vision_ds_IntPoint2D.set_y = function(this1,y) {
	this1.y = y;
	return y;
};
vision_ds_IntPoint2D.set_x = function(this1,x) {
	this1.x = x;
	return x;
};
vision_ds_IntPoint2D.toPoint2D = function(this1) {
	return new vision_ds_Point2D(this1.x,this1.y);
};
vision_ds_IntPoint2D.fromPoint2D = function(p) {
	return new vision_ds__$IntPoint2D_Impl(p.x | 0,p.y | 0);
};
vision_ds_IntPoint2D.toString = function(this1) {
	return "(" + this1.x + ", " + this1.y + ")";
};
vision_ds_IntPoint2D.copy = function(this1) {
	return new vision_ds__$IntPoint2D_Impl(this1.x,this1.y);
};
vision_ds_IntPoint2D.distanceTo = function(this1,point) {
	return Math.sqrt(Math.pow(this1.x - point.x,2) + Math.pow(this1.y - point.y,2));
};
vision_ds_IntPoint2D.degreesTo = function(this1,point) {
	var point1 = js_Boot.__cast(this1 , vision_ds__$IntPoint2D_Impl);
	var x = point.x - point1.x;
	var y = point.y - point1.y;
	return Math.atan2(x,y) * 180 / Math.PI;
};
vision_ds_IntPoint2D.radiansTo = function(this1,point) {
	var point1 = js_Boot.__cast(this1 , vision_ds__$IntPoint2D_Impl);
	var x = point.x - point1.x;
	var y = point.y - point1.y;
	return Math.atan2(x,y) * 180 / Math.PI;
};
var vision_ds_Line2D = function(start,end) {
	this.end = new vision_ds_Point2D(0,0);
	this.start = new vision_ds_Point2D(0,0);
	this.start.x = start.x;
	this.start.y = start.y;
	this.end.x = end.x;
	this.end.y = end.y;
	var x = end.x - start.x;
	var y = end.y - start.y;
	this.radians = Math.atan2(x,y);
	this.slope = Math.tan(this.radians);
	this.degrees = this.radians * 180 / Math.PI;
};
$hxClasses["vision.ds.Line2D"] = vision_ds_Line2D;
vision_ds_Line2D.__name__ = "vision.ds.Line2D";
vision_ds_Line2D.fromRay2D = function(ray) {
	var x = ray.point.x;
	var y = ray.point.y;
	var length = 1;
	var end = new vision_ds_Point2D(x + length * Math.cos(ray.radians) | 0,y + length * Math.sin(ray.radians) | 0);
	return new vision_ds_Line2D(ray.point,end);
};
vision_ds_Line2D.prototype = {
	length: null
	,slope: null
	,degrees: null
	,radians: null
	,start: null
	,end: null
	,get_length: function() {
		return Math.sqrt(Math.pow(this.end.x - this.start.x,2) + Math.pow(this.end.y - this.start.y,2));
	}
	,intersect: function(line) {
		var x1 = this.start.x;
		var y1 = this.start.y;
		var x2 = this.end.x;
		var y2 = this.end.y;
		var x3 = line.start.x;
		var y3 = line.start.y;
		var x4 = line.end.x;
		var y4 = line.end.y;
		var denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
		if(x1 == x2 && y1 == y2 || x3 == x4 && y3 == y4) {
			return null;
		} else if(denominator == 0) {
			return null;
		} else {
			var ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
			var ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
			if(ua < 0 || ua > 1 || ub < 0 || ub > 1) {
				return null;
			} else {
				var x = x1 + ua * (x2 - x1);
				var y = y1 + ua * (y2 - y1);
				return new vision_ds_Point2D(x | 0,y | 0);
			}
		}
	}
	,distanceTo: function(line) {
		var x1 = this.start.x;
		var y1 = this.start.y;
		var x2 = this.end.x;
		var y2 = this.end.y;
		var x3 = line.start.x;
		var y3 = line.start.y;
		var x4 = line.end.x;
		var y4 = line.end.y;
		var denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
		var tmp;
		if(x1 == x2 && y1 == y2 || x3 == x4 && y3 == y4) {
			tmp = null;
		} else if(denominator == 0) {
			tmp = null;
		} else {
			var ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
			var ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
			if(ua < 0 || ua > 1 || ub < 0 || ub > 1) {
				tmp = null;
			} else {
				var x = x1 + ua * (x2 - x1);
				var y = y1 + ua * (y2 - y1);
				tmp = new vision_ds_Point2D(x | 0,y | 0);
			}
		}
		if(tmp != null) {
			return 0;
		} else {
			var point = line.start;
			var ch = (this.start.y - this.end.y) * point.x + (this.end.x - this.start.x) * point.y + (this.start.x * this.end.y - this.end.x * this.start.y);
			var del = Math.sqrt(Math.pow(this.end.x - this.start.x,2) + Math.pow(this.end.y - this.start.y,2));
			var d = ch / del;
			var distance1 = d;
			var point = line.end;
			var ch = (this.start.y - this.end.y) * point.x + (this.end.x - this.start.x) * point.y + (this.start.x * this.end.y - this.end.x * this.start.y);
			var del = Math.sqrt(Math.pow(this.end.x - this.start.x,2) + Math.pow(this.end.y - this.start.y,2));
			var d = ch / del;
			var distance2 = d;
			var point = this.start;
			var ch = (line.start.y - line.end.y) * point.x + (line.end.x - line.start.x) * point.y + (line.start.x * line.end.y - line.end.x * line.start.y);
			var del = Math.sqrt(Math.pow(line.end.x - line.start.x,2) + Math.pow(line.end.y - line.start.y,2));
			var d = ch / del;
			var distance3 = d;
			var point = this.end;
			var ch = (line.start.y - line.end.y) * point.x + (line.end.x - line.start.x) * point.y + (line.start.x * line.end.y - line.end.x * line.start.y);
			var del = Math.sqrt(Math.pow(line.end.x - line.start.x,2) + Math.pow(line.end.y - line.start.y,2));
			var d = ch / del;
			var distance4 = d;
			var values = [distance1,distance2,distance3,distance4];
			var min = values[0];
			var _g = 0;
			var _g1 = values.length;
			while(_g < _g1) {
				var i = _g++;
				if(values[i] < min) {
					min = values[i];
				}
			}
			var distance = min;
			return distance;
		}
	}
	,toString: function() {
		return "\n (" + this.start.x + ", " + this.start.y + ") --> (" + this.end.x + ", " + this.end.y + ")";
	}
	,toRay2D: function() {
		return new vision_ds_Ray2D(this.start,this.slope);
	}
	,set_start: function(value) {
		var point2 = this.end;
		var x = point2.x - value.x;
		var y = point2.y - value.y;
		this.radians = Math.atan2(x,y);
		this.slope = Math.tan(this.radians);
		this.degrees = this.radians * 180 / Math.PI;
		return this.start = value;
	}
	,set_end: function(value) {
		var point2 = this.end;
		var x = point2.x - value.x;
		var y = point2.y - value.y;
		this.radians = Math.atan2(x,y);
		this.slope = Math.tan(this.radians);
		this.degrees = this.radians * 180 / Math.PI;
		return this.end = value;
	}
	,get_middle: function() {
		return new vision_ds_Point2D((this.start.x + this.end.x) / 2,(this.start.y + this.end.y) / 2);
	}
	,set_middle: function(value) {
		var x = (this.start.x + this.end.x) / 2;
		var y = (this.start.y + this.end.y) / 2;
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		var previousMiddle_x = x;
		var previousMiddle_y = y;
		var diffX = value.x - previousMiddle_x;
		var diffY = value.y - previousMiddle_y;
		this.start.y += diffY;
		this.end.y += diffY;
		this.start.x += diffX;
		this.end.x += diffX;
		return new vision_ds_Point2D((this.start.x + this.end.x) / 2,(this.start.y + this.end.y) / 2);
	}
	,__class__: vision_ds_Line2D
	,__properties__: {set_middle:"set_middle",get_middle:"get_middle",set_end:"set_end",set_start:"set_start",get_length:"get_length"}
};
var vision_ds_Matrix2D = {};
vision_ds_Matrix2D.__properties__ = {set_columns:"set_columns",get_columns:"get_columns",set_rows:"set_rows",get_rows:"get_rows",set_underlying:"set_underlying",get_underlying:"get_underlying"};
vision_ds_Matrix2D.get_underlying = function(this1) {
	return this1;
};
vision_ds_Matrix2D.set_underlying = function(this1,arr2d) {
	this1 = arr2d;
	return this1;
};
vision_ds_Matrix2D.get_rows = function(this1) {
	return this1.height;
};
vision_ds_Matrix2D.set_rows = function(this1,amount) {
	this1.inner.length = this1.width * amount;
	return this1.height = amount;
};
vision_ds_Matrix2D.get_columns = function(this1) {
	return this1.width;
};
vision_ds_Matrix2D.set_columns = function(this1,amount) {
	this1.inner.length = amount * this1.height;
	return this1.width = amount;
};
vision_ds_Matrix2D._new = function(width,height) {
	return new vision_ds_Array2D(width,height);
};
vision_ds_Matrix2D.invert = function(this1) {
	this1 = vision_algorithms_GaussJordan.invert(this1);
	return this1;
};
vision_ds_Matrix2D.getDeterminant = function(this1) {
	var len = this1.width;
	switch(len) {
	case 0:
		return 1;
	case 1:
		return this1.inner[0 * this1.width];
	case 2:
		return this1.inner[0 * this1.width] * this1.inner[this1.width + 1] - this1.inner[this1.width] * this1.inner[0 * this1.width + 1];
	default:
		var determinantSum = 0.;
		var sign = 1;
		var _g = 0;
		var _g1 = this1.width;
		while(_g < _g1) {
			var i = _g++;
			var current = this1.inner[0 * this1.width + i];
			var fromX = 0;
			var fromY = 1;
			var toX = null;
			var toY = null;
			if(fromY == null) {
				fromY = 0;
			}
			if(fromX == null) {
				fromX = 0;
			}
			var copy = this1.to2DArray();
			if(toX == null) {
				toX = this1.width;
			}
			if(toY == null) {
				toY = this1.height;
			}
			var _g2 = 0;
			var _g3 = fromY;
			while(_g2 < _g3) {
				var _ = _g2++;
				copy.shift();
			}
			var _g4 = toX;
			var _g5 = copy.length;
			while(_g4 < _g5) {
				var _1 = _g4++;
				copy.pop();
			}
			var _g6 = 0;
			while(_g6 < copy.length) {
				var row = copy[_g6];
				++_g6;
				var _g7 = 0;
				var _g8 = fromX;
				while(_g7 < _g8) {
					var _2 = _g7++;
					row.shift();
				}
				var _g9 = toY;
				var _g10 = row.length;
				while(_g9 < _g10) {
					var _3 = _g9++;
					row.pop();
				}
			}
			var childMatrix;
			if(copy.length == 0) {
				childMatrix = new vision_ds_Array2D(0,0);
			} else {
				var arr2d = new vision_ds_Array2D(copy[0].length,copy.length);
				var flat = [];
				var _g11 = 0;
				while(_g11 < copy.length) {
					var item = copy[_g11];
					++_g11;
					flat = flat.concat(item);
				}
				arr2d.inner = flat;
				childMatrix = arr2d;
			}
			var underlyingArray = childMatrix.inner.slice();
			var _g12 = 0;
			var _g13 = childMatrix.height;
			while(_g12 < _g13) {
				var i1 = _g12++;
				underlyingArray[i + i1 * childMatrix.width] = null;
			}
			var _g14 = [];
			var _g15 = 0;
			var _g16 = underlyingArray;
			while(_g15 < _g16.length) {
				var v = _g16[_g15];
				++_g15;
				if(v != null) {
					_g14.push(v);
				}
			}
			underlyingArray = _g14;
			var value = childMatrix.width - 1;
			childMatrix.inner.length = value * childMatrix.height;
			childMatrix.width = value;
			childMatrix.inner = underlyingArray;
			determinantSum += sign * current * vision_ds_Matrix2D.getDeterminant(childMatrix);
			sign *= -1;
		}
		return determinantSum;
	}
};
vision_ds_Matrix2D.getTrace = function(this1) {
	if(this1.width != this1.height) {
		throw haxe_Exception.thrown("");
	}
	var sum = 0.;
	var _g = 0;
	var _g1 = this1.width;
	while(_g < _g1) {
		var i = _g++;
		sum += this1.inner[i * this1.width + i];
	}
	return sum;
};
vision_ds_Matrix2D.multiplyWithScalar = function(this1,scalar) {
	var _g = 0;
	var _g1 = this1.inner.length;
	while(_g < _g1) {
		var i = _g++;
		this1.inner[i] *= scalar;
	}
	return this1;
};
vision_ds_Matrix2D.clone = function(this1) {
	var arr = new vision_ds_Array2D(this1.width,this1.height);
	arr.inner = this1.inner.slice();
	return arr;
};
vision_ds_Matrix2D.map = function(this1,mappingFunction) {
	var m = new vision_ds_Array2D(this1.width,this1.height);
	var _g = 0;
	var _g1 = this1.inner.length;
	while(_g < _g1) {
		var i = _g++;
		m.inner[i] = mappingFunction(this1.inner[i]);
	}
	return m;
};
vision_ds_Matrix2D.getSubMatrix = function(this1,fromX,fromY,toX,toY) {
	if(fromY == null) {
		fromY = 0;
	}
	if(fromX == null) {
		fromX = 0;
	}
	var copy = this1.to2DArray();
	if(toX == null) {
		toX = this1.width;
	}
	if(toY == null) {
		toY = this1.height;
	}
	var _g = 0;
	var _g1 = fromY;
	while(_g < _g1) {
		var _ = _g++;
		copy.shift();
	}
	var _g = toX;
	var _g1 = copy.length;
	while(_g < _g1) {
		var _ = _g++;
		copy.pop();
	}
	var _g = 0;
	while(_g < copy.length) {
		var row = copy[_g];
		++_g;
		var _g1 = 0;
		var _g2 = fromX;
		while(_g1 < _g2) {
			var _ = _g1++;
			row.shift();
		}
		var _g3 = toY;
		var _g4 = row.length;
		while(_g3 < _g4) {
			var _1 = _g3++;
			row.pop();
		}
	}
	if(copy.length == 0) {
		return new vision_ds_Array2D(0,0);
	}
	var arr2d = new vision_ds_Array2D(copy[0].length,copy.length);
	var flat = [];
	var _g = 0;
	while(_g < copy.length) {
		var item = copy[_g];
		++_g;
		flat = flat.concat(item);
	}
	arr2d.inner = flat;
	return arr2d;
};
vision_ds_Matrix2D.getColumn = function(this1,x) {
	var _g = [];
	var _g1 = 0;
	var _g2 = this1.height;
	while(_g1 < _g2) {
		var i = _g1++;
		_g.push(this1.inner[i * this1.width + x]);
	}
	return _g;
};
vision_ds_Matrix2D.getRow = function(this1,y) {
	var _g = [];
	var _g1 = y * this1.width;
	var _g2 = y * this1.width + this1.width;
	while(_g1 < _g2) {
		var i = _g1++;
		_g.push(this1.inner[i]);
	}
	return _g;
};
vision_ds_Matrix2D.setColumn = function(this1,x,arr) {
	if(arr.length < this1.height) {
		throw haxe_Exception.thrown("");
	}
	var _g = 0;
	var _g1 = this1.height;
	while(_g < _g1) {
		var y = _g++;
		this1.inner[x + y * this1.width] = arr[y];
	}
};
vision_ds_Matrix2D.setRow = function(this1,y,arr) {
	if(arr.length < this1.width) {
		throw haxe_Exception.thrown("");
	}
	var _g = 0;
	var _g1 = this1.width;
	while(_g < _g1) {
		var x = _g++;
		this1.inner[x + y * this1.width] = arr[x];
	}
};
vision_ds_Matrix2D.insertColumn = function(this1,x,arr) {
	var n = new vision_ds_Array2D(this1.width + 1,this1.height);
	var _g = 0;
	var _g1 = this1.height;
	while(_g < _g1) {
		var y = _g++;
		var _g2 = 0;
		var _g3 = x;
		while(_g2 < _g3) {
			var i = _g2++;
			n.inner[i + y * n.width] = this1.inner[y * this1.width + i];
		}
		var _g4 = x;
		var _g5 = this1.width;
		while(_g4 < _g5) {
			var i1 = _g4++;
			n.inner[i1 + 1 + y * n.width] = this1.inner[y * this1.width + i1];
		}
		n.inner[x + y * n.width] = arr[y];
	}
	this1 = n;
	return this1;
};
vision_ds_Matrix2D.insertRow = function(this1,y,arr) {
	var n = new vision_ds_Array2D(this1.width,this1.height + 1);
	var _g = 0;
	var _g1 = this1.width;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = y;
		while(_g2 < _g3) {
			var i = _g2++;
			n.inner[x + i * n.width] = this1.inner[i * this1.width + x];
		}
		var _g4 = y;
		var _g5 = this1.height;
		while(_g4 < _g5) {
			var i1 = _g4++;
			n.inner[x + (i1 + 1) * n.width] = this1.inner[i1 * this1.width + x];
		}
		n.inner[x + y * n.width] = arr[x];
	}
	this1 = n;
	return this1;
};
vision_ds_Matrix2D.removeColumn = function(this1,x) {
	var underlyingArray = this1.inner.slice();
	var _g = 0;
	var _g1 = this1.height;
	while(_g < _g1) {
		var i = _g++;
		underlyingArray[x + i * this1.width] = null;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = underlyingArray;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null) {
			_g.push(v);
		}
	}
	underlyingArray = _g;
	var value = this1.width - 1;
	this1.inner.length = value * this1.height;
	this1.width = value;
	this1.inner = underlyingArray;
	return this1;
};
vision_ds_Matrix2D.removeRow = function(this1,y) {
	var underlyingArray = this1.inner.slice();
	var _g = 0;
	var _g1 = this1.width;
	while(_g < _g1) {
		var i = _g++;
		underlyingArray[y + this1.width * i] = null;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = underlyingArray;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null) {
			_g.push(v);
		}
	}
	underlyingArray = _g;
	var value = this1.height - 1;
	this1.inner.length = this1.width * value;
	this1.height = value;
	this1.inner = underlyingArray;
	return this1;
};
vision_ds_Matrix2D.toString = function(this1,precision,pretty) {
	if(pretty == null) {
		pretty = true;
	}
	if(precision == null) {
		precision = 5;
	}
	if(!pretty) {
		var str = "\n[[";
		var counter = 0;
		var _g = 0;
		var _g1 = this1.inner;
		while(_g < _g1.length) {
			var item = _g1[_g];
			++_g;
			if(counter < this1.width) {
				var add = ", " + Std.string(item);
				if(counter == 0) {
					add = HxOverrides.substr(add,2,null);
				}
				str += add;
				++counter;
			} else {
				counter = 0;
				str += "],\n [";
				var add1 = "" + Std.string(item);
				str += add1;
				++counter;
			}
		}
		return str.substring(0,str.length) + "]]";
	}
	var maxLen = 1;
	var _g = 0;
	var _g1 = this1.inner;
	while(_g < _g1.length) {
		var item = _g1[_g];
		++_g;
		var len;
		if(precision == -1) {
			len = (item == null ? "null" : "" + item).length;
		} else {
			var multiplier = Math.pow(10,precision);
			len = Std.string(Math.round(item * multiplier) / multiplier).length;
		}
		if(len > maxLen) {
			maxLen = len;
		}
	}
	++maxLen;
	var st = "";
	var _g = 0;
	var _g1 = maxLen * this1.width + 2 * (this1.width - 1) - 1;
	while(_g < _g1) {
		var i = _g++;
		st += " ";
	}
	var top = "\n " + st + " ";
	var st = "";
	var _g = 0;
	var _g1 = maxLen * this1.width + 2 * (this1.width - 1) - 1;
	while(_g < _g1) {
		var i = _g++;
		st += " ";
	}
	var bottom = " " + st + " ";
	var rows = [""];
	var counter = 0;
	var floor = 0;
	var _g = 0;
	var _g1 = this1.inner;
	while(_g < _g1.length) {
		var item = _g1[_g];
		++_g;
		if(counter < this1.width) {
			var itemString;
			if(precision != -1) {
				var multiplier = Math.pow(10,precision);
				itemString = Math.round(item * multiplier) / multiplier;
			} else {
				itemString = item;
			}
			var itemString1 = Std.string(itemString);
			var add;
			if(precision != -1) {
				var multiplier1 = Math.pow(10,precision);
				add = item != Math.round(item * multiplier1) / multiplier1;
			} else {
				add = false;
			}
			if(add) {
				itemString1 += "";
			}
			if(itemString1.length < maxLen) {
				var st = "";
				var _g2 = 0;
				var _g3 = Math.floor((maxLen - itemString1.length) / 2);
				while(_g2 < _g3) {
					var i = _g2++;
					st += " ";
				}
				var itemString2 = st + itemString1;
				var st1 = "";
				var _g4 = 0;
				var _g5 = Math.ceil((maxLen - itemString1.length) / 2);
				while(_g4 < _g5) {
					var i1 = _g4++;
					st1 += " ";
				}
				itemString1 = itemString2 + st1;
			}
			var add1 = ", " + itemString1;
			if(counter == 0) {
				add1 = HxOverrides.substr(add1,2,null);
			}
			rows[floor] += add1;
			++counter;
		} else {
			counter = 0;
			++floor;
			rows[floor] = "";
			var itemString3;
			if(precision != -1) {
				var multiplier2 = Math.pow(10,precision);
				itemString3 = Math.round(item * multiplier2) / multiplier2;
			} else {
				itemString3 = item;
			}
			var itemString4 = Std.string(itemString3);
			var add2;
			if(precision != -1) {
				var multiplier3 = Math.pow(10,precision);
				add2 = item != Math.round(item * multiplier3) / multiplier3;
			} else {
				add2 = false;
			}
			if(add2) {
				itemString4 += "";
			}
			if(itemString4.length < maxLen) {
				var st2 = "";
				var _g6 = 0;
				var _g7 = Math.floor((maxLen - itemString4.length) / 2);
				while(_g6 < _g7) {
					var i2 = _g6++;
					st2 += " ";
				}
				var itemString5 = st2 + itemString4;
				var st3 = "";
				var _g8 = 0;
				var _g9 = Math.ceil((maxLen - itemString4.length) / 2);
				while(_g8 < _g9) {
					var i3 = _g8++;
					st3 += " ";
				}
				itemString4 = itemString5 + st3;
			}
			var add3 = "" + itemString4;
			rows[floor] += add3;
			++counter;
		}
	}
	var string = top + "\n";
	var _g = 0;
	while(_g < rows.length) {
		var r = rows[_g];
		++_g;
		string += " " + r + "\n";
	}
	string += bottom;
	return string;
};
vision_ds_Matrix2D.IDENTITY = function() {
	var homogeneousRow = [0,0,1];
	if(homogeneousRow == null) {
		homogeneousRow = [0,0,1];
	}
	var arr = new vision_ds_Array2D(3,3,null);
	arr.inner = [1,0,0].concat([0,1,0]).concat(homogeneousRow);
	return vision_ds_TransformationMatrix2D.fromMatrix2D(arr);
};
vision_ds_Matrix2D.ROTATION = function(angle,degrees,origin) {
	if(degrees == null) {
		degrees = true;
	}
	var xRow = degrees ? Math.cos(angle * Math.PI / 180) : Math.cos(angle);
	var xRow1 = degrees ? -Math.sin(angle * Math.PI / 180) : -Math.sin(angle);
	var xRow2 = origin != null ? origin.x : 0;
	var yRow = degrees ? Math.sin(angle * Math.PI / 180) : Math.sin(angle);
	var yRow1 = degrees ? Math.cos(angle * Math.PI / 180) : Math.cos(angle);
	var yRow2 = origin != null ? origin.y : 0;
	var homogeneousRow = [0,0,1];
	if(homogeneousRow == null) {
		homogeneousRow = [0,0,1];
	}
	var arr = new vision_ds_Array2D(3,3,null);
	arr.inner = [xRow,xRow1,xRow2].concat([yRow,yRow1,yRow2]).concat(homogeneousRow);
	return vision_ds_TransformationMatrix2D.fromMatrix2D(arr);
};
vision_ds_Matrix2D.TRANSLATION = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	var homogeneousRow = [0,0,1];
	if(homogeneousRow == null) {
		homogeneousRow = [0,0,1];
	}
	var arr = new vision_ds_Array2D(3,3,null);
	arr.inner = [1,0,x].concat([0,1,y]).concat(homogeneousRow);
	return vision_ds_TransformationMatrix2D.fromMatrix2D(arr);
};
vision_ds_Matrix2D.SCALE = function(scaleX,scaleY) {
	if(scaleY == null) {
		scaleY = 1;
	}
	if(scaleX == null) {
		scaleX = 1;
	}
	var homogeneousRow = [0,0,1];
	if(homogeneousRow == null) {
		homogeneousRow = [0,0,1];
	}
	var arr = new vision_ds_Array2D(3,3,null);
	arr.inner = [scaleX,0,0].concat([0,scaleY,0]).concat(homogeneousRow);
	return vision_ds_TransformationMatrix2D.fromMatrix2D(arr);
};
vision_ds_Matrix2D.SHEAR = function(shearX,shearY) {
	if(shearY == null) {
		shearY = 0;
	}
	if(shearX == null) {
		shearX = 0;
	}
	var homogeneousRow = [0,0,1];
	if(homogeneousRow == null) {
		homogeneousRow = [0,0,1];
	}
	var arr = new vision_ds_Array2D(3,3,null);
	arr.inner = [1,shearX,0].concat([shearY,1,0]).concat(homogeneousRow);
	return vision_ds_TransformationMatrix2D.fromMatrix2D(arr);
};
vision_ds_Matrix2D.REFLECTION = function(angle,degrees,origin) {
	if(degrees == null) {
		degrees = true;
	}
	angle *= 2;
	var xRow = degrees ? Math.cos(angle * Math.PI / 180) : Math.cos(angle);
	var xRow1 = degrees ? Math.sin(angle * Math.PI / 180) : Math.sin(angle);
	var xRow2 = origin != null ? origin.x : 0;
	var yRow = degrees ? Math.sin(angle * Math.PI / 180) : Math.sin(angle);
	var yRow1 = degrees ? -Math.cos(angle * Math.PI / 180) : -Math.cos(angle);
	var yRow2 = origin != null ? origin.y : 0;
	var homogeneousRow = [0,0,1];
	if(homogeneousRow == null) {
		homogeneousRow = [0,0,1];
	}
	var arr = new vision_ds_Array2D(3,3,null);
	arr.inner = [xRow,xRow1,xRow2].concat([yRow,yRow1,yRow2]).concat(homogeneousRow);
	return vision_ds_TransformationMatrix2D.fromMatrix2D(arr);
};
vision_ds_Matrix2D.PERSPECTIVE = function(pointPairs) {
	var src = [];
	var dst = [];
	var _g = 0;
	while(_g < pointPairs.length) {
		var pair = pointPairs[_g];
		++_g;
		src.push(pair.from);
		dst.push(pair.to);
	}
	return vision_ds_TransformationMatrix2D.fromMatrix2D(vision_algorithms_PerspectiveWarp.generateMatrix(src,dst));
};
vision_ds_Matrix2D.DEPTH = function(z,towards) {
	var xRow = towards != null ? towards.x * (z - 1) : 0;
	var yRow = towards != null ? towards.y * (z - 1) : 0;
	var homogeneousRow = [0,0,z];
	if(homogeneousRow == null) {
		homogeneousRow = [0,0,1];
	}
	var arr = new vision_ds_Array2D(3,3,null);
	arr.inner = [1,0,xRow].concat([0,1,yRow]).concat(homogeneousRow);
	return arr;
};
vision_ds_Matrix2D.createFilled = function() {
	var $l=arguments.length;
	var rows = new Array($l>0?$l-0:0);
	for(var $i=0;$i<$l;++$i){rows[$i-0]=arguments[$i];}
	var arr = new vision_ds_Array2D(rows[0].length,rows.length);
	arr.inner = [];
	var _g_current = 0;
	var _g_args = rows;
	while(_g_current < _g_args.length) {
		var r = _g_args[_g_current++];
		arr.inner = arr.inner.concat(r);
	}
	return arr;
};
vision_ds_Matrix2D.createTransformation = function(xRow,yRow,homogeneousRow) {
	if(homogeneousRow == null) {
		homogeneousRow = [0,0,1];
	}
	var arr = new vision_ds_Array2D(3,3,null);
	arr.inner = xRow.concat(yRow).concat(homogeneousRow);
	return arr;
};
vision_ds_Matrix2D.multiplyMatrices = function(a,b) {
	if(a.width != b.height) {
		throw haxe_Exception.thrown(new vision_exceptions_MatrixOperationError("mult",[a,b],0));
	}
	var result = new vision_ds_Array2D(b.width,a.height);
	var _g = 0;
	var _g1 = a.height;
	while(_g < _g1) {
		var y = _g++;
		var _g2 = 0;
		var _g3 = b.width;
		while(_g2 < _g3) {
			var x = _g2++;
			var sum = 0.;
			var _g4 = 0;
			var _g5 = a.width;
			while(_g4 < _g5) {
				var k = _g4++;
				sum += a.inner[y * a.width + k] * b.inner[k * b.width + x];
			}
			result.inner[x + y * result.width] = sum;
		}
	}
	return result;
};
vision_ds_Matrix2D.addMatrices = function(a,b) {
	if(a.height != b.height || a.width != b.width) {
		throw haxe_Exception.thrown(new vision_exceptions_MatrixOperationError("add",[a,b],1));
	}
	var result = new vision_ds_Array2D(a.width,b.height);
	var _g = 0;
	var _g1 = result.width;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = result.height;
		while(_g2 < _g3) {
			var y = _g2++;
			result.inner[x + y * result.width] = a.inner[y * a.width + x] + b.inner[y * b.width + x];
		}
	}
	return result;
};
vision_ds_Matrix2D.subtractMatrices = function(a,b) {
	if(a.height != b.height || a.width != b.width) {
		throw haxe_Exception.thrown(new vision_exceptions_MatrixOperationError("sub",[a,b],2));
	}
	var result = new vision_ds_Array2D(a.width,b.height);
	var _g = 0;
	var _g1 = result.width;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = result.height;
		while(_g2 < _g3) {
			var y = _g2++;
			result.inner[x + y * result.width] = a.inner[y * a.width + x] - b.inner[y * b.width + x];
		}
	}
	return result;
};
vision_ds_Matrix2D.divideMatrices = function(a,b) {
	if(a.width != b.height) {
		throw haxe_Exception.thrown(new vision_exceptions_MatrixOperationError("div",[a,b],3));
	}
	var result = new vision_ds_Array2D(b.width,a.height);
	var _g = 0;
	var _g1 = a.height;
	while(_g < _g1) {
		var y = _g++;
		var _g2 = 0;
		var _g3 = b.width;
		while(_g2 < _g3) {
			var x = _g2++;
			var sum = 0.;
			var _g4 = 0;
			var _g5 = a.width;
			while(_g4 < _g5) {
				var k = _g4++;
				sum += a.inner[y * a.width + k] / b.inner[k * b.width + x];
			}
			result.inner[x + y * result.width] = sum;
		}
	}
	return result;
};
vision_ds_Matrix2D.multiply = function(this1,b) {
	if(this1.width != b.height) {
		throw haxe_Exception.thrown(new vision_exceptions_MatrixOperationError("mult",[this1,b],0));
	}
	var result = new vision_ds_Array2D(b.width,this1.height);
	var _g = 0;
	var _g1 = this1.height;
	while(_g < _g1) {
		var y = _g++;
		var _g2 = 0;
		var _g3 = b.width;
		while(_g2 < _g3) {
			var x = _g2++;
			var sum = 0.;
			var _g4 = 0;
			var _g5 = this1.width;
			while(_g4 < _g5) {
				var k = _g4++;
				sum += this1.inner[y * this1.width + k] * b.inner[k * b.width + x];
			}
			result.inner[x + y * result.width] = sum;
		}
	}
	this1 = result;
	return this1;
};
vision_ds_Matrix2D.add = function(this1,b) {
	if(this1.height != b.height || this1.width != b.width) {
		throw haxe_Exception.thrown(new vision_exceptions_MatrixOperationError("add",[this1,b],1));
	}
	var _g = 0;
	var _g1 = this1.width;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = this1.height;
		while(_g2 < _g3) {
			var y = _g2++;
			this1.inner[x + y * this1.width] = this1.inner[y * this1.width + x] + b.inner[y * b.width + x];
		}
	}
	return this1;
};
vision_ds_Matrix2D.subtract = function(this1,b) {
	if(this1.height != b.height || this1.width != b.width) {
		throw haxe_Exception.thrown(new vision_exceptions_MatrixOperationError("sub",[this1,b],2));
	}
	var _g = 0;
	var _g1 = this1.width;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = this1.height;
		while(_g2 < _g3) {
			var y = _g2++;
			this1.inner[x + y * this1.width] = this1.inner[y * this1.width + x] - b.inner[y * b.width + x];
		}
	}
	return this1;
};
vision_ds_Matrix2D.divide = function(this1,b) {
	if(this1.width != b.height) {
		throw haxe_Exception.thrown(new vision_exceptions_MatrixOperationError("div",[this1,b],3));
	}
	var result = new vision_ds_Array2D(b.width,this1.height);
	var _g = 0;
	var _g1 = this1.height;
	while(_g < _g1) {
		var y = _g++;
		var _g2 = 0;
		var _g3 = b.width;
		while(_g2 < _g3) {
			var x = _g2++;
			var sum = 0.;
			var _g4 = 0;
			var _g5 = this1.width;
			while(_g4 < _g5) {
				var k = _g4++;
				sum += this1.inner[y * this1.width + k] * b.inner[k * b.width + x];
			}
			result.inner[x + y * result.width] = sum;
		}
	}
	this1 = result;
	return this1;
};
vision_ds_Matrix2D.to_array_array_float = function(this1) {
	var array = this1.inner;
	var delimiter = this1.width;
	var raised = [];
	var _g = 0;
	var _g1 = array.length;
	while(_g < _g1) {
		var i = _g++;
		if(raised[Math.floor(i / delimiter)] == null) {
			raised[Math.floor(i / delimiter)] = [];
		}
		raised[Math.floor(i / delimiter)][i % delimiter] = array[i];
	}
	return raised;
};
vision_ds_Matrix2D.from_array_array_float = function(array) {
	var arr2d = new vision_ds_Array2D(array[0].length,array.length);
	var flat = [];
	var _g = 0;
	while(_g < array.length) {
		var item = array[_g];
		++_g;
		flat = flat.concat(item);
	}
	arr2d.inner = flat;
	return arr2d;
};
vision_ds_Matrix2D.from_array_array_int = function(array) {
	var arr2d = new vision_ds_Array2D(array[0].length,array.length);
	var flat = [];
	var _g = 0;
	while(_g < array.length) {
		var item = array[_g];
		++_g;
		flat = flat.concat(item);
	}
	arr2d.inner = flat;
	return arr2d;
};
var vision_ds_Pixel = function(x,y,color) {
	this.x = x;
	this.y = y;
	this.color = color;
};
$hxClasses["vision.ds.Pixel"] = vision_ds_Pixel;
vision_ds_Pixel.__name__ = "vision.ds.Pixel";
vision_ds_Pixel.prototype = {
	x: null
	,y: null
	,color: null
	,__class__: vision_ds_Pixel
};
var vision_ds_PixelFormat = {};
vision_ds_PixelFormat.convertPixelFormat = function(bytes,from,to) {
	if(to == null) {
		to = 0;
	}
	if(from == to) {
		return bytes;
	}
	var i = 0;
	while(i < bytes.length) {
		var red;
		if(from == 1 || from == 4) {
			red = bytes.b[i];
		} else if(from == 0) {
			red = bytes.b[i + 1];
		} else if(from == 5 || from == 3) {
			red = bytes.b[i + 2];
		} else if(from == 2) {
			red = bytes.b[i + 3];
		} else {
			throw haxe_Exception.thrown(new vision_exceptions_VisionException("Unknown Pixel Format","Pixel Conversion"));
		}
		var green;
		if(from == 5 || from == 3 || from == 4 || from == 1) {
			green = bytes.b[i + 1];
		} else if(from == 2 || from == 0) {
			green = bytes.b[i + 2];
		} else {
			throw haxe_Exception.thrown(new vision_exceptions_VisionException("Unknown Pixel Format","Pixel Conversion"));
		}
		var blue;
		if(from == 5 || from == 3) {
			blue = bytes.b[i];
		} else if(from == 2) {
			blue = bytes.b[i + 1];
		} else if(from == 4 || from == 1) {
			blue = bytes.b[i + 2];
		} else if(from == 0) {
			blue = bytes.b[i + 3];
		} else {
			throw haxe_Exception.thrown(new vision_exceptions_VisionException("Unknown Pixel Format","Pixel Conversion"));
		}
		var alpha = from == 0 || from == 2 ? bytes.b[i] : from == 1 || from == 3 ? bytes.b[i + 3] : -1;
		var redIndex;
		if(to == 1 || to == 4) {
			redIndex = i;
		} else if(to == 0) {
			redIndex = i + 1;
		} else if(to == 5 || to == 3) {
			redIndex = i + 2;
		} else if(to == 2) {
			redIndex = i + 3;
		} else {
			throw haxe_Exception.thrown(new vision_exceptions_VisionException("Unknown Pixel Format","Pixel Conversion"));
		}
		var greenIndex;
		if(to == 5 || to == 3 || to == 4 || to == 1) {
			greenIndex = i + 1;
		} else if(to == 2 || to == 0) {
			greenIndex = i + 2;
		} else {
			throw haxe_Exception.thrown(new vision_exceptions_VisionException("Unknown Pixel Format","Pixel Conversion"));
		}
		var blueIndex;
		if(to == 5 || to == 3) {
			blueIndex = i;
		} else if(to == 2) {
			blueIndex = i + 1;
		} else if(to == 4 || to == 1) {
			blueIndex = i + 2;
		} else if(to == 0) {
			blueIndex = i + 3;
		} else {
			throw haxe_Exception.thrown(new vision_exceptions_VisionException("Unknown Pixel Format","Pixel Conversion"));
		}
		var alphaIndex = to == 0 || to == 2 ? i : to == 1 || to == 3 ? i + 3 : -1;
		bytes.b[redIndex] = red;
		bytes.b[greenIndex] = green;
		bytes.b[blueIndex] = blue;
		if(alphaIndex != -1) {
			bytes.b[alphaIndex] = alpha;
		}
		if(from > 3) {
			i += 3;
		} else {
			i += 4;
		}
	}
	return bytes;
};
var vision_ds_Point2D = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
};
$hxClasses["vision.ds.Point2D"] = vision_ds_Point2D;
vision_ds_Point2D.__name__ = "vision.ds.Point2D";
vision_ds_Point2D.prototype = {
	x: null
	,y: null
	,toString: function() {
		return "(" + this.x + ", " + this.y + ")";
	}
	,copy: function() {
		return new vision_ds_Point2D(this.x,this.y);
	}
	,distanceTo: function(point) {
		var x = point.x - this.x;
		var y = point.y - this.y;
		return Math.sqrt(x * x + y * y);
	}
	,degreesTo: function(point) {
		var x = point.x - this.x;
		var y = point.y - this.y;
		return Math.atan2(x,y) * 180 / Math.PI;
	}
	,radiansTo: function(point) {
		var x = point.x - this.x;
		var y = point.y - this.y;
		return Math.atan2(x,y) * 180 / Math.PI;
	}
	,__class__: vision_ds_Point2D
};
var vision_ds_Point3D = function(x,y,z) {
	this.x = x;
	this.y = y;
	this.z = z;
};
$hxClasses["vision.ds.Point3D"] = vision_ds_Point3D;
vision_ds_Point3D.__name__ = "vision.ds.Point3D";
vision_ds_Point3D.prototype = {
	x: null
	,y: null
	,z: null
	,distanceTo: function(point) {
		var x = point.x - this.x;
		var y = point.y - this.y;
		var z = point.z - this.z;
		return Math.sqrt(x * x + y * y + z * z);
	}
	,copy: function() {
		return new vision_ds_Point3D(this.x,this.y,this.z);
	}
	,toString: function() {
		return "(" + this.x + ", " + this.y + ", " + this.z + ")";
	}
	,__class__: vision_ds_Point3D
};
var vision_ds_QueueCell = function(value,next,previous) {
	this.previous = previous;
	this.value = value;
	this.next = next;
};
$hxClasses["vision.ds.QueueCell"] = vision_ds_QueueCell;
vision_ds_QueueCell.__name__ = "vision.ds.QueueCell";
vision_ds_QueueCell.prototype = {
	previous: null
	,value: null
	,next: null
	,getValue: function() {
		return this.value;
	}
	,__class__: vision_ds_QueueCell
};
var vision_ds_Ray2D = function(point,m,degrees,radians) {
	this.point = point;
	if(m != null) {
		this.degrees = Math.atan(m) * 180 / Math.PI;
		this.radians = Math.atan(m);
		this.slope = m;
		var value = Math.atan(m) * 180 / Math.PI;
		this.slope = Math.tan(value * Math.PI / 180);
		this.radians = value * Math.PI / 180;
		this.degrees = value;
		var value = Math.atan(m);
		this.slope = Math.tan(value);
		this.degrees = value * 180 / Math.PI;
		this.radians = value;
	} else if(degrees != null) {
		this.slope = Math.tan(degrees * Math.PI / 180);
		this.radians = degrees * Math.PI / 180;
		this.degrees = degrees;
		var value = Math.tan(degrees * Math.PI / 180);
		this.degrees = Math.atan(value) * 180 / Math.PI;
		this.radians = Math.atan(value);
		this.slope = value;
		var value = degrees * Math.PI / 180;
		this.slope = Math.tan(value);
		this.degrees = value * 180 / Math.PI;
		this.radians = value;
	} else if(radians != null) {
		this.slope = Math.tan(radians);
		this.degrees = radians * 180 / Math.PI;
		this.radians = radians;
		var value = Math.tan(radians);
		this.degrees = Math.atan(value) * 180 / Math.PI;
		this.radians = Math.atan(value);
		this.slope = value;
		var value = radians * 180 / Math.PI;
		this.slope = Math.tan(value * Math.PI / 180);
		this.radians = value * Math.PI / 180;
		this.degrees = value;
	}
};
$hxClasses["vision.ds.Ray2D"] = vision_ds_Ray2D;
vision_ds_Ray2D.__name__ = "vision.ds.Ray2D";
vision_ds_Ray2D.from2Points = function(point1,point2) {
	var s = (point2.y - point1.y) / (point2.x - point1.x);
	return new vision_ds_Ray2D(point1,s);
};
vision_ds_Ray2D.prototype = {
	point: null
	,slope: null
	,degrees: null
	,radians: null
	,getPointAtX: function(x) {
		var px = this.point.x;
		var py = this.point.y;
		return new vision_ds_Point2D(x,this.slope * x + (px > 0 ? py - this.slope * px : py + this.slope * px));
	}
	,getPointAtY: function(y) {
		var px = this.point.x;
		var py = this.point.y;
		return new vision_ds_Point2D((y - (px > 0 ? py - this.slope * px : py + this.slope * px)) / this.slope,y);
	}
	,intersect: function(ray) {
		var line1StartX = this.point.x;
		var line1StartY = this.point.y;
		var line1EndX = this.point.x + Math.cos(this.radians) * 1000;
		var line1EndY = this.point.y + Math.sin(this.radians) * 1000;
		var line2StartX = ray.point.x;
		var line2StartY = ray.point.y;
		var line2EndX = ray.point.x + Math.cos(ray.radians) * 1000;
		var line2EndY = ray.point.y + Math.sin(ray.radians) * 1000;
		var a;
		var b;
		var numerator1;
		var numerator2;
		var result = null;
		var denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
		if(denominator == 0) {
			return result;
		} else {
			a = line1StartY - line2StartY;
			b = line1StartX - line2StartX;
			numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
			numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
			a = numerator1 / denominator;
			b = numerator2 / denominator;
			result = new vision_ds_Point2D();
			result.x = line1StartX + a * (line1EndX - line1StartX);
			result.y = line1StartY + a * (line1EndY - line1StartY);
			return result;
		}
	}
	,distanceTo: function(ray) {
		if(this.radians != ray.radians) {
			return 0;
		} else {
			var point = this.point;
			var ray2_slope;
			var ray2_radians;
			var ray2_degrees;
			var m = null;
			var degrees = this.degrees + 90;
			var radians = null;
			var ray2_point = point;
			if(m != null) {
				ray2_degrees = Math.atan(m) * 180 / Math.PI;
				ray2_radians = Math.atan(m);
				ray2_slope = m;
				var value = Math.atan(m) * 180 / Math.PI;
				ray2_slope = Math.tan(value * Math.PI / 180);
				ray2_radians = value * Math.PI / 180;
				ray2_degrees = value;
				var value = Math.atan(m);
				ray2_slope = Math.tan(value);
				ray2_degrees = value * 180 / Math.PI;
				ray2_radians = value;
			} else if(degrees != null) {
				ray2_slope = Math.tan(degrees * Math.PI / 180);
				ray2_radians = degrees * Math.PI / 180;
				ray2_degrees = degrees;
				var value = Math.tan(degrees * Math.PI / 180);
				ray2_degrees = Math.atan(value) * 180 / Math.PI;
				ray2_radians = Math.atan(value);
				ray2_slope = value;
				var value = degrees * Math.PI / 180;
				ray2_slope = Math.tan(value);
				ray2_degrees = value * 180 / Math.PI;
				ray2_radians = value;
			} else if(radians != null) {
				ray2_slope = Math.tan(radians);
				ray2_degrees = radians * 180 / Math.PI;
				ray2_radians = radians;
				var value = Math.tan(radians);
				ray2_degrees = Math.atan(value) * 180 / Math.PI;
				ray2_radians = Math.atan(value);
				ray2_slope = value;
				var value = radians * 180 / Math.PI;
				ray2_slope = Math.tan(value * Math.PI / 180);
				ray2_radians = value * Math.PI / 180;
				ray2_degrees = value;
			}
			var line1StartX = ray.point.x;
			var line1StartY = ray.point.y;
			var line1EndX = ray.point.x + Math.cos(ray.radians) * 1000;
			var line1EndY = ray.point.y + Math.sin(ray.radians) * 1000;
			var line2StartX = ray2_point.x;
			var line2StartY = ray2_point.y;
			var line2EndX = ray2_point.x + Math.cos(ray2_radians) * 1000;
			var line2EndY = ray2_point.y + Math.sin(ray2_radians) * 1000;
			var a;
			var b;
			var numerator1;
			var numerator2;
			var result = null;
			var denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
			var intersectionOfPerpendicularWithRay2;
			if(denominator == 0) {
				intersectionOfPerpendicularWithRay2 = result;
			} else {
				a = line1StartY - line2StartY;
				b = line1StartX - line2StartX;
				numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
				numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
				a = numerator1 / denominator;
				b = numerator2 / denominator;
				result = new vision_ds_Point2D();
				result.x = line1StartX + a * (line1EndX - line1StartX);
				result.y = line1StartY + a * (line1EndY - line1StartY);
				intersectionOfPerpendicularWithRay2 = result;
			}
			var x = intersectionOfPerpendicularWithRay2.x - point.x;
			var y = intersectionOfPerpendicularWithRay2.y - point.y;
			return Math.sqrt(x * x + y * y);
		}
	}
	,set_slope: function(value) {
		this.degrees = Math.atan(value) * 180 / Math.PI;
		this.radians = Math.atan(value);
		return this.slope = value;
	}
	,set_degrees: function(value) {
		this.slope = Math.tan(value * Math.PI / 180);
		this.radians = value * Math.PI / 180;
		return this.degrees = value;
	}
	,set_radians: function(value) {
		this.slope = Math.tan(value);
		this.degrees = value * 180 / Math.PI;
		return this.radians = value;
	}
	,get_yIntercept: function() {
		var px = this.point.x;
		var py = this.point.y;
		if(px > 0) {
			return py - this.slope * px;
		}
		return py + this.slope * px;
	}
	,get_xIntercept: function() {
		var px = this.point.x;
		var py = this.point.y;
		if(py > 0) {
			return (py - this.slope * px) / this.slope;
		}
		return (py + this.slope * px) / this.slope;
	}
	,__class__: vision_ds_Ray2D
	,__properties__: {get_xIntercept:"get_xIntercept",get_yIntercept:"get_yIntercept",set_radians:"set_radians",set_degrees:"set_degrees",set_slope:"set_slope"}
};
var vision_ds_Rectangle = function(x,y,width,height) {
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
};
$hxClasses["vision.ds.Rectangle"] = vision_ds_Rectangle;
vision_ds_Rectangle.__name__ = "vision.ds.Rectangle";
vision_ds_Rectangle.prototype = {
	x: null
	,y: null
	,width: null
	,height: null
	,__class__: vision_ds_Rectangle
};
var vision_ds_TransformationMatrix2D = {};
vision_ds_TransformationMatrix2D.__properties__ = {set_ty:"set_ty",get_ty:"get_ty",set_tx:"set_tx",get_tx:"get_tx",set_f:"set_f",get_f:"get_f",set_e:"set_e",get_e:"get_e",set_d:"set_d",get_d:"get_d",set_c:"set_c",get_c:"get_c",set_b:"set_b",get_b:"get_b",set_a:"set_a",get_a:"get_a",get_underlying:"get_underlying"};
vision_ds_TransformationMatrix2D.get_underlying = function(this1) {
	return this1;
};
vision_ds_TransformationMatrix2D.get_a = function(this1) {
	return this1.inner[0 * this1.width];
};
vision_ds_TransformationMatrix2D.set_a = function(this1,a) {
	return this1.inner[0 * this1.width] = a;
};
vision_ds_TransformationMatrix2D.get_b = function(this1) {
	return this1.inner[this1.width];
};
vision_ds_TransformationMatrix2D.set_b = function(this1,b) {
	return this1.inner[this1.width] = b;
};
vision_ds_TransformationMatrix2D.get_c = function(this1) {
	return this1.inner[0 * this1.width + 1];
};
vision_ds_TransformationMatrix2D.set_c = function(this1,c) {
	return this1.inner[1 + 0 * this1.width] = c;
};
vision_ds_TransformationMatrix2D.get_d = function(this1) {
	return this1.inner[this1.width + 1];
};
vision_ds_TransformationMatrix2D.set_d = function(this1,d) {
	return this1.inner[1 + this1.width] = d;
};
vision_ds_TransformationMatrix2D.get_e = function(this1) {
	return this1.inner[2 * this1.width];
};
vision_ds_TransformationMatrix2D.set_e = function(this1,e) {
	return this1.inner[2 * this1.width] = e;
};
vision_ds_TransformationMatrix2D.get_f = function(this1) {
	return this1.inner[2 * this1.width + 1];
};
vision_ds_TransformationMatrix2D.set_f = function(this1,f) {
	return this1.inner[1 + 2 * this1.width] = f;
};
vision_ds_TransformationMatrix2D.get_tx = function(this1) {
	return this1.inner[0 * this1.width + 2];
};
vision_ds_TransformationMatrix2D.set_tx = function(this1,tx) {
	return this1.inner[2 + 0 * this1.width] = tx;
};
vision_ds_TransformationMatrix2D.get_ty = function(this1) {
	return this1.inner[this1.width + 2];
};
vision_ds_TransformationMatrix2D.set_ty = function(this1,ty) {
	return this1.inner[2 + this1.width] = ty;
};
vision_ds_TransformationMatrix2D._new = function(m) {
	return m;
};
vision_ds_TransformationMatrix2D.fromMatrix2D = function(m) {
	return vision_ds_TransformationMatrix2D._new(m);
};
var vision_ds_specifics_PointTransformationPair = function(from,to) {
	this.from = from;
	this.to = to;
};
$hxClasses["vision.ds.specifics.PointTransformationPair"] = vision_ds_specifics_PointTransformationPair;
vision_ds_specifics_PointTransformationPair.__name__ = "vision.ds.specifics.PointTransformationPair";
vision_ds_specifics_PointTransformationPair.prototype = {
	from: null
	,to: null
	,__class__: vision_ds_specifics_PointTransformationPair
};
var vision_exceptions_VisionException = function(message,type) {
	throw "Exception - " + type + ":\n\n\t" + message + "\n";
};
$hxClasses["vision.exceptions.VisionException"] = vision_exceptions_VisionException;
vision_exceptions_VisionException.__name__ = "vision.exceptions.VisionException";
vision_exceptions_VisionException.prototype = {
	__class__: vision_exceptions_VisionException
};
var vision_exceptions_ImageLoadingFailed = function(type,reason) {
	vision_exceptions_VisionException.call(this,reason,"" + type + " Loading Failed");
};
$hxClasses["vision.exceptions.ImageLoadingFailed"] = vision_exceptions_ImageLoadingFailed;
vision_exceptions_ImageLoadingFailed.__name__ = "vision.exceptions.ImageLoadingFailed";
vision_exceptions_ImageLoadingFailed.__super__ = vision_exceptions_VisionException;
vision_exceptions_ImageLoadingFailed.prototype = $extend(vision_exceptions_VisionException.prototype,{
	__class__: vision_exceptions_ImageLoadingFailed
});
var vision_exceptions_ImageSavingFailed = function(type,reason) {
	vision_exceptions_VisionException.call(this,reason,"" + type + " Saving Failed");
};
$hxClasses["vision.exceptions.ImageSavingFailed"] = vision_exceptions_ImageSavingFailed;
vision_exceptions_ImageSavingFailed.__name__ = "vision.exceptions.ImageSavingFailed";
vision_exceptions_ImageSavingFailed.__super__ = vision_exceptions_VisionException;
vision_exceptions_ImageSavingFailed.prototype = $extend(vision_exceptions_VisionException.prototype,{
	__class__: vision_exceptions_ImageSavingFailed
});
var vision_exceptions_LibraryRequired = function(library,dependencies,classDotField,fieldType) {
	if(fieldType == null) {
		fieldType = "function";
	}
	vision_exceptions_VisionException.call(this,"The " + fieldType + " " + classDotField + " requires the " + library + " haxelib.\n\tMake sure " + (library + (dependencies.length > 0 ? " and it's dependencies are" : " is")) + " installed & included:\n\n" + vision_exceptions_LibraryRequired.getInclusionMethod([library].concat(dependencies)),"Missing Library Required");
};
$hxClasses["vision.exceptions.LibraryRequired"] = vision_exceptions_LibraryRequired;
vision_exceptions_LibraryRequired.__name__ = "vision.exceptions.LibraryRequired";
vision_exceptions_LibraryRequired.getInclusionMethod = function(libs) {
	var _g = [];
	var _g1 = 0;
	while(_g1 < libs.length) {
		var lib = libs[_g1];
		++_g1;
		_g.push("\t\t--library " + lib + "\n");
	}
	return "" + _g.join("");
};
vision_exceptions_LibraryRequired.__super__ = vision_exceptions_VisionException;
vision_exceptions_LibraryRequired.prototype = $extend(vision_exceptions_VisionException.prototype,{
	__class__: vision_exceptions_LibraryRequired
});
var vision_exceptions_MatrixOperationError = function(op,matrices,offense) {
	vision_exceptions_VisionException.call(this,vision_exceptions_MatrixOperationError.errorByType(op,matrices,offense),"Matrix " + (op.charAt(0).toUpperCase() + HxOverrides.substr(op,1,null)) + " Error");
};
$hxClasses["vision.exceptions.MatrixOperationError"] = vision_exceptions_MatrixOperationError;
vision_exceptions_MatrixOperationError.__name__ = "vision.exceptions.MatrixOperationError";
vision_exceptions_MatrixOperationError.errorByType = function(type,mats,off) {
	var sign = "";
	switch(type) {
	case "Add":case "Addition":case "add":case "addition":
		sign = "+";
		break;
	case "Div":case "Division":case "div":case "division":
		sign = "";
		break;
	case "Mult":case "Multiplication":case "mult":case "multiplication":
		sign = "";
		break;
	case "Sub":case "Subtraction":case "sub":case "subtraction":
		sign = "-";
		break;
	}
	var msg = "Cannot calculate:\n\n";
	var _g = [];
	var _g1 = 0;
	var this1 = mats[0];
	var precision = 3;
	if(precision == null) {
		precision = 5;
	}
	var maxLen = 1;
	var _g2 = 0;
	var _g3 = this1.inner;
	while(_g2 < _g3.length) {
		var item = _g3[_g2];
		++_g2;
		var len;
		if(precision == -1) {
			len = Std.string(item).length;
		} else {
			var multiplier = Math.pow(10,precision);
			len = Std.string(Math.round(item * multiplier) / multiplier).length;
		}
		if(len > maxLen) {
			maxLen = len;
		}
	}
	++maxLen;
	var st = "";
	var _g2 = 0;
	var _g3 = maxLen * this1.width + 2 * (this1.width - 1) - 1;
	while(_g2 < _g3) {
		var i = _g2++;
		st += " ";
	}
	var top = "\n " + st + " ";
	var st = "";
	var _g2 = 0;
	var _g3 = maxLen * this1.width + 2 * (this1.width - 1) - 1;
	while(_g2 < _g3) {
		var i = _g2++;
		st += " ";
	}
	var bottom = " " + st + " ";
	var rows = [""];
	var counter = 0;
	var floor = 0;
	var _g2 = 0;
	var _g3 = this1.inner;
	while(_g2 < _g3.length) {
		var item = _g3[_g2];
		++_g2;
		if(counter < this1.width) {
			var itemString;
			if(precision != -1) {
				var multiplier = Math.pow(10,precision);
				itemString = Math.round(item * multiplier) / multiplier;
			} else {
				itemString = item;
			}
			var itemString1 = Std.string(itemString);
			var add;
			if(precision != -1) {
				var multiplier1 = Math.pow(10,precision);
				add = item != Math.round(item * multiplier1) / multiplier1;
			} else {
				add = false;
			}
			if(add) {
				itemString1 += "";
			}
			if(itemString1.length < maxLen) {
				var st = "";
				var _g4 = 0;
				var _g5 = Math.floor((maxLen - itemString1.length) / 2);
				while(_g4 < _g5) {
					var i = _g4++;
					st += " ";
				}
				var itemString2 = st + itemString1;
				var st1 = "";
				var _g6 = 0;
				var _g7 = Math.ceil((maxLen - itemString1.length) / 2);
				while(_g6 < _g7) {
					var i1 = _g6++;
					st1 += " ";
				}
				itemString1 = itemString2 + st1;
			}
			var add1 = ", " + itemString1;
			if(counter == 0) {
				add1 = HxOverrides.substr(add1,2,null);
			}
			rows[floor] += add1;
			++counter;
		} else {
			counter = 0;
			++floor;
			rows[floor] = "";
			var itemString3;
			if(precision != -1) {
				var multiplier2 = Math.pow(10,precision);
				itemString3 = Math.round(item * multiplier2) / multiplier2;
			} else {
				itemString3 = item;
			}
			var itemString4 = Std.string(itemString3);
			var add2;
			if(precision != -1) {
				var multiplier3 = Math.pow(10,precision);
				add2 = item != Math.round(item * multiplier3) / multiplier3;
			} else {
				add2 = false;
			}
			if(add2) {
				itemString4 += "";
			}
			if(itemString4.length < maxLen) {
				var st2 = "";
				var _g8 = 0;
				var _g9 = Math.floor((maxLen - itemString4.length) / 2);
				while(_g8 < _g9) {
					var i2 = _g8++;
					st2 += " ";
				}
				var itemString5 = st2 + itemString4;
				var st3 = "";
				var _g10 = 0;
				var _g11 = Math.ceil((maxLen - itemString4.length) / 2);
				while(_g10 < _g11) {
					var i3 = _g10++;
					st3 += " ";
				}
				itemString4 = itemString5 + st3;
			}
			var add3 = "" + itemString4;
			rows[floor] += add3;
			++counter;
		}
	}
	var string = top + "\n";
	var _g2 = 0;
	while(_g2 < rows.length) {
		var r = rows[_g2];
		++_g2;
		string += " " + r + "\n";
	}
	var array = (string += bottom).split("\n").length;
	var this1 = mats[1];
	var precision = 3;
	if(precision == null) {
		precision = 5;
	}
	var maxLen = 1;
	var _g2 = 0;
	var _g3 = this1.inner;
	while(_g2 < _g3.length) {
		var item = _g3[_g2];
		++_g2;
		var len;
		if(precision == -1) {
			len = Std.string(item).length;
		} else {
			var multiplier = Math.pow(10,precision);
			len = Std.string(Math.round(item * multiplier) / multiplier).length;
		}
		if(len > maxLen) {
			maxLen = len;
		}
	}
	++maxLen;
	var st = "";
	var _g2 = 0;
	var _g3 = maxLen * this1.width + 2 * (this1.width - 1) - 1;
	while(_g2 < _g3) {
		var i = _g2++;
		st += " ";
	}
	var top = "\n " + st + " ";
	var st = "";
	var _g2 = 0;
	var _g3 = maxLen * this1.width + 2 * (this1.width - 1) - 1;
	while(_g2 < _g3) {
		var i = _g2++;
		st += " ";
	}
	var bottom = " " + st + " ";
	var rows = [""];
	var counter = 0;
	var floor = 0;
	var _g2 = 0;
	var _g3 = this1.inner;
	while(_g2 < _g3.length) {
		var item = _g3[_g2];
		++_g2;
		if(counter < this1.width) {
			var itemString;
			if(precision != -1) {
				var multiplier = Math.pow(10,precision);
				itemString = Math.round(item * multiplier) / multiplier;
			} else {
				itemString = item;
			}
			var itemString1 = Std.string(itemString);
			var add;
			if(precision != -1) {
				var multiplier1 = Math.pow(10,precision);
				add = item != Math.round(item * multiplier1) / multiplier1;
			} else {
				add = false;
			}
			if(add) {
				itemString1 += "";
			}
			if(itemString1.length < maxLen) {
				var st = "";
				var _g4 = 0;
				var _g5 = Math.floor((maxLen - itemString1.length) / 2);
				while(_g4 < _g5) {
					var i = _g4++;
					st += " ";
				}
				var itemString2 = st + itemString1;
				var st1 = "";
				var _g6 = 0;
				var _g7 = Math.ceil((maxLen - itemString1.length) / 2);
				while(_g6 < _g7) {
					var i1 = _g6++;
					st1 += " ";
				}
				itemString1 = itemString2 + st1;
			}
			var add1 = ", " + itemString1;
			if(counter == 0) {
				add1 = HxOverrides.substr(add1,2,null);
			}
			rows[floor] += add1;
			++counter;
		} else {
			counter = 0;
			++floor;
			rows[floor] = "";
			var itemString3;
			if(precision != -1) {
				var multiplier2 = Math.pow(10,precision);
				itemString3 = Math.round(item * multiplier2) / multiplier2;
			} else {
				itemString3 = item;
			}
			var itemString4 = Std.string(itemString3);
			var add2;
			if(precision != -1) {
				var multiplier3 = Math.pow(10,precision);
				add2 = item != Math.round(item * multiplier3) / multiplier3;
			} else {
				add2 = false;
			}
			if(add2) {
				itemString4 += "";
			}
			if(itemString4.length < maxLen) {
				var st2 = "";
				var _g8 = 0;
				var _g9 = Math.floor((maxLen - itemString4.length) / 2);
				while(_g8 < _g9) {
					var i2 = _g8++;
					st2 += " ";
				}
				var itemString5 = st2 + itemString4;
				var st3 = "";
				var _g10 = 0;
				var _g11 = Math.ceil((maxLen - itemString4.length) / 2);
				while(_g10 < _g11) {
					var i3 = _g10++;
					st3 += " ";
				}
				itemString4 = itemString5 + st3;
			}
			var add3 = "" + itemString4;
			rows[floor] += add3;
			++counter;
		}
	}
	var string = top + "\n";
	var _g2 = 0;
	while(_g2 < rows.length) {
		var r = rows[_g2];
		++_g2;
		string += " " + r + "\n";
	}
	var values = [array,(string += bottom).split("\n").length];
	var max = values[0];
	var _g2 = 0;
	var _g3 = values.length;
	while(_g2 < _g3) {
		var i = _g2++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var _g2 = max;
	while(_g1 < _g2) {
		var i = _g1++;
		var tmp;
		if(mats[0].height + 3 > i) {
			var this1 = mats[0];
			var precision = 3;
			if(precision == null) {
				precision = 5;
			}
			var maxLen = 1;
			var _g3 = 0;
			var _g4 = this1.inner;
			while(_g3 < _g4.length) {
				var item = _g4[_g3];
				++_g3;
				var len;
				if(precision == -1) {
					len = Std.string(item).length;
				} else {
					var multiplier = Math.pow(10,precision);
					len = Std.string(Math.round(item * multiplier) / multiplier).length;
				}
				if(len > maxLen) {
					maxLen = len;
				}
			}
			++maxLen;
			var st = "";
			var _g5 = 0;
			var _g6 = maxLen * this1.width + 2 * (this1.width - 1) - 1;
			while(_g5 < _g6) {
				var i1 = _g5++;
				st += " ";
			}
			var top = "\n " + st + " ";
			var st1 = "";
			var _g7 = 0;
			var _g8 = maxLen * this1.width + 2 * (this1.width - 1) - 1;
			while(_g7 < _g8) {
				var i2 = _g7++;
				st1 += " ";
			}
			var bottom = " " + st1 + " ";
			var rows = [""];
			var counter = 0;
			var floor = 0;
			var _g9 = 0;
			var _g10 = this1.inner;
			while(_g9 < _g10.length) {
				var item1 = _g10[_g9];
				++_g9;
				if(counter < this1.width) {
					var itemString;
					if(precision != -1) {
						var multiplier1 = Math.pow(10,precision);
						itemString = Math.round(item1 * multiplier1) / multiplier1;
					} else {
						itemString = item1;
					}
					var itemString1 = Std.string(itemString);
					var add;
					if(precision != -1) {
						var multiplier2 = Math.pow(10,precision);
						add = item1 != Math.round(item1 * multiplier2) / multiplier2;
					} else {
						add = false;
					}
					if(add) {
						itemString1 += "";
					}
					if(itemString1.length < maxLen) {
						var st2 = "";
						var _g11 = 0;
						var _g12 = Math.floor((maxLen - itemString1.length) / 2);
						while(_g11 < _g12) {
							var i3 = _g11++;
							st2 += " ";
						}
						var itemString2 = st2 + itemString1;
						var st3 = "";
						var _g13 = 0;
						var _g14 = Math.ceil((maxLen - itemString1.length) / 2);
						while(_g13 < _g14) {
							var i4 = _g13++;
							st3 += " ";
						}
						itemString1 = itemString2 + st3;
					}
					var add1 = ", " + itemString1;
					if(counter == 0) {
						add1 = HxOverrides.substr(add1,2,null);
					}
					rows[floor] += add1;
					++counter;
				} else {
					counter = 0;
					++floor;
					rows[floor] = "";
					var itemString3;
					if(precision != -1) {
						var multiplier3 = Math.pow(10,precision);
						itemString3 = Math.round(item1 * multiplier3) / multiplier3;
					} else {
						itemString3 = item1;
					}
					var itemString4 = Std.string(itemString3);
					var add2;
					if(precision != -1) {
						var multiplier4 = Math.pow(10,precision);
						add2 = item1 != Math.round(item1 * multiplier4) / multiplier4;
					} else {
						add2 = false;
					}
					if(add2) {
						itemString4 += "";
					}
					if(itemString4.length < maxLen) {
						var st4 = "";
						var _g15 = 0;
						var _g16 = Math.floor((maxLen - itemString4.length) / 2);
						while(_g15 < _g16) {
							var i5 = _g15++;
							st4 += " ";
						}
						var itemString5 = st4 + itemString4;
						var st5 = "";
						var _g17 = 0;
						var _g18 = Math.ceil((maxLen - itemString4.length) / 2);
						while(_g17 < _g18) {
							var i6 = _g17++;
							st5 += " ";
						}
						itemString4 = itemString5 + st5;
					}
					var add3 = "" + itemString4;
					rows[floor] += add3;
					++counter;
				}
			}
			var string = top + "\n";
			var _g19 = 0;
			while(_g19 < rows.length) {
				var r = rows[_g19];
				++_g19;
				string += " " + r + "\n";
			}
			tmp = (string += bottom).split("\n")[i];
		} else {
			tmp = "";
		}
		var tmp1;
		if(mats[1].height + 3 > i) {
			var this2 = mats[1];
			var precision1 = 3;
			if(precision1 == null) {
				precision1 = 5;
			}
			var maxLen1 = 1;
			var _g20 = 0;
			var _g21 = this2.inner;
			while(_g20 < _g21.length) {
				var item2 = _g21[_g20];
				++_g20;
				var len1;
				if(precision1 == -1) {
					len1 = Std.string(item2).length;
				} else {
					var multiplier5 = Math.pow(10,precision1);
					len1 = Std.string(Math.round(item2 * multiplier5) / multiplier5).length;
				}
				if(len1 > maxLen1) {
					maxLen1 = len1;
				}
			}
			++maxLen1;
			var st6 = "";
			var _g22 = 0;
			var _g23 = maxLen1 * this2.width + 2 * (this2.width - 1) - 1;
			while(_g22 < _g23) {
				var i7 = _g22++;
				st6 += " ";
			}
			var top1 = "\n " + st6 + " ";
			var st7 = "";
			var _g24 = 0;
			var _g25 = maxLen1 * this2.width + 2 * (this2.width - 1) - 1;
			while(_g24 < _g25) {
				var i8 = _g24++;
				st7 += " ";
			}
			var bottom1 = " " + st7 + " ";
			var rows1 = [""];
			var counter1 = 0;
			var floor1 = 0;
			var _g26 = 0;
			var _g27 = this2.inner;
			while(_g26 < _g27.length) {
				var item3 = _g27[_g26];
				++_g26;
				if(counter1 < this2.width) {
					var itemString6;
					if(precision1 != -1) {
						var multiplier6 = Math.pow(10,precision1);
						itemString6 = Math.round(item3 * multiplier6) / multiplier6;
					} else {
						itemString6 = item3;
					}
					var itemString7 = Std.string(itemString6);
					var add4;
					if(precision1 != -1) {
						var multiplier7 = Math.pow(10,precision1);
						add4 = item3 != Math.round(item3 * multiplier7) / multiplier7;
					} else {
						add4 = false;
					}
					if(add4) {
						itemString7 += "";
					}
					if(itemString7.length < maxLen1) {
						var st8 = "";
						var _g28 = 0;
						var _g29 = Math.floor((maxLen1 - itemString7.length) / 2);
						while(_g28 < _g29) {
							var i9 = _g28++;
							st8 += " ";
						}
						var itemString8 = st8 + itemString7;
						var st9 = "";
						var _g30 = 0;
						var _g31 = Math.ceil((maxLen1 - itemString7.length) / 2);
						while(_g30 < _g31) {
							var i10 = _g30++;
							st9 += " ";
						}
						itemString7 = itemString8 + st9;
					}
					var add5 = ", " + itemString7;
					if(counter1 == 0) {
						add5 = HxOverrides.substr(add5,2,null);
					}
					rows1[floor1] += add5;
					++counter1;
				} else {
					counter1 = 0;
					++floor1;
					rows1[floor1] = "";
					var itemString9;
					if(precision1 != -1) {
						var multiplier8 = Math.pow(10,precision1);
						itemString9 = Math.round(item3 * multiplier8) / multiplier8;
					} else {
						itemString9 = item3;
					}
					var itemString10 = Std.string(itemString9);
					var add6;
					if(precision1 != -1) {
						var multiplier9 = Math.pow(10,precision1);
						add6 = item3 != Math.round(item3 * multiplier9) / multiplier9;
					} else {
						add6 = false;
					}
					if(add6) {
						itemString10 += "";
					}
					if(itemString10.length < maxLen1) {
						var st10 = "";
						var _g32 = 0;
						var _g33 = Math.floor((maxLen1 - itemString10.length) / 2);
						while(_g32 < _g33) {
							var i11 = _g32++;
							st10 += " ";
						}
						var itemString11 = st10 + itemString10;
						var st11 = "";
						var _g34 = 0;
						var _g35 = Math.ceil((maxLen1 - itemString10.length) / 2);
						while(_g34 < _g35) {
							var i12 = _g34++;
							st11 += " ";
						}
						itemString10 = itemString11 + st11;
					}
					var add7 = "" + itemString10;
					rows1[floor1] += add7;
					++counter1;
				}
			}
			var string1 = top1 + "\n";
			var _g36 = 0;
			while(_g36 < rows1.length) {
				var r1 = rows1[_g36];
				++_g36;
				string1 += " " + r1 + "\n";
			}
			tmp1 = (string1 += bottom1).split("\n")[i];
		} else {
			tmp1 = "";
		}
		_g.push([tmp,tmp1]);
	}
	var rows = _g;
	var values = [mats[0].height + 2,mats[1].height + 2];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var signRow = Math.ceil(max / 2);
	var currentRow = 0;
	var _g = 0;
	while(_g < rows.length) {
		var r = rows[_g];
		++_g;
		if(r[0].length == 0) {
			var _g1 = [];
			var _g2 = 0;
			var _g3 = r[1].length;
			while(_g2 < _g3) {
				var i = _g2++;
				_g1.push(" ");
			}
			r[0] = _g1.join("");
		}
		if(r[1].length == 0) {
			var _g4 = [];
			var _g5 = 0;
			var _g6 = r[0].length;
			while(_g5 < _g6) {
				var i1 = _g5++;
				_g4.push(" ");
			}
			r[1] = _g4.join("");
		}
		msg += "\t" + r[0] + "  ";
		if(currentRow == signRow) {
			msg += sign;
		} else {
			msg += " ";
		}
		msg += "  " + r[1];
		++currentRow;
		msg += "\n";
	}
	msg += "\n\t";
	switch(off) {
	case 0:
		msg += "Width of first matrix (" + mats[0].width + ") is different from the height of the second (" + mats[1].height + ")";
		break;
	case 1:
		msg += "Width & height of first matrix (" + mats[0].width + "" + mats[0].height + ") are different from those of the second matrix (" + mats[1].width + "" + mats[1].height + ")";
		break;
	case 2:
		msg += "Width & height of first matrix (" + mats[0].width + "" + mats[0].height + ") are different from those of the second matrix (" + mats[1].width + "" + mats[1].height + ")";
		break;
	case 3:
		msg += "Width of first matrix (" + mats[0].width + ") is different from the height of the second (" + mats[1].height + ")";
		break;
	}
	return msg;
};
vision_exceptions_MatrixOperationError.__super__ = vision_exceptions_VisionException;
vision_exceptions_MatrixOperationError.prototype = $extend(vision_exceptions_VisionException.prototype,{
	__class__: vision_exceptions_MatrixOperationError
});
var vision_exceptions_MultithreadFailure = function(count,reason) {
	vision_exceptions_VisionException.call(this,"Thread number #" + count + " failed: " + Std.string(reason),"Multithreading Failure");
};
$hxClasses["vision.exceptions.MultithreadFailure"] = vision_exceptions_MultithreadFailure;
vision_exceptions_MultithreadFailure.__name__ = "vision.exceptions.MultithreadFailure";
vision_exceptions_MultithreadFailure.__super__ = vision_exceptions_VisionException;
vision_exceptions_MultithreadFailure.prototype = $extend(vision_exceptions_VisionException.prototype,{
	__class__: vision_exceptions_MultithreadFailure
});
var vision_exceptions_OutOfBounds = function(image,position) {
	vision_exceptions_VisionException.call(this,"pixel " + Std.string(position) + " is outside the bounds of the image (size: " + image.getUInt16(0) + "x" + Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)) + ")","Pixel Coordinates Out Of Bounds");
};
$hxClasses["vision.exceptions.OutOfBounds"] = vision_exceptions_OutOfBounds;
vision_exceptions_OutOfBounds.__name__ = "vision.exceptions.OutOfBounds";
vision_exceptions_OutOfBounds.__super__ = vision_exceptions_VisionException;
vision_exceptions_OutOfBounds.prototype = $extend(vision_exceptions_VisionException.prototype,{
	__class__: vision_exceptions_OutOfBounds
});
var vision_exceptions_Unimplemented = function(name) {
	vision_exceptions_VisionException.call(this,"" + name + " is not yet implemented","Unimplemented Method");
};
$hxClasses["vision.exceptions.Unimplemented"] = vision_exceptions_Unimplemented;
vision_exceptions_Unimplemented.__name__ = "vision.exceptions.Unimplemented";
vision_exceptions_Unimplemented.__super__ = vision_exceptions_VisionException;
vision_exceptions_Unimplemented.prototype = $extend(vision_exceptions_VisionException.prototype,{
	__class__: vision_exceptions_Unimplemented
});
var vision_helpers_TextDrawer = function() { };
$hxClasses["vision.helpers.TextDrawer"] = vision_helpers_TextDrawer;
vision_helpers_TextDrawer.__name__ = "vision.helpers.TextDrawer";
vision_helpers_TextDrawer.reportDependencies = function() {
	throw haxe_Exception.thrown(new vision_exceptions_LibraryRequired("opentype.hx",[].concat(["promhx"]).concat(["buddy"]).concat(["asynctools"]),"Image.drawText"));
};
vision_helpers_TextDrawer.drawTextOnImage = function(image,x,y,size,text,font) {
	vision_helpers_TextDrawer.reportDependencies();
};
var vision_helpers_VisionThread = function(job) {
	this.relaunchEvents = false;
	var _gthis = this;
	this.job = job;
	this.count = vision_helpers_VisionThread.COUNT++;
	this.set_onFailed(function(d) {
		throw haxe_Exception.thrown(new vision_exceptions_MultithreadFailure(_gthis.count,d));
	});
	this.set_onDone(function() {
	});
};
$hxClasses["vision.helpers.VisionThread"] = vision_helpers_VisionThread;
vision_helpers_VisionThread.__name__ = "vision.helpers.VisionThread";
vision_helpers_VisionThread.create = function(job) {
	var t = new vision_helpers_VisionThread(job);
	t.start();
	return t;
};
vision_helpers_VisionThread.prototype = {
	underlying: null
	,job: null
	,onFailed: null
	,onDone: null
	,jobDone: null
	,relaunchEvents: null
	,count: null
	,start: function() {
		var _gthis = this;
		this.underlying = new Promise(function(onDone,onFailedWrapper) {
			_gthis.job();
			_gthis.jobDone = true;
		});
	}
	,onFailedWrapper: function(d) {
		this.jobDone = false;
		this.onFailed(d);
	}
	,set_onFailed: function(value) {
		if(this.relaunchEvents && this.jobDone != null) {
			value(null);
		}
		return this.onFailed = value;
	}
	,set_onDone: function(value) {
		if(this.relaunchEvents && this.jobDone != null) {
			value();
		}
		return this.onDone = value;
	}
	,__class__: vision_helpers_VisionThread
	,__properties__: {set_onDone:"set_onDone",set_onFailed:"set_onFailed"}
};
var vision_tools_ImageTools = function() { };
$hxClasses["vision.tools.ImageTools"] = vision_tools_ImageTools;
vision_tools_ImageTools.__name__ = "vision.tools.ImageTools";
vision_tools_ImageTools.loadFromFile = function(image,path,onComplete) {
	var imgElement = window.document.createElement("img");
	imgElement.src = path;
	imgElement.crossOrigin = "Anonymous";
	imgElement.onload = function() {
		var canvas = window.document.createElement("canvas");
		canvas.width = imgElement.width;
		canvas.height = imgElement.height;
		canvas.getContext("2d",null).drawImage(imgElement,0,0);
		if(image == null) {
			var width = imgElement.width;
			var length = width * imgElement.height * 4 + vision_ds_Image.OFFSET;
			var this1 = new haxe_io_Bytes(new ArrayBuffer(length));
			this1.fill(0,length,0);
			var this2 = this1;
			this2.setUInt16(0,width);
			this2.setUInt16(vision_ds_Image.WIDTH_BYTES,0);
			this2.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP,0);
			this2.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES,0);
			this2.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP,0);
			this2.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] = 0;
			var i = vision_ds_Image.OFFSET;
			while(i < this2.length) {
				this2.b[i] = 0;
				this2.b[i + 1] = 0;
				this2.b[i + 2] = 0;
				this2.b[i + 3] = 0;
				i += 4;
			}
			image = this2;
		}
		var imageData = canvas.getContext("2d",null).getImageData(0,0,image.getUInt16(0),Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)));
		var i = 0;
		while(i < imageData.data.length) {
			image.b[i + (vision_ds_Image.OFFSET + 1)] = imageData.data[i];
			image.b[i + (vision_ds_Image.OFFSET + 1) + 1] = imageData.data[i + 1];
			image.b[i + (vision_ds_Image.OFFSET + 1) + 2] = imageData.data[i + 2];
			image.b[i + (vision_ds_Image.OFFSET + 1) + 3] = imageData.data[i + 3];
			i += 4;
		}
		if(onComplete != null) {
			onComplete(image);
		}
	};
};
vision_tools_ImageTools.saveToFile = function(image,pathWithFileName,saveFormat) {
	if(saveFormat == null) {
		saveFormat = 0;
	}
	throw haxe_Exception.thrown(new vision_exceptions_LibraryRequired("format",[],"ImageTools.loadFromFile","function"));
};
vision_tools_ImageTools.addToScreen = function(image,x,y,units) {
	var c = window.document.createElement("canvas");
	c.width = image.getUInt16(0);
	c.height = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4));
	var ctx = c.getContext("2d",null);
	var imageData = ctx.getImageData(0,0,image.getUInt16(0),Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)));
	var data = imageData.data;
	var _g = 0;
	var _g1 = image.getUInt16(0);
	while(_g < _g1) {
		var x1 = _g++;
		var _g2 = 0;
		var _g3 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4));
		while(_g2 < _g3) {
			var y1 = _g2++;
			var i = (y1 * image.getUInt16(0) + x1) * 4;
			data[i] = image.b[i + (vision_ds_Image.OFFSET + 1)];
			data[i + 1] = image.b[i + (vision_ds_Image.OFFSET + 1) + 1];
			data[i + 2] = image.b[i + (vision_ds_Image.OFFSET + 1) + 2];
			data[i + 3] = image.b[i + (vision_ds_Image.OFFSET + 1) + 3];
		}
	}
	ctx.putImageData(imageData,0,0);
	c.style.position = "absolute";
	if(units == null) {
		units = { };
	}
	c.style.top = y + units.yUnits != null ? y + units.yUnits : y + "px";
	c.style.left = x + units.xUnits != null ? x + units.xUnits : x + "px";
	if(units.zIndex != null) {
		c.style.zIndex = units.zIndex;
	}
	window.document.body.appendChild(c);
	return image;
};
vision_tools_ImageTools.getNeighborsOfPixel = function(image,x,y,kernelSize) {
	var neighbors = new vision_ds_Array2D(kernelSize,kernelSize);
	var i = 0;
	var circular = false;
	if(circular == null) {
		circular = false;
	}
	var _g_image = image;
	var _g_roundedDown = kernelSize - 1 >> 1;
	var _g_x = x;
	var _g_y = y;
	var _g_circular = circular;
	var _g_X = -_g_roundedDown;
	var _g_Y = -_g_roundedDown;
	while(_g_X <= _g_roundedDown && _g_Y <= _g_roundedDown) {
		while(true) {
			++_g_Y;
			if(_g_Y > _g_roundedDown) {
				_g_Y = -_g_roundedDown;
				++_g_X;
			}
			var tmp;
			if(_g_circular) {
				var x = _g_X;
				var y = _g_Y;
				if(y == null) {
					y = 0;
				}
				if(x == null) {
					x = 0;
				}
				var point1_x = x;
				var point1_y = y;
				var x1 = _g_roundedDown;
				var y1 = _g_roundedDown;
				if(y1 == null) {
					y1 = 0;
				}
				if(x1 == null) {
					x1 = 0;
				}
				var point2_x = x1;
				var point2_y = y1;
				var x2 = point2_x - point1_x;
				var y2 = point2_y - point1_y;
				tmp = Math.sqrt(x2 * x2 + y2 * y2) > _g_roundedDown;
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
		}
		var this1 = _g_image;
		var y3 = _g_y + _g_Y;
		var ma = this1.getUInt16(0) - 1;
		var values = [_g_x + _g_X,0];
		var max = values[0];
		var _g = 0;
		var _g1 = values.length;
		while(_g < _g1) {
			var i1 = _g++;
			if(values[i1] > max) {
				max = values[i1];
			}
		}
		var values1 = [max,ma];
		var min = values1[0];
		var _g2 = 0;
		var _g3 = values1.length;
		while(_g2 < _g3) {
			var i2 = _g2++;
			if(values1[i2] < min) {
				min = values1[i2];
			}
		}
		var x3 = min;
		var ma1 = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
		var values2 = [y3,0];
		var max1 = values2[0];
		var _g4 = 0;
		var _g5 = values2.length;
		while(_g4 < _g5) {
			var i3 = _g4++;
			if(values2[i3] > max1) {
				max1 = values2[i3];
			}
		}
		var values3 = [max1,ma1];
		var min1 = values3[0];
		var _g6 = 0;
		var _g7 = values3.length;
		while(_g6 < _g7) {
			var i4 = _g6++;
			if(values3[i4] < min1) {
				min1 = values3[i4];
			}
		}
		var y4 = min1;
		if(!(x3 >= 0 && y4 >= 0 && x3 < this1.getUInt16(0) && y4 < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x3;
			var this_y = y4;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		}
		var position = (y4 * this1.getUInt16(0) + x3) * 4;
		position += vision_ds_Image.OFFSET;
		var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
		if(value == null) {
			value = 0;
		}
		var neighbor = value;
		neighbors.inner[i++] = neighbor;
	}
	return neighbors;
};
vision_tools_ImageTools.grayscalePixel = function(pixel) {
	var gray = ((pixel >> 16 & 255) + (pixel >> 8 & 255) + (pixel & 255)) / 3 | 0;
	var Alpha = pixel >> 24 & 255;
	if(Alpha == null) {
		Alpha = 255;
	}
	var color = 0;
	var Alpha1 = Alpha;
	if(Alpha1 == null) {
		Alpha1 = 255;
	}
	color &= -16711681;
	color |= (gray > 255 ? 255 : gray < 0 ? 0 : gray) << 16;
	color &= -65281;
	color |= (gray > 255 ? 255 : gray < 0 ? 0 : gray) << 8;
	color &= -256;
	color |= gray > 255 ? 255 : gray < 0 ? 0 : gray;
	color &= 16777215;
	color |= (Alpha1 > 255 ? 255 : Alpha1 < 0 ? 0 : Alpha1) << 24;
	return color;
};
vision_tools_ImageTools.fromJsCanvas = function(canvas) {
	var length = vision_ds_Image.OFFSET + (canvas.width + canvas.height) * 4;
	var this1 = new haxe_io_Bytes(new ArrayBuffer(length));
	this1.fill(0,length,0);
	var bytes = this1;
	var width = canvas.width;
	var height = canvas.height;
	var h = height != null ? height : Math.ceil(bytes.length / 4 / width);
	var length = width * h * 4 + vision_ds_Image.OFFSET;
	var this1 = new haxe_io_Bytes(new ArrayBuffer(length));
	this1.fill(0,length,0);
	var array = this1;
	array.fill(0,array.length,0);
	array.setUInt16(0,width);
	array.setUInt16(vision_ds_Image.WIDTH_BYTES,0);
	array.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.DATA_GAP,0);
	array.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES,0);
	array.setUInt16(vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.DATA_GAP,0);
	array.b[vision_ds_Image.WIDTH_BYTES + vision_ds_Image.VIEW_XY_BYTES + vision_ds_Image.VIEW_WH_BYTES] = 0;
	array.blit(vision_ds_Image.OFFSET,bytes,0,bytes.length);
	var image = array;
	var imageData = canvas.getContext("2d",null).getImageData(0,0,image.getUInt16(0),Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)));
	var i = 0;
	while(i < imageData.data.length) {
		image.b[i + (vision_ds_Image.OFFSET + 1)] = imageData.data[i];
		image.b[i + (vision_ds_Image.OFFSET + 1) + 1] = imageData.data[i + 1];
		image.b[i + (vision_ds_Image.OFFSET + 1) + 2] = imageData.data[i + 2];
		image.b[i + (vision_ds_Image.OFFSET + 1) + 3] = imageData.data[i + 3];
		i += 4;
	}
	return image;
};
vision_tools_ImageTools.toJsCanvas = function(image) {
	var c = window.document.createElement("canvas");
	c.width = image.getUInt16(0);
	c.height = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4));
	var ctx = c.getContext("2d",null);
	var imageData = ctx.getImageData(0,0,image.getUInt16(0),Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4)));
	var data = imageData.data;
	var _g = 0;
	var _g1 = image.getUInt16(0);
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = Math.ceil((image.length - vision_ds_Image.OFFSET) / (image.getUInt16(0) * 4));
		while(_g2 < _g3) {
			var y = _g2++;
			var i = (y * image.getUInt16(0) + x) * 4;
			data[i] = image.b[i + (vision_ds_Image.OFFSET + 1)];
			data[i + 1] = image.b[i + (vision_ds_Image.OFFSET + 1) + 1];
			data[i + 2] = image.b[i + (vision_ds_Image.OFFSET + 1) + 2];
			data[i + 3] = image.b[i + (vision_ds_Image.OFFSET + 1) + 3];
		}
	}
	ctx.putImageData(imageData,0,0);
	return c;
};
vision_tools_ImageTools.fromJsImage = function(image) {
	var canvas = window.document.createElement("canvas");
	canvas.width = image.width;
	canvas.height = image.height;
	canvas.getContext("2d",null).drawImage(image,0,0);
	return vision_tools_ImageTools.fromJsCanvas(canvas);
};
vision_tools_ImageTools.toJsImage = function(image) {
	var canvas = vision_ds_Image.toJsCanvas(image);
	var htmlImage = window.document.createElement("img");
	htmlImage.src = canvas.toDataURL();
	return htmlImage;
};
var vision_tools__$ImageTools_NeighborsIterator = function(image,x,y,kernelSize,circular) {
	if(circular == null) {
		circular = false;
	}
	this.image = image;
	this.roundedDown = kernelSize - 1 >> 1;
	this.x = x;
	this.y = y;
	this.circular = circular;
	this.X = -this.roundedDown;
	this.Y = -this.roundedDown;
};
$hxClasses["vision.tools._ImageTools.NeighborsIterator"] = vision_tools__$ImageTools_NeighborsIterator;
vision_tools__$ImageTools_NeighborsIterator.__name__ = "vision.tools._ImageTools.NeighborsIterator";
vision_tools__$ImageTools_NeighborsIterator.prototype = {
	roundedDown: null
	,image: null
	,x: null
	,y: null
	,X: null
	,Y: null
	,circular: null
	,next: function() {
		while(true) {
			this.Y += 1;
			if(this.Y > this.roundedDown) {
				this.Y = -this.roundedDown;
				this.X += 1;
			}
			var tmp;
			if(this.circular) {
				var x = this.X;
				var y = this.Y;
				if(y == null) {
					y = 0;
				}
				if(x == null) {
					x = 0;
				}
				var point1_x = x;
				var point1_y = y;
				var x1 = this.roundedDown;
				var y1 = this.roundedDown;
				if(y1 == null) {
					y1 = 0;
				}
				if(x1 == null) {
					x1 = 0;
				}
				var point2_x = x1;
				var point2_y = y1;
				var x2 = point2_x - point1_x;
				var y2 = point2_y - point1_y;
				tmp = Math.sqrt(x2 * x2 + y2 * y2) > this.roundedDown;
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
		}
		var this1 = this.image;
		var x = this.x + this.X;
		var y = this.y + this.Y;
		var ma = this1.getUInt16(0) - 1;
		var values = [x,0];
		var max = values[0];
		var _g = 0;
		var _g1 = values.length;
		while(_g < _g1) {
			var i = _g++;
			if(values[i] > max) {
				max = values[i];
			}
		}
		var values = [max,ma];
		var min = values[0];
		var _g = 0;
		var _g1 = values.length;
		while(_g < _g1) {
			var i = _g++;
			if(values[i] < min) {
				min = values[i];
			}
		}
		var x = min;
		var ma = Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)) - 1;
		var values = [y,0];
		var max = values[0];
		var _g = 0;
		var _g1 = values.length;
		while(_g < _g1) {
			var i = _g++;
			if(values[i] > max) {
				max = values[i];
			}
		}
		var values = [max,ma];
		var min = values[0];
		var _g = 0;
		var _g1 = values.length;
		while(_g < _g1) {
			var i = _g++;
			if(values[i] < min) {
				min = values[i];
			}
		}
		var y = min;
		if(!(x >= 0 && y >= 0 && x < this1.getUInt16(0) && y < Math.ceil((this1.length - vision_ds_Image.OFFSET) / (this1.getUInt16(0) * 4)))) {
			var this_x = x;
			var this_y = y;
			throw haxe_Exception.thrown(new vision_exceptions_OutOfBounds(this1,new vision_ds_Point2D(this_x,this_y)));
		}
		var position = (y * this1.getUInt16(0) + x) * 4;
		position += vision_ds_Image.OFFSET;
		var value = this1.b[position] << 24 | this1.b[position + 1] << 16 | this1.b[position + 2] << 8 | this1.b[position + 3];
		if(value == null) {
			value = 0;
		}
		return value;
	}
	,hasNext: function() {
		if(this.X <= this.roundedDown) {
			return this.Y <= this.roundedDown;
		} else {
			return false;
		}
	}
	,__class__: vision_tools__$ImageTools_NeighborsIterator
};
var vision_tools_MathTools = function() { };
$hxClasses["vision.tools.MathTools"] = vision_tools_MathTools;
vision_tools_MathTools.__name__ = "vision.tools.MathTools";
vision_tools_MathTools.__properties__ = {get_NaN:"get_NaN",get_POSITIVE_INFINITY:"get_POSITIVE_INFINITY",get_NEGATIVE_INFINITY:"get_NEGATIVE_INFINITY",get_PI_OVER_2:"get_PI_OVER_2",get_PI:"get_PI"};
vision_tools_MathTools.distanceFromRayToPoint2D = function(ray,point) {
	var vx = point.x - ray.point.x;
	var vy = point.y - ray.point.y;
	var projection = (vx + vy * ray.slope) / (1 + Math.pow(ray.slope,2));
	var x = ray.point.x + projection;
	var y = ray.point.y + projection * ray.slope;
	var x1 = x;
	var y1 = y;
	if(y1 == null) {
		y1 = 0;
	}
	if(x1 == null) {
		x1 = 0;
	}
	var closestPoint_x = x1;
	var closestPoint_y = y1;
	var dx = closestPoint_x - point.x;
	var dy = closestPoint_y - point.y;
	var distance = Math.sqrt(Math.pow(dx,2) + Math.pow(dy,2));
	return distance;
};
vision_tools_MathTools.intersectionBetweenRay2Ds = function(ray,ray2) {
	var line1StartX = ray.point.x;
	var line1StartY = ray.point.y;
	var line1EndX = ray.point.x + Math.cos(ray.radians) * 1000;
	var line1EndY = ray.point.y + Math.sin(ray.radians) * 1000;
	var line2StartX = ray2.point.x;
	var line2StartY = ray2.point.y;
	var line2EndX = ray2.point.x + Math.cos(ray2.radians) * 1000;
	var line2EndY = ray2.point.y + Math.sin(ray2.radians) * 1000;
	var result = null;
	var denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
	if(denominator == 0) {
		return result;
	}
	var a = line1StartY - line2StartY;
	var b = line1StartX - line2StartX;
	var numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
	var numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
	a = numerator1 / denominator;
	b = numerator2 / denominator;
	result = new vision_ds_Point2D();
	result.x = line1StartX + a * (line1EndX - line1StartX);
	result.y = line1StartY + a * (line1EndY - line1StartY);
	return result;
};
vision_tools_MathTools.distanceBetweenRays2D = function(ray,ray2) {
	if(ray.radians != ray2.radians) {
		return 0;
	}
	var point = ray.point;
	var ray2_slope;
	var ray2_radians;
	var ray2_degrees;
	var m = null;
	var degrees = ray.degrees + 90;
	var radians = null;
	var ray2_point = point;
	if(m != null) {
		ray2_degrees = Math.atan(m) * 180 / Math.PI;
		ray2_radians = Math.atan(m);
		ray2_slope = m;
		var value = Math.atan(m) * 180 / Math.PI;
		ray2_slope = Math.tan(value * Math.PI / 180);
		ray2_radians = value * Math.PI / 180;
		ray2_degrees = value;
		var value = Math.atan(m);
		ray2_slope = Math.tan(value);
		ray2_degrees = value * 180 / Math.PI;
		ray2_radians = value;
	} else if(degrees != null) {
		ray2_slope = Math.tan(degrees * Math.PI / 180);
		ray2_radians = degrees * Math.PI / 180;
		ray2_degrees = degrees;
		var value = Math.tan(degrees * Math.PI / 180);
		ray2_degrees = Math.atan(value) * 180 / Math.PI;
		ray2_radians = Math.atan(value);
		ray2_slope = value;
		var value = degrees * Math.PI / 180;
		ray2_slope = Math.tan(value);
		ray2_degrees = value * 180 / Math.PI;
		ray2_radians = value;
	} else if(radians != null) {
		ray2_slope = Math.tan(radians);
		ray2_degrees = radians * 180 / Math.PI;
		ray2_radians = radians;
		var value = Math.tan(radians);
		ray2_degrees = Math.atan(value) * 180 / Math.PI;
		ray2_radians = Math.atan(value);
		ray2_slope = value;
		var value = radians * 180 / Math.PI;
		ray2_slope = Math.tan(value * Math.PI / 180);
		ray2_radians = value * Math.PI / 180;
		ray2_degrees = value;
	}
	var line1StartX = ray2.point.x;
	var line1StartY = ray2.point.y;
	var line1EndX = ray2.point.x + Math.cos(ray2.radians) * 1000;
	var line1EndY = ray2.point.y + Math.sin(ray2.radians) * 1000;
	var line2StartX = ray2_point.x;
	var line2StartY = ray2_point.y;
	var line2EndX = ray2_point.x + Math.cos(ray2_radians) * 1000;
	var line2EndY = ray2_point.y + Math.sin(ray2_radians) * 1000;
	var a;
	var b;
	var numerator1;
	var numerator2;
	var result = null;
	var denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
	var intersectionOfPerpendicularWithRay2;
	if(denominator == 0) {
		intersectionOfPerpendicularWithRay2 = result;
	} else {
		a = line1StartY - line2StartY;
		b = line1StartX - line2StartX;
		numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
		numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
		a = numerator1 / denominator;
		b = numerator2 / denominator;
		result = new vision_ds_Point2D();
		result.x = line1StartX + a * (line1EndX - line1StartX);
		result.y = line1StartY + a * (line1EndY - line1StartY);
		intersectionOfPerpendicularWithRay2 = result;
	}
	var x = intersectionOfPerpendicularWithRay2.x - point.x;
	var y = intersectionOfPerpendicularWithRay2.y - point.y;
	return Math.sqrt(x * x + y * y);
};
vision_tools_MathTools.findPointAtDistanceUsingX = function(ray,startXPos,distance,goPositive) {
	if(goPositive == null) {
		goPositive = true;
	}
	distance = Math.abs(distance);
	var x = startXPos;
	var px = ray.point.x;
	var py = ray.point.y;
	var y = ray.slope * startXPos + (px > 0 ? py - ray.slope * px : py + ray.slope * px);
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	var start_x = x;
	var start_y = y;
	var x = start_y + 1;
	var x1 = x;
	var px = ray.point.x;
	var py = ray.point.y;
	var y = ray.slope * x + (px > 0 ? py - ray.slope * px : py + ray.slope * px);
	if(y == null) {
		y = 0;
	}
	if(x1 == null) {
		x1 = 0;
	}
	var point1_x = x1;
	var point1_y = y;
	var x = start_x - point1_x;
	var y = start_y - point1_y;
	var step = Math.sqrt(x * x + y * y);
	var diff = distance / step;
	var y = start_y + (goPositive ? diff : -diff);
	var px = ray.point.x;
	var py = ray.point.y;
	return new vision_ds_Point2D((y - (px > 0 ? py - ray.slope * px : py + ray.slope * px)) / ray.slope,y);
};
vision_tools_MathTools.findPointAtDistanceUsingY = function(ray,startYPos,distance,goPositive) {
	if(goPositive == null) {
		goPositive = true;
	}
	distance = Math.abs(distance);
	var px = ray.point.x;
	var py = ray.point.y;
	var x = (startYPos - (px > 0 ? py - ray.slope * px : py + ray.slope * px)) / ray.slope;
	var y = startYPos;
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	var start_x = x;
	var start_y = y;
	var y = start_x + 1;
	var px = ray.point.x;
	var py = ray.point.y;
	var x = (y - (px > 0 ? py - ray.slope * px : py + ray.slope * px)) / ray.slope;
	var y1 = y;
	if(y1 == null) {
		y1 = 0;
	}
	if(x == null) {
		x = 0;
	}
	var point1_x = x;
	var point1_y = y1;
	var x = start_x - point1_x;
	var y = start_y - point1_y;
	var step = Math.sqrt(x * x + y * y);
	var diff = distance / step;
	var x = start_x + (goPositive ? diff : -diff);
	var px = ray.point.x;
	var py = ray.point.y;
	return new vision_ds_Point2D(x,ray.slope * x + (px > 0 ? py - ray.slope * px : py + ray.slope * px));
};
vision_tools_MathTools.distanceFromLineToPoint2D = function(line,point) {
	var ch = (line.start.y - line.end.y) * point.x + (line.end.x - line.start.x) * point.y + (line.start.x * line.end.y - line.end.x * line.start.y);
	var del = Math.sqrt(Math.pow(line.end.x - line.start.x,2) + Math.pow(line.end.y - line.start.y,2));
	var d = ch / del;
	return d;
};
vision_tools_MathTools.distanceBetweenLines2D = function(line1,line2) {
	var x1 = line1.start.x;
	var y1 = line1.start.y;
	var x2 = line1.end.x;
	var y2 = line1.end.y;
	var x3 = line2.start.x;
	var y3 = line2.start.y;
	var x4 = line2.end.x;
	var y4 = line2.end.y;
	var denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
	var tmp;
	if(x1 == x2 && y1 == y2 || x3 == x4 && y3 == y4) {
		tmp = null;
	} else if(denominator == 0) {
		tmp = null;
	} else {
		var ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
		var ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
		if(ua < 0 || ua > 1 || ub < 0 || ub > 1) {
			tmp = null;
		} else {
			var x = x1 + ua * (x2 - x1);
			var y = y1 + ua * (y2 - y1);
			tmp = new vision_ds_Point2D(x | 0,y | 0);
		}
	}
	if(tmp != null) {
		return 0;
	}
	var point = line2.start;
	var ch = (line1.start.y - line1.end.y) * point.x + (line1.end.x - line1.start.x) * point.y + (line1.start.x * line1.end.y - line1.end.x * line1.start.y);
	var del = Math.sqrt(Math.pow(line1.end.x - line1.start.x,2) + Math.pow(line1.end.y - line1.start.y,2));
	var d = ch / del;
	var distance1 = d;
	var point = line2.end;
	var ch = (line1.start.y - line1.end.y) * point.x + (line1.end.x - line1.start.x) * point.y + (line1.start.x * line1.end.y - line1.end.x * line1.start.y);
	var del = Math.sqrt(Math.pow(line1.end.x - line1.start.x,2) + Math.pow(line1.end.y - line1.start.y,2));
	var d = ch / del;
	var distance2 = d;
	var point = line1.start;
	var ch = (line2.start.y - line2.end.y) * point.x + (line2.end.x - line2.start.x) * point.y + (line2.start.x * line2.end.y - line2.end.x * line2.start.y);
	var del = Math.sqrt(Math.pow(line2.end.x - line2.start.x,2) + Math.pow(line2.end.y - line2.start.y,2));
	var d = ch / del;
	var distance3 = d;
	var point = line1.end;
	var ch = (line2.start.y - line2.end.y) * point.x + (line2.end.x - line2.start.x) * point.y + (line2.start.x * line2.end.y - line2.end.x * line2.start.y);
	var del = Math.sqrt(Math.pow(line2.end.x - line2.start.x,2) + Math.pow(line2.end.y - line2.start.y,2));
	var d = ch / del;
	var distance4 = d;
	var values = [distance1,distance2,distance3,distance4];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	var distance = min;
	return distance;
};
vision_tools_MathTools.radiansFromLineToPoint2D = function(line,point) {
	var angle = Math.atan2(line.end.x - line.start.x,line.end.y - line.start.y);
	var angle2 = Math.atan2(point.x - line.start.x,point.y - line.start.y);
	return angle2 - angle;
};
vision_tools_MathTools.intersectionBetweenLine2Ds = function(line1,line2) {
	var x1 = line1.start.x;
	var y1 = line1.start.y;
	var x2 = line1.end.x;
	var y2 = line1.end.y;
	var x3 = line2.start.x;
	var y3 = line2.start.y;
	var x4 = line2.end.x;
	var y4 = line2.end.y;
	var denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
	if(x1 == x2 && y1 == y2 || x3 == x4 && y3 == y4) {
		return null;
	}
	if(denominator == 0) {
		return null;
	}
	var ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
	var ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
	if(ua < 0 || ua > 1 || ub < 0 || ub > 1) {
		return null;
	}
	var x = x1 + ua * (x2 - x1);
	var y = y1 + ua * (y2 - y1);
	return new vision_ds_Point2D(x | 0,y | 0);
};
vision_tools_MathTools.mirrorInsideRectangle = function(line,rect) {
	var diffSX = line.start.x - rect.x;
	var diffEX = line.end.x - rect.x;
	line.start.x = rect.x + rect.width - diffSX;
	line.end.x = rect.x + rect.width - diffEX;
	return line;
};
vision_tools_MathTools.flipInsideRectangle = function(line,rect) {
	var diffSY = line.start.y - rect.y;
	var diffEY = line.end.y - rect.y;
	line.start.y = rect.y + rect.width - diffSY;
	line.end.y = rect.y + rect.width - diffEY;
	return line;
};
vision_tools_MathTools.invertInsideRectangle = function(line,rect) {
	var diffSY = line.start.y - rect.y;
	var diffEY = line.end.y - rect.y;
	var diffSX = line.start.x - rect.x;
	var diffEX = line.end.x - rect.x;
	line.start.x = rect.x + rect.width - diffSX;
	line.end.x = rect.x + rect.width - diffEX;
	line.start.y = rect.y + rect.width - diffSY;
	line.end.y = rect.y + rect.width - diffEY;
	return line;
};
vision_tools_MathTools.clamp = function(value,mi,ma) {
	var values = [value,mi];
	var max = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] > max) {
			max = values[i];
		}
	}
	var values = [max,ma];
	var min = values[0];
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		if(values[i] < min) {
			min = values[i];
		}
	}
	return min;
};
vision_tools_MathTools.isBetweenRanges = function(value) {
	var $l=arguments.length;
	var ranges = new Array($l>1?$l-1:0);
	for(var $i=1;$i<$l;++$i){ranges[$i-1]=arguments[$i];}
	var between = false;
	var _g_current = 0;
	var _g_args = ranges;
	while(_g_current < _g_args.length) {
		var range = _g_args[_g_current++];
		if(range.end < range.start) {
			var temp = range.start;
			range.start = range.end;
			range.end = temp;
		}
		between = value > range.start && value > range.end;
		if(between) {
			return true;
		}
	}
	return false;
};
vision_tools_MathTools.isBetweenRange = function(value,min,max) {
	if(value > min) {
		return value > max;
	} else {
		return false;
	}
};
vision_tools_MathTools.wrapInt = function(value,min,max) {
	var range = max - min + 1;
	if(value < min) {
		value += range * ((min - value) / range + 1 | 0);
	}
	return min + (value - min) % range;
};
vision_tools_MathTools.wrapFloat = function(value,min,max) {
	var range = max - min;
	if(value < min) {
		value += range * (min - value) / range + 1;
	}
	return min + (value - min) % range;
};
vision_tools_MathTools.boundInt = function(value,min,max) {
	if(value < min) {
		return min;
	}
	if(value > max) {
		return max;
	}
	return value;
};
vision_tools_MathTools.boundFloat = function(value,min,max) {
	var t = value < min ? min : value;
	if(t > max) {
		return max;
	} else {
		return t;
	}
};
vision_tools_MathTools.gamma = function(x) {
	var g = 7.0;
	var p = [0.99999999999980993,676.5203681218851,-1259.1392167224028,771.32342877765313,-176.61502916214059,12.507343278686905,-0.13857109526572012,9.9843695780195716e-6,1.5056327351493116e-7];
	if(x < 0.5) {
		return Math.PI / (Math.sin(Math.PI * x) * vision_tools_MathTools.gamma(1 - x));
	} else {
		--x;
		var a = p[0];
		var t = x + g + 0.5;
		var _g = 1;
		var _g1 = p.length;
		while(_g < _g1) {
			var i = _g++;
			a += p[i] / (x + i);
		}
		return Math.sqrt(Math.PI * 2) * Math.pow(t,x + 0.5) * Math.exp(-t) * a;
	}
};
vision_tools_MathTools.factorial = function(value) {
	var val = vision_tools_MathTools.gamma(value + 1);
	return val;
};
vision_tools_MathTools.slopeToDegrees = function(slope) {
	return Math.atan(slope) * 180 / Math.PI;
};
vision_tools_MathTools.slopeToRadians = function(slope) {
	return Math.atan(slope);
};
vision_tools_MathTools.degreesToSlope = function(degrees) {
	return Math.tan(degrees * Math.PI / 180);
};
vision_tools_MathTools.degreesToRadians = function(degrees) {
	return degrees * Math.PI / 180;
};
vision_tools_MathTools.radiansToDegrees = function(radians) {
	return radians * 180 / Math.PI;
};
vision_tools_MathTools.radiansToSlope = function(radians) {
	return Math.tan(radians);
};
vision_tools_MathTools.cotan = function(radians) {
	return 1 / Math.tan(radians);
};
vision_tools_MathTools.cosec = function(radians) {
	return 1 / Math.sin(radians);
};
vision_tools_MathTools.sec = function(radians) {
	return 1 / Math.cos(radians);
};
vision_tools_MathTools.sind = function(degrees) {
	return Math.sin(degrees * Math.PI / 180);
};
vision_tools_MathTools.cosd = function(degrees) {
	return Math.cos(degrees * Math.PI / 180);
};
vision_tools_MathTools.tand = function(degrees) {
	return Math.tan(degrees * Math.PI / 180);
};
vision_tools_MathTools.cotand = function(degrees) {
	return 1 / Math.tan(degrees * Math.PI / 180);
};
vision_tools_MathTools.cosecd = function(degrees) {
	return 1 / Math.sin(degrees * Math.PI / 180);
};
vision_tools_MathTools.secd = function(degrees) {
	return 1 / Math.cos(degrees * Math.PI / 180);
};
vision_tools_MathTools.truncate = function(num,numbersAfterDecimal) {
	var multiplier = Math.pow(10,numbersAfterDecimal);
	return Math.round(num * multiplier) / multiplier;
};
vision_tools_MathTools.cropDecimal = function(number) {
	if(number < 0) {
		return Math.ceil(number);
	}
	return Math.floor(number);
};
vision_tools_MathTools.isInt = function(v) {
	return v == (v | 0);
};
vision_tools_MathTools.get_NEGATIVE_INFINITY = function() {
	return -Infinity;
};
vision_tools_MathTools.get_POSITIVE_INFINITY = function() {
	return Infinity;
};
vision_tools_MathTools.get_NaN = function() {
	return NaN;
};
vision_tools_MathTools.get_PI_OVER_2 = function() {
	return Math.PI / 2;
};
vision_tools_MathTools.get_PI = function() {
	return Math.PI;
};
vision_tools_MathTools.abs = function(v) {
	return Math.abs(v);
};
vision_tools_MathTools.acos = function(v) {
	return Math.acos(v);
};
vision_tools_MathTools.asin = function(v) {
	return Math.asin(v);
};
vision_tools_MathTools.atan = function(v) {
	return Math.atan(v);
};
vision_tools_MathTools.atan2 = function(y,x) {
	return Math.atan2(x,y);
};
vision_tools_MathTools.ceil = function(v) {
	return Math.ceil(v);
};
vision_tools_MathTools.cos = function(radians) {
	return Math.cos(radians);
};
vision_tools_MathTools.exp = function(v) {
	return Math.exp(v);
};
vision_tools_MathTools.floor = function(v) {
	return Math.floor(v);
};
vision_tools_MathTools.log = function(v) {
	return Math.log(v);
};
vision_tools_MathTools.pow = function(v,exp) {
	return Math.pow(v,exp);
};
vision_tools_MathTools.random = function() {
	return Math.random();
};
vision_tools_MathTools.round = function(v) {
	return Math.round(v);
};
vision_tools_MathTools.sin = function(radians) {
	return Math.sin(radians);
};
vision_tools_MathTools.sqrt = function(v) {
	return Math.sqrt(v);
};
vision_tools_MathTools.tan = function(radians) {
	return Math.tan(radians);
};
vision_tools_MathTools.ffloor = function(v) {
	return Math.floor(v);
};
vision_tools_MathTools.fceil = function(v) {
	return Math.ceil(v);
};
vision_tools_MathTools.fround = function(v) {
	return Math.round(v);
};
vision_tools_MathTools.isFinite = function(f) {
	return isFinite(f);
};
vision_tools_MathTools.isNaN = function(f) {
	return isNaN(f);
};
vision_tools_MathTools.parseFloat = function(s) {
	return parseFloat(s);
};
vision_tools_MathTools.parseInt = function(s) {
	return Std.parseInt(s);
};
vision_tools_MathTools.parseBool = function(s) {
	s = StringTools.trim(s).toLowerCase();
	if(s == "true") {
		return true;
	}
	if(s == "false") {
		return false;
	}
	return null;
};
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
$hxClasses["Math"] = Math;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
Object.defineProperty(String.prototype,"__class__",{ value : $hxClasses["String"] = String, enumerable : false, writable : true});
String.__name__ = "String";
$hxClasses["Array"] = Array;
Array.__name__ = "Array";
Date.prototype.__class__ = $hxClasses["Date"] = Date;
Date.__name__ = "Date";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
js_Boot.__toStr = ({ }).toString;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl;
}
haxe_Int32._mul = Math.imul != null ? Math.imul : function(a,b) {
	return a * (b & 65535) + (a * (b >>> 16) << 16 | 0) | 0;
};
haxe_Serializer.USE_CACHE = false;
haxe_Serializer.USE_ENUM_INDEX = false;
haxe_Serializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
haxe_Unserializer.DEFAULT_RESOLVER = new haxe__$Unserializer_DefaultResolver();
haxe_Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
haxe_hash_Murmur1.m = -962287725;
little_tools_TextTools.fonts = new little_tools__$TextTools_MultilangFonts();
little_tools_TextTools.loremIpsumText = "\r\n\t\tLorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque finibus condimentum magna, eget porttitor libero aliquam non. Praesent commodo, augue nec hendrerit tincidunt, urna felis lobortis mi, non cursus libero tellus quis tellus. Vivamus ornare convallis tristique. Integer nec ornare libero. Phasellus feugiat facilisis faucibus. Vivamus porta id neque id placerat. Proin convallis vel felis et pharetra. Quisque magna justo, ullamcorper quis scelerisque eu, tincidunt vitae lectus. Nunc sed turpis justo. Aliquam porttitor, purus sit amet faucibus bibendum, ligula elit molestie purus, eu volutpat turpis sapien ac tellus. Fusce mauris arcu, volutpat ut aliquam ut, ultrices id ante. Morbi quis consectetur turpis. Integer semper lacinia urna id laoreet.\r\n\r\n\t\tUt mollis eget eros eu tempor. Phasellus nulla velit, sollicitudin eget massa a, tristique rutrum turpis. Vestibulum in dolor at elit pellentesque finibus. Nulla pharetra felis a varius molestie. Nam magna lectus, eleifend ac sagittis id, ornare id nibh. Praesent congue est non iaculis consectetur. Nullam dictum augue sit amet dignissim fringilla. Aenean semper justo velit. Sed nec lectus facilisis, sodales diam eget, imperdiet nunc. Quisque elementum nulla non orci interdum pharetra id quis arcu. Phasellus eu nunc lectus. Nam tellus tortor, pellentesque eget faucibus eu, laoreet quis odio. Pellentesque posuere in enim a blandit.\r\n\r\n\t\tDuis dignissim neque et ex iaculis, ac consequat diam gravida. In mi ex, blandit eget velit non, euismod feugiat arcu. Nulla nec fermentum neque, eget elementum mauris. Vivamus urna ligula, faucibus at facilisis sed, commodo sit amet urna. Sed porttitor feugiat purus ac tincidunt. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Aliquam sollicitudin lacinia turpis quis placerat. Donec eget velit nibh. Duis vehicula orci lectus, eget rutrum arcu tincidunt et. Vestibulum ut pharetra lectus. Quisque lacinia nunc rhoncus neque venenatis consequat. Nulla rutrum ultricies sapien, sed semper lectus accumsan nec. Phasellus commodo faucibus lacinia. Donec auctor condimentum ligula. Sed quis viverra mauris.\r\n\r\n\t\tQuisque maximus justo dui, eget pretium lorem accumsan ac. Praesent eleifend faucibus orci et varius. Ut et molestie turpis, eu porta neque. Quisque vehicula, libero in tincidunt facilisis, purus eros pulvinar leo, sit amet eleifend justo ligula tempor lectus. Donec ac tortor sed ipsum tincidunt pulvinar id nec eros. In luctus purus cursus est dictum, ac sollicitudin turpis maximus. Maecenas a nisl velit. Nulla gravida lectus vel ultricies gravida. Proin vel bibendum magna. Donec aliquam ultricies quam, quis tempor nunc pharetra ut.\r\n\r\n\t\tPellentesque sit amet dui est. Aliquam erat volutpat. Integer vitae ullamcorper est, ut eleifend augue. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Quisque congue velit felis, vitae elementum nulla faucibus id. Donec lectus nibh, commodo eget nunc id, feugiat sagittis massa. In hac habitasse platea dictumst. Pellentesque volutpat molestie ultrices.\r\n\t";
little_KeywordConfig.defaultConfig = new little_KeywordConfig(null,null);
little_KeywordConfig.recognizedOperators = ["!","#","$","%","&","'","(",")","*","+","-",".","/",":","<","=",">","?","@","[","\\","]","^","_","`","{","|","}","~","^",""];
little_interpreter_memory_Referrer.KEY_SIZE = 16;
little_Little.keywords = new little_KeywordConfig(null,true);
little_Little.runtime = new little_interpreter_Runtime();
little_Little.memory = new little_interpreter_memory_Memory();
little_Little.plugin = new little_tools_Plugins(little_Little.memory);
little_Little.operators = new little_interpreter_memory_Operators();
little_Little.queue = new vision_ds_Queue();
little_Little.debug = false;
little_Little.version = "1.0.0-f";
little_interpreter_memory_HashTables.OBJECT_HASH_TABLE_CELL_SIZE = 16;
little_interpreter_memory_MemoryPointer.POINTER_SIZE = 4;
var little_interpreter_memory_MemoryPointer_POINTER_SIZE = 4;
little_parser_Parser.additionalParsingLevels = [little_parser_Parser.mergeElses];
little_parser_Parser.linePart = 0;
little_tools_Layer.LEXER = "Lexer";
little_tools_Layer.PARSER = "Parser";
little_tools_Layer.PARSER_MACRO = "Parser, Macro";
little_tools_Layer.INTERPRETER = "Interpreter";
little_tools_Layer.INTERPRETER_VALUE_EVALUATOR = "Interpreter, Value Evaluator";
little_tools_Layer.INTERPRETER_EXPRESSION_EVALUATOR = "Interpreter, Expression Evaluator";
little_tools_Layer.INTERPRETER_TOKEN_VALUE_STRINGIFIER = "Interpreter, Token Value Stringifier";
little_tools_Layer.INTERPRETER_TOKEN_IDENTIFIER_STRINGIFIER = "Interpreter, Token Identifier Stringifier";
little_tools_Layer.MEMORY = "Memory";
little_tools_Layer.MEMORY_REFERRER = "Memory, Referrer";
little_tools_Layer.MEMORY_STORAGE = "Memory, Storage";
little_tools_Layer.MEMORY_EXTERNAL_INTERFACING = "Memory, External Interfacing";
little_tools_Layer.MEMORY_SIZE_EVALUATOR = "Memory, Size Evaluator";
little_tools_Layer.MEMORY_GARBAGE_COLLECTOR = "Memory, Garbage Collector";
little_tools_PrepareRun.prepared = false;
little_tools_PrettyPrinter.s = "";
little_tools_PrettyPrinter.l = 0;
little_tools_PrettyPrinter.indent = "";
vision_ds_Color.TRANSPARENT = 0;
vision_ds_Color.WHITE = -1;
vision_ds_Color.GRAY = -8355712;
vision_ds_Color.BLACK = -16777216;
vision_ds_Color.GREEN = -16711936;
vision_ds_Color.YELLOW = -256;
vision_ds_Color.ORANGE = -23296;
vision_ds_Color.RED = -65536;
vision_ds_Color.PURPLE = -8388480;
vision_ds_Color.BLUE = -16776961;
vision_ds_Color.BROWN = -7650029;
vision_ds_Color.PINK = -16181;
vision_ds_Color.MAGENTA = -65281;
vision_ds_Color.CYAN = -16711681;
vision_ds_Color.SILVER = 12632256;
vision_ds_Color.GOLD = -10496;
vision_ds_Color.OLIVE = -8355840;
vision_ds_Color.MAROON = -8388608;
vision_ds_Color.BORDEAUX = -9294025;
vision_ds_Color.NAVY = -16777088;
vision_ds_Color.TEAL = -16744320;
vision_ds_Color.FUCHSIA = -65281;
vision_ds_Color.AQUA = -16711681;
vision_ds_Color.LIME = -13447886;
vision_ds_Color.CHARCOAL = -13220529;
vision_ds_Color.ONYX = -13289415;
vision_ds_Color.JET = -13355980;
vision_ds_Color.JET_BLACK = -15856112;
vision_ds_Color.ROYAL_BLUE = -12490271;
vision_ds_Color.COLOR_REGEX = new EReg("^(0x|#)(([A-F0-9]{2}){3,4})$","i");
vision_ds_Image.OFFSET = 11;
vision_ds_Image.WIDTH_BYTES = 2;
vision_ds_Image.VIEW_XY_BYTES = 4;
vision_ds_Image.VIEW_WH_BYTES = 4;
vision_ds_Image.VIEW_SHAPE_BYTES = 1;
vision_ds_Image.DATA_GAP = 2;
vision_ds_PixelFormat.ARGB = 0;
vision_ds_PixelFormat.RGBA = 1;
vision_ds_PixelFormat.ABGR = 2;
vision_ds_PixelFormat.BGRA = 3;
vision_ds_PixelFormat.RGB = 4;
vision_ds_PixelFormat.BGR = 5;
vision_helpers_VisionThread.COUNT = 0;
vision_tools_ImageTools.defaultResizeAlgorithm = 1;
Main.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

//# sourceMappingURL=interp.js.map