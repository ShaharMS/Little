private class haxe.ds._Map.Map_Impl_ {

	@:noCompletion
	public static function _new

	public static inline function set(this:haxe.IMap<haxe.ds.Map.K, haxe.ds.Map.V>, key:haxe.ds.Map.K, value:haxe.ds.Map.V) this.set(key, value)

	@:arrayAccess
	public static inline function get(this:haxe.IMap<haxe.ds.Map.K, haxe.ds.Map.V>, key:haxe.ds.Map.K) return this.get(key)

	public static inline function exists(this:haxe.IMap<haxe.ds.Map.K, haxe.ds.Map.V>, key:haxe.ds.Map.K) return this.exists(key)

	public static inline function remove(this:haxe.IMap<haxe.ds.Map.K, haxe.ds.Map.V>, key:haxe.ds.Map.K) return this.remove(key)

	public static inline function keys(this:haxe.IMap<haxe.ds.Map.K, haxe.ds.Map.V>) {
		return this.keys();
	}

	public static inline function iterator(this:haxe.IMap<haxe.ds.Map.K, haxe.ds.Map.V>) {
		return this.iterator();
	}

	public static inline function keyValueIterator(this:haxe.IMap<haxe.ds.Map.K, haxe.ds.Map.V>) {
		return this.keyValueIterator();
	}

	public static inline function copy(this:haxe.IMap<haxe.ds.Map.K, haxe.ds.Map.V>) {
		return cast this.copy();
	}

	public static inline function toString(this:haxe.IMap<haxe.ds.Map.K, haxe.ds.Map.V>) {
		return this.toString();
	}

	public static inline function clear(this:haxe.IMap<haxe.ds.Map.K, haxe.ds.Map.V>) {
		this.clear();
	}

	@:arrayAccess @:noCompletion
	public static inline function arrayWrite(this:haxe.IMap<haxe.ds.Map.K, haxe.ds.Map.V>, k:haxe.ds.Map.K, v:haxe.ds.Map.V) {
		this.set(k, v);
		return v;
	}

	@:multiType @:to
	static inline function toStringMap<K:String, V>(t:haxe.IMap<toStringMap.K, toStringMap.V>) {
		return new haxe.ds.StringMap();
	}

	@:multiType @:to
	static inline function toIntMap<K:Int, V>(t:haxe.IMap<toIntMap.K, toIntMap.V>) {
		return new haxe.ds.IntMap();
	}

	@:multiType @:to
	static inline function toEnumValueMapMap<K:EnumValue, V>(t:haxe.IMap<toEnumValueMapMap.K, toEnumValueMapMap.V>) {
		return new haxe.ds.EnumValueMap();
	}

	@:multiType @:to
	static inline function toObjectMap<K:{ }, V>(t:haxe.IMap<toObjectMap.K, toObjectMap.V>) {
		return new haxe.ds.ObjectMap();
	}

	@:from
	static inline function fromStringMap<V>(map:haxe.ds.StringMap<fromStringMap.V>) {
		return cast map;
	}

	@:from
	static inline function fromIntMap<V>(map:haxe.ds.IntMap<fromIntMap.V>) {
		return cast map;
	}

	@:from
	static inline function fromObjectMap<K:{ }, V>(map:haxe.ds.ObjectMap<fromObjectMap.K, fromObjectMap.V>) {
		return cast map;
	}
}