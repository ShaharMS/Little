@:keep @:directlyUsed @:used
class haxe.ds.ArraySort {

	public static function sort<T>(a:Array<sort.T>, cmp:(sort.T, sort.T) -> Int) {
		haxe.ds.ArraySort.rec(a, cmp, 0, a.length);
	}

	static function rec<T>(a:Array<rec.T>, cmp:(rec.T, rec.T) -> Int, from:Int, to:Int) {
		var middle = from + to >> 1;
		if ((to - from < 12)) {
			if ((to <= from)) return;
			{
				var ` = from + 1;
				var ` = to;
				while ((` < `)) {
					var i = ` ++;
					var j = i;
					while ((j > from)) {
						if ((cmp(a[j], a[j - 1]) < 0)) haxe.ds.ArraySort.swap(a, j - 1, j) else break;
						-- j;
					};
				};
			};
			return;
		};
		haxe.ds.ArraySort.rec(a, cmp, from, middle);
		haxe.ds.ArraySort.rec(a, cmp, middle, to);
		haxe.ds.ArraySort.doMerge(a, cmp, from, middle, to, middle - from, to - middle);
	}

	static function doMerge<T>(a:Array<doMerge.T>, cmp:(doMerge.T, doMerge.T) -> Int, from:Int, pivot:Int, to:Int, len1:Int, len2:Int) {
		var first_cut;
		var second_cut;
		var len11;
		var len22;
		if ((len1 == 0 || len2 == 0)) return;
		if ((len1 + len2 == 2)) {
			if ((cmp(a[pivot], a[from]) < 0)) haxe.ds.ArraySort.swap(a, pivot, from);
			return;
		};
		if ((len1 > len2)) {
			len11 = len1 >> 1;
			first_cut = from + len11;
			second_cut = haxe.ds.ArraySort.lower(a, cmp, pivot, to, first_cut);
			len22 = second_cut - pivot;
		} else {
			len22 = len2 >> 1;
			second_cut = pivot + len22;
			first_cut = haxe.ds.ArraySort.upper(a, cmp, from, pivot, second_cut);
			len11 = first_cut - from;
		};
		haxe.ds.ArraySort.rotate(a, cmp, first_cut, pivot, second_cut);
		var new_mid = first_cut + len22;
		haxe.ds.ArraySort.doMerge(a, cmp, from, first_cut, new_mid, len11, len22);
		haxe.ds.ArraySort.doMerge(a, cmp, new_mid, second_cut, to, len1 - len11, len2 - len22);
	}

	static function rotate<T>(a:Array<rotate.T>, cmp:(rotate.T, rotate.T) -> Int, from:Int, mid:Int, to:Int) {
		if ((from == mid || mid == to)) return;
		var n = haxe.ds.ArraySort.gcd(to - from, mid - from);
		while ((n -- != 0)) {
			var val = a[from + n];
			var shift = mid - from;
			var p1 = from + n;
			var p2 = from + n + shift;
			while ((p2 != from + n)) {
				a[p1] = a[p2];
				p1 = p2;
				if ((to - p2 > shift)) p2 += shift else p2 = from + (shift - (to - p2));
			};
			a[p1] = val;
		};
	}

	static function gcd(m:Int, n:Int) {
		while ((n != 0)) {
			var t = m % n;
			m = n;
			n = t;
		};
		return m;
	}

	static function upper<T>(a:Array<upper.T>, cmp:(upper.T, upper.T) -> Int, from:Int, to:Int, val:Int) {
		var len = to - from;
		var half;
		var mid;
		while ((len > 0)) {
			half = len >> 1;
			mid = from + half;
			if ((cmp(a[val], a[mid]) < 0)) len = half else {
				from = mid + 1;
				len = len - half - 1;
			};
		};
		return from;
	}

	static function lower<T>(a:Array<lower.T>, cmp:(lower.T, lower.T) -> Int, from:Int, to:Int, val:Int) {
		var len = to - from;
		var half;
		var mid;
		while ((len > 0)) {
			half = len >> 1;
			mid = from + half;
			if ((cmp(a[mid], a[val]) < 0)) {
				from = mid + 1;
				len = len - half - 1;
			} else len = half;
		};
		return from;
	}

	static function swap<T>(a:Array<swap.T>, i:Int, j:Int) {
		var tmp = a[i];
		a[i] = a[j];
		a[j] = tmp;
	}
}