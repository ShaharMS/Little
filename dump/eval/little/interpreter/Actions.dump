@:directlyUsed @:used @:access(little.interpreter.Runtime) @:access(little.interpreter.Interpreter)
class little.interpreter.Actions {

	@:value(Interpreter.memory)
	public static var memory:little.interpreter.memory.MemoryTree = little.interpreter.Interpreter.memory;

	public static function scwm(memory:little.interpreter.memory.MemoryTree) {
		little.interpreter.Actions.memory = memory;
	}

	@:value({ layer : INTERPRETER })
	public static function error(message:String, layer:little.tools.Layer = "Interpreter") {
		little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage(message), layer);
		haxe.Log.trace(little.interpreter.Runtime.stdout.output, {fileName : "src/little/interpreter/Actions.hx", lineNumber : 37, className : "little.interpreter.Actions", methodName : "error"});
		throw "";
	}

	@:value({ layer : INTERPRETER })
	public static function warn(message:String, layer:little.tools.Layer = "Interpreter") {
		little.interpreter.Runtime.warn(little.parser.ParserTokens.ErrorMessage(message), layer);
		return little.parser.ParserTokens.ErrorMessage(message);
	}

	public static function setLine(l:Int) {
		var o = little.interpreter.Runtime.line;
		little.interpreter.Runtime.line = l;
		{
			var ` = 0;
			var ` = little.interpreter.Runtime.onLineChanged;
			while ((` < `.length)) {
				var listener = `[`];
				++ `;
				listener(o);
			};
		};
	}

	public static function setModule(name:String) {
		var o = little.interpreter.Runtime.currentModule;
		little.interpreter.Runtime.currentModule = name;
	}

	public static function splitLine() {}

	public static function declareVariable(name:little.parser.ParserTokens, type:little.parser.ParserTokens, doc:little.parser.ParserTokens) {
		var access = [null];
		access[0] = function(onObject:little.interpreter.memory.MemoryObject, prop:little.parser.ParserTokens, objName:String) {
			if ((enumIndex prop == 14)) {
				var ` = prop[0];
				var property = prop[1];
				objName += "" + little.Little.keywords.PROPERTY_ACCESS_SIGN + little.tools.Extensions.value(prop);
				var propName = little.tools.Extensions.value(prop);
				if ((little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(onObject.props, propName) == null)) {
					little.interpreter.Actions.error("Unable to create `" + objName + little.Little.keywords.PROPERTY_ACCESS_SIGN + little.tools.Extensions.identifier(property) + "`: `" + objName + "` Does not contain property `" + little.tools.Extensions.identifier(property) + "`.", null);
					return null;
				};
				var access = access[0];
				var propName = little.tools.Extensions.value(prop);
				return access(little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(onObject.props, propName), property, objName);
			} else {
				var propName = little.tools.Extensions.identifier(prop);
				if ((little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(onObject.props, propName) == null)) {
					var propName = little.tools.Extensions.identifier(prop);
					var object = new little.interpreter.memory.MemoryObject(little.parser.ParserTokens.NullValue, null, null, type, null, null, null, onObject, little.tools.Extensions.value(doc));
					little.interpreter.memory._MemoryTree.MemoryTree_Impl_.set(onObject.props, propName, object);
				};
				var propName = little.tools.Extensions.identifier(prop);
				return little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(onObject.props, propName);
			};
		};
		if ((enumIndex name == 14)) {
			var name = name[0];
			var property = name[1];
			access[0](little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(little.interpreter.Actions.memory, little.tools.Extensions.value(name)), property, little.tools.Extensions.value(name));
		} else {
			var this = little.interpreter.Actions.memory;
			var key = little.tools.Extensions.value(name);
			if ((cast cast this.map.exists(key))) little.interpreter.Actions.warn("Variable " + little.tools.Extensions.value(name) + " already exists. New declaration ignored.", null) else little.interpreter.memory._MemoryTree.MemoryTree_Impl_.set(little.interpreter.Actions.memory, little.tools.Extensions.value(name), new little.interpreter.memory.MemoryObject(little.parser.ParserTokens.NullValue, null, null, if ((type != null)) little.interpreter.Actions.evaluate(type, null) else little.parser.ParserTokens.NullValue, null, null, null, little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get_object(little.interpreter.Actions.memory), little.tools.Extensions.value(doc)));
		};
		return little.interpreter.Actions.read(name);
	}

	public static function declareFunction(name:little.parser.ParserTokens, params:little.parser.ParserTokens, type:little.parser.ParserTokens, doc:little.parser.ParserTokens) {
		var access = [null];
		access[0] = function(object:little.interpreter.memory.MemoryObject, prop:little.parser.ParserTokens, objName:String) {
			if ((enumIndex prop == 14)) {
				var ` = prop[0];
				var nestedProperty = prop[1];
				objName += "" + little.Little.keywords.PROPERTY_ACCESS_SIGN + little.tools.Extensions.value(prop);
				var propName = little.tools.Extensions.value(prop);
				if ((little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(object.props, propName) == null)) {
					little.interpreter.Actions.error("Unable to create `" + objName + little.Little.keywords.PROPERTY_ACCESS_SIGN + little.tools.Extensions.identifier(nestedProperty) + "`: `" + objName + "` Does not contain property `" + little.tools.Extensions.identifier(nestedProperty) + "`.", null);
					return null;
				};
				var access = access[0];
				var propName = little.tools.Extensions.value(prop);
				return access(little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(object.props, propName), nestedProperty, objName);
			} else {
				var propName = little.tools.Extensions.identifier(prop);
				if ((little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(object.props, propName) == null)) {
					var propName = little.tools.Extensions.identifier(prop);
					var object = new little.interpreter.memory.MemoryObject(little.parser.ParserTokens.NullValue, null, Type.enumParameters(params)[0], if ((type != null)) type else little.parser.ParserTokens.NullValue, null, null, null, object, little.tools.Extensions.value(doc));
					little.interpreter.memory._MemoryTree.MemoryTree_Impl_.set(object.props, propName, object);
				};
				var propName = little.tools.Extensions.identifier(prop);
				return little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(object.props, propName);
			};
		};
		if ((enumIndex name == 14)) {
			var name = name[0];
			var property = name[1];
			access[0](little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(little.interpreter.Actions.memory, little.tools.Extensions.value(name)), property, little.tools.Extensions.value(name));
		} else {
			var this = little.interpreter.Actions.memory;
			var key = little.tools.Extensions.value(name);
			if ((cast cast this.map.exists(key))) little.interpreter.Actions.warn("Function " + little.tools.Extensions.value(name) + " already exists. New declaration ignored.", null) else little.interpreter.memory._MemoryTree.MemoryTree_Impl_.set(little.interpreter.Actions.memory, little.tools.Extensions.value(name), new little.interpreter.memory.MemoryObject(little.parser.ParserTokens.NullValue, null, Type.enumParameters(params)[0], if ((type != null)) little.interpreter.Actions.evaluate(type, null) else little.parser.ParserTokens.NullValue, null, null, null, little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get_object(little.interpreter.Actions.memory), little.tools.Extensions.value(doc)));
		};
		return little.interpreter.Actions.read(name);
	}

	public static function condition(name:little.parser.ParserTokens, conditionParams:little.parser.ParserTokens, body:little.parser.ParserTokens) {
		if ((little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(little.interpreter.Actions.memory, little.tools.Extensions.value(name)) == null)) return little.interpreter.Actions.error("No Such Condition:  `" + little.tools.Extensions.value(name) + "`", null) else {
			var o = little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(little.interpreter.Actions.memory, little.tools.Extensions.value(name)).use(little.parser.ParserTokens.PartArray([conditionParams, body]));
			if ((Type.enumEq(o, little.parser.ParserTokens.NullValue))) return o;
			if ((Type.enumConstructor(o) == "ErrorMessage")) return little.interpreter.Actions.error(little.tools.Extensions.value(o), null);
			return o;
		};
	}

	public static function write(assignees:Array<little.parser.ParserTokens>, value:little.parser.ParserTokens) {
		var v = null;
		if ((little.tools.Extensions.containsAny(assignees, function(x:little.parser.ParserTokens) {
			return little.tools.Extensions.is(x, @:implicitCast cast [little.tools.ParserTokensSimple.FUNCTION]);
		}))) v = value else v = little.interpreter.Actions.evaluate(value, null);
		{
			var ` = 0;
			while ((` < assignees.length)) {
				var a = assignees[`];
				++ `;
				var assignee = little.interpreter.Interpreter.accessObject(a, little.interpreter.Actions.memory);
				if ((assignee == null)) continue;
				if ((assignee.params != null)) assignee.set_value(value) else if ((Type.enumConstructor(v) != "ErrorMessage")) assignee.set_value(v);
			};
		};
		return v;
	}

	public static function call(name:little.parser.ParserTokens, params:little.parser.ParserTokens) {
		if ((little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(little.interpreter.Actions.memory, little.tools.Extensions.value(name)) == null)) return little.interpreter.Actions.error("No Such Function: `" + little.tools.Extensions.value(name) + "`", null) else {
			var o = little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(little.interpreter.Actions.memory, little.tools.Extensions.value(name)).use(params);
			if ((Type.enumConstructor(o) == "ErrorMessage")) return little.interpreter.Actions.error(little.tools.Extensions.value(o), null);
			return o;
		};
	}

	public static function read(name:little.parser.ParserTokens) {
		if ((Type.enumConstructor(name) == "PropertyAccess")) return little.interpreter.Actions.evaluate(name, null);
		var word = little.tools.Extensions.identifier(name);
		return little.interpreter.Actions.evaluate(if ((little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(little.interpreter.Actions.memory, word) != null)) little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(little.interpreter.Actions.memory, word).value else little.parser.ParserTokens.ErrorMessage("No Such Variable: `" + word + "`"), null);
	}

	public static function type(value:little.parser.ParserTokens, type:little.parser.ParserTokens) {
		var val = little.interpreter.Actions.evaluate(value, null);
		var valT = little.interpreter.Interpreter.getValueType(val);
		var t = little.interpreter.Actions.evaluate(type, null);
		if ((! little.tools.Extensions.is(t, @:implicitCast cast [little.tools.ParserTokensSimple.MODULE]) || ! little.tools.Extensions.is(valT, @:implicitCast cast [little.tools.ParserTokensSimple.MODULE]))) haxe.Log.trace(val, {fileName : "src/little/interpreter/Actions.hx", lineNumber : 257, className : "little.interpreter.Actions", methodName : "type", customParams : [valT, t]});
		if ((Type.enumEq(t, valT))) return val else {
			var _this = little.interpreter.Interpreter.accessObject(value, null);
			var propName = little.Little.keywords.TYPE_CAST_FUNCTION_PREFIX + little.tools.Extensions.value(t);
			var castFunc = little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(_this.props, propName);
			if ((castFunc == null)) {
				little.interpreter.Actions.warn("Mismatch at type declaration: the value " + Std.string(value) + " has been declared as being of type " + Std.string(t) + ", while its type is " + Std.string(valT) + ". This might cause issues.", cast "Interpreter, Value Evaluator");
				return val;
			};
			return castFunc.use(little.parser.ParserTokens.PartArray([]));
		};
	}

	public static function run(body:Array<little.parser.ParserTokens>) {
		var returnVal = null;
		var i = 0;
		while ((i < body.length)) {
			var token = body[i];
			if ((token == null)) {
				++ i;
				continue;
			};
			switch ((enumIndex token)) {
				case 0: {
					var line = token[0];
					little.interpreter.Actions.setLine(line);
				};
				case 1: little.interpreter.Actions.splitLine();
				case 2: {
					var name = token[0];
					var type = token[1];
					var doc = token[2];
					{
						little.interpreter.Actions.declareVariable(name, type, doc);
						returnVal = little.parser.ParserTokens.NullValue;
					};
				};
				case 3: {
					var name = token[0];
					var params = token[1];
					var type = token[2];
					var doc = token[3];
					{
						little.interpreter.Actions.declareFunction(name, params, type, doc);
						returnVal = little.parser.ParserTokens.NullValue;
					};
				};
				case 4: {
					var name = token[0];
					var exp = token[1];
					var body = token[2];
					returnVal = little.interpreter.Actions.condition(name, exp, body);
				};
				case 5: {
					var name = token[0];
					returnVal = little.interpreter.Actions.read(name);
				};
				case 6: {
					var assignees = token[0];
					var value = token[1];
					returnVal = little.interpreter.Actions.write(assignees, value);
				};
				case 9: {
					var name = token[0];
					var params = token[1];
					returnVal = little.interpreter.Actions.call(name, params);
				};
				case 10: {
					var value = token[0];
					var type = token[1];
					return little.interpreter.Actions.evaluate(value, null);
				};
				case 12: {
					var body = token[0];
					var type = token[1];
					returnVal = little.interpreter.Actions.run(body);
				};
				case 14: {
					var name = token[0];
					var property = token[1];
					returnVal = little.interpreter.Actions.evaluate(token, null);
				};
				case 20: {
					var name = token[0];
					little.interpreter.Actions.setModule(name);
				};
				default: returnVal = little.interpreter.Actions.evaluate(token, null)
			};
			++ i;
		};
		return returnVal;
	}

	@:value({ dontThrow : false })
	public static function evaluate(exp:little.parser.ParserTokens, dontThrow:Null<Bool> = false) {
		if ((little.interpreter.Actions.memory == null)) little.interpreter.Actions.memory = little.interpreter.Interpreter.memory;
		if ((exp == null)) return little.parser.ParserTokens.NullValue;
		switch ((enumIndex exp)) {
			case 0: {
				var line = exp[0];
				little.interpreter.Actions.setLine(line);
				return little.parser.ParserTokens.NullValue;
			};
			case 1: {
				little.interpreter.Actions.splitLine();
				return little.parser.ParserTokens.NullValue;
			};
			case 2: {
				var name = exp[0];
				var type = exp[1];
				var doc = exp[2];
				return little.interpreter.Actions.declareVariable(name, type, doc);
			};
			case 3: {
				var name = exp[0];
				var params = exp[1];
				var type = exp[2];
				var doc = exp[3];
				return little.interpreter.Actions.declareFunction(name, params, type, doc);
			};
			case 4: {
				var name = exp[0];
				var exp = exp[1];
				var body = exp[2];
				return little.interpreter.Actions.condition(name, exp, body);
			};
			case 5: {
				var name = exp[0];
				return little.interpreter.Actions.read(name);
			};
			case 6: {
				var assignees = exp[0];
				var value = exp[1];
				return little.interpreter.Actions.write(assignees, value);
			};
			case 7: {
				var word = exp[0];
				return little.interpreter.Actions.evaluate(if ((little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(little.interpreter.Actions.memory, word) != null)) little.interpreter.memory._MemoryTree.MemoryTree_Impl_.get(little.interpreter.Actions.memory, word).value else little.parser.ParserTokens.ErrorMessage("No Such Variable: `" + word + "`"), dontThrow);
			};
			case 8: {
				var value = exp[0];
				var t = exp[1];
				return little.interpreter.Actions.type(value, t);
			};
			case 9: {
				var name = exp[0];
				var params = exp[1];
				return little.interpreter.Actions.call(name, params);
			};
			case 10: {
				var value = exp[0];
				var t = exp[1];
				return little.interpreter.Actions.evaluate(little.interpreter.Actions.type(value, t), null);
			};
			case 11: {
				var parts = exp[0];
				var t = exp[1];
				if ((t != null)) return little.interpreter.Actions.type(little.interpreter.Actions.calculate(parts), t);
				return little.interpreter.Actions.calculate(parts);
			};
			case 12: {
				var body = exp[0];
				var t = exp[1];
				var returnVal = little.interpreter.Actions.run(body);
				if ((t == null)) return little.interpreter.Actions.evaluate(returnVal, dontThrow);
				return little.interpreter.Actions.evaluate(little.interpreter.Actions.type(returnVal, t), dontThrow);
			};
			case 13: {
				var parts = exp[0];
				var ` = [];
				{
					var ` = 0;
					while ((` < parts.length)) {
						var p = parts[`];
						++ `;
						`.push(little.interpreter.Actions.evaluate(p, dontThrow));
					};
				};
				return little.parser.ParserTokens.PartArray(`);
			};
			case 14: {
				var ` = exp[0];
				var ` = exp[1];
				var o = little.interpreter.Interpreter.accessObject(exp, little.interpreter.Actions.memory);
				if ((o != null)) return o.value;
				return little.parser.ParserTokens.NullValue;
			};
			case 15: {
				var ` = exp[0];
				return exp;
			};
			case 16: {
				var ` = exp[0];
				return exp;
			};
			case 17: {
				var ` = exp[0];
				return exp;
			};
			case 18: {
				var ` = exp[0];
				return exp;
			};
			case 20: {
				var ` = exp[0];
				return exp;
			};
			case 21: {
				var ` = exp[0];
				return little.parser.ParserTokens.Characters("External Function/Variable");
			};
			case 23: {
				var msg = exp[0];
				if ((! dontThrow)) little.interpreter.Runtime.throwError(exp, cast "Interpreter, Value Evaluator");
				return exp;
			};
			case 24, 25, 26: return exp;
			default: return little.interpreter.Actions.evaluate(little.parser.ParserTokens.ErrorMessage("Unable to evaluate token `" + Std.string(exp) + "`"), dontThrow)
		};
	}

	public static function calculate(p:Array<little.parser.ParserTokens>) {
		while ((p.length == 1 && Std.isOfType(little.tools.Extensions.parameter(p[0], 0), Array))) p = little.tools.Extensions.parameter(p[0], 0);
		var tokens = little.interpreter.Actions.group(p);
		var castType = null;
		if ((tokens.length == 1)) {
			if ((little.tools.Extensions.is(tokens[0], @:implicitCast cast [little.tools.ParserTokensSimple.PART_ARRAY]))) tokens = little.tools.Extensions.parameter(tokens[0], 0) else if ((little.tools.Extensions.is(tokens[0], @:implicitCast cast [little.tools.ParserTokensSimple.EXPRESSION]))) {
				tokens = little.tools.Extensions.parameter(tokens[0], 0);
				castType = little.tools.Extensions.parameter(tokens[0], 1);
			};
		};
		var calculated = null;
		var sign = "";
		var ` = [];
		{
			var ` = 0;
			var ` = tokens;
			while ((` < `.length)) {
				var v = `[`];
				++ `;
				if ((v != null)) `.push(v);
			};
		};
		tokens = `;
		{
			var ` = 0;
			while ((` < tokens.length)) {
				var token = tokens[`];
				++ `;
				switch ((enumIndex token)) {
					case 11: {
						var parts = token[0];
						var t = token[1];
						{
							var val = if ((t != null)) little.interpreter.Actions.type(little.interpreter.Actions.calculate(parts), t) else little.interpreter.Actions.calculate(parts);
							if ((sign != "" && calculated == null)) calculated = if ((cast cast little.interpreter.Operators.rhsOnly.exists(sign))) cast cast little.interpreter.Operators.rhsOnly.get(sign)(val) else if ((cast cast little.interpreter.Operators.lhsOnly.exists(sign))) little.parser.ParserTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear before the sign (" + little.tools.PrettyPrinter.stringify(null, val) + sign + " instead of " + sign + little.tools.PrettyPrinter.stringify(null, val) + ")") else if ((cast cast little.interpreter.Operators.standard.exists(sign))) little.parser.ParserTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear between two values (" + little.tools.PrettyPrinter.stringify(null, val) + " " + sign + " <some value>)") else little.parser.ParserTokens.ErrorMessage("Operator " + sign + " does not exist. did you make a typo?") else if ((calculated == null)) calculated = val else if ((sign == null)) little.interpreter.Actions.error("Two values cannot come one after the other. At least one of them should be an operator, or, put an operator in between.", null) else calculated = if ((cast cast little.interpreter.Operators.standard.exists(sign))) cast cast little.interpreter.Operators.standard.get(sign)(calculated, val) else if ((cast cast little.interpreter.Operators.lhsOnly.exists(sign))) little.parser.ParserTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should not appear between two values, only to the right of one of them (" + little.tools.PrettyPrinter.stringify(null, val) + sign + " or " + little.tools.PrettyPrinter.stringify(null, calculated) + sign + ")") else if ((cast cast little.interpreter.Operators.rhsOnly.exists(sign))) little.parser.ParserTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should not appear between two values, only to the left of one of them (" + sign + little.tools.PrettyPrinter.stringify(null, val) + " or " + sign + little.tools.PrettyPrinter.stringify(null, calculated) + ")") else little.parser.ParserTokens.ErrorMessage("Operator " + sign + " does not exist. did you make a typo?");
						};
					};
					case 13: {
						var parts = token[0];
						if ((sign != "" && calculated == null)) {
							var rhs = little.interpreter.Actions.calculate(parts);
							calculated = if ((cast cast little.interpreter.Operators.rhsOnly.exists(sign))) cast cast little.interpreter.Operators.rhsOnly.get(sign)(rhs) else if ((cast cast little.interpreter.Operators.lhsOnly.exists(sign))) little.parser.ParserTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear before the sign (" + little.tools.PrettyPrinter.stringify(null, rhs) + sign + " instead of " + sign + little.tools.PrettyPrinter.stringify(null, rhs) + ")") else if ((cast cast little.interpreter.Operators.standard.exists(sign))) little.parser.ParserTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear between two values (" + little.tools.PrettyPrinter.stringify(null, rhs) + " " + sign + " <some value>)") else little.parser.ParserTokens.ErrorMessage("Operator " + sign + " does not exist. did you make a typo?");
						} else if ((calculated == null)) calculated = little.interpreter.Actions.calculate(parts) else if ((sign == null)) little.interpreter.Actions.error("Two values cannot come one after the other. At least one of them should be an operator, or, put an operator in between.", null) else {
							var rhs = little.interpreter.Actions.calculate(parts);
							calculated = if ((cast cast little.interpreter.Operators.standard.exists(sign))) cast cast little.interpreter.Operators.standard.get(sign)(calculated, rhs) else if ((cast cast little.interpreter.Operators.lhsOnly.exists(sign))) little.parser.ParserTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should not appear between two values, only to the right of one of them (" + little.tools.PrettyPrinter.stringify(null, rhs) + sign + " or " + little.tools.PrettyPrinter.stringify(null, calculated) + sign + ")") else if ((cast cast little.interpreter.Operators.rhsOnly.exists(sign))) little.parser.ParserTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should not appear between two values, only to the left of one of them (" + sign + little.tools.PrettyPrinter.stringify(null, rhs) + " or " + sign + little.tools.PrettyPrinter.stringify(null, calculated) + ")") else little.parser.ParserTokens.ErrorMessage("Operator " + sign + " does not exist. did you make a typo?");
						};
					};
					case 15: {
						var s = token[0];
						{
							sign = s;
							if ((Type.enumEq(tokens[tokens.length - 1], token))) calculated = if ((cast cast little.interpreter.Operators.lhsOnly.exists(sign))) cast cast little.interpreter.Operators.lhsOnly.get(sign)(calculated) else if ((cast cast little.interpreter.Operators.rhsOnly.exists(sign))) little.parser.ParserTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear after the sign (" + sign + little.tools.PrettyPrinter.stringify(null, calculated) + " instead of " + little.tools.PrettyPrinter.stringify(null, calculated) + sign + ")") else if ((cast cast little.interpreter.Operators.standard.exists(sign))) little.parser.ParserTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear between two values (" + little.tools.PrettyPrinter.stringify(null, calculated) + " " + sign + " <some value>)") else little.parser.ParserTokens.ErrorMessage("Operator " + sign + " does not exist. did you make a typo?");
						};
					};
					default: if ((sign != "" && calculated == null)) calculated = if ((cast cast little.interpreter.Operators.rhsOnly.exists(sign))) cast cast little.interpreter.Operators.rhsOnly.get(sign)(token) else if ((cast cast little.interpreter.Operators.lhsOnly.exists(sign))) little.parser.ParserTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear before the sign (" + little.tools.PrettyPrinter.stringify(null, token) + sign + " instead of " + sign + little.tools.PrettyPrinter.stringify(null, token) + ")") else if ((cast cast little.interpreter.Operators.standard.exists(sign))) little.parser.ParserTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should appear between two values (" + little.tools.PrettyPrinter.stringify(null, token) + " " + sign + " <some value>)") else little.parser.ParserTokens.ErrorMessage("Operator " + sign + " does not exist. did you make a typo?") else if ((calculated == null)) calculated = token else if ((sign == null)) little.interpreter.Actions.error("Two values cannot come one after the other. At least one of them should be an operator, or, put an operator in between.", null) else calculated = if ((cast cast little.interpreter.Operators.standard.exists(sign))) cast cast little.interpreter.Operators.standard.get(sign)(calculated, token) else if ((cast cast little.interpreter.Operators.lhsOnly.exists(sign))) little.parser.ParserTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should not appear between two values, only to the right of one of them (" + little.tools.PrettyPrinter.stringify(null, token) + sign + " or " + little.tools.PrettyPrinter.stringify(null, calculated) + sign + ")") else if ((cast cast little.interpreter.Operators.rhsOnly.exists(sign))) little.parser.ParserTokens.ErrorMessage("Operator " + sign + " is used incorrectly - should not appear between two values, only to the left of one of them (" + sign + little.tools.PrettyPrinter.stringify(null, token) + " or " + sign + little.tools.PrettyPrinter.stringify(null, calculated) + ")") else little.parser.ParserTokens.ErrorMessage("Operator " + sign + " does not exist. did you make a typo?")
				};
			};
		};
		if ((castType != null)) return little.interpreter.Actions.type(calculated, castType);
		return calculated;
	}

	public static function group(tokens:Array<little.parser.ParserTokens>) {
		var post = tokens;
		var pre = [];
		{
			var operatorGroup = little.Little.operators.iterateByPriority();
			while ((operatorGroup.hasNext())) {
				var operatorGroup = operatorGroup.next();
				pre = post.copy();
				post = [];
				var i = 0;
				@:loopLabel(2) while ((i < pre.length)) {
					var token = if ((little.tools.Extensions.is(pre[i], @:implicitCast cast [little.tools.ParserTokensSimple.READ, little.tools.ParserTokensSimple.IDENTIFIER, little.tools.ParserTokensSimple.BLOCK]))) little.interpreter.Actions.evaluate(pre[i], null) else pre[i];
					switch ((enumIndex token)) {
						case 11: {
							var parts = token[0];
							var type = token[1];
							post.push(little.parser.ParserTokens.Expression(little.interpreter.Actions.group(parts), type));
						};
						case 15: {
							var ` = token[0];
							{
								var ` = [];
								{
									var ` = 0;
									var ` = operatorGroup;
									while ((` < `.length)) {
										var v = `[`];
										++ `;
										if ((v.sign == `)) `.push(v);
									};
								};
								if ((`.length > 0 == true)) {
									if ((i == pre.length - 1)) {
										post.push(little.parser.ParserTokens.PartArray([post.pop(), token]));
										@:loopLabel(2) break;
									};
									var lookbehind = if ((post.length > 0)) post[post.length - 1] else little.parser.ParserTokens.Sign("_");
									var lookahead = if ((little.tools.Extensions.is(pre[i + 1], @:implicitCast cast [little.tools.ParserTokensSimple.READ, little.tools.ParserTokensSimple.IDENTIFIER, little.tools.ParserTokensSimple.BLOCK]))) little.interpreter.Actions.evaluate(pre[i + 1], null) else pre[i + 1];
									var tmp;
									if ((little.tools.Extensions.is(lookbehind, @:implicitCast cast [little.tools.ParserTokensSimple.SIGN]))) {
										var ` = [];
										{
											var ` = 0;
											var ` = operatorGroup;
											while ((` < `.length)) {
												var v = `[`];
												++ `;
												if ((v.sign == little.tools.Extensions.parameter(lookbehind, 1))) `.push(v);
											};
										};
										tmp = `.length > 0;
									} else tmp = false;
									if ((tmp)) {
										if ((little.tools.Extensions.is(lookahead, @:implicitCast cast [little.tools.ParserTokensSimple.SIGN]))) {
											++ i;
											if ((i + 1 >= pre.length)) little.interpreter.Actions.error("Expression ended with an operator, when an operand was expected.", null);
											var lookahead2 = if ((little.tools.Extensions.is(pre[i + 1], @:implicitCast cast [little.tools.ParserTokensSimple.READ, little.tools.ParserTokensSimple.IDENTIFIER, little.tools.ParserTokensSimple.BLOCK]))) little.interpreter.Actions.evaluate(pre[i + 1], null) else pre[i + 1];
											var g = [];
											while ((true)) {
												var tmp;
												if ((little.tools.Extensions.is(lookahead2, @:implicitCast cast [little.tools.ParserTokensSimple.SIGN]))) {
													var ` = [];
													{
														var ` = 0;
														var ` = operatorGroup;
														while ((` < `.length)) {
															var v = `[`];
															++ `;
															if ((v.sign == little.tools.Extensions.parameter(lookahead2, 1) && v.side == little.interpreter.OperatorType.RHS_ONLY)) `.push(v);
														};
													};
													tmp = `.length > 0;
												} else tmp = false;
												if ((! tmp)) break;
												g.push(lookahead2);
												++ i;
												if ((i + 1 >= pre.length)) little.interpreter.Actions.error("Expression ended with an operator, when an operand was expected.", null);
												lookahead2 = if ((little.tools.Extensions.is(pre[i + 1], @:implicitCast cast [little.tools.ParserTokensSimple.READ, little.tools.ParserTokensSimple.IDENTIFIER, little.tools.ParserTokensSimple.BLOCK]))) little.interpreter.Actions.evaluate(pre[i + 1], null) else pre[i + 1];
											};
											g.push(lookahead2);
											post.push(little.parser.ParserTokens.PartArray([token, little.parser.ParserTokens.PartArray(little.interpreter.Actions.group(g))]));
											++ i;
										} else if ((little.tools.Extensions.is(lookahead, @:implicitCast cast [little.tools.ParserTokensSimple.EXPRESSION]))) post.push(little.parser.ParserTokens.PartArray([token, little.parser.ParserTokens.Expression(little.interpreter.Actions.group(little.tools.Extensions.parameter(lookahead, 0)), little.tools.Extensions.parameter(lookahead, 1))])) else post.push(little.parser.ParserTokens.PartArray([token, lookahead]));
									} else {
										var tmp;
										if ((little.tools.Extensions.is(lookahead, @:implicitCast cast [little.tools.ParserTokensSimple.SIGN]))) {
											var ` = [];
											{
												var ` = 0;
												var ` = operatorGroup;
												while ((` < `.length)) {
													var v = `[`];
													++ `;
													if ((v.sign == little.tools.Extensions.parameter(lookahead, 0))) `.push(v);
												};
											};
											tmp = `.length > 0;
										} else tmp = false;
										if ((tmp)) {
											var ` = [];
											{
												var ` = 0;
												var ` = operatorGroup;
												while ((` < `.length)) {
													var v = `[`];
													++ `;
													if ((v.sign == little.tools.Extensions.parameter(token, 0) && v.side == little.interpreter.OperatorType.LHS_ONLY)) `.push(v);
												};
											};
											if ((`.length > 0)) post.push(little.parser.ParserTokens.PartArray([post.pop(), token])) else {
												var ` = [];
												{
													var ` = 0;
													var ` = operatorGroup;
													while ((` < `.length)) {
														var v = `[`];
														++ `;
														if ((v.sign == little.tools.Extensions.parameter(token, 0) && v.side == little.interpreter.OperatorType.LHS_RHS)) `.push(v);
													};
												};
												if ((`.length > 0)) {
													var operand1 = post.pop();
													var op = lookahead;
													if ((i + 2 >= pre.length)) little.interpreter.Actions.error("Expression ended with an operator, when an operand was expected.", null);
													var lookahead2 = if ((little.tools.Extensions.is(pre[i + 2], @:implicitCast cast [little.tools.ParserTokensSimple.READ, little.tools.ParserTokensSimple.IDENTIFIER, little.tools.ParserTokensSimple.BLOCK]))) little.interpreter.Actions.evaluate(pre[i + 2], null) else pre[i + 2];
													if ((! little.tools.Extensions.is(lookahead2, @:implicitCast cast [little.tools.ParserTokensSimple.SIGN]))) {
														post.push(little.parser.ParserTokens.PartArray([operand1, token, little.parser.ParserTokens.PartArray([lookahead, lookahead2])]));
														i += 2;
													} else {
														var g = [];
														while ((true)) {
															var tmp;
															if ((little.tools.Extensions.is(lookahead2, @:implicitCast cast [little.tools.ParserTokensSimple.SIGN]))) {
																var ` = [];
																{
																	var ` = 0;
																	var ` = operatorGroup;
																	while ((` < `.length)) {
																		var v = `[`];
																		++ `;
																		if ((v.sign == little.tools.Extensions.parameter(lookahead2, 0) && v.side == little.interpreter.OperatorType.RHS_ONLY)) `.push(v);
																	};
																};
																tmp = `.length > 0;
															} else tmp = false;
															if ((! tmp)) break;
															g.push(lookahead2);
															++ i;
															if ((i + 2 >= pre.length)) little.interpreter.Actions.error("Expression ended with an operator, when an operand was expected.", null);
															lookahead2 = if ((little.tools.Extensions.is(pre[i + 2], @:implicitCast cast [little.tools.ParserTokensSimple.READ, little.tools.ParserTokensSimple.IDENTIFIER, little.tools.ParserTokensSimple.BLOCK]))) little.interpreter.Actions.evaluate(pre[i + 2], null) else pre[i + 2];
														};
														g.push(lookahead2);
														++ i;
														var operand2 = if ((g.length == 1)) g[0] else little.parser.ParserTokens.PartArray(little.interpreter.Actions.group(g));
														post.push(little.parser.ParserTokens.PartArray([operand1, op, operand2]));
													};
												} else {
													var ` = [];
													{
														var ` = 0;
														var ` = operatorGroup;
														while ((` < `.length)) {
															var v = `[`];
															++ `;
															if ((v.sign == little.tools.Extensions.parameter(token, 0) && v.side == little.interpreter.OperatorType.RHS_ONLY)) `.push(v);
														};
													};
													if ((`.length > 0)) little.interpreter.Actions.error("An operator that expects a right side can't be preceded by an operator that expects a left side.", null);
												};
											};
										} else if ((little.tools.Extensions.is(lookahead, @:implicitCast cast [little.tools.ParserTokensSimple.SIGN]))) post.push(little.parser.ParserTokens.PartArray([post.pop(), token])) else {
											post.push(little.parser.ParserTokens.PartArray([post.pop(), token, lookahead]));
											++ i;
										};
									};
								} else post.push(token);
							};
						};
						default: post.push(token)
					};
					++ i;
				};
			};
		};
		return post;
	}
}