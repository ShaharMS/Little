@:directlyUsed @:used @:access(little.lexer.Lexer) @:allow(little.interpreter.Interpreter) @:allow(little.tools.Plugins)
class little.interpreter.Operators {

	@:value([])
	public static var priority:Map<Int, Array<{ sign : String, side : little.interpreter.OperatorType }>> = new haxe.ds.IntMap();

	@:value(new Map())
	public static var standard:Map<String, (lhs : little.parser.ParserTokens, rhs : little.parser.ParserTokens) -> little.parser.ParserTokens> = new haxe.ds.StringMap();

	@:value(new Map())
	public static var rhsOnly:Map<String, little.parser.ParserTokens -> little.parser.ParserTokens> = new haxe.ds.StringMap();

	@:value(new Map())
	public static var lhsOnly:Map<String, little.parser.ParserTokens -> little.parser.ParserTokens> = new haxe.ds.StringMap();

	public static function setPriority(op:String, type:little.interpreter.OperatorType, opPriority:String) {
		var obj = {sign : op, side : type};
		if ((opPriority == "first")) {
			if ((cast cast little.interpreter.Operators.priority.get(-1) == null)) {
				var v = [];
				cast cast little.interpreter.Operators.priority.set(-1, v);
			};
			cast cast little.interpreter.Operators.priority.get(-1).push(obj);
		} else if ((opPriority == "last")) {
			var i = -1;
			{
				var key = cast cast little.interpreter.Operators.priority.keys();
				while ((key.hasNext())) {
					var key = key.next();
					if ((i < key)) i = key;
				};
			};
			if ((cast cast little.interpreter.Operators.priority.get(i + 1) == null)) {
				var v = [];
				cast cast little.interpreter.Operators.priority.set(i + 1, v);
			};
			cast cast little.interpreter.Operators.priority.get(i + 1).push(obj);
		} else if ((new EReg("[0-9]+", "").match(opPriority))) {
			var p = Std.parseInt(opPriority);
			if ((cast cast little.interpreter.Operators.priority.get(p) == null)) {
				var v = [];
				cast cast little.interpreter.Operators.priority.set(p, v);
			};
			cast cast little.interpreter.Operators.priority.get(p).push(obj);
		} else if ((StringTools.startsWith(opPriority, "before") || StringTools.startsWith(opPriority, "after") || StringTools.startsWith(opPriority, "with"))) {
			var destinationOp;
			var opSide;
			var signPos = StringTools.trim(little.tools.TextTools.remove(little.tools.TextTools.remove(little.tools.TextTools.remove(opPriority, "before"), "after"), "with"));
			if ((little.tools.TextTools.countOccurrencesOf(signPos, "_") != 1)) {
				destinationOp = StringTools.replace(signPos, "_", "");
				opSide = little.interpreter.OperatorType.LHS_RHS;
			} else if ((StringTools.startsWith(signPos, "_"))) {
				destinationOp = StringTools.replace(signPos, "_", "");
				opSide = little.interpreter.OperatorType.LHS_ONLY;
			} else {
				destinationOp = StringTools.replace(signPos, "_", "");
				opSide = little.interpreter.OperatorType.RHS_ONLY;
			};
			{
				var map = cast cast little.interpreter.Operators.priority;
				var `_map = map;
				var `_keys = map.keys();
				while ((`_keys.hasNext())) {
					var key = `_keys.next();
					var `_value = @:nullSafety(Off) cast `_map.get(key);
					var `_key = key;
					var key = `_key;
					var value = `_value;
					var ` = [];
					{
						var ` = 0;
						var ` = value;
						while ((` < `.length)) {
							var v = `[`];
							++ `;
							if ((v.side == opSide && v.sign == destinationOp)) `.push(v);
						};
					};
					if ((`.length > 0)) {
						if ((StringTools.startsWith(opPriority, "before"))) {
							if ((cast cast little.interpreter.Operators.priority.get(key - 1) == null)) {
								var v = [];
								cast cast little.interpreter.Operators.priority.set(key - 1, v);
							};
							cast cast little.interpreter.Operators.priority.get(key - 1).push(obj);
						} else if ((StringTools.startsWith(opPriority, "after"))) {
							if ((cast cast little.interpreter.Operators.priority.get(key + 1) == null)) {
								var v = [];
								cast cast little.interpreter.Operators.priority.set(key + 1, v);
							};
							cast cast little.interpreter.Operators.priority.get(key + 1).push(obj);
						} else cast cast little.interpreter.Operators.priority.get(key).push(obj);
						break;
					};
				};
			};
		} else if ((StringTools.startsWith(opPriority, "between"))) {
			var signPos = StringTools.trim(little.tools.TextTools.remove(opPriority, "between"));
			var ` = [];
			{
				var ` = 0;
				var ` = signPos.split(" ");
				while ((` < `.length)) {
					var v = `[`];
					++ `;
					`.push(StringTools.trim(v));
				};
			};
			var signs = `;
			var sign1Data = little.interpreter.Operators.signPosToObject(signs[0]);
			var sign2Data = little.interpreter.Operators.signPosToObject(signs[1]);
			var sign1Level = -1;
			var sign2Level = -1;
			{
				var map = cast cast little.interpreter.Operators.priority;
				var `_map = map;
				var `_keys = map.keys();
				while ((`_keys.hasNext())) {
					var key = `_keys.next();
					var `_value = @:nullSafety(Off) cast `_map.get(key);
					var `_key = key;
					var key = `_key;
					var value = `_value;
					{
						var ` = [];
						{
							var ` = 0;
							var ` = value;
							while ((` < `.length)) {
								var v = `[`];
								++ `;
								if ((v.side == sign1Data.side && v.sign == sign1Data.sign)) `.push(v);
							};
						};
						if ((`.length > 0)) sign1Level = key;
						var ` = [];
						{
							var ` = 0;
							var ` = value;
							while ((` < `.length)) {
								var v = `[`];
								++ `;
								if ((v.side == sign2Data.side && v.sign == sign2Data.sign)) `.push(v);
							};
						};
						if ((`.length > 0)) sign2Level = key;
					};
				};
			};
			if ((sign1Level != -1 && sign2Level != -1 && sign1Level != sign2Level && Math.abs(sign1Level - sign2Level) <= 2)) {
				if ((Math.abs(sign1Level - sign2Level) == 2)) {
					var key = Std.int((sign1Level + sign2Level) / 2);
					if ((cast cast little.interpreter.Operators.priority.get(key) == null)) {
						var v = [];
						cast cast little.interpreter.Operators.priority.set(key, v);
					};
					cast cast little.interpreter.Operators.priority.get(key).push(obj);
				} else {
					var insert = Std.int(Math.max(sign1Level, sign2Level));
					var newMap = new haxe.ds.IntMap();
					{
						var map = cast cast little.interpreter.Operators.priority;
						var `_map = map;
						var `_keys = map.keys();
						while ((`_keys.hasNext())) {
							var key = `_keys.next();
							var `_value = @:nullSafety(Off) cast `_map.get(key);
							var `_key = key;
							var k = `_key;
							var v = `_value;
							if ((k < insert)) newMap.set(k, v) else newMap.set(k + 1, v);
						};
					};
					{
						var v = [obj];
						newMap.set(insert, v);
					};
					little.interpreter.Operators.priority = newMap;
				};
			};
		};
		var ` = [];
		{
			var x = cast cast little.interpreter.Operators.priority.keys();
			while ((x.hasNext())) {
				var x = x.next();
				`.push(x);
			};
		};
		var a = `;
		if ((a.length == 0)) return;
		haxe.ds.ArraySort.sort(a, function(x:Int, y:Int) {
			return x - y;
		});
		var minimumKey = a[0];
		if ((minimumKey != 0)) {
			var diff = 0 - minimumKey;
			var priorityCopy = new haxe.ds.IntMap();
			{
				var map = cast cast little.interpreter.Operators.priority;
				var `_map = map;
				var `_keys = map.keys();
				while ((`_keys.hasNext())) {
					var key = `_keys.next();
					var `_value = @:nullSafety(Off) cast `_map.get(key);
					var `_key = key;
					var key = `_key;
					var value = `_value;
					priorityCopy.set(key + diff, value);
				};
			};
			little.interpreter.Operators.priority = priorityCopy;
		};
	}

	public static function iterateByPriority() {
		var ` = [];
		{
			var x = cast cast little.interpreter.Operators.priority.keys();
			while ((x.hasNext())) {
				var x = x.next();
				`.push(x);
			};
		};
		var a = `;
		haxe.ds.ArraySort.sort(a, function(x:Int, y:Int) {
			return x - y;
		});
		var ` = [];
		{
			var ` = 0;
			while ((` < a.length)) {
				var x = a[`];
				++ `;
				`.push(cast cast little.interpreter.Operators.priority.get(x));
			};
		};
		var b = `;
		var i = [0];
		return {next : function() {
			return b[i[0] ++];
		}, hasNext : function() {
			return i[0] < b.length;
		}};
	}

	public static function add(op:String, operatorType:little.interpreter.OperatorType, priority:String, callback:haxe.extern.EitherType<little.parser.ParserTokens -> little.parser.ParserTokens, (little.parser.ParserTokens, little.parser.ParserTokens) -> little.parser.ParserTokens>) {
		{
			var ` = 0;
			var ` = op.length;
			while ((` < `)) {
				var i = ` ++;
				if ((! little.lexer.Lexer.signs.contains(op.charAt(i)))) little.lexer.Lexer.signs.push(op.charAt(i));
			};
		};
		little.Keywords.SPECIAL_OR_MULTICHAR_SIGNS.push(op);
		switch ((@:exhaustive enumIndex operatorType)) {
			case 0: cast cast little.interpreter.Operators.standard.set(op, cast callback);
			case 1: cast cast little.interpreter.Operators.lhsOnly.set(op, cast callback);
			case 2: cast cast little.interpreter.Operators.rhsOnly.set(op, cast callback);
		};
		little.interpreter.Operators.setPriority(op, operatorType, priority);
	}

	static function signPosToObject(signPos:String) {
		var destinationOp;
		var opSide;
		if ((little.tools.TextTools.countOccurrencesOf(signPos, "_") != 1)) {
			destinationOp = StringTools.replace(signPos, "_", "");
			opSide = little.interpreter.OperatorType.LHS_RHS;
		} else if ((StringTools.startsWith(signPos, "_"))) {
			destinationOp = StringTools.replace(signPos, "_", "");
			opSide = little.interpreter.OperatorType.LHS_ONLY;
		} else {
			destinationOp = StringTools.replace(signPos, "_", "");
			opSide = little.interpreter.OperatorType.RHS_ONLY;
		};
		return {sign : destinationOp, side : opSide};
	}
}