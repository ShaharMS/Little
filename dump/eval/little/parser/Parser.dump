@:directlyUsed @:used @:access(little.interpreter.Runtime)
class little.parser.Parser {

	@:value([Parser.mergeNonBlockBodies, Parser.mergeElses])
	public static var additionalParsingLevels:Array<Array<little.parser.ParserTokens> -> Array<little.parser.ParserTokens>> = [little.parser.Parser.mergeNonBlockBodies, little.parser.Parser.mergeElses];

	public static function parse(lexerTokens:Array<little.lexer.LexerTokens>) {
		var tokens = little.parser.Parser.convert(lexerTokens);
		tokens = little.parser.Parser.mergeBlocks(tokens);
		tokens = little.parser.Parser.mergeExpressions(tokens);
		tokens = little.parser.Parser.mergePropertyOperations(tokens);
		tokens = little.parser.Parser.mergeTypeDecls(tokens);
		tokens = little.parser.Parser.mergeComplexStructures(tokens);
		tokens = little.parser.Parser.mergeCalls(tokens);
		tokens = little.parser.Parser.mergeWrites(tokens);
		tokens = little.parser.Parser.mergeValuesWithTypeDeclarations(tokens);
		{
			var ` = 0;
			var ` = little.parser.Parser.additionalParsingLevels;
			while ((` < `.length)) {
				var level = `[`];
				++ `;
				tokens = level(tokens);
			};
		};
		return tokens;
	}

	public static function convert(lexerTokens:Array<little.lexer.LexerTokens>) {
		var tokens = [];
		var line = 1;
		var i = 0;
		while ((i < lexerTokens.length)) {
			var token = lexerTokens[i];
			switch ((@:exhaustive enumIndex token)) {
				case 0: {
					var name = token[0];
					tokens.push(little.parser.ParserTokens.Identifier(name));
				};
				case 1: {
					var char = token[0];
					tokens.push(little.parser.ParserTokens.Sign(char));
				};
				case 2: {
					var num = token[0];
					if ((little.tools.TextTools.countOccurrencesOf(num, ".") == 0)) tokens.push(little.parser.ParserTokens.Number(num)) else if ((little.tools.TextTools.countOccurrencesOf(num, ".") == 1)) tokens.push(little.parser.ParserTokens.Decimal(num));
				};
				case 3: {
					var value = token[0];
					if ((value == little.Keywords.FALSE_VALUE)) tokens.push(little.parser.ParserTokens.FalseValue) else if ((value == little.Keywords.TRUE_VALUE)) tokens.push(little.parser.ParserTokens.TrueValue);
				};
				case 4: {
					var string = token[0];
					tokens.push(little.parser.ParserTokens.Characters(string));
				};
				case 5: tokens.push(little.parser.ParserTokens.NullValue);
				case 6: {
					tokens.push(little.parser.ParserTokens.SetLine(line));
					++ line;
				};
				case 7: tokens.push(little.parser.ParserTokens.SplitLine);
				case 8: {
					var content = token[0];
					tokens.push(little.parser.ParserTokens.Documentation(content));
				};
			};
			++ i;
		};
		return tokens;
	}

	public static function mergeBlocks(pre:Array<little.parser.ParserTokens>) {
		if ((pre == null)) return null;
		if ((pre.length == 1 && pre[0] == null)) return [null];
		var post = [];
		var i = 0;
		while ((i < pre.length)) {
			var token = pre[i];
			switch ((enumIndex token)) {
				case 0: {
					var line = token[0];
					{
						little.parser.Parser.setLine(line);
						post.push(token);
					};
				};
				case 1: {
					little.parser.Parser.nextPart();
					post.push(token);
				};
				case 11: {
					var parts = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Expression(little.parser.Parser.mergeBlocks(parts), little.parser.Parser.mergeBlocks([type])[0]));
				};
				case 12: {
					var body = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Block(little.parser.Parser.mergeBlocks(body), little.parser.Parser.mergeBlocks([type])[0]));
				};
				case 15: if ((token[0] == "{")) {
					var blockStartLine = little.parser.Parser.get_line();
					var blockBody = [];
					var blockStack = 1;
					while ((i + 1 < pre.length)) {
						var lookahead = pre[i + 1];
						if ((Type.enumEq(lookahead, little.parser.ParserTokens.Sign("{")))) {
							++ blockStack;
							blockBody.push(lookahead);
						} else if ((Type.enumEq(lookahead, little.parser.ParserTokens.Sign("}")))) {
							-- blockStack;
							if ((blockStack == 0)) break;
							blockBody.push(lookahead);
						} else blockBody.push(lookahead);
						++ i;
					};
					if ((i + 1 == pre.length)) {
						little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Unclosed code block, starting at line " + blockStartLine), null);
						return null;
					};
					post.push(little.parser.ParserTokens.Block(little.parser.Parser.mergeBlocks(blockBody), null));
					++ i;
				} else post.push(token);
				default: post.push(token)
			};
			++ i;
		};
		little.parser.Parser.resetLines();
		return post;
	}

	public static function mergeExpressions(pre:Array<little.parser.ParserTokens>) {
		if ((pre == null)) return null;
		if ((pre.length == 1 && pre[0] == null)) return [null];
		var post = [];
		var i = 0;
		while ((i < pre.length)) {
			var token = pre[i];
			switch ((enumIndex token)) {
				case 0: {
					var line = token[0];
					{
						little.parser.Parser.setLine(line);
						post.push(token);
					};
				};
				case 1: {
					little.parser.Parser.nextPart();
					post.push(token);
				};
				case 11: {
					var parts = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Expression(little.parser.Parser.mergeExpressions(parts), little.parser.Parser.mergeExpressions([type])[0]));
				};
				case 12: {
					var body = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Block(little.parser.Parser.mergeExpressions(body), little.parser.Parser.mergeExpressions([type])[0]));
				};
				case 15: if ((token[0] == "(")) {
					var expressionStartLine = little.parser.Parser.get_line();
					var expressionBody = [];
					var expressionStack = 1;
					while ((i + 1 < pre.length)) {
						var lookahead = pre[i + 1];
						if ((Type.enumEq(lookahead, little.parser.ParserTokens.Sign("(")))) {
							++ expressionStack;
							expressionBody.push(lookahead);
						} else if ((Type.enumEq(lookahead, little.parser.ParserTokens.Sign(")")))) {
							-- expressionStack;
							if ((expressionStack == 0)) break;
							expressionBody.push(lookahead);
						} else expressionBody.push(lookahead);
						++ i;
					};
					if ((i + 1 == pre.length)) {
						little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Unclosed expression, starting at line " + expressionStartLine), null);
						return null;
					};
					post.push(little.parser.ParserTokens.Expression(little.parser.Parser.mergeExpressions(expressionBody), null));
					++ i;
				} else post.push(token);
				default: post.push(token)
			};
			++ i;
		};
		little.parser.Parser.resetLines();
		return post;
	}

	public static function mergePropertyOperations(pre:Array<little.parser.ParserTokens>) {
		if ((pre == null)) return null;
		if ((pre.length == 1 && pre[0] == null)) return [null];
		var post = [];
		var i = 0;
		while ((i < pre.length)) {
			var token = pre[i];
			switch ((enumIndex token)) {
				case 0: {
					var line = token[0];
					{
						little.parser.Parser.setLine(line);
						post.push(token);
					};
				};
				case 1: {
					little.parser.Parser.nextPart();
					post.push(token);
				};
				case 11: {
					var parts = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Expression(little.parser.Parser.mergePropertyOperations(parts), little.parser.Parser.mergePropertyOperations([type])[0]));
				};
				case 12: {
					var body = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Block(little.parser.Parser.mergePropertyOperations(body), little.parser.Parser.mergePropertyOperations([type])[0]));
				};
				case 15: if ((token[0] == little.Keywords.PROPERTY_ACCESS_SIGN == true)) {
					if ((i + 1 >= pre.length)) {
						little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Property access cut off by the end of file, block or expression."), cast "Parser");
						return null;
					};
					if ((post.length == 0)) {
						little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Property access cut off by the start of file, block or expression."), cast "Parser");
						return null;
					};
					var lookbehind = post.pop();
					if ((lookbehind == null)) {
						var field = pre[++ i];
						post.push(little.parser.ParserTokens.PropertyAccess(lookbehind, field));
					} else switch ((enumIndex lookbehind)) {
						case 0: {
							var ` = lookbehind[0];
							little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Property access cut off by the start of a line, or by a line split (; or ,)."), cast "Parser");
							return null;
						};
						case 1: {
							little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Property access cut off by the start of a line, or by a line split (; or ,)."), cast "Parser");
							return null;
						};
						case 15: {
							var s = lookbehind[0];
							little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Cannot access the property of a sign (" + s + "). Was the property access cut off by accident?"), null);
							return null;
						};
						default: {
							var field = pre[++ i];
							post.push(little.parser.ParserTokens.PropertyAccess(lookbehind, field));
						}
					};
				} else post.push(token);
				default: post.push(token)
			};
			++ i;
		};
		little.parser.Parser.resetLines();
		return post;
	}

	public static function mergeTypeDecls(pre:Array<little.parser.ParserTokens>) {
		if ((pre == null)) return null;
		if ((pre.length == 1 && pre[0] == null)) return [null];
		var post = [];
		var i = 0;
		while ((i < pre.length)) {
			var token = pre[i];
			switch ((enumIndex token)) {
				case 0: {
					var line = token[0];
					{
						little.parser.Parser.setLine(line);
						post.push(token);
					};
				};
				case 1: {
					little.parser.Parser.nextPart();
					post.push(token);
				};
				case 7: {
					var word = token[0];
					if ((word == little.Keywords.TYPE_DECL_OR_CAST && i + 1 < pre.length)) {
						var lookahead = pre[i + 1];
						post.push(little.parser.ParserTokens.TypeDeclaration(null, little.parser.Parser.mergeTypeDecls([lookahead])[0]));
						++ i;
					} else if ((word == little.Keywords.TYPE_DECL_OR_CAST)) {
						if ((i + 1 == pre.length)) {
							little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Incomplete type declaration, make sure to input a type after the `" + little.Keywords.TYPE_DECL_OR_CAST + "`."), null);
							return null;
						};
					} else post.push(token);
				};
				case 11: {
					var parts = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Expression(little.parser.Parser.mergeTypeDecls(parts), little.parser.Parser.mergeTypeDecls([type])[0]));
				};
				case 12: {
					var body = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Block(little.parser.Parser.mergeTypeDecls(body), little.parser.Parser.mergeTypeDecls([type])[0]));
				};
				case 14: {
					var name = token[0];
					var property = token[1];
					post.push(little.parser.ParserTokens.PropertyAccess(little.parser.Parser.mergeTypeDecls([name])[0], little.parser.Parser.mergeTypeDecls([property])[0]));
				};
				default: post.push(token)
			};
			++ i;
		};
		little.parser.Parser.resetLines();
		return post;
	}

	public static function mergeComplexStructures(pre:Array<little.parser.ParserTokens>) {
		if ((pre == null)) return null;
		if ((pre.length == 1 && pre[0] == null)) return [null];
		var post = [];
		var currentDoc = null;
		var i = 0;
		while ((i < pre.length)) {
			var token = pre[i];
			switch ((enumIndex token)) {
				case 0: {
					var line = token[0];
					{
						little.parser.Parser.setLine(line);
						post.push(token);
					};
				};
				case 1: {
					little.parser.Parser.nextPart();
					post.push(token);
				};
				case 7: {
					var ` = token[0];
					{
						var _hx_tmp;
						var _hx_tmp;
						var _hx_tmp;
						if ((` == little.Keywords.VARIABLE_DECLARATION == true)) {
							++ i;
							if ((i >= pre.length)) {
								little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Missing variable name, variable is cut off by the end of the file, block or expression."), cast "Parser");
								return null;
							};
							var name = [];
							var pushToName = true;
							var type = null;
							@:loopLabel(2) while ((i < pre.length)) {
								var lookahead = pre[i];
								switch ((enumIndex lookahead)) {
									case 0: {
										var ` = lookahead[0];
										-- i;
										@:loopLabel(2) break;
									};
									case 1: {
										-- i;
										@:loopLabel(2) break;
									};
									case 8: {
										var ` = lookahead[0];
										var typeToken = lookahead[1];
										if ((name.length == 0)) {
											little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Missing variable name before type declaration."), cast "Parser");
											return null;
										};
										type = typeToken;
										@:loopLabel(2) break;
									};
									case 11: {
										var body = lookahead[0];
										var type = lookahead[1];
										if ((pushToName)) {
											name.push(little.parser.ParserTokens.Expression(little.parser.Parser.mergeComplexStructures(body), little.parser.Parser.mergeComplexStructures([type])[0]));
											pushToName = false;
										} else if ((type == null)) type = little.parser.ParserTokens.Expression(little.parser.Parser.mergeComplexStructures(body), little.parser.Parser.mergeComplexStructures([type])[0]) else {
											-- i;
											@:loopLabel(2) break;
										};
									};
									case 12: {
										var body = lookahead[0];
										var type = lookahead[1];
										if ((pushToName)) {
											name.push(little.parser.ParserTokens.Block(little.parser.Parser.mergeComplexStructures(body), little.parser.Parser.mergeComplexStructures([type])[0]));
											pushToName = false;
										} else if ((type == null)) type = little.parser.ParserTokens.Block(little.parser.Parser.mergeComplexStructures(body), little.parser.Parser.mergeComplexStructures([type])[0]) else {
											-- i;
											@:loopLabel(2) break;
										};
									};
									case 15: {
										var ` = lookahead[0];
										{
											var _hx_tmp;
											if ((` == "=")) {
												-- i;
												@:loopLabel(2) break;
											} else {
												_hx_tmp = ` == little.Keywords.PROPERTY_ACCESS_SIGN;
												if ((_hx_tmp == true)) {
													pushToName = true;
													name.push(lookahead);
												} else if ((pushToName)) {
													name.push(lookahead);
													pushToName = false;
												} else if ((type == null && Type.enumConstructor(lookahead) == "TypeDeclaration")) type = lookahead else {
													-- i;
													@:loopLabel(2) break;
												};
											};
										};
									};
									default: if ((pushToName)) {
										name.push(lookahead);
										pushToName = false;
									} else if ((type == null && Type.enumConstructor(lookahead) == "TypeDeclaration")) type = lookahead else {
										-- i;
										@:loopLabel(2) break;
									}
								};
								++ i;
							};
							post.push(little.parser.ParserTokens.Variable(if ((name.length == 1)) name[0] else little.parser.ParserTokens.PartArray(name), type, currentDoc));
							currentDoc = null;
						} else {
							_hx_tmp = ` == little.Keywords.FUNCTION_DECLARATION;
							if ((_hx_tmp == true)) {
								++ i;
								if ((i >= pre.length)) {
									little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Missing function name, function is cut off by the end of the file, block or expression."), cast "Parser");
									return null;
								};
								if ((i + 1 >= pre.length)) {
									little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Missing function parameter body, function is cut off by the end of the file, block or expression."), cast "Parser");
									return null;
								};
								var name = [];
								var pushToName = true;
								var params = null;
								var type = null;
								@:loopLabel(3) while ((i < pre.length)) {
									var lookahead = pre[i];
									switch ((enumIndex lookahead)) {
										case 8: {
											var ` = lookahead[0];
											var typeToken = lookahead[1];
											if ((name.length == 0)) {
												little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Missing function name & parameters before type declaration."), cast "Parser");
												return null;
											} else if ((params == null)) {
												little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Missing function parameters before type declaration."), cast "Parser");
												return null;
											};
											type = little.parser.Parser.mergeComplexStructures([typeToken])[0];
											@:loopLabel(3) break;
										};
										case 11: {
											var body = lookahead[0];
											var type = lookahead[1];
											if ((pushToName)) {
												name.push(little.parser.ParserTokens.Expression(little.parser.Parser.mergeComplexStructures(body), little.parser.Parser.mergeComplexStructures([type])[0]));
												pushToName = false;
											} else if ((params == null)) params = little.parser.ParserTokens.Expression(little.parser.Parser.mergeComplexStructures(body), little.parser.Parser.mergeComplexStructures([type])[0]) else if ((type == null)) type = little.parser.ParserTokens.Expression(little.parser.Parser.mergeComplexStructures(body), little.parser.Parser.mergeComplexStructures([type])[0]) else @:loopLabel(3) break;
										};
										case 12: {
											var body = lookahead[0];
											var type = lookahead[1];
											if ((pushToName)) {
												name.push(little.parser.ParserTokens.Block(little.parser.Parser.mergeComplexStructures(body), little.parser.Parser.mergeComplexStructures([type])[0]));
												pushToName = false;
											} else if ((params == null)) params = little.parser.ParserTokens.Block(little.parser.Parser.mergeComplexStructures(body), little.parser.Parser.mergeComplexStructures([type])[0]) else if ((type == null)) type = little.parser.ParserTokens.Block(little.parser.Parser.mergeComplexStructures(body), little.parser.Parser.mergeComplexStructures([type])[0]) else @:loopLabel(3) break;
										};
										case 15: {
											var ` = lookahead[0];
											{
												var _hx_tmp;
												if ((` == "=")) {
													-- i;
													@:loopLabel(3) break;
												} else {
													_hx_tmp = ` == little.Keywords.PROPERTY_ACCESS_SIGN;
													if ((_hx_tmp == true)) {
														if ((params != null)) {
															-- i;
															@:loopLabel(3) break;
														};
														pushToName = true;
														name.push(lookahead);
													} else if ((pushToName)) {
														name.push(lookahead);
														pushToName = false;
													} else if ((params == null)) params = lookahead else if ((type == null && Type.enumConstructor(lookahead) == "TypeDeclaration")) type = little.parser.Parser.mergeComplexStructures([Type.enumParameters(lookahead)[1]])[0] else @:loopLabel(3) break;
												};
											};
										};
										default: if ((pushToName)) {
											name.push(lookahead);
											pushToName = false;
										} else if ((params == null)) params = lookahead else if ((type == null && Type.enumConstructor(lookahead) == "TypeDeclaration")) type = little.parser.Parser.mergeComplexStructures([Type.enumParameters(lookahead)[1]])[0] else @:loopLabel(3) break
									};
									++ i;
								};
								post.push(little.parser.ParserTokens.Function(if ((name.length == 1)) name[0] else little.parser.ParserTokens.PartArray(name), params, type, currentDoc));
								currentDoc = null;
							} else {
								_hx_tmp = little.Keywords.CONDITION_TYPES.contains(`);
								if ((_hx_tmp == true)) {
									++ i;
									if ((i >= pre.length)) {
										little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Missing condition name, condition is cut off by the end of the file, block or expression."), cast "Parser");
										return null;
									};
									var name = little.parser.ParserTokens.Identifier(Type.enumParameters(token)[0]);
									var exp = null;
									var body = null;
									@:loopLabel(4) while ((i < pre.length)) {
										var lookahead = pre[i];
										switch ((enumIndex lookahead)) {
											case 0: {
												var ` = lookahead[0];
												if ((exp == null)) {
													little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Condition expression does not exist/is cut off by the end of a line"), cast "Parser");
													return null;
												} else if ((body == null)) {
													little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Condition body does not exist/is cut off by the end of a line"), cast "Parser");
													return null;
												} else @:loopLabel(4) break;
											};
											case 1: if ((exp == null)) {
												little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Condition expression does not exist/is cut off by a line split"), cast "Parser");
												return null;
											} else if ((body == null)) {
												little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Condition body does not exist/is cut off by a line split"), cast "Parser");
												return null;
											} else @:loopLabel(4) break;
											case 11: {
												var parts = lookahead[0];
												var type = lookahead[1];
												if ((exp == null)) exp = little.parser.ParserTokens.Expression(little.parser.Parser.mergeComplexStructures(parts), little.parser.Parser.mergeComplexStructures([type])[0]) else if ((body == null)) body = little.parser.ParserTokens.Expression(little.parser.Parser.mergeComplexStructures(parts), little.parser.Parser.mergeComplexStructures([type])[0]) else @:loopLabel(4) break;
											};
											case 12: {
												var b = lookahead[0];
												var type = lookahead[1];
												if ((exp == null)) exp = little.parser.ParserTokens.Block(little.parser.Parser.mergeComplexStructures(b), little.parser.Parser.mergeComplexStructures([type])[0]) else if ((body == null)) body = little.parser.ParserTokens.Block(little.parser.Parser.mergeComplexStructures(b), little.parser.Parser.mergeComplexStructures([type])[0]) else @:loopLabel(4) break;
											};
											default: if ((exp == null)) exp = lookahead else if ((body == null)) {
												body = little.parser.ParserTokens.NoBody;
												-- i;
											} else @:loopLabel(4) break
										};
										++ i;
									};
									-- i;
									post.push(little.parser.ParserTokens.Condition(name, exp, body));
									currentDoc = null;
								} else {
									_hx_tmp = ` == little.Keywords.FUNCTION_RETURN;
									if ((_hx_tmp == true)) {
										++ i;
										if ((i >= pre.length)) {
											little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Missing return value, value is cut off by the end of the file, block or expression."), cast "Parser");
											return null;
										};
										var valueToReturn = [];
										@:loopLabel(5) while ((i < pre.length)) {
											var lookahead = pre[i];
											switch ((enumIndex lookahead)) {
												case 0: {
													var ` = lookahead[0];
													-- i;
													@:loopLabel(5) break;
												};
												case 1: {
													-- i;
													@:loopLabel(5) break;
												};
												case 11: {
													var body = lookahead[0];
													var type = lookahead[1];
													valueToReturn.push(little.parser.ParserTokens.Expression(little.parser.Parser.mergeComplexStructures(body), little.parser.Parser.mergeComplexStructures([type])[0]));
												};
												case 12: {
													var body = lookahead[0];
													var type = lookahead[1];
													valueToReturn.push(little.parser.ParserTokens.Block(little.parser.Parser.mergeComplexStructures(body), little.parser.Parser.mergeComplexStructures([type])[0]));
												};
												default: valueToReturn.push(lookahead)
											};
											++ i;
										};
										post.push(little.parser.ParserTokens.Return(if ((valueToReturn.length == 1)) valueToReturn[0] else little.parser.ParserTokens.Expression(valueToReturn.copy(), null), null));
									} else post.push(token);
								};
							};
						};
					};
				};
				case 11: {
					var parts = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Expression(little.parser.Parser.mergeComplexStructures(parts), little.parser.Parser.mergeComplexStructures([type])[0]));
				};
				case 12: {
					var body = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Block(little.parser.Parser.mergeComplexStructures(body), little.parser.Parser.mergeComplexStructures([type])[0]));
				};
				case 14: {
					var name = token[0];
					var property = token[1];
					post.push(little.parser.ParserTokens.PropertyAccess(little.parser.Parser.mergeComplexStructures([name])[0], little.parser.Parser.mergeComplexStructures([property])[0]));
				};
				case 19: {
					var doc = token[0];
					currentDoc = token;
				};
				default: post.push(token)
			};
			++ i;
		};
		little.parser.Parser.resetLines();
		return post;
	}

	public static function mergeCalls(pre:Array<little.parser.ParserTokens>) {
		if ((pre == null)) return null;
		if ((pre.length == 1 && pre[0] == null)) return [null];
		var post = [];
		var i = 0;
		while ((i < pre.length)) {
			var token = pre[i];
			switch ((enumIndex token)) {
				case 0: {
					var line = token[0];
					{
						little.parser.Parser.setLine(line);
						post.push(token);
					};
				};
				case 1: {
					little.parser.Parser.nextPart();
					post.push(token);
				};
				case 2: {
					var name = token[0];
					var type = token[1];
					var doc = token[2];
					post.push(little.parser.ParserTokens.Variable(little.parser.Parser.mergeCalls([name])[0], little.parser.Parser.mergeCalls([type])[0], little.parser.Parser.mergeCalls([doc])[0]));
				};
				case 3: {
					var name = token[0];
					var params = token[1];
					var type = token[2];
					var doc = token[3];
					post.push(little.parser.ParserTokens.Function(little.parser.Parser.mergeCalls([name])[0], little.parser.Parser.mergeCalls([params])[0], little.parser.Parser.mergeCalls([type])[0], little.parser.Parser.mergeCalls([doc])[0]));
				};
				case 4: {
					var name = token[0];
					var exp = token[1];
					var body = token[2];
					post.push(little.parser.ParserTokens.Condition(little.parser.Parser.mergeCalls([name])[0], little.parser.Parser.mergeCalls([exp])[0], little.parser.Parser.mergeCalls([body])[0]));
				};
				case 10: {
					var value = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Return(little.parser.Parser.mergeCalls([value])[0], little.parser.Parser.mergeCalls([type])[0]));
				};
				case 11: {
					var parts = token[0];
					var type = token[1];
					{
						parts = little.parser.Parser.mergeCalls(parts);
						if ((i == 0)) post.push(little.parser.ParserTokens.Expression(parts, type)) else {
							var lookbehind = pre[i - 1];
							switch ((enumIndex lookbehind)) {
								case 0: {
									var ` = lookbehind[0];
									post.push(little.parser.ParserTokens.Expression(parts, type));
								};
								case 1: post.push(little.parser.ParserTokens.Expression(parts, type));
								case 14: {
									var name = lookbehind[0];
									var property = lookbehind[1];
									{
										post.pop();
										token = little.parser.ParserTokens.PartArray(parts);
										post.push(little.parser.ParserTokens.PropertyAccess(name, little.parser.ParserTokens.FunctionCall(property, token)));
									};
								};
								case 15: {
									var ` = lookbehind[0];
									post.push(little.parser.ParserTokens.Expression(parts, type));
								};
								default: {
									var previous = post.pop();
									token = little.parser.ParserTokens.PartArray(parts);
									post.push(little.parser.ParserTokens.FunctionCall(previous, token));
								}
							};
						};
					};
				};
				case 12: {
					var body = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Block(little.parser.Parser.mergeCalls(body), little.parser.Parser.mergeCalls([type])[0]));
				};
				case 13: {
					var parts = token[0];
					post.push(little.parser.ParserTokens.PartArray(little.parser.Parser.mergeCalls(parts)));
				};
				case 14: {
					var name = token[0];
					var property = token[1];
					post.push(little.parser.ParserTokens.PropertyAccess(little.parser.Parser.mergeCalls([name])[0], little.parser.Parser.mergeCalls([property])[0]));
				};
				default: post.push(token)
			};
			++ i;
		};
		little.parser.Parser.resetLines();
		return post;
	}

	public static function mergeWrites(pre:Array<little.parser.ParserTokens>) {
		if ((pre == null)) return null;
		if ((pre.length == 1 && pre[0] == null)) return [null];
		var post = [];
		var potentialAssignee = little.parser.ParserTokens.NullValue;
		var i = 0;
		while ((i < pre.length)) {
			var token = pre[i];
			switch ((enumIndex token)) {
				case 0: {
					var line = token[0];
					{
						little.parser.Parser.setLine(line);
						if ((potentialAssignee != null)) post.push(potentialAssignee);
						potentialAssignee = token;
					};
				};
				case 1: {
					little.parser.Parser.nextPart();
					if ((potentialAssignee != null)) post.push(potentialAssignee);
					potentialAssignee = token;
				};
				case 2: {
					var name = token[0];
					var type = token[1];
					var doc = token[2];
					{
						if ((potentialAssignee != null)) post.push(potentialAssignee);
						potentialAssignee = little.parser.ParserTokens.Variable(little.parser.Parser.mergeWrites([name])[0], little.parser.Parser.mergeWrites([type])[0], little.parser.Parser.mergeWrites([doc])[0]);
					};
				};
				case 3: {
					var name = token[0];
					var params = token[1];
					var type = token[2];
					var doc = token[3];
					{
						if ((potentialAssignee != null)) post.push(potentialAssignee);
						potentialAssignee = little.parser.ParserTokens.Function(little.parser.Parser.mergeWrites([name])[0], little.parser.Parser.mergeWrites([params])[0], little.parser.Parser.mergeWrites([type])[0], little.parser.Parser.mergeWrites([doc])[0]);
					};
				};
				case 4: {
					var name = token[0];
					var exp = token[1];
					var body = token[2];
					{
						if ((potentialAssignee != null)) post.push(potentialAssignee);
						potentialAssignee = little.parser.ParserTokens.Condition(little.parser.Parser.mergeWrites([name])[0], little.parser.Parser.mergeWrites([exp])[0], little.parser.Parser.mergeWrites([body])[0]);
					};
				};
				case 9: {
					var name = token[0];
					var params = token[1];
					{
						if ((potentialAssignee != null)) post.push(potentialAssignee);
						potentialAssignee = little.parser.ParserTokens.FunctionCall(little.parser.Parser.mergeWrites([name])[0], little.parser.Parser.mergeWrites([params])[0]);
					};
				};
				case 10: {
					var value = token[0];
					var type = token[1];
					{
						if ((potentialAssignee != null)) post.push(potentialAssignee);
						potentialAssignee = little.parser.ParserTokens.Return(little.parser.Parser.mergeWrites([value])[0], little.parser.Parser.mergeWrites([type])[0]);
					};
				};
				case 11: {
					var parts = token[0];
					var type = token[1];
					{
						if ((potentialAssignee != null)) post.push(potentialAssignee);
						potentialAssignee = little.parser.ParserTokens.Expression(little.parser.Parser.mergeWrites(parts), little.parser.Parser.mergeWrites([type])[0]);
					};
				};
				case 12: {
					var body = token[0];
					var type = token[1];
					{
						if ((potentialAssignee != null)) post.push(potentialAssignee);
						potentialAssignee = little.parser.ParserTokens.Block(little.parser.Parser.mergeWrites(body), little.parser.Parser.mergeWrites([type])[0]);
					};
				};
				case 13: {
					var parts = token[0];
					{
						if ((potentialAssignee != null)) post.push(potentialAssignee);
						potentialAssignee = little.parser.ParserTokens.PartArray(little.parser.Parser.mergeWrites(parts));
					};
				};
				case 14: {
					var name = token[0];
					var property = token[1];
					{
						if ((potentialAssignee != null)) post.push(potentialAssignee);
						potentialAssignee = little.parser.ParserTokens.PropertyAccess(little.parser.Parser.mergeWrites([name])[0], little.parser.Parser.mergeWrites([property])[0]);
					};
				};
				case 15: if ((token[0] == "=")) {
					if ((i + 1 >= pre.length)) {
						little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Missing value after the `=`"), cast "Parser");
						return null;
					};
					var currentAssignee = [potentialAssignee];
					var assignees = [if ((currentAssignee.length == 1)) currentAssignee[0] else little.parser.ParserTokens.Expression(currentAssignee.copy(), null)];
					currentAssignee = [];
					@:loopLabel(2) while ((i + 1 < pre.length)) {
						var lookahead = pre[i + 1];
						switch ((enumIndex lookahead)) {
							case 0: {
								var ` = lookahead[0];
								@:loopLabel(2) break;
							};
							case 1: @:loopLabel(2) break;
							case 15: if ((lookahead[0] == "=")) {
								var assignee = if ((currentAssignee.length == 1)) currentAssignee[0] else little.parser.ParserTokens.Expression(currentAssignee.copy(), null);
								assignees.push(assignee);
								currentAssignee = [];
							} else currentAssignee.push(lookahead);
							default: currentAssignee.push(lookahead)
						};
						++ i;
					};
					if ((currentAssignee.length == 0)) {
						little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Missing value after the last `=`"), cast "Parser");
						return null;
					};
					var value = if ((currentAssignee.length == 1)) currentAssignee[0] else little.parser.ParserTokens.Expression(currentAssignee, null);
					var fValue = little.parser.Parser.mergeWrites([value]);
					var v = if ((fValue.length == 1)) fValue[0] else little.parser.ParserTokens.Expression(fValue, null);
					post.push(little.parser.ParserTokens.Write(assignees, v));
					potentialAssignee = null;
				} else {
					if ((potentialAssignee != null)) post.push(potentialAssignee);
					potentialAssignee = token;
				};
				default: {
					if ((potentialAssignee != null)) post.push(potentialAssignee);
					potentialAssignee = token;
				}
			};
			++ i;
		};
		if ((potentialAssignee != null)) post.push(potentialAssignee);
		post.shift();
		little.parser.Parser.resetLines();
		return post;
	}

	public static function mergeValuesWithTypeDeclarations(pre:Array<little.parser.ParserTokens>) {
		if ((pre == null)) return null;
		if ((pre.length == 1 && pre[0] == null)) return [null];
		var post = [];
		var i = pre.length - 1;
		while ((i >= 0)) {
			var token = pre[i];
			switch ((enumIndex token)) {
				case 0: {
					var line = token[0];
					{
						little.parser.Parser.setLine(line);
						post.unshift(token);
					};
				};
				case 1: {
					little.parser.Parser.nextPart();
					post.unshift(token);
				};
				case 2: {
					var name = token[0];
					var type = token[1];
					var doc = token[2];
					post.unshift(little.parser.ParserTokens.Variable(little.parser.Parser.mergeValuesWithTypeDeclarations([name])[0], little.parser.Parser.mergeValuesWithTypeDeclarations([type])[0], little.parser.Parser.mergeValuesWithTypeDeclarations([doc])[0]));
				};
				case 3: {
					var name = token[0];
					var params = token[1];
					var type = token[2];
					var doc = token[3];
					post.unshift(little.parser.ParserTokens.Function(little.parser.Parser.mergeValuesWithTypeDeclarations([name])[0], little.parser.Parser.mergeValuesWithTypeDeclarations([params])[0], little.parser.Parser.mergeValuesWithTypeDeclarations([type])[0], little.parser.Parser.mergeValuesWithTypeDeclarations([doc])[0]));
				};
				case 4: {
					var name = token[0];
					var exp = token[1];
					var body = token[2];
					post.unshift(little.parser.ParserTokens.Condition(little.parser.Parser.mergeValuesWithTypeDeclarations([name])[0], little.parser.Parser.mergeValuesWithTypeDeclarations([exp])[0], little.parser.Parser.mergeValuesWithTypeDeclarations([body])[0]));
				};
				case 6: {
					var assignees = token[0];
					var value = token[1];
					post.unshift(little.parser.ParserTokens.Write(little.parser.Parser.mergeValuesWithTypeDeclarations(assignees), little.parser.Parser.mergeValuesWithTypeDeclarations([value])[0]));
				};
				case 8: if ((token[0] == null)) {
					var type = token[1];
					{
						if ((i -- <= 0)) {
							little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Value's type declaration cut off by the start of file, block or expression."), cast "Parser");
							return null;
						};
						var lookbehind = pre[i];
						switch ((enumIndex lookbehind)) {
							case 0: {
								var ` = lookbehind[0];
								little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Value's type declaration access cut off by the start of a line, or by a line split (; or ,)."), cast "Parser");
								return null;
							};
							case 1: {
								little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Value's type declaration access cut off by the start of a line, or by a line split (; or ,)."), cast "Parser");
								return null;
							};
							default: post.unshift(little.parser.ParserTokens.TypeDeclaration(lookbehind, type))
						};
					};
				} else post.unshift(token);
				case 9: {
					var name = token[0];
					var params = token[1];
					post.unshift(little.parser.ParserTokens.FunctionCall(little.parser.Parser.mergeValuesWithTypeDeclarations([name])[0], little.parser.Parser.mergeValuesWithTypeDeclarations([params])[0]));
				};
				case 10: {
					var value = token[0];
					var type = token[1];
					post.unshift(little.parser.ParserTokens.Return(little.parser.Parser.mergeValuesWithTypeDeclarations([value])[0], little.parser.Parser.mergeValuesWithTypeDeclarations([type])[0]));
				};
				case 11: {
					var parts = token[0];
					var type = token[1];
					post.unshift(little.parser.ParserTokens.Expression(little.parser.Parser.mergeValuesWithTypeDeclarations(parts), little.parser.Parser.mergeValuesWithTypeDeclarations([type])[0]));
				};
				case 12: {
					var body = token[0];
					var type = token[1];
					post.unshift(little.parser.ParserTokens.Block(little.parser.Parser.mergeValuesWithTypeDeclarations(body), little.parser.Parser.mergeValuesWithTypeDeclarations([type])[0]));
				};
				case 13: {
					var parts = token[0];
					post.unshift(little.parser.ParserTokens.PartArray(little.parser.Parser.mergeValuesWithTypeDeclarations(parts)));
				};
				case 14: {
					var name = token[0];
					var property = token[1];
					post.unshift(little.parser.ParserTokens.PropertyAccess(little.parser.Parser.mergeValuesWithTypeDeclarations([name])[0], little.parser.Parser.mergeValuesWithTypeDeclarations([property])[0]));
				};
				default: post.unshift(token)
			};
			-- i;
		};
		little.parser.Parser.resetLines();
		return post;
	}

	public static function mergeNonBlockBodies(pre:Array<little.parser.ParserTokens>) {
		if ((pre == null)) return null;
		if ((pre.length == 1 && pre[0] == null)) return [null];
		var post = [];
		var i = 0;
		while ((i < pre.length)) {
			var token = pre[i];
			switch ((enumIndex token)) {
				case 0: {
					var line = token[0];
					{
						little.parser.Parser.setLine(line);
						post.push(token);
					};
				};
				case 1: {
					little.parser.Parser.nextPart();
					post.push(token);
				};
				case 2: {
					var name = token[0];
					var type = token[1];
					var doc = token[2];
					post.push(little.parser.ParserTokens.Variable(little.parser.Parser.mergeNonBlockBodies([name])[0], little.parser.Parser.mergeNonBlockBodies([type])[0], little.parser.Parser.mergeNonBlockBodies([doc])[0]));
				};
				case 3: {
					var name = token[0];
					var params = token[1];
					var type = token[2];
					var doc = token[3];
					post.push(little.parser.ParserTokens.Function(little.parser.Parser.mergeNonBlockBodies([name])[0], little.parser.Parser.mergeNonBlockBodies([params])[0], little.parser.Parser.mergeNonBlockBodies([type])[0], little.parser.Parser.mergeNonBlockBodies([doc])[0]));
				};
				case 4: {
					var ` = token[0];
					var ` = token[1];
					var ` = token[2];
					if ((enumIndex ` == 27)) {
						var exp = [`];
						var name = [`];
						if ((i + 1 >= pre.length)) {
							little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Condition has no body, body may be cut off by the end of file, block or expression."), cast "Parser");
							return null;
						};
						var skip = [2];
						var look = [null];
						look[0] = function(i:Int) {
							++ i;
							var lookahead = pre[i];
							switch ((enumIndex lookahead)) {
								case 0: {
									var ` = lookahead[0];
									little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Condition has no body, body cut off by a new line, or does not exist"), cast "Parser");
									return null;
								};
								case 1: {
									little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Condition has no body, body cut off by a line split, or does not exist"), cast "Parser");
									return null;
								};
								case 4: if ((enumIndex lookahead[2] == 27)) {
									var exp1 = lookahead[1];
									var name1 = lookahead[0];
									skip[0] ++;
									var tmp = little.parser.Parser.mergeNonBlockBodies([name[0]])[0];
									var tmp = little.parser.Parser.mergeNonBlockBodies([exp[0]])[0];
									name[0] = name1;
									exp[0] = exp1;
									return little.parser.ParserTokens.Condition(tmp, tmp, little.parser.Parser.mergeNonBlockBodies([look[0](i)])[0]);
								} else return little.parser.ParserTokens.Condition(little.parser.Parser.mergeNonBlockBodies([name[0]])[0], little.parser.Parser.mergeNonBlockBodies([exp[0]])[0], little.parser.Parser.mergeNonBlockBodies([lookahead])[0]);
								default: return little.parser.ParserTokens.Condition(little.parser.Parser.mergeNonBlockBodies([name[0]])[0], little.parser.Parser.mergeNonBlockBodies([exp[0]])[0], little.parser.Parser.mergeNonBlockBodies([lookahead])[0])
							};
						};
						post.push(little.parser.Parser.mergeNonBlockBodies([look[0](i)])[0]);
						i += skip[0];
						continue;
					} else {
						var body = `;
						var exp = `;
						var name = `;
						post.push(little.parser.ParserTokens.Condition(little.parser.Parser.mergeNonBlockBodies([name])[0], little.parser.Parser.mergeNonBlockBodies([exp])[0], little.parser.Parser.mergeNonBlockBodies([body])[0]));
					};
				};
				case 6: {
					var assignees = token[0];
					var value = token[1];
					post.push(little.parser.ParserTokens.Write(little.parser.Parser.mergeNonBlockBodies(assignees), little.parser.Parser.mergeNonBlockBodies([value])[0]));
				};
				case 9: {
					var name = token[0];
					var params = token[1];
					post.push(little.parser.ParserTokens.FunctionCall(little.parser.Parser.mergeNonBlockBodies([name])[0], little.parser.Parser.mergeNonBlockBodies([params])[0]));
				};
				case 10: {
					var value = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Return(little.parser.Parser.mergeNonBlockBodies([value])[0], little.parser.Parser.mergeNonBlockBodies([type])[0]));
				};
				case 11: {
					var parts = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Expression(little.parser.Parser.mergeNonBlockBodies(parts), little.parser.Parser.mergeNonBlockBodies([type])[0]));
				};
				case 12: {
					var body = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Block(little.parser.Parser.mergeNonBlockBodies(body), little.parser.Parser.mergeNonBlockBodies([type])[0]));
				};
				case 13: {
					var parts = token[0];
					post.push(little.parser.ParserTokens.PartArray(little.parser.Parser.mergeNonBlockBodies(parts)));
				};
				case 14: {
					var name = token[0];
					var property = token[1];
					post.push(little.parser.ParserTokens.PropertyAccess(little.parser.Parser.mergeNonBlockBodies([name])[0], little.parser.Parser.mergeNonBlockBodies([property])[0]));
				};
				default: post.push(token)
			};
			++ i;
		};
		little.parser.Parser.resetLines();
		return post;
	}

	public static function mergeElses(pre:Array<little.parser.ParserTokens>) {
		if ((pre == null)) return null;
		if ((pre.length == 1 && pre[0] == null)) return [null];
		var post = [];
		var i = 0;
		while ((i < pre.length)) {
			var token = pre[i];
			switch ((enumIndex token)) {
				case 0: {
					var line = token[0];
					{
						little.parser.Parser.setLine(line);
						post.push(token);
					};
				};
				case 1: {
					little.parser.Parser.nextPart();
					post.push(token);
				};
				case 2: {
					var name = token[0];
					var type = token[1];
					var doc = token[2];
					post.push(little.parser.ParserTokens.Variable(little.parser.Parser.mergeElses([name])[0], little.parser.Parser.mergeElses([type])[0], little.parser.Parser.mergeElses([doc])[0]));
				};
				case 3: {
					var name = token[0];
					var params = token[1];
					var type = token[2];
					var doc = token[3];
					post.push(little.parser.ParserTokens.Function(little.parser.Parser.mergeElses([name])[0], little.parser.Parser.mergeElses([params])[0], little.parser.Parser.mergeElses([type])[0], little.parser.Parser.mergeElses([doc])[0]));
				};
				case 4: {
					var name = token[0];
					var exp = token[1];
					var body = token[2];
					post.push(little.parser.ParserTokens.Condition(little.parser.Parser.mergeElses([name])[0], little.parser.Parser.mergeElses([exp])[0], little.parser.Parser.mergeElses([body])[0]));
				};
				case 6: {
					var assignees = token[0];
					var value = token[1];
					post.push(little.parser.ParserTokens.Write(little.parser.Parser.mergeElses(assignees), little.parser.Parser.mergeElses([value])[0]));
				};
				case 7: if ((token[0] == little.Keywords.ELSE == true)) {
					if ((post.length == 0 || Type.enumConstructor(cast post[post.length - 1]) != "Condition")) {
						post.push(token);
						++ i;
						continue;
					};
					if ((i + 1 >= pre.length)) {
						little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("Condition has no body, body may be cut off by the end of file, block or expression."), cast "Parser");
						return null;
					};
					var exp = Type.enumParameters(cast post[post.length - 1])[1];
					exp = little.parser.ParserTokens.Expression([exp, little.parser.ParserTokens.Sign("!="), little.parser.ParserTokens.TrueValue], little.parser.ParserTokens.Module(little.Keywords.TYPE_BOOLEAN));
					++ i;
					var body = pre[i];
					switch ((enumIndex body)) {
						case 0: {
							var ` = body[0];
							little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("`" + little.Keywords.ELSE + "` condition has no body, body cut off by a new line, or does not exist"), cast "Parser");
							return null;
						};
						case 1: {
							little.interpreter.Runtime.throwError(little.parser.ParserTokens.ErrorMessage("`" + little.Keywords.ELSE + "` condition has no body, body cut off by a line split, or does not exist"), cast "Parser");
							return null;
						};
						default: post.push(little.parser.ParserTokens.Condition(little.parser.ParserTokens.Identifier("if"), exp, body))
					};
				} else post.push(token);
				case 9: {
					var name = token[0];
					var params = token[1];
					post.push(little.parser.ParserTokens.FunctionCall(little.parser.Parser.mergeElses([name])[0], little.parser.Parser.mergeElses([params])[0]));
				};
				case 10: {
					var value = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Return(little.parser.Parser.mergeElses([value])[0], little.parser.Parser.mergeElses([type])[0]));
				};
				case 11: {
					var parts = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Expression(little.parser.Parser.mergeElses(parts), little.parser.Parser.mergeElses([type])[0]));
				};
				case 12: {
					var body = token[0];
					var type = token[1];
					post.push(little.parser.ParserTokens.Block(little.parser.Parser.mergeElses(body), little.parser.Parser.mergeElses([type])[0]));
				};
				case 13: {
					var parts = token[0];
					post.push(little.parser.ParserTokens.PartArray(little.parser.Parser.mergeElses(parts)));
				};
				case 14: {
					var name = token[0];
					var property = token[1];
					post.push(little.parser.ParserTokens.PropertyAccess(little.parser.Parser.mergeElses([name])[0], little.parser.Parser.mergeElses([property])[0]));
				};
				default: post.push(token)
			};
			++ i;
		};
		little.parser.Parser.resetLines();
		return post;
	}

	static var line(get,set):Int;

	static function get_line() {
		return little.interpreter.Runtime.line;
	}

	static function set_line(l:Int) {
		return little.interpreter.Runtime.line = l;
	}

	@:value(0)
	static var linePart:Int = 0;

	static function setLine(l:Int) {
		little.parser.Parser.set_line(l);
		little.parser.Parser.linePart = 0;
	}

	static function nextPart() {
		little.parser.Parser.linePart ++;
	}

	static function resetLines() {
		little.parser.Parser.set_line(0);
		little.parser.Parser.linePart = 0;
	}

	static function get<T>(a:Array<get.T>, i:Int) {
		return a[i];
	}
}