@:directlyUsed @:used
enum little.parser.ParserTokens {
	SetLine(line:Int);
	SplitLine;
	Variable(name:little.parser.ParserTokens, type:little.parser.ParserTokens, ?doc:Null<little.parser.ParserTokens>);
	Function(name:little.parser.ParserTokens, params:little.parser.ParserTokens, type:little.parser.ParserTokens, ?doc:Null<little.parser.ParserTokens>);
	Condition(name:little.parser.ParserTokens, exp:little.parser.ParserTokens, body:little.parser.ParserTokens);
	Read(name:little.parser.ParserTokens);
	Write(assignees:Array<little.parser.ParserTokens>, value:little.parser.ParserTokens);
	Identifier(word:String);
	TypeDeclaration(value:little.parser.ParserTokens, type:little.parser.ParserTokens);
	FunctionCall(name:little.parser.ParserTokens, params:little.parser.ParserTokens);
	Return(value:little.parser.ParserTokens, type:little.parser.ParserTokens);
	Expression(parts:Array<little.parser.ParserTokens>, type:little.parser.ParserTokens);
	Block(body:Array<little.parser.ParserTokens>, type:little.parser.ParserTokens);
	PartArray(parts:Array<little.parser.ParserTokens>);
	PropertyAccess(name:little.parser.ParserTokens, property:little.parser.ParserTokens);
	Sign(sign:String);
	Number(num:String);
	Decimal(num:String);
	Characters(string:String);
	Documentation(doc:String);
	Module(name:String);
	External(get:Array<little.parser.ParserTokens> -> little.parser.ParserTokens);
	ExternalCondition(use:(con : Array<little.parser.ParserTokens>, body : Array<little.parser.ParserTokens>) -> little.parser.ParserTokens);
	ErrorMessage(msg:String);
	NullValue;
	TrueValue;
	FalseValue;
	NoBody;
}