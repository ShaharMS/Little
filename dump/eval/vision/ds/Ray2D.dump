@:directlyUsed @:used
class vision.ds.Ray2D {

	public inline function new(point:vision.ds.Point2D, m:Null<Float> = null, degrees:Null<Float> = null, radians:Null<Float> = null) {
		this.point = point;
		if ((m != null)) {
			{
				this.degrees = Math.atan(m) * 180 / Math.PI;
				this.radians = Math.atan(m);
				this.slope = m;
			};
			{
				var value = Math.atan(m) * 180 / Math.PI;
				this.slope = Math.tan(value * Math.PI / 180);
				this.radians = value * Math.PI / 180;
				this.degrees = value;
			};
			{
				var value = Math.atan(m);
				this.slope = Math.tan(value);
				this.degrees = value * 180 / Math.PI;
				this.radians = value;
			};
		} else if ((degrees != null)) {
			{
				this.slope = Math.tan(degrees * Math.PI / 180);
				this.radians = degrees * Math.PI / 180;
				this.degrees = degrees;
			};
			{
				var value = Math.tan(degrees * Math.PI / 180);
				this.degrees = Math.atan(value) * 180 / Math.PI;
				this.radians = Math.atan(value);
				this.slope = value;
			};
			{
				var value = degrees * Math.PI / 180;
				this.slope = Math.tan(value);
				this.degrees = value * 180 / Math.PI;
				this.radians = value;
			};
		} else if ((radians != null)) {
			{
				this.slope = Math.tan(radians);
				this.degrees = radians * 180 / Math.PI;
				this.radians = radians;
			};
			{
				var value = Math.tan(radians);
				this.degrees = Math.atan(value) * 180 / Math.PI;
				this.radians = Math.atan(value);
				this.slope = value;
			};
			{
				var value = radians * 180 / Math.PI;
				this.slope = Math.tan(value * Math.PI / 180);
				this.radians = value * Math.PI / 180;
				this.degrees = value;
			};
		};
	}

	public var point:vision.ds.Point2D;

	public var slope(default,set):Float;

	public var degrees(default,set):Float;

	public var radians(default,set):Float;

	public var yIntercept(get,never):Float;

	public var xIntercept(get,never):Float;

	public inline function getPointAtX(x:Float) {
		var px = this.point.x;
		var py = this.point.y;
		return new vision.ds.Point2D(x, this.slope * x + (if ((px > 0)) py - this.slope * px else py + this.slope * px));
	}

	public inline function getPointAtY(y:Float) {
		var px = this.point.x;
		var py = this.point.y;
		return new vision.ds.Point2D((y - (if ((px > 0)) py - this.slope * px else py + this.slope * px)) / this.slope, y);
	}

	public inline function intersect(ray:vision.ds.Ray2D) {
		var line1StartX = this.point.x;
		var line1StartY = this.point.y;
		var line1EndX = this.point.x + Math.cos(this.radians) * 1000;
		var line1EndY = this.point.y + Math.sin(this.radians) * 1000;
		var line2StartX = ray.point.x;
		var line2StartY = ray.point.y;
		var line2EndX = ray.point.x + Math.cos(ray.radians) * 1000;
		var line2EndY = ray.point.y + Math.sin(ray.radians) * 1000;
		var a;
		var b;
		var numerator1;
		var numerator2;
		var result = null;
		var denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
		if ((denominator == 0)) return result else {
			a = line1StartY - line2StartY;
			b = line1StartX - line2StartX;
			numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
			numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
			a = numerator1 / denominator;
			b = numerator2 / denominator;
			result = new vision.ds.Point2D(null, null);
			result.x = line1StartX + a * (line1EndX - line1StartX);
			result.y = line1StartY + a * (line1EndY - line1StartY);
			return result;
		};
	}

	public function distanceTo(ray:vision.ds.Ray2D) {
		if ((this.radians != ray.radians)) return 0 else {
			var point = this.point;
			var ray2_slope;
			var ray2_radians;
			var ray2_degrees;
			var m = null;
			var degrees = this.degrees + 90;
			var radians = null;
			var ray2_point = point;
			if ((m != null)) {
				{
					ray2_degrees = Math.atan(m) * 180 / Math.PI;
					ray2_radians = Math.atan(m);
					ray2_slope = m;
				};
				{
					var value = Math.atan(m) * 180 / Math.PI;
					ray2_slope = Math.tan(value * Math.PI / 180);
					ray2_radians = value * Math.PI / 180;
					ray2_degrees = value;
				};
				{
					var value = Math.atan(m);
					ray2_slope = Math.tan(value);
					ray2_degrees = value * 180 / Math.PI;
					ray2_radians = value;
				};
			} else if ((degrees != null)) {
				{
					ray2_slope = Math.tan(degrees * Math.PI / 180);
					ray2_radians = degrees * Math.PI / 180;
					ray2_degrees = degrees;
				};
				{
					var value = Math.tan(degrees * Math.PI / 180);
					ray2_degrees = Math.atan(value) * 180 / Math.PI;
					ray2_radians = Math.atan(value);
					ray2_slope = value;
				};
				{
					var value = degrees * Math.PI / 180;
					ray2_slope = Math.tan(value);
					ray2_degrees = value * 180 / Math.PI;
					ray2_radians = value;
				};
			} else if ((radians != null)) {
				{
					ray2_slope = Math.tan(radians);
					ray2_degrees = radians * 180 / Math.PI;
					ray2_radians = radians;
				};
				{
					var value = Math.tan(radians);
					ray2_degrees = Math.atan(value) * 180 / Math.PI;
					ray2_radians = Math.atan(value);
					ray2_slope = value;
				};
				{
					var value = radians * 180 / Math.PI;
					ray2_slope = Math.tan(value * Math.PI / 180);
					ray2_radians = value * Math.PI / 180;
					ray2_degrees = value;
				};
			};
			var line1StartX = ray.point.x;
			var line1StartY = ray.point.y;
			var line1EndX = ray.point.x + Math.cos(ray.radians) * 1000;
			var line1EndY = ray.point.y + Math.sin(ray.radians) * 1000;
			var line2StartX = ray2_point.x;
			var line2StartY = ray2_point.y;
			var line2EndX = ray2_point.x + Math.cos(ray2_radians) * 1000;
			var line2EndY = ray2_point.y + Math.sin(ray2_radians) * 1000;
			var a;
			var b;
			var numerator1;
			var numerator2;
			var result = null;
			var denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
			var intersectionOfPerpendicularWithRay2;
			if ((denominator == 0)) intersectionOfPerpendicularWithRay2 = result else {
				a = line1StartY - line2StartY;
				b = line1StartX - line2StartX;
				numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
				numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
				a = numerator1 / denominator;
				b = numerator2 / denominator;
				result = new vision.ds.Point2D(null, null);
				result.x = line1StartX + a * (line1EndX - line1StartX);
				result.y = line1StartY + a * (line1EndY - line1StartY);
				intersectionOfPerpendicularWithRay2 = result;
			};
			var x = intersectionOfPerpendicularWithRay2.x - point.x;
			var y = intersectionOfPerpendicularWithRay2.y - point.y;
			return Math.sqrt(x * x + y * y);
		};
	}

	inline function set_slope(value:Float) {
		this.degrees = Math.atan(value) * 180 / Math.PI;
		this.radians = Math.atan(value);
		return this.slope = value;
	}

	inline function set_degrees(value:Float) {
		this.slope = Math.tan(value * Math.PI / 180);
		this.radians = value * Math.PI / 180;
		return this.degrees = value;
	}

	inline function set_radians(value:Float) {
		this.slope = Math.tan(value);
		this.degrees = value * 180 / Math.PI;
		return this.radians = value;
	}

	inline function get_yIntercept() {
		var px = this.point.x;
		var py = this.point.y;
		if ((px > 0)) return py - this.slope * px;
		return py + this.slope * px;
	}

	inline function get_xIntercept() {
		var px = this.point.x;
		var py = this.point.y;
		if ((py > 0)) return (py - this.slope * px) / this.slope;
		return (py + this.slope * px) / this.slope;
	}

	public static inline function from2Points(point1:vision.ds.Point2D, point2:vision.ds.Point2D) {
		var s = (point2.y - point1.y) / (point2.x - point1.x);
		return new vision.ds.Ray2D(point1, s, null, null);
	}
}