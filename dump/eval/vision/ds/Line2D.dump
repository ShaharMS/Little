@:used
class vision.ds.Line2D {

	public inline function new(start:vision.ds.Point2D, end:vision.ds.Point2D) {
		this.end = new vision.ds.Point2D(cast 0, cast 0);
		this.start = new vision.ds.Point2D(cast 0, cast 0);
		this.start.x = start.x;
		this.start.y = start.y;
		this.end.x = end.x;
		this.end.y = end.y;
		var x = end.x - start.x;
		var y = end.y - start.y;
		this.radians = Math.atan2(x, y);
		this.slope = Math.tan(this.radians);
		this.degrees = this.radians * 180 / Math.PI;
	}

	public var length(get,null):Float;

	public var slope(default,null):Float;

	public var degrees(default,null):Float;

	public var radians(default,null):Float;

	@:value({ x : 0, y : 0 })
	public var start(default,set):vision.ds.Point2D;

	@:value({ x : 0, y : 0 })
	public var end(default,set):vision.ds.Point2D;

	public var middle(get,set):vision.ds.Point2D;

	inline function get_length() {
		return Math.sqrt(Math.pow(this.end.x - this.start.x, 2) + Math.pow(this.end.y - this.start.y, 2));
	}

	public function intersect(line:vision.ds.Line2D) {
		var x1 = this.start.x;
		var y1 = this.start.y;
		var x2 = this.end.x;
		var y2 = this.end.y;
		var x3 = line.start.x;
		var y3 = line.start.y;
		var x4 = line.end.x;
		var y4 = line.end.y;
		var denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
		if ((x1 == x2 && y1 == y2 || x3 == x4 && y3 == y4)) return null else if ((denominator == 0)) return null else {
			var ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
			var ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
			if ((ua < 0 || ua > 1 || ub < 0 || ub > 1)) return null else {
				var x = x1 + ua * (x2 - x1);
				var y = y1 + ua * (y2 - y1);
				return new vision.ds.Point2D(cast Std.int(x), cast Std.int(y));
			};
		};
	}

	public function distanceTo(line:vision.ds.Line2D) {
		var x1 = this.start.x;
		var y1 = this.start.y;
		var x2 = this.end.x;
		var y2 = this.end.y;
		var x3 = line.start.x;
		var y3 = line.start.y;
		var x4 = line.end.x;
		var y4 = line.end.y;
		var denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
		var tmp;
		if ((x1 == x2 && y1 == y2 || x3 == x4 && y3 == y4)) tmp = null else if ((denominator == 0)) tmp = null else {
			var ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
			var ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
			if ((ua < 0 || ua > 1 || ub < 0 || ub > 1)) tmp = null else {
				var x = x1 + ua * (x2 - x1);
				var y = y1 + ua * (y2 - y1);
				tmp = new vision.ds.Point2D(cast Std.int(x), cast Std.int(y));
			};
		};
		if ((tmp != null)) return 0 else {
			var point = line.start;
			var ch = (this.start.y - this.end.y) * point.x + (this.end.x - this.start.x) * point.y + (this.start.x * this.end.y - this.end.x * this.start.y);
			var del = Math.sqrt(Math.pow(this.end.x - this.start.x, 2) + Math.pow(this.end.y - this.start.y, 2));
			var d = ch / del;
			var distance1 = d;
			var point = line.end;
			var ch = (this.start.y - this.end.y) * point.x + (this.end.x - this.start.x) * point.y + (this.start.x * this.end.y - this.end.x * this.start.y);
			var del = Math.sqrt(Math.pow(this.end.x - this.start.x, 2) + Math.pow(this.end.y - this.start.y, 2));
			var d = ch / del;
			var distance2 = d;
			var point = this.start;
			var ch = (line.start.y - line.end.y) * point.x + (line.end.x - line.start.x) * point.y + (line.start.x * line.end.y - line.end.x * line.start.y);
			var del = Math.sqrt(Math.pow(line.end.x - line.start.x, 2) + Math.pow(line.end.y - line.start.y, 2));
			var d = ch / del;
			var distance3 = d;
			var point = this.end;
			var ch = (line.start.y - line.end.y) * point.x + (line.end.x - line.start.x) * point.y + (line.start.x * line.end.y - line.end.x * line.start.y);
			var del = Math.sqrt(Math.pow(line.end.x - line.start.x, 2) + Math.pow(line.end.y - line.start.y, 2));
			var d = ch / del;
			var distance4 = d;
			var values = cast [distance1, distance2, distance3, distance4];
			var min = cast values[0];
			{
				var ` = 0;
				var ` = cast values.length;
				while ((` < `)) {
					var i = ` ++;
					if ((cast values[i] < min)) min = cast values[i];
				};
			};
			var distance = min;
			return distance;
		};
	}

	@:keep
	public inline function toString() {
		return "\n (" + this.start.x + ", " + this.start.y + ") --> (" + this.end.x + ", " + this.end.y + ")";
	}

	public inline function toRay2D() {
		return new vision.ds.Ray2D(this.start, this.slope, null, null);
	}

	inline function set_start(value:vision.ds.Point2D) {
		var point2 = this.end;
		var x = point2.x - value.x;
		var y = point2.y - value.y;
		this.radians = Math.atan2(x, y);
		this.slope = Math.tan(this.radians);
		this.degrees = this.radians * 180 / Math.PI;
		return this.start = value;
	}

	inline function set_end(value:vision.ds.Point2D) {
		var point2 = this.end;
		var x = point2.x - value.x;
		var y = point2.y - value.y;
		this.radians = Math.atan2(x, y);
		this.slope = Math.tan(this.radians);
		this.degrees = this.radians * 180 / Math.PI;
		return this.end = value;
	}

	inline function get_middle() {
		return new vision.ds.Point2D((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
	}

	inline function set_middle(value:vision.ds.Point2D) {
		var x = (this.start.x + this.end.x) / 2;
		var y = (this.start.y + this.end.y) / 2;
		if ((y == null)) y = 0;
		if ((x == null)) x = 0;
		var previousMiddle_x = x;
		var previousMiddle_y = y;
		var diffX = value.x - previousMiddle_x;
		var diffY = value.y - previousMiddle_y;
		this.start.y += diffY;
		this.end.y += diffY;
		this.start.x += diffX;
		this.end.x += diffX;
		return new vision.ds.Point2D((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
	}

	public static inline function fromRay2D(ray:vision.ds.Ray2D) {
		var x = ray.point.x;
		var y = ray.point.y;
		var length = 1;
		var end = new vision.ds.Point2D(Std.int(x + length * Math.cos(ray.radians)), Std.int(y + length * Math.sin(ray.radians)));
		return new vision.ds.Line2D(ray.point, end);
	}
}